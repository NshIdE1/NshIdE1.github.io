<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>安卓加固学习记录 | NshIdE&#39;s Home</title>
  <meta name="keywords" content=" Android ">
  <meta name="description" content="安卓加固学习记录 | NshIdE&#39;s Home">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="tags">
<meta property="og:url" content="https://nshide1.github.io/tags/">
<meta property="og:site_name" content="NshIdE&#39;s Home">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-03-04T12:20:04.979Z">
<meta property="article:modified_time" content="2025-03-04T12:20:04.979Z">
<meta property="article:author" content="NshIdE">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/logo.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/logo.jpg"/>
</a>
<div class="author">
    <span>NshIdE</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/NshIdE1/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="csdn"
               href="https://www.csdn.net/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-csdn"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1621925986&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(40)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="其他">
            
            其他
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Android-RE">
            
            Android-RE
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Android学习">
            
            Android学习
            <small>(9)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Angr入门">
            
            Angr入门
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="CTF">
            
            CTF
            <small>(15)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Frida入门">
            
            Frida入门
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Java学习">
            
            Java学习
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Unidbg学习">
            
            Unidbg学习
            <small>(10)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="40">
<input type="hidden" id="yelog_site_word_count" value="221.9k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://bananashipsbbq.github.io/">bananaships</a></li>
            
            <li><a target="_blank" href="https://astralprisma.github.io/">AstralPrisma</a></li>
            
            <li><a target="_blank" href="https://monoceros406.github.io/">Monoceros406</a></li>
            
            <li><a target="_blank" href="https://github.com/Thir0th">Thir0th</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="search shortcut key i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="switch to outline view shortcut key w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="return"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="case sensitive"></i>
            <i class="iconfont icon-tag" data-title="label"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">outline</div>
            <i class="iconfont icon-list" data-title="switch to article list"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>抽象</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>符号执行</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>取证</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>应急响应</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CTF</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Frida</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>go</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Harmony</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>il2Cpps</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>iOS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ISW</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>RE</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SIMD</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unidbg</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unity</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>vm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>WritesUp</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="All CTF "
           href="/2025/10/25/%E7%AC%AC%E5%85%AB%E5%B1%8A%E5%BC%BA%E7%BD%91%C2%B7%E6%8B%9F%E6%80%81%E9%98%B2%E5%BE%A1%E5%9B%BD%E9%99%85%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B/"
           data-tag="CTF,RE,WritesUp,Android,il2Cpps"
           data-author="" >
            <span class="post-title" title="第八届强网·拟态防御国际精英挑战赛">第八届强网·拟态防御国际精英挑战赛</span>
            <span class="post-date" title="2025-10-25 17:31:37">2025/10/25</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/10/22/Android%20APP%20%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android APP 常见漏洞">Android APP 常见漏洞</span>
            <span class="post-date" title="2025-10-22 17:06:07">2025/10/22</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/10/10/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20PackageInfo%20%E5%92%8C%20LoadedApk/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="从源码分析 PackageInfo 和 LoadedApk">从源码分析 PackageInfo 和 LoadedApk</span>
            <span class="post-date" title="2025-10-10 18:15:17">2025/10/10</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/09/09/2025%E5%B9%B4%E6%B9%BE%E5%8C%BA%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B/"
           data-tag="CTF,RE,WritesUp,Android"
           data-author="" >
            <span class="post-title" title="2025年湾区杯网络安全大赛初赛">2025年湾区杯网络安全大赛初赛</span>
            <span class="post-date" title="2025-09-09 09:34:17">2025/09/09</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/09/08/Android%20SO%20%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android SO 文件加载过程">Android SO 文件加载过程</span>
            <span class="post-date" title="2025-09-08 17:18:50">2025/09/08</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/25/Dex%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Dex 文件结构学习">Dex 文件结构学习</span>
            <span class="post-date" title="2025-08-25 17:33:29">2025/08/25</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/19/ClassLoader%20%E6%9C%BA%E5%88%B6/"
           data-tag="Android,Java"
           data-author="" >
            <span class="post-title" title="ClassLoader 机制">ClassLoader 机制</span>
            <span class="post-date" title="2025-08-19 17:42:51">2025/08/19</span>
        </a>
        
        
        <a  class="All Java学习 "
           href="/2025/08/19/Java%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"
           data-tag="Android,Java"
           data-author="" >
            <span class="post-title" title="Java学习----反射机制">Java学习----反射机制</span>
            <span class="post-date" title="2025-08-19 17:00:02">2025/08/19</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/19/Android%20%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android 应用启动流程">Android 应用启动流程</span>
            <span class="post-date" title="2025-08-19 11:14:13">2025/08/19</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/19/%E5%AE%89%E5%8D%93%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="安卓加固学习记录">安卓加固学习记录</span>
            <span class="post-date" title="2025-08-19 10:50:46">2025/08/19</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/14/Android%20%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94NDK%20%E5%BC%80%E5%8F%91/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android 开发--NDK 开发">Android 开发--NDK 开发</span>
            <span class="post-date" title="2025-08-14 17:56:58">2025/08/14</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/08/10/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E5%85%AD)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(六)">从实践中学习unidbg使用(六)</span>
            <span class="post-date" title="2025-08-10 10:25:02">2025/08/10</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/08/08/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%BA%94)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(五)">从实践中学习unidbg使用(五)</span>
            <span class="post-date" title="2025-08-08 17:45:59">2025/08/08</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/05/%E6%BC%AB%E8%B0%88%E5%94%AF%E4%B8%80%E8%AE%BE%E5%A4%87ID/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="漫谈唯一设备 ID">漫谈唯一设备 ID</span>
            <span class="post-date" title="2025-08-05 18:00:44">2025/08/05</span>
        </a>
        
        
        <a  class="All 其他 "
           href="/2025/07/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E7%B3%BB%E7%BB%9F%E4%B8%8B%20proc%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AE%B9/"
           data-tag="Android,Linux"
           data-author="" >
            <span class="post-title" title="浅谈 Linux 系统下 proc 文件系统内容">浅谈 Linux 系统下 proc 文件系统内容</span>
            <span class="post-date" title="2025-07-24 17:56:57">2025/07/24</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/07/24/Unidbg%20%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%88%E4%BA%8C%EF%BC%89/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="Unidbg 中处理文件访问(二)">Unidbg 中处理文件访问(二)</span>
            <span class="post-date" title="2025-07-24 17:00:12">2025/07/24</span>
        </a>
        
        
        <a  class="All Android-RE "
           href="/2025/07/23/2025%E7%AC%AC%E5%8D%81%E5%B1%8A%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B-%E5%88%9D%E8%B5%9B-%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/"
           data-tag="RE,WritesUp,Android"
           data-author="" >
            <span class="post-title" title="2025第十届游戏安全竞赛-初赛-安卓客户端安全">2025第十届游戏安全竞赛-初赛-安卓客户端安全</span>
            <span class="post-date" title="2025-07-23 15:32:11">2025/07/23</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/07/19/%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="创建模拟器和加载模块">创建模拟器和加载模块</span>
            <span class="post-date" title="2025-07-19 15:14:29">2025/07/19</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/07/15/Unidbg%20%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="Unidbg 中处理文件访问(一)">Unidbg 中处理文件访问(一)</span>
            <span class="post-date" title="2025-07-15 16:52:06">2025/07/15</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/07/08/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E5%9B%9B)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(四)">从实践中学习unidbg使用(四)</span>
            <span class="post-date" title="2025-07-08 11:44:49">2025/07/08</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/07/01/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%B8%89)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(三)">从实践中学习unidbg使用(三)</span>
            <span class="post-date" title="2025-07-01 15:29:42">2025/07/01</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/06/07/%E7%AC%AC%E4%B8%80%E5%B1%8AOpenHarmonyCTF/"
           data-tag="CTF,RE,WritesUp,Harmony"
           data-author="" >
            <span class="post-title" title="第一届OpenHarmonyCTF">第一届OpenHarmonyCTF</span>
            <span class="post-date" title="2025-06-07 13:32:45">2025/06/07</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/06/04/%E8%A1%A5%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%94%EF%BC%89/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="补库函数(五)">补库函数(五)</span>
            <span class="post-date" title="2025-06-04 19:07:56">2025/06/04</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/06/02/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%BA%8C)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(二)">从实践中学习unidbg使用(二)</span>
            <span class="post-date" title="2025-06-02 15:33:15">2025/06/02</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/05/31/D%5E3CTF2025/"
           data-tag="CTF,RE,WritesUp,Android"
           data-author="" >
            <span class="post-title" title="D^3CTF2025">D^3CTF2025</span>
            <span class="post-date" title="2025-05-31 16:21:11">2025/05/31</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/05/28/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%B8%80)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(一)">从实践中学习unidbg使用(一)</span>
            <span class="post-date" title="2025-05-28 16:39:23">2025/05/28</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/05/17/Parloo2025/"
           data-tag="CTF,RE,WritesUp"
           data-author="" >
            <span class="post-title" title="Parloo RE">Parloo RE</span>
            <span class="post-date" title="2025-05-17 09:34:20">2025/05/17</span>
        </a>
        
        
        <a  class="All Android-RE "
           href="/2025/05/07/%E8%AE%B0%E4%B8%80%E6%AC%A1APK%E5%88%86%E6%9E%90/"
           data-tag="RE,WritesUp,Android"
           data-author="" >
            <span class="post-title" title="记一次APK分析">记一次APK分析</span>
            <span class="post-date" title="2025-05-07 21:12:00">2025/05/07</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/04/26/%E4%B8%80%E9%81%93%E5%BE%88%E9%80%86%E5%A4%A9%E7%9A%84RC4/"
           data-tag="CTF,RE,WritesUp,抽象"
           data-author="" >
            <span class="post-title" title="抽象RC4">抽象RC4</span>
            <span class="post-date" title="2025-04-26 22:21:19">2025/04/26</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/04/24/%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98/"
           data-tag="CTF,RE,WritesUp"
           data-author="" >
            <span class="post-title" title="很有意思的一道题">很有意思的一道题</span>
            <span class="post-date" title="2025-04-24 21:56:18">2025/04/24</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/04/23/%E4%BA%AC%E9%BA%92CTF2025%20%E7%83%AD%E8%BA%AB%E8%B5%9B/"
           data-tag="CTF,RE,WritesUp,iOS,SIMD"
           data-author="" >
            <span class="post-title" title="京麒CTF2025热身赛">京麒CTF2025热身赛</span>
            <span class="post-date" title="2025-04-23 13:33:59">2025/04/23</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/04/14/TGCTF2025/"
           data-tag="CTF,RE,WritesUp"
           data-author="" >
            <span class="post-title" title="TGCTF2025 RE">TGCTF2025 RE</span>
            <span class="post-date" title="2025-04-14 18:51:29">2025/04/14</span>
        </a>
        
        
        <a  class="All Angr入门 "
           href="/2025/04/14/Angr%E5%85%A5%E9%97%A8/"
           data-tag="符号执行"
           data-author="" >
            <span class="post-title" title="Angr入门">Angr入门</span>
            <span class="post-date" title="2025-04-14 18:50:44">2025/04/14</span>
        </a>
        
        
        <a  class="All Frida入门 "
           href="/2025/04/14/Frida%E5%85%A5%E9%97%A8/"
           data-tag="Android,Frida"
           data-author="" >
            <span class="post-title" title="Frida入门">Frida入门</span>
            <span class="post-date" title="2025-04-14 18:47:37">2025/04/14</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/04/12/TEXSAWCTF%202025/"
           data-tag="CTF,RE,WritesUp"
           data-author="" >
            <span class="post-title" title="TEXSAWCTF 2025">TEXSAWCTF 2025</span>
            <span class="post-date" title="2025-04-12 15:32:31">2025/04/12</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/03/23/NCTF2024/"
           data-tag="CTF,RE,WritesUp,vm,go"
           data-author="" >
            <span class="post-title" title="NCTF2024">NCTF2024</span>
            <span class="post-date" title="2025-03-23 11:58:53">2025/03/23</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/03/18/CISCN%20x%20CCB%20%E5%8D%8A%E5%86%B3%E8%B5%9B%202025%20ISW(%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94)/"
           data-tag="ISW,应急响应,取证"
           data-author="" >
            <span class="post-title" title="CISCN x CCB 半决赛 2025 ISW(应急响应)">CISCN x CCB 半决赛 2025 ISW(应急响应)</span>
            <span class="post-date" title="2025-03-18 10:24:23">2025/03/18</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/03/11/TPCTF%202025/"
           data-tag="CTF,RE,WritesUp"
           data-author="" >
            <span class="post-title" title="TPCTF 2025">TPCTF 2025</span>
            <span class="post-date" title="2025-03-11 21:41:19">2025/03/11</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/03/06/VishwaCTF2025/"
           data-tag="CTF,RE,WritesUp,Android,Unity"
           data-author="" >
            <span class="post-title" title="VishwaCTF2025">VishwaCTF2025</span>
            <span class="post-date" title="2025-03-06 21:52:51">2025/03/06</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/03/03/HGAME%20RE/"
           data-tag="CTF,RE,WritesUp,Android"
           data-author="" >
            <span class="post-title" title="HGAME-RE-WEEK1">HGAME-RE-WEEK1</span>
            <span class="post-date" title="2025-03-03 22:20:33">2025/03/03</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="Toggle full screen shortcut key s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-安卓加固学习记录" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">安卓加固学习记录</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Android学习">Android学习</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">Android</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-08-27 11:25:37'>2025-08-19 10:50</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:20.7k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="Jump to comment area">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E5%8D%93%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95"><span class="toc-text">安卓加固学习记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E4%BB%A3%E5%A3%B3-Dex-%E6%95%B4%E4%BD%93%E5%8A%A0%E5%9B%BA"><span class="toc-text">二、第一、二代壳 Dex 整体加固</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dex-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">Dex 文件结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BB%A3%E5%A3%B3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">一代壳实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BB%A3%E5%A3%B3-%E6%95%B4%E4%BD%93%E5%8A%A0%E5%9B%BA%EF%BC%88%E8%90%BD%E5%9C%B0%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="toc-text">一代壳-整体加固（落地加载）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-text">源程序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#MainActivity-java"><span class="toc-text">MainActivity.java</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#MyApplication-java"><span class="toc-text">MyApplication.java</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#native-lib-cpp"><span class="toc-text">native-lib.cpp</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#AndroidManifest-xml"><span class="toc-text">AndroidManifest.xml</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#activity-main-xml"><span class="toc-text">activity_main.xml</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F"><span class="toc-text">加壳程序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#FirstShell-py"><span class="toc-text">FirstShell.py</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%B1%E5%A3%B3%E7%A8%8B%E5%BA%8F"><span class="toc-text">脱壳程序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#FirstProxyApplication-java"><span class="toc-text">FirstProxyApplication.java</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Reflection-java"><span class="toc-text">Reflection.java</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#AndroidManifest-xml-1"><span class="toc-text">AndroidManifest.xml</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E4%BB%A3%E5%A3%B3-%E6%95%B4%E4%BD%93%E5%8A%A0%E5%9B%BA%EF%BC%88%E4%B8%8D%E8%90%BD%E5%9C%B0%E5%8A%A0%E8%BD%BD%EF%BC%89"><span class="toc-text">二代壳-整体加固（不落地加载）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F-1"><span class="toc-text">源程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F-1"><span class="toc-text">加壳程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%B1%E5%A3%B3%E7%A8%8B%E5%BA%8F-1"><span class="toc-text">脱壳程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%AC%AC%E4%B8%89%E4%BB%A3%E5%A3%B3-%E6%8A%BD%E5%8F%96%E5%8A%A0%E5%9B%BA"><span class="toc-text">三、第三代壳-抽取加固</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A8%8B%E5%BA%8F3"><span class="toc-text">源程序3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F-2"><span class="toc-text">加壳程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%B1%E5%A3%B3%E7%A8%8B%E5%BA%8F-2"><span class="toc-text">脱壳程序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">环境初始化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2-ClassLoader"><span class="toc-text">替换 ClassLoader</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2-application"><span class="toc-text">替换 application</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Native-%E5%B1%82"><span class="toc-text">Native 层</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ThirdProxyApplication-java"><span class="toc-text">ThirdProxyApplication.java</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shell-cpp"><span class="toc-text">shell.cpp</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8A%A0%E5%9B%BA%E6%B5%8B%E8%AF%95"><span class="toc-text">四、加固测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%82%E8%80%83"><span class="toc-text">五、参考</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="安卓加固学习记录"><a href="#安卓加固学习记录" class="headerlink" title="安卓加固学习记录"></a>安卓加固学习记录</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​        近期开始接触公司的加固业务——Android App 加固，由于之前在 CTF 中遇到的加固一是少，二是都不难，frida-dump 基本都能秒，所以也没有较为系统的去学习了解安卓加固这一块。所以在看雪上找了一些较为详细的文章进行学习并记录，同时也会补充一些个人的理解或者在原文章中讲的不那么详细的点加以补充。</p>
<h3 id="二、第一、二代壳-Dex-整体加固"><a href="#二、第一、二代壳-Dex-整体加固" class="headerlink" title="二、第一、二代壳 Dex 整体加固"></a>二、第一、二代壳 Dex 整体加固</h3><p>​        <strong>第一代壳</strong>主要是对 **dex&#x2F;APK ** 文件整体进行加密，然后使用自定义加载器动态加载 dex&#x2F;APK 文件并执行。而 <strong>动态加载</strong> 又分为 <strong>落地加载</strong> 和 <strong>不落地加载</strong>，落地加载就是通过 <strong>DexClassLoader</strong> 从磁盘加载 dex&#x2F;APK 文件，<strong>不落地加载</strong> 就是通过 <strong>InMemoryDexClassLoader</strong> 从内存中加载 dex&#x2F;APK 文件。</p>
<p>​        这里解释一下上面提到的 <strong>磁盘</strong> 和 <strong>内存</strong> 分别的含义，磁盘指的是 <strong>Android 文件系统上的存储空间</strong>，通常是应用的私有存储目录（<code>/data/data/&lt;package&gt;/</code> 下），或者外部存储卡路径，使用 <strong>DexClassLoader</strong> 时，需要先把 .dex 或 .apk 文件以真实文件形式存放在磁盘上，然后 DexClassLoader 会通过文件路径去读取和加载字节码，故称之为 <strong>落地</strong>；<strong>内存</strong> 指的是 <strong>进程的堆内存（RAM）</strong>，即由 Java 代码直接持有的 <strong>ByteBuffer</strong> 或 byte[]，使用 <strong>InMemoryDexClassLoader</strong> 时，不需要在磁盘上生成 .dex 文件，而是可以直接把字节码存放在内存（通常是通过网络下载的字节流、解密后的字节数组、或 mmap 的 buffer），然后直接传给 InMemoryDexClassLoader 来加载，这样，整个过程中不会在磁盘中产生持久化的 dex 文件，故称之为 <strong>不落地</strong>。</p>
<h4 id="Dex-文件结构"><a href="#Dex-文件结构" class="headerlink" title="Dex 文件结构"></a>Dex 文件结构</h4><p>借用文章里的图<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250819103114984.png" alt="image-20250819103114984"></p>
<h4 id="一代壳实现原理"><a href="#一代壳实现原理" class="headerlink" title="一代壳实现原理"></a>一代壳实现原理</h4><p><strong>App 的启动流程</strong><br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250819103443269.png" alt="image-20250819103443269"></p>
<p>​        通过将原 APK 进行加密后保存在加壳 APK 的 dex 文件尾部，在加壳 APK 运行时将 dex 文件尾部加密的原 APK 文件解密后进行动态加载。（这里提到的加壳 APK 也确实是一个真正的 APK 文件，包含完整的 APK 文件结构，但是并无业务代码，而是 <strong>负责加载、解密、再运行真正的原始 APK</strong>）。</p>
<p>​        壳代码需要最早回去到 加壳APK 的执行时机，所以 加壳APK 的 Application 实现了 <strong>attachContextApplication</strong> 函数，此函数在 <strong>handleBindApplication</strong> 函数中通过调用 <strong>makeApplication</strong> 进行调用，是一个 APP 进程最早的执行入口。（有关 Android 应用启动流程可以看这篇<a href="https://nshide1.github.io/2025/08/19/Android%20%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">文章</a>）。</p>
<p>​        加壳 APK 需要进行如下操作：</p>
<ul>
<li><strong>attachContextApplication</strong> 解密原 APK 保存到磁盘文件中（不落地加载可以不保存磁盘文件），动态加载解密后的 APK 并替换掉 <strong>mClassLoader</strong>。</li>
<li><strong>Application::onCreate</strong> 重定位 Application，调用原 APK 的 Application 的 onCreate 函数。</li>
</ul>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250819112238763.png" alt="image-20250819112238763"></p>
<p>这里再补充解释一下 <strong>mClassLoader</strong> 和 <strong>Application::onCreate</strong>：</p>
<ul>
<li><strong>mClassLoader</strong> 是 <strong>Android 系统内部  LoadedApk  对象的一个字段</strong>，它表示这个 APK 对应的 <strong>类加载器（ClassLoader）</strong>；在 Android 中，每个 APK 都有一个 LoadedApk 对象，里面包含：APK 的路径、资源（Resources）、类加载器（ClassLoader）–&gt; mClassLoader；<strong>功能</strong>：系统通过 mClassLoader 去加载 APK 里的类（Java&#x2F;DEX 类），包括 Activity、Service、Application 等，默认情况下，mClassLoader 是 <strong>PathClassLoader</strong>，加载 APK 自带的 dex 文件。</li>
<li><strong>Application::onCreate()</strong> 是 <strong>Application 生命周期的第一个回调函数</strong>，在 <strong>attach()</strong> 后调用；<strong>功能</strong>：执行全局初始化逻辑，例如，初始化 SDK、设置全局单例、加载配置，这是应用在启动时的“第一个执行点”，比任何 Activity 的 <code>onCreate()</code> 都早。</li>
</ul>
<h4 id="一代壳-整体加固（落地加载）"><a href="#一代壳-整体加固（落地加载）" class="headerlink" title="一代壳-整体加固（落地加载）"></a>一代壳-整体加固（落地加载）</h4><p>​        一代加固是所有加固的基础，了解一代加固的基本思路有助于理解后续加固技术的演进。</p>
<p><strong>原理</strong>：</p>
<p>主要涉及三个对象：</p>
<pre><code>1. 待加固的源程序APK；
1. （脱）壳程序APK 负责加载，解密和执行被保护的源程序；
1. 加壳程序 负责解析源程序并利用壳程序对其进行加固保护，将壳程序和源程序合并为新的程序。
</code></pre>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820151911526.png" alt="image-20250820151911526"></h4><p>加壳后的 壳 Dex 文件示意图如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250820152435521.png" alt="image-20250820152435521"></p>
<p>最终新 APK 中包括以下内容：</p>
<pre><code>1. 修改过的 AndroidManifest.xml；
1. 由壳 Dex 和 源 APK 合并而来的 class.dex；
1. 源 APK 的所有其他资源文件（包括 lib、assets、resources 等）。
</code></pre>
<p>（脱）壳程序：</p>
<pre><code>1. 在壳程序 dex 末尾追加源程序的所有 dex；
1. 在壳程序 Application 的 **attachBaseContext** 方法释放源程序所有 dex 并替换 mClassLoader；
1. 在壳程序 Application 的 onCreate 方法注册源程序 Application 并开始生命周期。
</code></pre>
<h5 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h5><p>​        源程序即一般的用户程序，我们的主要目的是对源程序进行加固保护，所以需要注意源程序可能涉及到的技术点：</p>
<ul>
<li>源程序自定义 Application</li>
</ul>
<p>​        Application.attachBaseContext 是 APP 进程真正的入口点。如果源程序没有使用自定义Application，则可以直接复用壳程序 Application；如果源程序有自定义Application，则一定要在 AndroidManifest.xml 文件中 由  <application android:name=""> 标签声明指定，可以替换属性值为<strong>壳 application</strong>，同时添加 <strong>meta-data 标签</strong>保存<strong>源程序application</strong>。</p>
<ul>
<li>Native</li>
</ul>
<p>​        源程序使用NDK开发时会生成lib文件夹和对应so文件，需要进行处理；主要是创建lib库的释放文件夹，提供给新的 ClassLoader。</p>
<p>源程序主要包括以下文件：</p>
<pre><code>	1. MainActivity.java
	2. MyApplication.java
	3. native-lib.cpp
	4. AndroidManifest.xml
	5. activity_main.xml
</code></pre>
<p><strong>注意关闭Multidex支持,保证只编译出一个Dex文件</strong></p>
<h6 id="MainActivity-java"><a href="#MainActivity-java" class="headerlink" title="MainActivity.java"></a>MainActivity.java</h6><p>主要功能：</p>
<pre><code>1. Java 层组件 TextView
1. Native 层 JNI 函数调用
</code></pre>
<p>注意点：</p>
<pre><code>1. MainActivity 继承自 **Activity 类**而非 AppCompatActivity，这一步是为了方便资源处理；
1. 使用到了 native 函数，所以要处理 lib 文件夹；
1. 关闭 MultiDex 支持，只生成一个 dex 文件便于处理。
</code></pre>
<pre><code class="language-java">package com.example.sourcecodeforshell1;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

import com.example.sourcecodeforshell1.databinding.ActivityMainBinding;

public class MainActivity extends AppCompatActivity &#123;
    
    static &#123;
        System.loadLibrary(&quot;sourcecodeforshell1&quot;);
    &#125;
    @Override
    protected void onCreate(Bundle savedInstanceState) &#123;
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        String hint = stringFromJNI();
        
        TextView tv = (TextView) findViewById(R.id.sample_text);
        tv.setText(hint);

        Log.d(&quot;NshIdE&quot;, &quot;Run source MainActivity.onCreate &quot; + this);
    &#125;
    
    public native String stringFromJNI();
&#125;
</code></pre>
<h6 id="MyApplication-java"><a href="#MyApplication-java" class="headerlink" title="MyApplication.java"></a>MyApplication.java</h6><p>主要功能：log 输出便于定位执行流程</p>
<p>注意：</p>
<pre><code>		1. 程序执行的顺序为 Application.attachBaseContext --&gt; Application.onCreate() --&gt; MainActivity.onCreate()；
		2. 该类主要用于模拟存在自定义 Application 的情况。如果源程序不存在自定义 Application 
		3. 使用默认的 Application 即可，否则需要解析 Application 并进行创建和替换。
</code></pre>
<pre><code class="language-Java">package com.example.sourcecodeforshell1;

import android.app.Application;
import android.content.Context;
import android.util.Log;

public class MyApplication extends Application &#123;
    
    @Override
    protected void attachBaseContext(Context base) &#123;
        super.attachBaseContext(base);
        Log.d(&quot;NshIdE&quot;, &quot;Run source MyApplication.attachBaseContext &quot; + this);
    &#125;
    
    @Override
    public void onCreate() &#123;
        super.onCreate();
        Log.d(&quot;NshIdE&quot;, &quot;Run source MyApplication.onCreate &quot; + this);
    &#125;
    
&#125;
</code></pre>
<h6 id="native-lib-cpp"><a href="#native-lib-cpp" class="headerlink" title="native-lib.cpp"></a>native-lib.cpp</h6><p>定义了静态注册的方法 stringFromJNI</p>
<pre><code class="language-c++">#include &lt;jni.h&gt;
#include &lt;string&gt;

extern &quot;C&quot; JNIEXPORT jstring JNICALL
Java_com_example_sourcecodeforshell1_MainActivity_stringFromJNI(
        JNIEnv* env,
        jobject /* this */) &#123;
    std::string hello = &quot;Hello from C++&quot;;
    return env-&gt;NewStringUTF(hello.c_str());
&#125;
</code></pre>
<h6 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h6><p>主要功能：</p>
<pre><code>	1. 指定根 activity 为 MainActivity
	1. 指定 android:name 为 MyApplication
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;

    &lt;application
        android:allowBackup=&quot;true&quot;
        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;
        android:fullBackupContent=&quot;@xml/backup_rules&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/Theme.SourceCodeForShell1&quot;
        android:name=&quot;.MyApplication&quot;&gt;
        &lt;activity
            android:name=&quot;.MainActivity&quot;
            android:exported=&quot;true&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>
<h6 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h6><p>这个就没改动了，就是 Android studio 默认初始化的</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/sample_text&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Hello World!&quot;
        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
        app:layout_constraintEnd_toEndOf=&quot;parent&quot;
        app:layout_constraintStart_toStartOf=&quot;parent&quot;
        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>
<p>以上就是源程序。</p>
<h5 id="加壳程序"><a href="#加壳程序" class="headerlink" title="加壳程序"></a>加壳程序</h5><p>加壳程序主要需要完成以下工作：</p>
<ol>
<li>解包 壳程序和源程序。得到<strong>壳程序</strong>的 dex 以及<strong>源程序</strong>的 AndroidManifest.xml 和资源文件等；</li>
<li>复制源程序解包后的文件到新 APK 临时目录（忽略部分文件）；</li>
<li>处理源程序 AndroidManifest.xml 写入新 APK 临时目录。判断是否存在 application 标签的 name 属性指定了<strong>自定义的 Application</strong>，若存在则添加 meta-data 标签保存原始 application，无论是否存在都要指定 name 值为壳的 Application；</li>
<li>合并壳 dex 和源程序 APK 写入新 APK 临时目录；</li>
<li>重打包新的 APK；</li>
<li>对新 APK 签名</li>
<li>删除临时目录。</li>
</ol>
<h6 id="FirstShell-py"><a href="#FirstShell-py" class="headerlink" title="FirstShell.py"></a>FirstShell.py</h6><ol>
<li>封装 <strong>Path</strong> 类，保存全局使用到的路径，主要是 APK 路径和临时目录；</li>
<li>封装 <strong>Apkktool</strong> 类，通过 apktool 提供的 APK 解包和打包功能，通过 uber-apk-signer 提供 apk 签名功能；</li>
<li>封装 <strong>ManifestEditor</strong> 类，提供 ManifestEditor 解析功能，支持获取和修改标签属性，添加新标签；</li>
<li><strong>combineShellDexAndSrcApk</strong> 合并壳 dex 和源 APK。将原 APK 加密后填充到 壳 dex 后方，并添加 4 字节标识 APK 大小。故，新 dex &#x3D; 壳dex + 加密后的原 APK + 原 APK 大小；</li>
<li>handleManifest 处理 AndroidManifest.xml。分别提取原 APK 和壳的 AndroidManifest 文件，以源 manifest 为基准，根据原 APK 是否指定自定义 application 确定是否添加 meta-data 标签保存，最后修改 application:name 为 壳 application；</li>
<li>start 完整的处理函数。</li>
</ol>
<pre><code class="language-python">from zlib import adler32
from hashlib import sha1
from binascii import unhexlify
from lxml import etree
import subprocess
import shutil
from pathlib import Path
import argparse

#封装 path 类，保存全局需要用到的路径
class Paths:
    def __init__(self, srcApk:Path, shellApk:Path, outputApk:Path):
        # Apk file paths
        self.srcApkPath = srcApk.resolve()  #解析为绝对路径
        self.shellApkPath = shellApk.resolve()
        self.newApkPath = outputApk.resolve()

        # 临时目录路径为python文件路径
        self.tmpdir = Path(__file__).parent / &#39;temp&#39;
        self.srcApkTempDir = self.tmpdir / &#39;srcApkTemp&#39;
        self.shellApkTempDir = self.tmpdir / &#39;shellApkTemp&#39;
        self.newApkTempDir = self.tmpdir / &#39;newApkTemp&#39;

# ApkTool 类 提供解包，打包，签名功能
class Apktool:
    def __init__(self):
        self.apktool_path = Path(__file__).parent.parent / &#39;tools/apktool/apktool.bat&#39;
        self.signer_path = Path(__file__).parent / &#39;tools/uber-apk-signer-1.3.0.jar&#39;

    def signApk(self, unsignedApkPath:Path):
        self.runCommand([&#39;java&#39;, &#39;-jar&#39;, self.signer_path, &#39;--apk&#39;, unsignedApkPath])

    # 使用 aoktool 解包 apk，只解包资源不解包 dex
    def extractApk(self, apkPath:Path, outputDir:Path):
        self.runCommand([self.apktool_path, &#39;d&#39;, apkPath, &#39;-s&#39;, &#39;-o&#39;, outputDir])

    # 重打包 apk
    def repackApk(self, inputDir:Path, outApk:Path):
        self.runCommand([self.apktool_path, &#39;b&#39;, inputDir, &#39;-o&#39;, outApk])

    def runCommand(self, args):
        #仅调用工具,不需要输出,重定向stdout到os.devnull
        subprocess.run(args, stdout=subprocess.DEVNULL)
        #参数列表 捕获输出 输出转为字符串
        print(subprocess.run(args, capture_output=True).stdout)

# AndroidManifest.xml的editor 用于获取和修改标签属性以及添加标签
class ManifestEditor:
    def __init__(self, xml_content: bytes):
        self.ns = &#123;&#39;android&#39;: &#39;http://schemas.android.com/apk/res/android&#39;&#125;
        self.tree = etree.fromstring(xml_content)

    #获取指定标签的android属性值 examples: get_attr(&#39;application&#39;, &#39;name&#39;) get_attr(&#39;activity&#39;. &#39;name&#39;)
    def getTagAttribute(self, tag_name: str, attr_name: str):
        if tag_name == &#39;manifest&#39;:  #根标签特殊处理
            elem = self.tree
            if elem is not None:
                return elem.get(f&#39;&#123;attr_name&#125;&#39;)   # 寻找标签的属性
        else:
            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)
            if elem is not None:
                #根标签之外的属性位于Android命名空间下
                return elem.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;)
        return None

    #设置指定标签的属性值
    #example set_attr(&#39;application&#39;, &#39;name&#39;, &#39;com.example.ProxyApplication&#39;)
    def setTagAttribute(self, tag_name: str, attr_name: str, new_value: str):
        if tag_name == &#39;manifest&#39;:   #根标签特殊处理
            elem = self.tree
            if elem is not None:
                return elem.set(f&#39;&#123;attr_name&#125;&#39;, new_value)  #设置属性值
        else:
            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)
            if elem is not None:
                elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;, new_value)
                return True
        return False

    # 在指定父标签下添加新子标签
    # example: add_tag(&#39;application&#39;,&quot;meta-data&quot;,&#123;&#39;name&#39;: &#39;android.permission.CAMERA&#39;,&#39;value&#39;:&#39;hello&#39;&#125;)
    def addTagWithAttribute(self, parent_tag: str, new_tag: str, attrs: dict):
        if parent_tag == &#39;manifest&#39;:
            parent = self.tree
            if parent is not None:
                new_elem = etree.SubElement(parent, new_tag)
                for k, v in attrs.items(): #支持一次给添加的标签设置多个属性
                    new_elem.set(f&#39;&#123;k&#125;&#39;, v)
                return True
        else:
            parent = self.tree.find(f&#39;.//&#123;parent_tag&#125;&#39;, namespaces=self.ns)
            if parent is not None:
                new_elem = etree.SubElement(parent, new_tag)
                for k, v in attrs.items():
                    new_elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;k&#125;&#39;, v)
                return True
        return False

    # 不以壳manifest为基准操作则用不到该函数,以源apk的manifest为基准自带,无需额外设置
    def getMainActivity(self):
        activities = self.tree.findall(&#39;.//activity&#39;, namespaces=self.ns)
        for activity in activities:
            intent_filters = activity.findall(&#39;.//intent-filter&#39;, namespaces=self.ns)
            for intent_filter in intent_filters:
                action = intent_filter.find(&#39;.//action[@android:name=&quot;android.intent.action.MAIN&quot;]&#39;, namespaces=self.ns)
                category = intent_filter.find(&#39;.//category[@android:name=&quot;android.intent.category.LAUNCHER&quot;]&#39;,
                                              namespaces=self.ns)
                if action is not None and category is not None:
                    return activity.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;name&#39;)
        return None

    def getApplication(self):
        return self.getTagAttribute(&#39;application&#39;, &#39;name&#39;)

    def setApplication(self, application: str):
        self.setTagAttribute(&#39;application&#39;, &#39;name&#39;, application)

    def addMetaData(self, name: str, value: str):
        self.addTagWithAttribute(&#39;application&#39;, &#39;meta-data&#39;, &#123;&#39;name&#39;: name, &#39;value&#39;: value&#125;)

    def getManifestData(self):
        &quot;&quot;&quot;返回XML字符串&quot;&quot;&quot;
        return etree.tostring(self.tree, pretty_print=True, encoding=&#39;utf-8&#39;, xml_declaration=True).decode()

# 合并壳dex和源apk
def combineShellDexAndSrcApk(sourceApkPath:Path, shellApkTempDir:Path, newApkTempDir:Path):
    def fixCheckSum(dexBytesArray):
        # dexfile[8:12]
        # 小端存储
        value = adler32(bytes(dexBytesArray[12:]))
        valueArray = bytearray(value.to_bytes(4, &#39;little&#39;))
        for i in range(len(valueArray)):
            dexBytesArray[8 + i] = valueArray[i]

    def fixSignature(dexBytesArray):
        # dexfile[12:32]
        sha_1 = sha1()
        sha_1.update(bytes(dexBytesArray[32:]))
        value = sha_1.hexdigest()
        valueArray = bytearray(unhexlify(value))
        for i in range(len(valueArray)):
            dexBytesArray[12 + i] = valueArray[i]

    def fixFileSize(dexBytesArray, fileSize):
        # dexfile[32:36]
        # 小端存储
        fileSizeArray = bytearray(fileSize.to_bytes(4, &quot;little&quot;))
        for i in range(len(fileSizeArray)):
            dexBytesArray[32 + i] = fileSizeArray[i]

    def encrypto(file):
        for i in range(len(file)):
            file[i] ^= 0xff
        return file

    # 获取源apk
    with open(sourceApkPath, &#39;rb&#39;) as f:
        SourceApkArray = bytearray(f.read())
    # 获取shelldex
    with open(shellApkTempDir / &#39;classes.dex&#39;, &#39;rb&#39;) as f:
        shellDexArray = bytearray(f.read())

    SourceApkLen = len(SourceApkArray)
    shellDexLen = len(shellDexArray)

    # 新的dex文件长度
    newDexLen = shellDexLen + SourceApkLen + 4
    # 加密源文件
    enApkArray = encrypto(SourceApkArray)
    # 新的dex文件内容 = 壳dex + 加密的源apk + 四字节标识加密后源apk大小长度
    newDexArray = shellDexArray + enApkArray + bytearray(SourceApkLen.to_bytes(4, &#39;little&#39;))

    # 修改filesize
    fixFileSize(newDexArray, newDexLen)
    # 修改signature
    fixSignature(newDexArray)
    # 修改checksum
    fixCheckSum(newDexArray)
    # 导出文件
    with open(newApkTempDir / &#39;classes.dex&#39;, &#39;wb&#39;) as f:
        f.write(newDexArray)


# 提取源apk的Manifest文件,修改application为壳application(可能添加meta-data标签),输出新的Manifest文件
def handleManifest(srcApkTempDir: Path, shellApkTempDir: Path, newApkTempDir: Path):
    # 从源apk提取AndroidManifest.xml
    with open(srcApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:
        srcManifestEditor = ManifestEditor(f.read().encode())
    srcApplication = srcManifestEditor.getApplication()

    # 从壳apk提取AndroidManifest.xml
    with open(shellApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:
        shellManifestEditor = ManifestEditor(f.read().encode())
    print(&#39;ShellApplication:&#39;, shellManifestEditor.getApplication())

    # 修改源AndroidManifest.xml的application为壳的代理application
    srcManifestEditor.setApplication(shellManifestEditor.getApplication())

    # 写入meta-data标签 保存源apk的原始application
    if srcApplication != None:
        print(&#39;Source application:&#39;, srcApplication)
        srcManifestEditor.addMetaData(&#39;APPLICATION_CLASS_NAME&#39;, srcApplication)

    # 输出新的AndroidManifest.xml
    with open(newApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;w&#39;) as f:
        f.write(srcManifestEditor.getManifestData())


def start(paths: Paths):
    apktool = Apktool()
    # 1.分别解包源文件和壳文件到临时目录
    print(&#39;Extracting source and shell apk...&#39;)
    apktool.extractApk(paths.srcApkPath, paths.srcApkTempDir)
    print(&#39;Extract source apk success!&#39;)

    print(&#39;Extracting shell apk...&#39;)
    apktool.extractApk(paths.shellApkPath, paths.shellApkTempDir)
    print(&#39;Extract shell apk success!&#39;)

    # 2.复制源apk所有文件到新apk临时目录中
    print(&#39;Copying source apk files to new apk temp dir...&#39;)
    shutil.copytree(paths.srcApkTempDir, paths.newApkTempDir)
    print(&#39;Copy source apk files success!&#39;)

    # 3.处理AndroidManifest.xml
    print(&#39;Handling AndroidManifest.xml...&#39;)
    handleManifest(paths.srcApkTempDir, paths.shellApkTempDir, paths.newApkTempDir)
    print(&#39;Handle AndroidManifest.xml success!&#39;)

    # 4.合并壳dex和源apk并导出文件
    print(&#39;Combining shell dex and source apk...&#39;)
    combineShellDexAndSrcApk(paths.srcApkPath, paths.shellApkTempDir, paths.newApkTempDir)
    print(&#39;Combine shell dex and source apk success!&#39;)

    # 5.重打包apk
    print(&#39;Repacking apk...&#39;)
    apktool.repackApk(paths.newApkTempDir, paths.newApkPath)
    print(&#39;Repack apk success!&#39;)

    # 6.签名apk
    print(&#39;Signing apk...&#39;)
    apktool.signApk(paths.newApkPath)
    print(&#39;Resign apk success!&#39;)

    # 7.删除临时目录
    print(&#39;Deleting temp directories...&#39;)
    shutil.rmtree(paths.tmpdir)  # 删除临时目录
    print(&#39;Delete temp directories success!&#39;)


def main():
    parser = argparse.ArgumentParser(description=&quot;Android APK Packer&quot;)
    parser.add_argument(&#39;-src&#39;, &#39;--src-apk&#39;, required=True, type=Path, help=&#39;Path to source APK file&#39;)
    parser.add_argument(&#39;-shell&#39;, &#39;--shell-apk&#39;, required=True, type=Path, help=&#39;Path to shell APK file&#39;)
    parser.add_argument(&#39;-o&#39;, &#39;-out&#39;, &#39;--output-apk&#39;, type=Path,
                        help=&#39;Output path for packed APK (Default: ./out/&lt;src-apk&gt;_protected.apk)&#39;)
    args = parser.parse_args()
    if args.output_apk == None:
        args.output_apk = Path(&#39;./out&#39;) / (args.src_apk.stem + &#39;_protected.apk&#39;)  # 默认新apk名称及输出路径
    paths = Paths(args.src_apk, args.shell_apk, args.output_apk)

    print(&#39;Source APK:&#39;, paths.srcApkPath)
    print(&#39;Shell APK:&#39;, paths.shellApkPath)
    print(&#39;Output APK:&#39;, paths.newApkPath)
    start(paths)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h5 id="脱壳程序"><a href="#脱壳程序" class="headerlink" title="脱壳程序"></a>脱壳程序</h5><h6 id="FirstProxyApplication-java"><a href="#FirstProxyApplication-java" class="headerlink" title="FirstProxyApplication.java"></a>FirstProxyApplication.java</h6><p>注意关闭Multidex支持，保证只生成一个Dex文件。</p>
<p><strong>attachBaseContext</strong> 中执行以下操作：</p>
<pre><code>1. 创建私有目录，用于保存释放的 dex，lib，源 APK；
1. 调用 **readDexFromApk**， 从壳 APK 中提取壳 dex 文件，保存为字节数组；
1. 调用 **extractSrcApkFromShellDex** 从壳 dex 文件提取源程序 APK 文件，解包 lib 文件到 lib 私有目录；
1. 调用 **replaceClassLoader** 替换壳程序的 ClassLoader；新的 ClassLoader 指定了原 APK dex文件，lib 文件，odex 路径，也就是前面释放的原 APK 和原 lib
</code></pre>
<p>onCreate 调用了 replaceApplication</p>
<ol>
<li>判断 manifest 文件是否通过 meta-data 标签保存了原 APK 的 application，如果原 APK 未指定 application，则使用默认的 application（即壳 application）；</li>
<li>如果原 APK 指定了自定义 application，则创建对应实例，替换掉壳的 application，之后调用 onCreate 方法。</li>
</ol>
<pre><code class="language-Java">package com.example.androidshell1;

import android.app.Application;
import android.app.Instrumentation;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.util.ArrayMap;
import android.util.Log;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import dalvik.system.DexClassLoader;

public class FirstProxyApplication extends  Application &#123;
    private static final String TAG = &quot;NshIdE&quot;;
    private String apkPath;
    private String dexPath;
    private String libPath;
    public void log(String message)&#123;Log.d(TAG, message);&#125;
    @Override
    protected void attachBaseContext(Context base) &#123;
        super.attachBaseContext(base);
        log(&quot;FirstProxyApplication.attachBaseContext() running!&quot;);
        try &#123;
            //1.创建私有目录,保存dex,lib和源apk 具体路径为data/user/0/&lt;package_name&gt;/app_tmp_dex
            File dex = getDir(&quot;tmp_dex&quot;, MODE_PRIVATE);
            File lib = getDir(&quot;tmp_lib&quot;, MODE_PRIVATE);
            dexPath = dex.getAbsolutePath();
            libPath = lib.getAbsolutePath();
            apkPath = dex.getAbsolutePath() + File.separator + &quot;Source.apk&quot;;
            log(&quot;dexPath: &quot; + dexPath);
            log(&quot;libPath: &quot; + libPath);
            log(&quot;apkPath: &quot; + apkPath);

            // 根据文件路径创建File对象
            File apkFile = new File(apkPath);
            // 只有首次运行时需要创建相关文件
            if (!apkFile.exists()) &#123;
                // 根据路径创建文件
                apkFile.createNewFile();
                //读取Classes.dex文件
                byte[] shellDexData = readDexFromApk();
                //从中分离出源apk文件
                extractSrcApkFromShellDex(shellDexData);
            &#125;
            //配置加载源程序的动态环境,即替换mClassLoader
            replaceClassLoader();
        &#125; catch (Exception e) &#123;
            Log.getStackTraceString(e);
        &#125;
    &#125;
    // 从当前程序的apk读取dex文件并存储为字节数组
    private byte[] readDexFromApk() throws IOException &#123;
        //1.获取当前应用程序的源码路径(apk),一般是data/app目录下,该目录用于存放用户安装的软件
        String sourceDir = this.getApplicationInfo().sourceDir;
        log(&quot;this.getApplicationInfo().sourceDir: &quot; +sourceDir);

        //2.创建相关输入流
        FileInputStream fileInputStream = new FileInputStream(sourceDir);
        BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
        ZipInputStream zipInputStream = new ZipInputStream(bufferedInputStream); //用于解析apk文件

        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); //用于存放dex文件

        //3.遍历apk的所有文件并提取dex文件
        ZipEntry zipEntry;
        while((zipEntry = zipInputStream.getNextEntry()) != null)&#123; //存在下一个文件
            // 将classes.dex文件存储到bytearray中 壳dex和源apk合并后只保留一个dex便于处理
            if (zipEntry.getName().equals(&quot;classes.dex&quot;))&#123;
                byte[] bytes = new byte[1024];
                int num;
                while((num = zipInputStream.read(bytes))!=-1)&#123;      //每次读取1024byte,返回读取到的byte数
                    byteArrayOutputStream.write(bytes,0, num); //存放到开辟的byteArrayOutputStream中
                &#125;
            &#125;
            zipInputStream.closeEntry(); //关闭当前文件
        &#125;
        zipInputStream.close();

        log(&quot;Read dex from apk succeed!&quot;);
        return byteArrayOutputStream.toByteArray(); //将读取到的dex文件以字节数组形式返回
    &#125;

    // 从壳dex文件中提取源apk并解析
    private void extractSrcApkFromShellDex(byte[] shellDexData) throws IOException &#123;
        int shellDexLen = shellDexData.length;
        //开始解析dex文件
        //1.读取源apk的大小
        byte[] srcApkSizeBytes = new byte[4];
        System.arraycopy(shellDexData, shellDexLen - 4, srcApkSizeBytes,0,4);
        int srcApkSize =ByteBuffer.wrap(srcApkSizeBytes).order(ByteOrder.LITTLE_ENDIAN).getInt();//转成bytebuffer,方便4 bytes转int 将bytes转成int,加壳时,长度按小端存储

        //2.读取源apk
        byte[] sourceApkData = new byte[srcApkSize];
        System.arraycopy(shellDexData, shellDexLen - srcApkSize - 4, sourceApkData, 0, srcApkSize);//注意减4

        //3.解密源apk
        sourceApkData = decrypt(sourceApkData);
        //写入新建的apk文件中
        File apkfile = new File(apkPath);
        try &#123;
            FileOutputStream apkfileOutputStream = new FileOutputStream(apkfile);
            apkfileOutputStream.write(sourceApkData);
            apkfileOutputStream.close();
        &#125;catch (IOException e)&#123;
            throw new IOException(e);
        &#125;

        //分析源apk,取出so文件放入libPath目录中
        FileInputStream fileInputStream = new FileInputStream(apkfile);
        BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
        ZipInputStream zipInputStream = new ZipInputStream(bufferedInputStream);
        ZipEntry nextEntry;
        while ((nextEntry=zipInputStream.getNextEntry())!=null)&#123;
            String name = nextEntry.getName();
            if (name.startsWith(&quot;lib/&quot;) &amp;&amp; name.endsWith(&quot;.so&quot;))&#123;
                //获取文件名并创建相应文件
                String[] nameSplit = name.split(&quot;/&quot;);
                String soFileStorePath = libPath + File.separator + nameSplit[nameSplit.length - 1];
                File storeFile = new File(soFileStorePath);
                storeFile.createNewFile();

                //读数据到相应so文件中
                FileOutputStream fileOutputStream = new FileOutputStream(storeFile);
                byte[] bytes = new byte[1024];
                int num;
                while((num = zipInputStream.read(bytes))!=-1)&#123;
                    fileOutputStream.write(bytes,0,num);
                &#125;
                fileOutputStream.flush();
                fileOutputStream.close();
            &#125;
            zipInputStream.closeEntry();
        &#125;
        zipInputStream.close();
    &#125;

    // 解密函数
    private byte[] decrypt(byte[] data) &#123;
        for (int i = 0; i &lt; data.length; i++)&#123;
            data[i] ^= (byte) 0xff;
        &#125;
        return data;
    &#125;

    // 替换壳App的ClassLoader为源App的ClassLoader
    private void replaceClassLoader() &#123;
        //1.获取当前的classloader
        ClassLoader classLoader = this.getClassLoader();
        log(&quot;Current ClassLoader: &quot; + classLoader.toString());
        log(&quot;Parent ClassLoader: &quot; + classLoader.getParent().toString());

        //2.反射获取ActivityThread
        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);
        log(&quot;ActivityThread.sCurrentActivity: &quot; + sCurrentActivityThreadObj.toString());

        //3.反射获取LoadedApk
        //获取当前ActivityThread实例的mPackages字段 类型为ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt;, 里面存放了当前应用的LoadedApk对象
        ArrayMap mPackagesObj = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mPackages&quot;);
        log( &quot;mPackagesObj: &quot; + mPackagesObj.toString());

        //获取mPackages中的当前应用包名
        String currentPackageName = this.getPackageName();
        log(&quot;currentPackageName: &quot; + currentPackageName);

        // 获取loadedApk实例也有好几种,mInitialApplication mAllApplications mPackages
        // 通过包名获取当前应用的loadedApk实例
        WeakReference weakReference = (WeakReference) mPackagesObj.get(currentPackageName);
        Object loadedApkObj = weakReference.get();
        log( &quot;LoadedApk: &quot; + loadedApkObj.toString());

        //4.替换ClassLoader
        DexClassLoader dexClassLoader = new DexClassLoader(apkPath,dexPath,libPath, classLoader.getParent()); //动态加载源程序的dex文件,以当前classloader的父加载器作为parent
        Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mClassLoader&quot;,loadedApkObj,dexClassLoader); //替换当前loadedApk实例中的mClassLoader字段
        log(&quot;New DexClassLoader: &quot; + dexClassLoader);
    &#125;

    //替换壳程序LoadedApk的Application为源程序Application,并调用其onCreate方法
    public boolean replaceApplication()&#123;
        // Application实例存在于: LoadedApk.mApplication
        // 以及ActivityThread的mInitialApplication和mAllApplications和mBoundApplication

        //判断源程序是否使用自定义Application 若使用则需要进行替换,若未使用则直接返回,使用壳的默认Application即可

        String appClassName = null; //源程序的Application类名
        try &#123;
            //获取AndroidManifest.xml 文件中的 &lt;meta-data&gt; 元素
            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(this.getPackageName(), PackageManager.GET_META_DATA);
            Bundle metaData = applicationInfo.metaData;
            //获取xml文件声明的Application类
            if (metaData != null &amp;&amp; metaData.containsKey(&quot;APPLICATION_CLASS_NAME&quot;))&#123;
                appClassName = metaData.getString(&quot;APPLICATION_CLASS_NAME&quot;);
            &#125; else &#123;
                log(&quot;源程序中没有自定义Application&quot;);
                return false; //如果不存在直接返回,使用壳的application即可
            &#125;
        &#125; catch (PackageManager.NameNotFoundException e) &#123;
            log(Log.getStackTraceString(e));
        &#125;

        //源程序存在自定义application类,开始替换
        log(&quot;Try to replace Application&quot;);

        //1.反射获取ActivityThread实例
        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);
        log(&quot;ActivityThread: &quot; + sCurrentActivityThreadObj.toString());

        //2.获取并设置LoadedApk
        //获取mBoundApplication (AppBindData对象)
        Object mBoundApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mBoundApplication&quot;) ;
        log(&quot;mBoundApplication: &quot;+mBoundApplicationObj.toString());
        //获取mBoundApplication.info (即LoadedApk)
        Object infoObj = Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;info&quot;);
        log( &quot;LoadedApk: &quot; + infoObj.toString());
        //把LoadedApk的mApplication设置为null,这样后续才能调用makeApplication() 否则由于已存在Application,无法进行替换
        Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mApplication&quot;,infoObj,null);

        //3.获取ActivityThread.mInitialApplication 即拿到旧的Application(对于要加载的Application来讲)
        Object mInitialApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mInitialApplication&quot;);
        log(&quot;mInitialApplicationObj: &quot; + mInitialApplicationObj.toString());

        //4.获取ActivityThread.mAllApplications并删除旧的application
        ArrayList&lt;Application&gt; mAllApplicationsObj = (ArrayList&lt;Application&gt;) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mAllApplications&quot;);
        mAllApplicationsObj.remove(mInitialApplicationObj);
        log(&quot;mInitialApplication 从 mAllApplications 中移除成功&quot;);

        //5.重置相关类的Application类名 便于后续创建Application
        //获取LoadedApk.mApplicationInfo
        ApplicationInfo applicationInfo = (ApplicationInfo) Reflection.getField(&quot;android.app.LoadedApk&quot;,infoObj,&quot;mApplicationInfo&quot;);
        log( &quot;LoadedApk.mApplicationInfo: &quot; + applicationInfo.toString());
        //获取mBoundApplication.appInfo
        ApplicationInfo appinfoInAppBindData = (ApplicationInfo) Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;appInfo&quot;);
        log(&quot;ActivityThread.mBoundApplication.appInfo: &quot; + appinfoInAppBindData.toString());
        //此处通过引用修改值,虽然后续没有使用,但是实际上是修改其指向的LoadedApk相关字段的值
        //设置两个appinfo的classname为源程序的application类名,以便后续调用makeApplication()创建源程序的application
        applicationInfo.className = appClassName;
        appinfoInAppBindData.className = appClassName;
        log(&quot;Source Application name: &quot; + appClassName);


        //6.反射调用makeApplication方法创建源程序的application
        Application application = (Application) Reflection.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;false,null&#125;); //使用源程序中的application
        //Application app = (Application)ReflectionMethods.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;true,null&#125;); //使用自定义的application 强制为系统默认
        log(&quot;Create source Application succeed: &quot;+application);

        //7.重置ActivityThread.mInitialApplication为新的Application
        Reflection.setField(&quot;android.app.ActivityThread&quot;,&quot;mInitialApplication&quot;,sCurrentActivityThreadObj,application);
        log(&quot;Reset ActivityThread.mInitialApplication by new Application succeed!&quot;);

        //8.ContentProvider会持有代理的Application,需要特殊处理一下
        ArrayMap mProviderMap = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mProviderMap&quot;);
        log(&quot;ActivityThread.mProviderMap: &quot; + mProviderMap);

        //获取所有provider,装进迭代器中遍历
        Iterator iterator = mProviderMap.values().iterator();
        while(iterator.hasNext())&#123;
            Object providerClientRecord = iterator.next();
            //获取ProviderClientRecord.mLocalProvider,可能为空
            Object mLocalProvider = Reflection.getField(&quot;android.app.ActivityThread$ProviderClientRecord&quot;,providerClientRecord,&quot;mLocalProvider&quot;) ;
            if(mLocalProvider != null)&#123;
                log(&quot;ProviderClientRecord.mLocalProvider: &quot; + mLocalProvider);
                //获取ContentProvider中的mContext字段,设置为新的Application
                Reflection.setField(&quot;android.content.ContentProvider&quot;,&quot;mContext&quot;,mLocalProvider,application);
            &#125;
        &#125;

        log( &quot;Run Application.onCreate&quot; );
        application.onCreate(); //源程序,启动!
        return true;
    &#125;
    @Override
    public void onCreate() &#123;
        super.onCreate();
        log(&quot;ProxyApplication.onCreate() is running!&quot;);
        if(replaceApplication())
            log(&quot;Replace application succeed!&quot;);
    &#125;
&#125;
</code></pre>
<h6 id="Reflection-java"><a href="#Reflection-java" class="headerlink" title="Reflection.java"></a>Reflection.java</h6><pre><code class="language-Java">package com.example.androidshell1;

import android.util.Log;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class Reflection &#123;
    private static final String TAG = &quot;NshIdE&quot;;
    public static Object invokeStaticMethod(String class_name,String method_name,Class&lt;?&gt;[] parameterTypes,Object[] parameterValues)&#123;
        try &#123;
            Class&lt;?&gt; clazz = Class.forName(class_name); //反射获取Class类对象
            Method method = clazz.getMethod(method_name,parameterTypes);//反射获取方法
            method.setAccessible(true);//突破权限访问控制
            return method.invoke(null,parameterValues);//反射调用,静态方法无需指定所属实例,直接传参即可
        &#125;catch (Exception e)&#123;
            Log.d(TAG, e.toString());
            return null;
        &#125;
    &#125;

    public static Object invokeMethod(String class_name,String method_name,Object obj,Class&lt;?&gt;[] parameterTypes,Object[] parameterValues)
    &#123;
        try &#123;
            Class&lt;?&gt; clazz = Class.forName(class_name);
            Method method = clazz.getMethod(method_name,parameterTypes);
            method.setAccessible(true);//突破权限访问控制
            return method.invoke(obj,parameterValues);// 反射调用,动态方法需要指定所属实例
        &#125;catch (Exception e)
        &#123;
            Log.d(TAG, e.toString());
            return null;
        &#125;
    &#125;

    public static Object getField(String class_name,Object obj,String field_name)
    &#123;
        try &#123;
            Class&lt;?&gt; clazz = Class.forName(class_name);
            Field field = clazz.getDeclaredField(field_name);
            field.setAccessible(true);
            return field.get(obj);  //获取实例字段,需要指定实例对象
        &#125;catch(Exception e)
        &#123;
            Log.d(TAG, e.toString());
            return null;
        &#125;
    &#125;

    public static Object getStaticField(String class_name,String field_name)
    &#123;
        try &#123;
            Class&lt;?&gt; clazz = Class.forName(class_name);
            Field field = clazz.getDeclaredField(field_name);
            field.setAccessible(true);
            return field.get(null);
        &#125;catch (Exception e)
        &#123;
            Log.d(TAG, e.toString());
            return null;
        &#125;
    &#125;

    public static void setField(String class_name,String field_name,Object obj,Object value)
    &#123;
        try &#123;
            Class&lt;?&gt; clazz = Class.forName(class_name);
            Field field = clazz.getDeclaredField(field_name);
            field.setAccessible(true);
            field.set(obj,value);
        &#125;catch (Exception e)
        &#123;
            Log.d(TAG, e.toString());
        &#125;
    &#125;

    public static void setStaticField(String class_name,String field_name,Object value)
    &#123;
        try &#123;
            Class&lt;?&gt; clazz = Class.forName(class_name);
            Field field = clazz.getDeclaredField(field_name);
            field.setAccessible(true);
            field.set(null,value);
        &#125;catch (Exception e)&#123;
            Log.d(TAG, e.toString());
        &#125;
    &#125;
&#125;
</code></pre>
<h6 id="AndroidManifest-xml-1"><a href="#AndroidManifest-xml-1" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h6><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;

    &lt;application
        android:allowBackup=&quot;true&quot;
        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;
        android:fullBackupContent=&quot;@xml/backup_rules&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/Theme.AndroidShell1&quot;
        android:name=&quot;com.example.androidshell1.FirstProxyApplication&quot;&gt;
    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>
<p>​        但是这里脚本略有问题，就是在加载原 APK 的 so 的时候，会存在覆盖的情况，也就是说每次打包加壳生成的 APK，只支持一种 ABI，尽管该 APK 的 lib 目录下有四种 ABI 对应的 so，但是在运行动态加载的时候 会出问题。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​        整体加固——落地加载的核心思路就是将源程序 APK 和 壳 dex 进行合并，运行时动态解密并执行相关环境处理操作，重新执行原 APK 的代码。</p>
<ul>
<li><p>优点：易于实现；</p>
</li>
<li><p>缺点：由于文件落地加载，所以非常容易在文件系统中获取到源程序 APK；两次加载原程序 APK 到内存，效率低。</p>
</li>
</ul>
<h4 id="二代壳-整体加固（不落地加载）"><a href="#二代壳-整体加固（不落地加载）" class="headerlink" title="二代壳-整体加固（不落地加载）"></a>二代壳-整体加固（不落地加载）</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>​        针对落地加载的部分问题，引申出了不落地加载的思路： 即直接加载内存中的dex字节码，避免释放文件。</p>
<p>​        如何在内存中加载dex？<strong>Android 8</strong> 及以上系统中,可以使用系统提供的 <strong>InMemoryDexClassLoader</strong> 实现内存加载，Android7及以下则需要手动实现。</p>
<p>​        另外需要针对第一代加固不支持Multidex进行优化：源apk每个 dex 文件前添加 <strong>4 字节</strong>标识其大小，之后全部合并成一个文件再合并到壳 dex，最后添加 4 字节标识文件总大小。</p>
<p>结构如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821103600951.png" alt="image-20250821103600951"></p>
<h5 id="源程序-1"><a href="#源程序-1" class="headerlink" title="源程序"></a>源程序</h5><p>同一代加固，可开启Multidex支持，其他部分不变。</p>
<h5 id="加壳程序-1"><a href="#加壳程序-1" class="headerlink" title="加壳程序"></a>加壳程序</h5><p>主要改动如下：</p>
<ol>
<li><p>调用 <strong>combineShellAndSourceDexs</strong> 合并壳 dex 和源dex。内部调用 <strong>readAndCombineDexs</strong> 读取并合并源 apk 的<strong>多个 dex</strong> 为一个文件。</p>
</li>
<li><p>复制原 APK 文件时忽略 Manifest 和 dex 文件。</p>
<pre><code class="language-Java">shutil.copytree(paths.srcApkTempDir,paths.newApkTempDir,ignore=shutil.ignore_patterns(&#39;AndroidManifest.xml&#39;,&#39;classes*.dex&#39;))
</code></pre>
</li>
<li><p>ManifeseEditor。添加 <strong>getEtractNativeLibs</strong>，获取application 标签的 <strong>android:extractNativeLibs</strong> 属性值</p>
<p>添加 <strong>resetExtractNativeLibs</strong>，<strong>重置extractNativeLibs&#x3D;true</strong> 强制释放 lib 文件。</p>
</li>
<li><p>handleManifest。判断源程序 Manifest 是否设置了android:extractNativeLibs&#x3D;”true”，若为 false(默认)则改为true。</p>
</li>
</ol>
<pre><code class="language-python">from zlib import adler32
from hashlib import sha1
from binascii import unhexlify
from lxml import etree
import subprocess
import shutil
from pathlib import Path
import argparse


# 封装path类,保存全局用到的路径
class Paths:
    def __init__(self, srcApk: Path, shellApk: Path, outputApk: Path):
        # Apk file paths
        self.srcApkPath = srcApk.resolve()  # 解析为绝对路径
        self.shellApkPath = shellApk.resolve()
        self.newApkPath = outputApk.resolve()

        # Temp directories default python file path
        self.tmpdir = Path(__file__).parent / &#39;temp&#39;
        self.srcApkTempDir = self.tmpdir / &#39;srcApkTemp&#39;
        self.shellApkTempDir = self.tmpdir / &#39;shellApkTemp&#39;
        self.newApkTempDir = self.tmpdir / &#39;newApkTemp&#39;


# Apktool类 提供解包,打包,签名功能
class Apktool:
    def __init__(self):
        self.apktool_path = Path(__file__).parent.parent / &#39;tools/apktool/apktool.bat&#39;
        self.signer_path = Path(__file__).parent / &#39;tools/uber-apk-signer-1.3.0.jar&#39;

    def signApk(self, unsignedApkPath: Path):
        self.runCommand([&#39;java&#39;, &#39;-jar&#39;, self.signer_path, &#39;--apk&#39;, unsignedApkPath])

    # 使用apktool解包apk 只解包资源不解包dex
    def extractApk(self, apkPath: Path, outputDir: Path):
        self.runCommand([self.apktool_path, &#39;d&#39;, apkPath, &#39;-s&#39;, &#39;-o&#39;, outputDir])

    # 重打包apk
    def repackApk(self, inputDir: Path, outApk: Path):
        self.runCommand([self.apktool_path, &#39;b&#39;, inputDir, &#39;-o&#39;, outApk])

    def runCommand(self, args):
        subprocess.run(args, stdout=subprocess.DEVNULL)  # 仅调用工具,不需要输出,重定向stdout到os.devnull
        # 参数列表 捕获输出 输出转为字符串
        # print(subprocess.run(args,  capture_output=True,text=True).stdout)


# AndroidManifest.xml的editor 用于获取和修改标签属性,以及添加标签
class ManifestEditor:
    def __init__(self, xml_content: bytes):
        self.ns = &#123;&#39;android&#39;: &#39;http://schemas.android.com/apk/res/android&#39;&#125;
        self.tree = etree.fromstring(xml_content)

    # 获取指定标签的android属性值 examples: get_attr(&#39;application&#39;, &#39;name&#39;) get_attr(&#39;activity&#39;, &#39;name&#39;)
    def getTagAttribute(self, tag_name: str, attr_name: str):
        if tag_name == &#39;manifest&#39;:  # 根标签特殊处理
            elem = self.tree
            if elem is not None:
                return elem.get(f&#39;&#123;attr_name&#125;&#39;)  # 寻找标签的属性
        else:
            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)
            if elem is not None:
                return elem.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;)  # 根标签之外的属性位于android命名空间下
        return None

    # 设置指定标签的属性值 example:set_attr(&#39;application&#39;,&#39;name&#39;,&quot;com.example.ProxyApplication&quot;)
    def setTagAttribute(self, tag_name: str, attr_name: str, new_value: str):
        if tag_name == &#39;manifest&#39;:  # 根标签特殊处理
            elem = self.tree
            if elem is not None:
                return elem.set(f&#39;&#123;attr_name&#125;&#39;, new_value)  # 设置属性值
        else:
            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)
            if elem is not None:
                elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;, new_value)
                return True
        return False

    # 在指定父标签下添加新子标签 example: add_tag(&#39;application&#39;,&quot;meta-data&quot;,&#123;&#39;name&#39;: &#39;android.permission.CAMERA&#39;,&#39;value&#39;:&#39;hello&#39;&#125;)
    def addTagWithAttributes(self, parent_tag: str, new_tag: str, attrs: dict):
        if parent_tag == &#39;manifest&#39;:
            parent = self.tree
            if parent is not None:
                new_elem = etree.SubElement(parent, new_tag)
                for k, v in attrs.items():  # 支持一次给添加的标签设置多个属性
                    new_elem.set(f&#39;&#123;k&#125;&#39;, v)
                return True
        else:
            parent = self.tree.find(f&#39;.//&#123;parent_tag&#125;&#39;, namespaces=self.ns)
            if parent is not None:
                new_elem = etree.SubElement(parent, new_tag)
                for k, v in attrs.items():
                    new_elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;k&#125;&#39;, v)
                return True
        return False

    # 不以壳manifest为基准操作则用不到该函数,以源apk的manifest为基准自带,无需额外设置
    def getMainActivity(self):
        activities = self.tree.findall(&#39;.//activity&#39;, namespaces=self.ns)
        for activity in activities:
            intent_filters = activity.findall(&#39;.//intent-filter&#39;, namespaces=self.ns)
            for intent_filter in intent_filters:
                action = intent_filter.find(&#39;.//action[@android:name=&quot;android.intent.action.MAIN&quot;]&#39;, namespaces=self.ns)
                category = intent_filter.find(&#39;.//category[@android:name=&quot;android.intent.category.LAUNCHER&quot;]&#39;,
                                              namespaces=self.ns)
                if action is not None and category is not None:
                    return activity.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;name&#39;)
        return None

    def getApplication(self):
        return self.getTagAttribute(&#39;application&#39;, &#39;name&#39;)

    def setApplication(self, application: str):
        self.setTagAttribute(&#39;application&#39;, &#39;name&#39;, application)

    def addMetaData(self, name: str, value: str):
        self.addTagWithAttributes(&#39;application&#39;, &#39;meta-data&#39;, &#123;&#39;name&#39;: name, &#39;value&#39;: value&#125;)

    def getManifestData(self):
        &quot;&quot;&quot;返回XML字符串&quot;&quot;&quot;
        return etree.tostring(self.tree, pretty_print=True, encoding=&#39;utf-8&#39;, xml_declaration=True).decode()

    def getEtractNativeLibs(self):
        &quot;&quot;&quot;返回是否释放so文件&quot;&quot;&quot;
        return self.getTagAttribute(&#39;application&#39;, &#39;extractNativeLibs&#39;)

    def resetExtractNativeLibs(self):
        &quot;&quot;&quot;重置etractNativeLibs属性为true&quot;&quot;&quot;
        self.setTagAttribute(&#39;application&#39;, &#39;extractNativeLibs&#39;, &#39;true&#39;)


# 合并壳dex和源apk的dex
def combineShellAndSourceDexs(shellApkTempDir: Path, srcApkTempDir: Path, newApkTempDir: Path):
    def fixCheckSum(dexBytesArray):
        # dexfile[8:12]
        # 小端存储
        value = adler32(bytes(dexBytesArray[12:]))
        valueArray = bytearray(value.to_bytes(4, &#39;little&#39;))
        for i in range(len(valueArray)):
            dexBytesArray[8 + i] = valueArray[i]

    def fixSignature(dexBytesArray):
        # dexfile[12:32]
        sha_1 = sha1()
        sha_1.update(bytes(dexBytesArray[32:]))
        value = sha_1.hexdigest()
        valueArray = bytearray(unhexlify(value))
        for i in range(len(valueArray)):
            dexBytesArray[12 + i] = valueArray[i]

    def fixFileSize(dexBytesArray, fileSize):
        # dexfile[32:36]
        # 小端存储
        fileSizeArray = bytearray(fileSize.to_bytes(4, &quot;little&quot;))
        for i in range(len(fileSizeArray)):
            dexBytesArray[32 + i] = fileSizeArray[i]

    def encrypto(file):
        for i in range(len(file)):
            file[i] ^= 0xff
        return file

    def readAndCombineDexs(unpackedApkDir: Path):
        # 读取解包后的apk的所有dex文件,并合并为一个dex文件
        combinedDex = bytearray()
        # glob方法返回包含所有匹配文件的生成器
        for dex in unpackedApkDir.glob(&#39;classes*.dex&#39;):
            print(&#39;Source Apk Dex file:&#39;, dex)
            with open(dex, &#39;rb&#39;) as f:
                data = bytearray(f.read())
                combinedDex += bytearray(len(data).to_bytes(4, &#39;little&#39;))  # dex文件的长度,小端序
                combinedDex += data  # dex文件内容
        return combinedDex

    # 获取shelldex
    with open(shellApkTempDir / &#39;classes.dex&#39;, &#39;rb&#39;) as f:
        shellDexArray = bytearray(f.read())

    # 获取源apk的dex文件
    srcDexArray = readAndCombineDexs(srcApkTempDir)
    # 新的dex文件长度
    newDexLen = len(srcDexArray) + len(shellDexArray) + 4
    # 加密源文件
    encSrcDexArray = encrypto(srcDexArray)
    # 新的dex文件内容 = 壳dex + 加密的源dex + 四字节标识加密后源dex大小长度
    newDexArray = shellDexArray + encSrcDexArray + bytearray(len(encSrcDexArray).to_bytes(4, &#39;little&#39;))

    # 修改filesize
    fixFileSize(newDexArray, newDexLen)
    # 修改signature
    fixSignature(newDexArray)
    # 修改checksum
    fixCheckSum(newDexArray)
    # 导出文件
    with open(newApkTempDir / &#39;classes.dex&#39;, &#39;wb&#39;) as f:
        f.write(newDexArray)


# 提取源apk的Manifest文件,修改application为壳application(可能添加meta-data标签),输出新的Manifest文件
def handleManifest(srcApkTempDir: Path, shellApkTempDir: Path, newApkTempDir: Path):
    # 从源apk提取AndroidManifest.xml
    with open(srcApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:
        srcManifestEditor = ManifestEditor(f.read().encode())
    srcApplication = srcManifestEditor.getApplication()
    srcExtractNativeLibs = srcManifestEditor.getEtractNativeLibs()
    print(&#39;SourceApplication:&#39;, srcApplication)
    print(&#39;SourceExtractNativeLibs:&#39;, srcExtractNativeLibs)

    # 从壳apk提取AndroidManifest.xml
    with open(shellApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:
        shellManifestEditor = ManifestEditor(f.read().encode())
    print(&#39;ShellApplication:&#39;, shellManifestEditor.getApplication())

    # 修改源AndroidManifest.xml的application为壳的代理application
    srcManifestEditor.setApplication(shellManifestEditor.getApplication())

    # 写入meta-data标签 保存源apk的原始application
    if srcApplication != None:
        print(&#39;Source application:&#39;, srcApplication)
        srcManifestEditor.addMetaData(&#39;APPLICATION_CLASS_NAME&#39;, srcApplication)

    # 如果源apk的manifest中默认设置etractNativeLibs=false,则重置为true,确保释放lib文件
    if srcExtractNativeLibs == &#39;false&#39;:
        srcManifestEditor.resetExtractNativeLibs()

    # 输出新的AndroidManifest.xml
    with open(newApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;w&#39;) as f:
        f.write(srcManifestEditor.getManifestData())


def start(paths: Paths):
    apktool = Apktool()
    # 1.分别解包源文件和壳文件到临时目录
    print(&#39;Extracting source and shell apk...&#39;)
    apktool.extractApk(paths.srcApkPath, paths.srcApkTempDir)
    print(&#39;Extract source apk success!&#39;)

    print(&#39;Extracting shell apk...&#39;)
    apktool.extractApk(paths.shellApkPath, paths.shellApkTempDir)
    print(&#39;Extract shell apk success!&#39;)

    # 2.复制源apk所有文件到新apk临时目录中,忽略源dex和manifest文件
    print(&#39;Copying source apk files to new apk temp dir...&#39;)
    shutil.copytree(paths.srcApkTempDir, paths.newApkTempDir,
                    ignore=shutil.ignore_patterns(&#39;AndroidManifest.xml&#39;, &#39;classes*.dex&#39;))
    print(&#39;Copy source apk files success!&#39;)

    # 3.处理AndroidManifest.xml
    print(&#39;Handling AndroidManifest.xml...&#39;)
    handleManifest(paths.srcApkTempDir, paths.shellApkTempDir, paths.newApkTempDir)
    print(&#39;Handle AndroidManifest.xml success!&#39;)

    # 4.合并壳dex和源apk并导出文件
    print(&#39;Combining shell dex and source dexs...&#39;)
    combineShellAndSourceDexs(paths.shellApkTempDir, paths.srcApkTempDir, paths.newApkTempDir)
    print(&#39;Combine shell dex and source dexs success!&#39;)

    # 5.重打包apk
    print(&#39;Repacking apk...&#39;)
    apktool.repackApk(paths.newApkTempDir, paths.newApkPath)
    print(&#39;Repack apk success!&#39;)

    # 6.签名apk
    print(&#39;Signing apk...&#39;)
    apktool.signApk(paths.newApkPath)
    print(&#39;Resign apk success!&#39;)

    # 7.删除临时目录
    print(&#39;Deleting temp directories...&#39;)
    shutil.rmtree(paths.tmpdir)  # 删除临时目录
    print(&#39;Delete temp directories success!&#39;)


def main():
    parser = argparse.ArgumentParser(description=&quot;Android APK Packer&quot;)
    parser.add_argument(&#39;-src&#39;, &#39;--src-apk&#39;, required=True, type=Path, help=&#39;Path to source APK file&#39;)
    parser.add_argument(&#39;-shell&#39;, &#39;--shell-apk&#39;, required=True, type=Path, help=&#39;Path to shell APK file&#39;)
    parser.add_argument(&#39;-o&#39;, &#39;-out&#39;, &#39;--output-apk&#39;, type=Path,
                        help=&#39;Output path for packed APK (Default: ./out/&lt;src-apk&gt;_protected.apk)&#39;)
    args = parser.parse_args()
    if args.output_apk == None:
        args.output_apk = Path(&#39;./out&#39;) / (args.src_apk.stem + &#39;_protected.apk&#39;)  # 默认新apk名称及输出路径
    paths = Paths(args.src_apk, args.shell_apk, args.output_apk)

    print(&#39;Source APK:&#39;, paths.srcApkPath)
    print(&#39;Shell APK:&#39;, paths.shellApkPath)
    print(&#39;Output APK:&#39;, paths.newApkPath)
    start(paths)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h5 id="脱壳程序-1"><a href="#脱壳程序-1" class="headerlink" title="脱壳程序"></a>脱壳程序</h5><p>SecondProxyApplication.java 相比 FirstProxyApplication.java改动如下：</p>
<ol>
<li>attachBaseContext。读取壳 dex 文件后，提取源程序 dex 文件,之后替换 ClassLoader，没有设置私有目录和释放文件等操作。</li>
<li>extractDexFilesFromShellDex。替代<strong>splitSourceApkFromShellDex</strong>，从壳 dex 提取源程序dex 文件并存储为 ByteBuffer[]。</li>
<li>replaceClassLoader。一代加固使用 DexClassLoader 从文件加载，二代加固使用 InMemoryDexClassLoader。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>在 Android 8.0 以下不支持 InMemoryDexClassLoader，需要手动实现；</li>
<li>在 Android 10.0 以下不支持 InMemoryDexClassLoader 指定 lib 目录的重载；默认搜索路径为<strong>nativeLibraryDirectories&#x3D;[&#x2F;system&#x2F;lib64, &#x2F;product&#x2F;lib64]]]</strong>。</li>
</ul>
<p>​        可参考以下文章修复 lib 目录的问题：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/q610098308/article/details/105246355">https://blog.csdn.net/q610098308/article/details/105246355</a></p>
<p><a target="_blank" rel="noopener" href="http://www.yxhuang.com/2020/03/28/android-so-load/">http://www.yxhuang.com/2020/03/28/android-so-load/</a></p>
<ul>
<li>若源程序设置了 android:extractNativeLibs&#x3D;”false”，则不会释放 lib 文件到文件系统，而是直接映射 APK 文件的 lib 数据。如果遇到这种情况则需要手动处理，模拟映射加载 so 的操作，背后的逻辑比较复杂，并且需要考虑兼容性。为了简化处理可以将加壳后 APK 的 <strong>android:extractNativeLibs</strong> 属性改为 true，强行指定释放 lib。</li>
</ul>
<pre><code class="language-Java">package com.example.androidshell2;

import android.app.Application;
import android.app.Instrumentation;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.util.ArrayMap;
import android.util.Log;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import dalvik.system.InMemoryDexClassLoader;

public class SecondProxyApplication extends Application &#123;
    private final String TAG=&quot;NshIdE&quot;;
    public void log(String message)&#123;Log.d(TAG,message);&#125;
    @Override
    protected void attachBaseContext(Context base) &#123;
        super.attachBaseContext(base);
        log(&quot;SecondProxyApplication.attachBaseContext is running!&quot;);
        try &#123;
            byte[] shellDexData = readDexFromApk();
            log(&quot;成功从源APK中读取classes.dex&quot;);
            //从中分理出源dex文件
            ByteBuffer[] byteBuffers = extractDexFilesFromShellDex(shellDexData);
            log(&quot;成功分离出源dex集合&quot;);
            //配置加载源程序的动态环境,即替换mClassLoader
            replaceClassLoader(byteBuffers);
        &#125; catch (Exception e) &#123;
            log( Log.getStackTraceString(e));
        &#125;
    &#125;
    @Override
    public void onCreate() &#123;
        super.onCreate();
        log(&quot;SecondProxyApplication.onCreate is running!&quot;);
        if(replaceApplication())
            log(&quot;替换Application成功&quot;);
    &#125;
    // 从壳dex文件中提取源apk的dex并封装为ByteBuffer
    private ByteBuffer[] extractDexFilesFromShellDex(byte[] shellDexData) throws IOException &#123;
        int shellDexlength = shellDexData.length;
        //开始解析dex文件
        byte[] sourceDexsSizeByte = new byte[4];
        //读取源dexs的大小
        System.arraycopy(shellDexData,shellDexlength - 4, sourceDexsSizeByte,0,4);
        //转成bytebuffer,方便4byte转int
        ByteBuffer wrap = ByteBuffer.wrap(sourceDexsSizeByte);
        //将byte转成int, 加壳时,长度按小端存储
        int sourceDexsSizeInt = wrap.order(ByteOrder.LITTLE_ENDIAN).getInt();
        Log.d(TAG, &quot;源dex集合的大小: &quot; + sourceDexsSizeInt);
        //读取源dexs
        byte[] sourceDexsData = new byte[sourceDexsSizeInt];
        System.arraycopy(shellDexData,shellDexlength - sourceDexsSizeInt - 4, sourceDexsData, 0, sourceDexsSizeInt);
        //解密源dexs
        sourceDexsData = decrypt(sourceDexsData);

        //更新部分
        //从源dexs中分离dex
        ArrayList&lt;byte[]&gt; sourceDexList = new ArrayList&lt;&gt;();
        int pos = 0;
        while(pos &lt; sourceDexsSizeInt)&#123;
            //先提取四个字节,描述当前dex的大小
            //开始解析dex文件
            byte[] singleDexSizeByte = new byte[4];
            //读取源dexs的大小
            System.arraycopy(sourceDexsData, pos, singleDexSizeByte,0,4);
            //转成bytebuffer,方便4byte转int
            ByteBuffer singleDexwrap = ByteBuffer.wrap(singleDexSizeByte);
            int singleDexSizeInt = singleDexwrap.order(ByteOrder.LITTLE_ENDIAN).getInt();
            Log.d(TAG, &quot;当前singleDex的大小: &quot; + singleDexSizeInt);
            //读取单独dex
            byte[] singleDexData = new byte[singleDexSizeInt];
            System.arraycopy(sourceDexsData,pos + 4, singleDexData, 0, singleDexSizeInt);
            //加入到dexlist中
            sourceDexList.add(singleDexData);
            //更新pos
            pos += 4 + singleDexSizeInt;
        &#125;

        //将dexlist包装成ByteBuffer
        int dexNum = sourceDexList.size();
        Log.d(TAG, &quot;源dex的数量: &quot; + dexNum);
        ByteBuffer[] dexBuffers = new ByteBuffer[dexNum];
        for (int i = 0; i &lt; dexNum; i++)&#123;
            dexBuffers[i] = ByteBuffer.wrap(sourceDexList.get(i));
        &#125;

        return dexBuffers;

    &#125;
    // 从apk读取dex文件并返回dex对应字节数组
    // 从当前程序的apk读取dex文件并存储为字节数组
    private byte[] readDexFromApk() throws IOException &#123;
        //1.获取当前应用程序的源码路径(apk),一般是data/app目录下,该目录用于存放用户安装的软件
        String sourceDir = this.getApplicationInfo().sourceDir;
        log(&quot;this.getApplicationInfo().sourceDir: &quot; +sourceDir);

        //2.创建相关输入流
        FileInputStream fileInputStream = new FileInputStream(sourceDir);
        BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
        ZipInputStream zipInputStream = new ZipInputStream(bufferedInputStream); //用于解析apk文件

        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); //用于存放dex文件

        //3.遍历apk的所有文件并提取dex文件
        ZipEntry zipEntry;
        while((zipEntry = zipInputStream.getNextEntry()) != null)&#123; //存在下一个文件
            // 将classes.dex文件存储到bytearray中 壳dex和源apk合并后只保留一个dex便于处理
            if (zipEntry.getName().equals(&quot;classes.dex&quot;))&#123;
                byte[] bytes = new byte[1024];
                int num;
                while((num = zipInputStream.read(bytes))!=-1)&#123;      //每次读取1024byte,返回读取到的byte数
                    byteArrayOutputStream.write(bytes,0, num); //存放到开辟的byteArrayOutputStream中
                &#125;
            &#125;
            zipInputStream.closeEntry(); //关闭当前文件
        &#125;
        zipInputStream.close();

        log(&quot;Read dex from apk succeed!&quot;);
        return byteArrayOutputStream.toByteArray(); //将读取到的dex文件以字节数组形式返回
    &#125;
    private byte[] decrypt(byte[] sourceApkdata) &#123;
        for (int i = 0; i &lt; sourceApkdata.length; i++)&#123;
            sourceApkdata[i] ^= (byte) 0xff;
        &#125;
        return sourceApkdata;

    &#125;
    //替换壳程序LoadedApk的Application为源程序Application,并调用其onCreate方法
    public boolean replaceApplication()&#123;
        // Application实例存在于: LoadedApk.mApplication
        // 以及ActivityThread的mInitialApplication和mAllApplications和mBoundApplication

        //判断源程序是否使用自定义Application 若使用则需要进行替换,若未使用则直接返回,使用壳的默认Application即可

        String appClassName = null; //源程序的Application类名
        try &#123;
            //获取AndroidManifest.xml 文件中的 &lt;meta-data&gt; 元素
            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(this.getPackageName(), PackageManager.GET_META_DATA);
            Bundle metaData = applicationInfo.metaData;
            //获取xml文件声明的Application类
            if (metaData != null &amp;&amp; metaData.containsKey(&quot;APPLICATION_CLASS_NAME&quot;))&#123;
                appClassName = metaData.getString(&quot;APPLICATION_CLASS_NAME&quot;);
            &#125; else &#123;
                log(&quot;源程序中没有自定义Application&quot;);
                return false; //如果不存在直接返回,使用壳的application即可
            &#125;
        &#125; catch (PackageManager.NameNotFoundException e) &#123;
            log(Log.getStackTraceString(e));
        &#125;

        //源程序存在自定义application类,开始替换
        log(&quot;Try to replace Application&quot;);

        //1.反射获取ActivityThread实例
        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);
        log(&quot;ActivityThread: &quot; + sCurrentActivityThreadObj.toString());

        //2.获取并设置LoadedApk
        //获取mBoundApplication (AppBindData对象)
        Object mBoundApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mBoundApplication&quot;) ;
        log(&quot;mBoundApplication: &quot;+mBoundApplicationObj.toString());
        //获取mBoundApplication.info (即LoadedApk)
        Object infoObj = Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;info&quot;);
        log( &quot;LoadedApk: &quot; + infoObj.toString());
        //把LoadedApk的mApplication设置为null,这样后续才能调用makeApplication() 否则由于已存在Application,无法进行替换
        Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mApplication&quot;,infoObj,null);

        //3.获取ActivityThread.mInitialApplication 即拿到旧的Application(对于要加载的Application来讲)
        Object mInitialApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mInitialApplication&quot;);
        log(&quot;mInitialApplicationObj: &quot; + mInitialApplicationObj.toString());

        //4.获取ActivityThread.mAllApplications并删除旧的application
        ArrayList&lt;Application&gt; mAllApplicationsObj = (ArrayList&lt;Application&gt;) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mAllApplications&quot;);
        mAllApplicationsObj.remove(mInitialApplicationObj);
        log(&quot;mInitialApplication 从 mAllApplications 中移除成功&quot;);

        //5.重置相关类的Application类名 便于后续创建Application
        //获取LoadedApk.mApplicationInfo
        ApplicationInfo applicationInfo = (ApplicationInfo) Reflection.getField(&quot;android.app.LoadedApk&quot;,infoObj,&quot;mApplicationInfo&quot;);
        log( &quot;LoadedApk.mApplicationInfo: &quot; + applicationInfo.toString());
        //获取mBoundApplication.appInfo
        ApplicationInfo appinfoInAppBindData = (ApplicationInfo) Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;appInfo&quot;);
        log(&quot;ActivityThread.mBoundApplication.appInfo: &quot; + appinfoInAppBindData.toString());
        //此处通过引用修改值,虽然后续没有使用,但是实际上是修改其指向的LoadedApk相关字段的值
        //设置两个appinfo的classname为源程序的application类名,以便后续调用makeApplication()创建源程序的application
        applicationInfo.className = appClassName;
        appinfoInAppBindData.className = appClassName;
        log(&quot;Source Application name: &quot; + appClassName);


        //6.反射调用makeApplication方法创建源程序的application
        Application application = (Application) Reflection.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;false,null&#125;); //使用源程序中的application
        //Application app = (Application)ReflectionMethods.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;true,null&#125;); //使用自定义的application 强制为系统默认
        log(&quot;Create source Application succeed: &quot;+application);

        //7.重置ActivityThread.mInitialApplication为新的Application
        Reflection.setField(&quot;android.app.ActivityThread&quot;,&quot;mInitialApplication&quot;,sCurrentActivityThreadObj,application);
        log(&quot;Reset ActivityThread.mInitialApplication by new Application succeed!&quot;);

        //8.ContentProvider会持有代理的Application,需要特殊处理一下
        ArrayMap mProviderMap = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mProviderMap&quot;);
        log(&quot;ActivityThread.mProviderMap: &quot; + mProviderMap);

        //获取所有provider,装进迭代器中遍历
        Iterator iterator = mProviderMap.values().iterator();
        while(iterator.hasNext())&#123;
            Object providerClientRecord = iterator.next();
            //获取ProviderClientRecord.mLocalProvider,可能为空
            Object mLocalProvider = Reflection.getField(&quot;android.app.ActivityThread$ProviderClientRecord&quot;,providerClientRecord,&quot;mLocalProvider&quot;) ;
            if(mLocalProvider != null)&#123;
                log(&quot;ProviderClientRecord.mLocalProvider: &quot; + mLocalProvider);
                //获取ContentProvider中的mContext字段,设置为新的Application
                Reflection.setField(&quot;android.content.ContentProvider&quot;,&quot;mContext&quot;,mLocalProvider,application);
            &#125;
        &#125;

        log( &quot;Run Application.onCreate&quot; );
        application.onCreate(); //源程序,启动!
        return true;
    &#125;
    // 替换壳App的ClassLoader为源App的ClassLoader
    private void replaceClassLoader(ByteBuffer[] byteBuffers) throws Exception&#123;
        //1.获取当前的classloader
        ClassLoader classLoader = this.getClassLoader();
        log(&quot;Current ClassLoader: &quot; + classLoader.toString());
        log(&quot;Parent ClassLoader: &quot; + classLoader.getParent().toString());

        //2.反射获取ActivityThread
        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);
        log(&quot;ActivityThread.sCurrentActivity: &quot; + sCurrentActivityThreadObj.toString());

        //3.反射获取LoadedApk
        //获取当前ActivityThread实例的mPackages字段 类型为ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt;, 里面存放了当前应用的LoadedApk对象
        ArrayMap mPackagesObj = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mPackages&quot;);
        log( &quot;mPackagesObj: &quot; + mPackagesObj.toString());

        //获取mPackages中的当前应用包名
        String currentPackageName = this.getPackageName();
        log(&quot;currentPackageName: &quot; + currentPackageName);

        // 获取loadedApk实例也有好几种,mInitialApplication mAllApplications mPackages
        // 通过包名获取当前应用的loadedApk实例
        WeakReference weakReference = (WeakReference) mPackagesObj.get(currentPackageName);
        Object loadedApkObj = weakReference.get();
        log( &quot;LoadedApk: &quot; + loadedApkObj.toString());

        //动态加载源程序的dex文件
        if(Build.VERSION.SDK_INT&gt;=29)&#123;
            Log.d(TAG,&quot;Library path:&quot;+this.getApplicationInfo().nativeLibraryDir);
            InMemoryDexClassLoader dexClassLoader=new InMemoryDexClassLoader(byteBuffers,this.getApplicationInfo().nativeLibraryDir,classLoader.getParent());
            Log.d(TAG, &quot;New InMemoryDexClassLoader: &quot; + dexClassLoader);
            //替换当前loadedApk实例中的mClassLoader字段
            Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mClassLoader&quot;,loadedApkObj,dexClassLoader);
        &#125;
        else&#123;

            Log.d(TAG,&quot;不支持Android 8.0以下版本&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>​        二代加固使用不落地加载技术，可在内存中直接加载dex，实际上是对落地加载的更新。</p>
<p>​        第一代和第二代加固统称为整体加固，在部分资料中将他们合称为一代加固，将代码抽取加固称为二代加固。</p>
<ul>
<li>优点：相对一代加固更加高效，不容易从文件系统获取 dex 文件从而得到关键代码；</li>
<li>缺点：兼容性问题: 源程序的libso处理起来比较复杂；低版本需要手动实现InMemoryDexClassLoader。</li>
</ul>
<p>​        当然，总的来说，整体加固现在都能一把梭，用 frida-dexdump。</p>
<h3 id="三、第三代壳-抽取加固"><a href="#三、第三代壳-抽取加固" class="headerlink" title="三、第三代壳-抽取加固"></a>三、第三代壳-抽取加固</h3><p>​        基于整体加固遇到的部分问题，引申出了第三代加固——代码抽取加固。</p>
<p>​        思路：将关键方法的指令抽空，替换为 nop 指令，运行时动态回填指令执行，回填的核心是对 Android 系统核心函数进行 hook。</p>
<ol>
<li>Hook 点<ul>
<li>常用的 Hook 点有 <strong>ClassLinker::LoadMethod</strong> 和 <strong>ClassLinker:DefineClass</strong>，二者都可以获取 DexFile 对象；</li>
<li>LoadMethod：可获取 Method 对象，从而获取 codeOff，方便回填处理，但兼容性差；</li>
<li>DefineClass：可获取 ClassDef 对象，需要解析得到 codeOff，更复杂但兼容性更好，变化不大。</li>
</ul>
</li>
<li>如何抽取代码（可参考这篇<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-284995.htm">文章</a>中的 Dex 文件结构和代码抽取部分）<ul>
<li>Dex 文件结构中的 <strong>DexClassDef</strong> 结构定义了各个类的信息，其中的 <strong>DexClassData</strong> 结构记录了类的 <strong>字段</strong> 和 <strong>方法数据</strong>；</li>
<li>方法由 <strong>DexMethod</strong> 结构保存，其 codeOff 成员保存了方法的字节码数据在文件中的偏移，根据该偏移可以进行抽取。</li>
</ul>
</li>
</ol>
<p><strong>LoadMethod</strong> 声明如下</p>
<pre><code class="language-c++">//Android 7及以前
  void LoadMethod(Thread* self,
                  const DexFile&amp; dex_file,
                  const ClassDataItemIterator&amp; it,
                  Handle&lt;mirror::Class&gt; klass, ArtMethod* dst)
//Android 8-9
  void LoadMethod(const DexFile&amp; dex_file,
                  const ClassDataItemIterator&amp; it,
                  Handle&lt;mirror::Class&gt; klass, ArtMethod* dst)
//Android 10-14
    void LoadMethod(const DexFile&amp; dex_file,
                  const ClassAccessor::Method&amp; method,
                  Handle&lt;mirror::Class&gt; klass,
                  ArtMethod* dst)
     
//Android 15
  void LoadMethod(const DexFile&amp; dex_file,
                  const ClassAccessor::Method&amp; method,
                  ObjPtr&lt;mirror::Class&gt; klass,
                  /*inout*/ MethodAnnotationsIterator* mai,
                  /*out*/ ArtMethod* dst)
</code></pre>
<p><strong>DefineClass</strong> 声明如下</p>
<pre><code class="language-c++">// Android 5.0 Level 21 及之前使用该声明
static void* (*g_originDefineClassV21)(void* thiz,
                                       const char* descriptor,
                                       void* class_loader,
                                       const void* dex_file,
                                       const void* dex_class_def);
/*
//原始声明
mirror::Class* DefineClass(const char* descriptor,
                            Handle&lt;mirror::ClassLoader&gt; class_loader,
                            const DexFile&amp; dex_file,
                            const DexFile::ClassDef&amp; dex_class_def)
*/
 
// Android 5.1-14 Level22-34使用该声明
static void* (*g_originDefineClassV22)(void* thiz,
                                       void* self,
                                       const char* descriptor,
                                       size_t hash,
                                       void* class_loader,
                                       const void* dex_file,
                                       const void* dex_class_def);
/*
//原始声明
ObjPtr&lt;mirror::Class&gt; DefineClass(Thread* self,
                                  const char* descriptor,
                                  size_t hash,
                                  Handle&lt;mirror::ClassLoader&gt; class_loader,
                                  const DexFile&amp; dex_file,
                                  const dex::ClassDef&amp; dex_class_def)
*/
 
//Android 15 Level 35 以后使用该声明
static void* (*g_originDefineClassV35)(void* thiz,
                                       void* self,
                                       const char* descriptor,
                                       size_t descriptor_length,
                                       size_t hash,
                                       void* class_loader,
                                       const void* dex_file,
                                       const void* dex_class_def);
//原始声明
/*
ObjPtr&lt;mirror::Class&gt; DefineClass(Thread* self,
                                  const char* descriptor,
                                  size_t descriptor_length,
                                  size_t hash,
                                  Handle&lt;mirror::ClassLoader&gt; class_loader,
                                  const DexFile&amp; dex_file,
                                  const dex::ClassDef&amp; dex_class_def)
*/
</code></pre>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><h5 id="源程序3"><a href="#源程序3" class="headerlink" title="源程序3"></a>源程序3</h5><p>主要包括 3 个技术点（同上）：</p>
<ol>
<li>Native 层 NDK 开发；</li>
<li>Multidex</li>
<li>自定义 Application</li>
</ol>
<hr>
<h5 id="加壳程序-2"><a href="#加壳程序-2" class="headerlink" title="加壳程序"></a>加壳程序</h5><p>加壳程序主要分为三个模块</p>
<ol>
<li>APK 处理模块：提供解包 APK、打包 APK、签名 APK 的功能；</li>
<li>XML 处理模块：提供读取标签、修改标签、添加标签的功能；</li>
<li>DEX 处理模块：提供合并多 Dex，加密 Dex，代码抽取、文件修复的功能。</li>
</ol>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821160930725.png" alt="image-20250821160930725"></p>
<p>加壳程序工作基本流程图如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821161000396.png" alt="image-20250821161000396"></p>
<p>加壳程序工作流程总览图如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821161209038.png" alt="image-20250821161209038"></p>
<p>相对于 SecondShell.py 的改动如下：</p>
<ol>
<li>start<ul>
<li>解包原 APK 后 调用 extractAllDexFiles 抽取出所有 dex 文件的代码；</li>
<li>另外复制了壳 APK 的 lib 库到新 APK 的临时目录（hook 和代码回填逻辑在 native 层）；</li>
</ul>
</li>
<li>extractAllDexFiles<ul>
<li>遍历指定目录的所有 dex 文件，调用 ReadDex 抽取代码，得到对应的 .patched 和 .codes 文件；</li>
<li>修复 patch 后的 dex 文件并覆写原 dex 文件，将 codes 移动到 assets 目录下。</li>
</ul>
</li>
</ol>
<pre><code class="language-python">from zlib import adler32
from hashlib import sha1
from binascii import unhexlify
from lxml import etree
import subprocess
import shutil
from pathlib import Path
import argparse


# Paths类,管理全局用到的路径
class Paths:
    def __init__(self, srcApk: Path, shellApk: Path, outputApk: Path):
        # 相关APK文件路径
        self.srcApkPath = srcApk.resolve()  # 解析为绝对路径
        self.shellApkPath = shellApk.resolve()
        self.newApkPath = outputApk.resolve()

        # 临时目录 以该脚本文件父目录为根目录
        self.tmpdir = Path(__file__).parent / &#39;temp&#39;
        self.srcApkTempDir = self.tmpdir / &#39;srcApkTemp&#39;
        self.shellApkTempDir = self.tmpdir / &#39;shellApkTemp&#39;
        self.newApkTempDir = self.tmpdir / &#39;newApkTemp&#39;


# Apktool类,通过subprocess调用其他工具 提供解包,打包,签名,抽取代码功能
class Apktool:
    def __init__(self):
        self.apktool_path = Path(__file__).parent.parent / &#39;tools/apktool/apktool.bat&#39;
        self.signer_path = Path(__file__).parent / &#39;tools/uber-apk-signer-1.3.0.jar&#39;
        self.readDex_path = Path(__file__).parent / &#39;tools/ReadDex.exe&#39;

    # 为apk签名
    def signApk(self, unsignedApkPath: Path):
        self.runCommand([&#39;java&#39;, &#39;-jar&#39;, self.signer_path, &#39;--apk&#39;, unsignedApkPath])

    # 使用apktool解包apk 只解包资源得到AndroidManifest.xml 不需要解包dex文件得到smali
    def unpackApk(self, apkPath: Path, outputDir: Path):
        self.runCommand([self.apktool_path, &#39;d&#39;, apkPath, &#39;-s&#39;, &#39;-o&#39;, outputDir])

    # 重打包apk
    def repackApk(self, inputDir: Path, outApk: Path):
        self.runCommand([self.apktool_path, &#39;b&#39;, inputDir, &#39;-o&#39;, outApk])

    # 抽取指定dex文件的代码
    def extractDexCodes(self, dexPath: Path):
        # 调用ReadDex.exe抽取dex文件代码,输出到同级目录 例如classes.dex抽取后生成classes.dex.patched和classes.dex.codes
        self.runCommand([self.readDex_path, &#39;-file&#39;, dexPath, &#39;-extractCodes&#39;])

    # 执行命令
    def runCommand(self, args):
        # subprocess.run(args)
        subprocess.run(args, stdout=subprocess.DEVNULL)  # 仅调用工具,不需要额外输出,重定向stdout到os.devnull
        # 参数列表 捕获输出 输出转为字符串
        # print(subprocess.run(args,  capture_output=True,text=True).stdout)


# AndroidManifest.xml的editor 用于获取和修改标签属性,以及添加标签
class ManifestEditor:
    def __init__(self, xml_content: bytes):
        self.ns = &#123;&#39;android&#39;: &#39;http://schemas.android.com/apk/res/android&#39;&#125;
        self.tree = etree.fromstring(xml_content)

    # 获取指定标签的android属性值 examples: get_attr(&#39;application&#39;, &#39;name&#39;) get_attr(&#39;activity&#39;, &#39;name&#39;)
    def getTagAttribute(self, tag_name: str, attr_name: str):
        if tag_name == &#39;manifest&#39;:  # 根标签特殊处理
            elem = self.tree
            if elem is not None:
                return elem.get(f&#39;&#123;attr_name&#125;&#39;)  # 寻找标签的属性
        else:
            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)
            if elem is not None:
                return elem.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;)  # 根标签之外的属性位于android命名空间下
        return None

    # 设置指定标签的属性值 example:s et_attr(&#39;application&#39;,&#39;name&#39;,&quot;com.example.ProxyApplication&quot;)
    def setTagAttribute(self, tag_name: str, attr_name: str, new_value: str):
        if tag_name == &#39;manifest&#39;:  # 根标签特殊处理
            elem = self.tree
            if elem is not None:
                return elem.set(f&#39;&#123;attr_name&#125;&#39;, new_value)  # 设置属性值
        else:
            elem = self.tree.find(f&#39;.//&#123;tag_name&#125;&#39;, namespaces=self.ns)
            if elem is not None:
                elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;attr_name&#125;&#39;, new_value)
                return True
        return False

    # 在指定父标签下添加新子标签 example: add_tag(&#39;application&#39;,&quot;meta-data&quot;,&#123;&#39;name&#39;: &#39;android.permission.CAMERA&#39;,&#39;value&#39;:&#39;hello&#39;&#125;)
    def addTagWithAttributes(self, parent_tag: str, new_tag: str, attrs: dict):
        if parent_tag == &#39;manifest&#39;:
            parent = self.tree
            if parent is not None:
                new_elem = etree.SubElement(parent, new_tag)
                for k, v in attrs.items():  # 支持一次给添加的标签设置多个属性
                    new_elem.set(f&#39;&#123;k&#125;&#39;, v)
                return True
        else:
            parent = self.tree.find(f&#39;.//&#123;parent_tag&#125;&#39;, namespaces=self.ns)
            if parent is not None:
                new_elem = etree.SubElement(parent, new_tag)
                for k, v in attrs.items():
                    new_elem.set(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;&#123;k&#125;&#39;, v)
                return True
        return False

    # 不以壳manifest为基准操作则用不到该函数,以源apk的manifest为基准自带,无需额外设置
    def getMainActivity(self):
        activities = self.tree.findall(&#39;.//activity&#39;, namespaces=self.ns)
        for activity in activities:
            intent_filters = activity.findall(&#39;.//intent-filter&#39;, namespaces=self.ns)
            for intent_filter in intent_filters:
                action = intent_filter.find(&#39;.//action[@android:name=&quot;android.intent.action.MAIN&quot;]&#39;, namespaces=self.ns)
                category = intent_filter.find(&#39;.//category[@android:name=&quot;android.intent.category.LAUNCHER&quot;]&#39;,
                                              namespaces=self.ns)
                if action is not None and category is not None:
                    return activity.get(f&#39;&#123;&#123;&#123;self.ns["android"]&#125;&#125;&#125;name&#39;)
        return None

    # 获取application标签的name属性值
    def getApplicationName(self):
        return self.getTagAttribute(&#39;application&#39;, &#39;name&#39;)

    # 设置application标签的name属性值
    def setApplicationName(self, application: str):
        self.setTagAttribute(&#39;application&#39;, &#39;name&#39;, application)

    # 添加meta-data标签,并设置name和value属性值
    def addMetaData(self, name: str, value: str):
        self.addTagWithAttributes(&#39;application&#39;, &#39;meta-data&#39;, &#123;&#39;name&#39;: name, &#39;value&#39;: value&#125;)

    # 获取AndroidManifest.xml的字符串
    def getManifestData(self):
        &quot;&quot;&quot;返回XML字符串&quot;&quot;&quot;
        return etree.tostring(self.tree, pretty_print=True, encoding=&#39;utf-8&#39;, xml_declaration=True).decode()

    # 获取application标签的extractNativeLibs属性值
    def getEtractNativeLibs(self):
        return self.getTagAttribute(&#39;application&#39;, &#39;extractNativeLibs&#39;)

    # 设置application标签的extractNativeLibs属性值为true
    def resetExtractNativeLibs(self):
        self.setTagAttribute(&#39;application&#39;, &#39;extractNativeLibs&#39;, &#39;true&#39;)


# 工具函数,注意修复时顺序为: fileSize-&gt;signature-&gt;checksum
# 修复dex文件的checksum
def fixCheckSum(dexBytes: bytearray):
    # dexfile[8:12] 小端序4字节
    value = adler32(bytes(dexBytes[12:]))
    valueArray = bytearray(value.to_bytes(4, &#39;little&#39;))
    for i in range(len(valueArray)):
        dexBytes[8 + i] = valueArray[i]


# 修复dex文件的signature
def fixSignature(dexBytes: bytearray):
    # dexfile[12:32] 小端序20字节
    sha_1 = sha1()
    sha_1.update(bytes(dexBytes[32:]))
    value = sha_1.hexdigest()
    valueArray = bytearray(unhexlify(value))
    for i in range(len(valueArray)):
        dexBytes[12 + i] = valueArray[i]


# 修复dex文件的filesize
def fixFileSize(dexBytes: bytearray, fileSize):
    # dexfile[32:36] 小端存储
    fileSizeArray = bytearray(fileSize.to_bytes(4, &quot;little&quot;))
    for i in range(len(fileSizeArray)):
        dexBytes[32 + i] = fileSizeArray[i]


# 加密函数,使用异或
def encrypt(data: bytearray):
    # todo:使用aes/sm4等加密算法替代
    for i in range(len(data)):
        data[i] ^= 0xff
    return data


# 抽取指定目录下的所有dex文件的代码 patch所有dex文件并修复,将codes文件移动到assets目录下
def extractAllDexFiles(directory: Path):
    apktool = Apktool()
    # 1.遍历目录下的所有dex文件,并抽取对应代码
    for dex in directory.glob(&#39;classes*.dex&#39;):
        apktool.extractDexCodes(dex)  # 抽取dex文件代码 得到classes*.dex.patched和classes*.dex.codes

    # 2.修复抽取后的文件并覆写原dex文件
    for patchedDex in directory.glob(&#39;classes*.dex.patched&#39;):
        newDexName = str(patchedDex).replace(&#39;.patched&#39;, &#39;&#39;)  # 重命名
        # 读取文件内容
        with open(patchedDex, &#39;rb&#39;) as f:
            data = bytearray(f.read())
            # 修复signature和checksum,注意先后顺序
            fixSignature(data)
            fixCheckSum(data)
            # 修复后的文件覆写原dex文件
            with open(newDexName, &#39;wb&#39;) as newf:
                newf.write(data)

    # 3.删除patched文件
    for patchedDex in directory.glob(&#39;classes*.dex.patched&#39;):
        patchedDex.unlink()

    # 4.移动.codes文件到assets目录下
    # 如果没有assets目录则创建
    if not (directory / &#39;assets&#39;).exists():
        (directory / &#39;assets&#39;).mkdir(parents=True)

    for codes in directory.glob(&#39;classes*.dex.codes&#39;):
        shutil.move(codes, directory / &#39;assets&#39; / codes.name)  # 移动到assets目录下


# 合并壳dex和源apk的dex,支持多dex文件,合并为一个dex
def combineShellAndSourceDexs(shellApkTempDir: Path, srcApkTempDir: Path, newApkTempDir: Path):
    # 读取解包后的apk的所有dex文件,并合并为一个dex文件
    def readAndCombineDexs(unpackedApkDir: Path):
        combinedDex = bytearray()
        # glob方法返回包含所有匹配文件的生成器
        for dex in unpackedApkDir.glob(&#39;classes*.dex&#39;):
            print(&#39;Source Apk Dex file:&#39;, dex)
            with open(dex, &#39;rb&#39;) as f:
                data = bytearray(f.read())
                combinedDex += bytearray(len(data).to_bytes(4, &#39;little&#39;))  # dex文件的长度,小端序
                combinedDex += data  # dex文件内容
        return combinedDex

    # 获取shelldex
    with open(shellApkTempDir / &#39;classes.dex&#39;, &#39;rb&#39;) as f:
        shellDexArray = bytearray(f.read())

    # 获取源apk的dex文件
    srcDexArray = readAndCombineDexs(srcApkTempDir)
    # 新的dex文件长度
    newDexLen = len(srcDexArray) + len(shellDexArray) + 4
    # 加密源文件
    encSrcDexArray = encrypt(srcDexArray)
    # 新的dex文件内容 = 壳dex + 加密的源dex + 四字节标识加密后源dex大小长度
    newDexArray = shellDexArray + encSrcDexArray + bytearray(len(encSrcDexArray).to_bytes(4, &#39;little&#39;))

    # 修改filesize
    fixFileSize(newDexArray, newDexLen)
    # 修改signature
    fixSignature(newDexArray)
    # 修改checksum
    fixCheckSum(newDexArray)  # 注意先后顺序,先修改signature,再修改checksum

    # 导出文件
    with open(newApkTempDir / &#39;classes.dex&#39;, &#39;wb&#39;) as f:
        f.write(newDexArray)


# 提取源apk的Manifest文件,修改application为壳application(可能添加meta-data标签),输出新的Manifest文件
def handleManifest(srcApkTempDir: Path, shellApkTempDir: Path, newApkTempDir: Path):
    # 从源apk提取AndroidManifest.xml
    with open(srcApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:
        srcManifestEditor = ManifestEditor(f.read().encode())
    srcApplication = srcManifestEditor.getApplicationName()  # 获取application:name,确定是否存在自定义Application类
    srcExtractNativeLibs = srcManifestEditor.getEtractNativeLibs()  # 获取application:extractNativeLibs,判断是否释放lib文件
    print(&#39;SourceApplication:&#39;, srcApplication)
    print(&#39;SourceExtractNativeLibs:&#39;, srcExtractNativeLibs)

    # 从壳apk提取AndroidManifest.xml
    with open(shellApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;r&#39;) as f:
        shellManifestEditor = ManifestEditor(f.read().encode())
    print(&#39;ShellApplication:&#39;, shellManifestEditor.getApplicationName())

    # 修改源AndroidManifest.xml的application为壳的代理application
    srcManifestEditor.setApplicationName(shellManifestEditor.getApplicationName())

    # 写入meta-data标签 保存源apk的原始application
    if srcApplication != None:
        print(&#39;Source application:&#39;, srcApplication)
        srcManifestEditor.addMetaData(&#39;APPLICATION_CLASS_NAME&#39;, srcApplication)

    # 如果源apk的manifest中默认设置etractNativeLibs=false,则重置为true,确保释放lib文件
    if srcExtractNativeLibs == &#39;false&#39;:
        srcManifestEditor.resetExtractNativeLibs()

    # 输出新的AndroidManifest.xml
    with open(newApkTempDir / &#39;AndroidManifest.xml&#39;, &#39;w&#39;) as f:
        f.write(srcManifestEditor.getManifestData())


# 执行加固流程
def start(paths: Paths):
    apktool = Apktool()
    # 1.分别解包源文件和壳文件到临时目录
    print(&#39;Extracting source and shell apk...&#39;)
    apktool.unpackApk(paths.srcApkPath, paths.srcApkTempDir)
    print(&#39;Extract source apk success!&#39;)

    print(&#39;Extracting shell apk...&#39;)
    apktool.unpackApk(paths.shellApkPath, paths.shellApkTempDir)
    print(&#39;Extract shell apk success!&#39;)

    # 2.抽取源dex文件代码
    print(&#39;Exrtracting dex files codes...&#39;)
    extractAllDexFiles(paths.srcApkTempDir)
    print(&#39;Extract dex files codes success!&#39;)

    # 3.复制源apk所有文件到新apk临时目录中 忽略源dex和manifest文件
    print(&#39;Copying source apk files to new apk temp dir...&#39;)
    shutil.copytree(paths.srcApkTempDir, paths.newApkTempDir,
                    ignore=shutil.ignore_patterns(&#39;AndroidManifest.xml&#39;, &#39;classes*.dex&#39;))
    print(&#39;Copy source apk files success!&#39;)

    # 4.复制壳apk的lib库文件到新apk临时目录中 （壳的代码回填逻辑在lib中实现）
    print(&#39;Copying shell apk lib files to new apk temp dir...&#39;)
    shutil.copytree(paths.shellApkTempDir / &#39;lib&#39;, paths.newApkTempDir / &#39;lib&#39;,
                    dirs_exist_ok=True)  # dirs_exist_ok=True 如果目标目录已存在,则覆盖
    print(&#39;Copy shell apk lib files success!&#39;)

    # 5.处理AndroidManifest.xml
    print(&#39;Handling AndroidManifest.xml...&#39;)
    handleManifest(paths.srcApkTempDir, paths.shellApkTempDir, paths.newApkTempDir)
    print(&#39;Handle AndroidManifest.xml success!&#39;)

    # 6.合并壳dex和源apk的dex并导出文件
    print(&#39;Combining shell dex and source dexs...&#39;)
    combineShellAndSourceDexs(paths.shellApkTempDir, paths.srcApkTempDir, paths.newApkTempDir)
    print(&#39;Combine shell dex and source dexs success!&#39;)

    # 7.重打包apk
    print(&#39;Repacking apk...&#39;)
    apktool.repackApk(paths.newApkTempDir, paths.newApkPath)
    print(&#39;Repack apk success!&#39;)

    # 8.签名apk
    print(&#39;Signing apk...&#39;)
    apktool.signApk(paths.newApkPath)
    print(&#39;Resign apk success!&#39;)

    # 9.删除临时目录
    print(&#39;Deleting temp directories...&#39;)
    shutil.rmtree(paths.tmpdir)
    print(&#39;Delete temp directories success!&#39;)


def main():
    parser = argparse.ArgumentParser(description=&quot;Android APK Packer&quot;)
    parser.add_argument(&#39;-src&#39;, &#39;--src-apk&#39;, required=True, type=Path, help=&#39;Path to source APK file&#39;)
    parser.add_argument(&#39;-shell&#39;, &#39;--shell-apk&#39;, required=True, type=Path, help=&#39;Path to shell APK file&#39;)
    parser.add_argument(&#39;-o&#39;, &#39;-out&#39;, &#39;--output-apk&#39;, type=Path,
                        help=&#39;Output path for packed APK (Default: ./out/&lt;src-apk&gt;_protected.apk)&#39;)
    args = parser.parse_args()
    if args.output_apk == None:
        args.output_apk = Path(&#39;./out&#39;) / (args.src_apk.stem + &#39;_protected.apk&#39;)  # 默认新apk名称及输出路径
    paths = Paths(args.src_apk, args.shell_apk, args.output_apk)

    print(&#39;Source APK:&#39;, paths.srcApkPath)
    print(&#39;Shell APK:&#39;, paths.shellApkPath)
    print(&#39;Output APK:&#39;, paths.newApkPath)
    start(paths)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<hr>
<h5 id="脱壳程序-2"><a href="#脱壳程序-2" class="headerlink" title="脱壳程序"></a>脱壳程序</h5><p>脱壳程序主要分为 2 个模块：</p>
<ol>
<li>Java 层：提供环境初始化、替换 <strong>ClassLoader</strong>、替换 <strong>Application</strong> 的功能；</li>
<li>Native 层：提供禁用 <strong>Dex2Oat</strong>、设置 Dex 文件可写、代码回填、代码文件解析的功能。</li>
</ol>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821163913301.png" alt="image-20250821163913301"></p>
<p>​        经过前文加壳程序的处理后，源程序 <strong>AndroidManifest.xml</strong> 文件的 <strong>application</strong> 标签的 name 属性指定壳的 application，由于 application 是 Android 应用程序真正的入口类，所以启动加壳后的程序时控制权在壳的代理 application 中。</p>
<p>​        在壳的代理 application 中主要执行以下操作：</p>
<ol>
<li>初始化操作<ul>
<li>设置相关文件路径，解析相关文件用于后续处理</li>
</ul>
</li>
<li>替换 ClassLoader<ul>
<li>替换壳程序的 ClassLoader 为被保护程序的 ClassLoader</li>
</ul>
</li>
<li>替换 application<ul>
<li>若被保护程序存在自定义 application，则创建实例并替换</li>
</ul>
</li>
<li>加载壳 so<ul>
<li>调用 System.loadLiabray() 主动加载即可，后续在 Native 层执行代码回填</li>
</ul>
</li>
</ol>
<p>示意图如下：<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821164406781.png" alt="image-20250821164406781"></p>
<hr>
<h6 id="环境初始化"><a href="#环境初始化" class="headerlink" title="环境初始化"></a>环境初始化</h6><p>主要执行以下操作：</p>
<ol>
<li>设置相关私有目录，供后续释放文件以及设置 <strong>DexClassLoader</strong>；</li>
<li>从壳 APK 文件提取并解析被保护的 dex 文件，写入私有目录<ul>
<li>调用 <strong>readDexFromApk</strong> 从当前 APK 文件中提取 classs.dex，再调用 <strong>extractDexFilesFromShellDex</strong> 从中提取并分离源程序 Dex 文件，最后调用 <strong>writeByteBuffersToDirectory</strong> 将多个 Dex 文件依次写入私有目录；</li>
</ul>
</li>
<li>从 assets 目录提取 codes 文件写入私有目录<ul>
<li>调用 <strong>copyClassesCodesFiles</strong> 执行该操作；</li>
</ul>
</li>
<li>拼接源程序所有的 dex 文件的路径<ul>
<li>用 “:” 分隔，拼接源程序所有 dex 文件路径，供后续 <strong>DexClassLoader</strong> 加载使用。</li>
</ul>
</li>
</ol>
<p>示意图如下：</p>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821164948347.png" alt="image-20250821164948347"></p>
<hr>
<h6 id="替换-ClassLoader"><a href="#替换-ClassLoader" class="headerlink" title="替换 ClassLoader"></a>替换 ClassLoader</h6><p>主要执行以下操作：</p>
<ol>
<li>获取当前 ClassLoader<ul>
<li>调用 this.getClassLoader() 获取；</li>
</ul>
</li>
<li>反射获取 ActivityThread 实例<ul>
<li>通过反射直接获取 ActivityThread.sCurrentActivityThread 字段，即当前程序对应的 ActivityThread 实例；</li>
</ul>
</li>
<li>反射获取 LoadedApk 实例<ul>
<li>首先反射获取ActivityThread.mPackages 字段</li>
<li>再根据当前程序的包名，从中查找获取对应的 LoadedApk 实例；</li>
</ul>
</li>
<li>创建并替换 ClassLoader<ul>
<li>将环境初始化工作中创建的 lib 和 dex 文件的私有目录路径以及当前 ClassLoader 作为参数，新建 DexClassLoader，该 ClassLoader 可用于加载之前释放的源程序 Dex 文件和 libso 文件。</li>
</ul>
</li>
<li>最后通过反射修改 <strong>LoadedApk.mClassLoader</strong> 实例完整修改。</li>
</ol>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821170928572.png" alt="image-20250821170928572"></p>
<hr>
<h6 id="替换-application"><a href="#替换-application" class="headerlink" title="替换 application"></a>替换 application</h6><p>主要执行以下操作：</p>
<ol>
<li>获取自定义 application 完整类名<ul>
<li>同上文，加壳程序为 AndroidManifest.xml 添加 meta-data 标签，其中保存了源程序自定义的 Application类名；</li>
</ul>
</li>
<li>反射获取 ActivityThread 实例，同上；</li>
<li>反射获取 LoadedApk 实例，并设置 mApplication 为空；<ul>
<li>获取 LoadedApk 实例也同上，设置 mApplication 为空的原因是调用 <strong>LoadedApk.makeApplication</strong> 时，如果 mApplication 不为空，则直接返回当前的 Application实例，所以想要替换 Application必须先置空再创建；</li>
</ul>
</li>
<li>获取 <strong>ActivityThread.mInitialApplication</strong> 并删除壳 Application；</li>
<li>反射调用 <strong>LoadedApk.makeApplication</strong> 创建源 Application；</li>
<li>重置 <strong>ActivityThread.mInitialApplication</strong> 为源 Application；</li>
<li>处理 <strong>ContentProvider</strong> 持有的代理 Application；</li>
<li><strong>调用 Application.onCreate()</strong>，源程序，启动！</li>
</ol>
<p>流程图如下：</p>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821172208017.png" alt="image-20250821172208017"></p>
<hr>
<h6 id="Native-层"><a href="#Native-层" class="headerlink" title="Native 层"></a>Native 层</h6><p>​        调用 System.loadLibrary 主动加载了壳的 so 文件，首先调用 <strong>init</strong> 函数，其中依次执行以下 Hook 操作（劫持对应函数）：</p>
<ol>
<li>Hook execve<ul>
<li>在 Hook 后添加判断逻辑，匹配到调用 dex2oat 系统调用时直接返回（dex2oat 是 ART 将所有 Dex 文件优化为一个 OAT 文件(本质为 ELF 文件)操作，目的是加快指令执行速度，但这会影响加固工具执行指令回填）；</li>
</ul>
</li>
<li>Hook mmap<ul>
<li>在 mmap 映射内存时添加写权限，保证可以修改 DexFile 进行指令回填；</li>
</ul>
</li>
<li>Hook LoadMethod<ul>
<li>LoadMethod 有两个关键参数：<code>DexFile* dexFile</code> 和 <code>Method* method1</code>；</li>
<li>通过 <strong>dexFile</strong> 获取方法所在的 Dex 文件路径，从而判断是否为源程序被抽取了代码的 Dex 文件，如果是则判断是否进行过文件解析；</li>
<li>若没有解析过则调用 parseExtractedCodeFiles 函数解析 Dex 文件对应的 codes 文件，这样便成功创建了一组 CodeMap（保存 codeOff 和 CodeItem 映射）；</li>
<li>之后调用目标方法时，根据 Method.codeOff 从 CodeMap 中提取对应的 CodeItem 并执行指令回填，<strong>dexFile.begin + Method.codeOff</strong> 即为 <strong>insns[]</strong> 指令字节数组的位置。</li>
</ul>
</li>
</ol>
<p>其中 Hook 主要使用 <strong>BHook</strong> 和 <strong>Dobby</strong></p>
<ol>
<li><p>Dobby</p>
<ul>
<li><p>参考 <a target="_blank" rel="noopener" href="https://github.com/luoyesiqiu/dpt-shell/blob/main/shell/src/main/cpp/CMakeLists.txt">https://github.com/luoyesiqiu/dpt-shell/blob/main/shell/src/main/cpp/CMakeLists.txt</a> 和 <a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1779984-1-1.html">https://www.52pojie.cn/thread-1779984-1-1.html</a></p>
</li>
<li><p>源码编译似乎有点麻烦，静态导入 <strong>Dobby</strong><br>下面是完整的 CMakeLists.txt</p>
<pre><code class="language-ASN.1">cmake_minimum_required(VERSION 3.22.1)

project(&quot;androidshell3&quot;)

find_package(bytehook REQUIRED CONFIG)
include_directories(dobby)
add_library(local_dobby STATIC IMPORTED)
set_target_properties(local_dobby PROPERTIES
        IMPORTED_LOCATION $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../libs/$&#123;ANDROID_ABI&#125;/libdobby.a)


add_library($&#123;CMAKE_PROJECT_NAME&#125; SHARED
        # List C/C++ source files with relative paths to this CMakeLists.txt.
        dex/DexFile.cpp
        dex/DexFile.h
        dex/CodeItem.h
        dex/class_accessor.h
        shell.cpp)

target_link_libraries($&#123;CMAKE_PROJECT_NAME&#125;
        # List libraries link to the target library
        android
        log
        local_dobby
        bytehook::bytehook)
</code></pre>
<p>但是当我去 GitHub 上找已编译好的 Dobby 时，发现Android 版本的 release 已经没了，不过好在之前因为公司的一个项目，组长发过一份给我，就直接用了。</p>
</li>
</ul>
</li>
<li><p>Bhook</p>
<ul>
<li><p>参考 </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/bytedance/bhook/blob/main/README.zh-CN.md">https://github.com/bytedance/bhook/blob/main/README.zh-CN.md</a> 添加 Bhook 依赖</p>
<pre><code class="language-ASN.1">android &#123;
    buildFeatures &#123;
        prefab true
    &#125;
&#125;
 
dependencies &#123;
    implementation &#39;com.bytedance:bytehook:1.1.1&#39;
&#125;
</code></pre>
</li>
</ul>
</li>
</ol>
<p>Hook 后的 LoadMethod 主要工作如下：</p>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250821175351659.png" alt="image-20250821175351659"></p>
<hr>
<h6 id="ThirdProxyApplication-java"><a href="#ThirdProxyApplication-java" class="headerlink" title="ThirdProxyApplication.java"></a>ThirdProxyApplication.java</h6><p>相对 FirstProxyApplication.java 的改动如下：</p>
<ol>
<li>System.loadLibrary(“androidshell3”)<ul>
<li>主动加载壳程序的 so，设置 hook；</li>
</ul>
</li>
<li>writeByteBuffersToDirectory<ul>
<li>用于将壳 dex 中提取的源 dex 字节数组写为文件；</li>
</ul>
</li>
<li>copyClassesCodesFiles<ul>
<li>用于将 dex  文件对应的 codes 文件复制到和 dex 相同的私有目录。</li>
</ul>
</li>
</ol>
<pre><code class="language-Java">package com.example.androidshell3;

import android.app.Application;
import android.app.Instrumentation;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.content.res.AssetManager;
import android.os.Bundle;
import android.util.ArrayMap;
import android.util.Log;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import dalvik.system.DexClassLoader;

public class ThirdProxyApplication extends Application &#123;
    private final String TAG=&quot;NshIdE&quot;;
    private String dexPath;
    private String odexPath;
    private String libPath;
    public void log(String message)&#123;Log.d(TAG,message);&#125;

    @Override
    protected void attachBaseContext(Context base) &#123;
        super.attachBaseContext(base);
        log(&quot;ThirdProxyApplication.attachBaseContext is running!&quot;);
        System.loadLibrary(&quot;androidshell&quot;);     //主动加载so,设置hook,进行指令回填
        log(&quot;Load libandroidshell.so succeed!&quot;);
        try &#123;
            //初始化相关环境
            initEnvironments();
            //配置加载源程序的动态环境,即替换mClassLoader
            replaceClassLoader();
        &#125; catch (Exception e) &#123;
            log( Log.getStackTraceString(e));
        &#125;
    &#125;
    @Override
    public void onCreate() &#123;
        super.onCreate();
        log(&quot;ThirdProxyApplication.onCreate is running!&quot;);
        if(replaceApplication())
            log(&quot;Replace Application succeed!&quot;);
    &#125;

    private void initEnvironments() throws IOException &#123;
        //1.设置相关目录和路径
        File dex = getDir(&quot;tmp_dex&quot;, MODE_PRIVATE);     // 私有目录,存放dex文件
        //File lib = getDir(&quot;tmp_lib&quot;, MODE_PRIVATE);       // lib可使用默认目录
        //libPath = lib.getAbsolutePath();
        odexPath = dex.getAbsolutePath();
        libPath=this.getApplicationInfo().nativeLibraryDir; //默认lib路径
        dexPath =this.getApplicationInfo().sourceDir;   //当前base.apk路径
        //2.从当前base.apk读取classes.dex并读取为字节数组
        byte[] shellDexData = readDexFromApk();
        log(&quot;Get classes.dex from base.apk succeed!&quot;);
        //3.从壳dex文件中分离出源dex文件
        ByteBuffer[] byteBuffers = extractDexFilesFromShellDex(shellDexData);
        //4.将源dex文件依次写入私有目录
        writeByteBuffersToDirectory(byteBuffers, odexPath);
        //5.将codes文件依次写入私有目录
        copyClassesCodesFiles(this, odexPath);
        //6.拼接dex目录字符串,设置dex文件路径 DexClassLoader支持传递多个dex文件路径以加载多个dex文件,通过&#39;:&#39;分隔路径
        StringBuffer dexFiles=new StringBuffer();
        for(File file:dex.listFiles())&#123;
            if(file.getName().contains(&quot;.codes&quot;))
                continue;
            dexFiles.append(file.getAbsolutePath());
            dexFiles.append(&quot;:&quot;);
        &#125;
        dexPath=dexFiles.toString();
    &#125;
    private void writeByteBuffersToDirectory(ByteBuffer[] byteBuffers, String directoryPath) throws IOException &#123;
        // 创建目录对象
        File directory = new File(directoryPath);
        // 检查目录是否存在,不存在则创建
        if (!directory.exists()) &#123;
            if (!directory.mkdirs()) &#123;
                throw new IOException(&quot;无法创建目录: &quot; + directoryPath);
            &#125;
        &#125;

        // 遍历 ByteBuffer 数组
        for (int i = 0; i &lt; byteBuffers.length; i++) &#123;
            // 生成文件名
            String fileName;
            if (i == 0) &#123;
                fileName = &quot;classes.dex&quot;;
            &#125; else &#123;
                fileName = &quot;classes&quot; + (i + 1) + &quot;.dex&quot;;
            &#125;
            // 构建文件对象
            File file = new File(directory, fileName);
            // 创建文件输出流
            try (FileOutputStream fos = new FileOutputStream(file)) &#123;
                // 获取 ByteBuffer 中的字节数组
                ByteBuffer buffer = byteBuffers[i];
                byte[] bytes = new byte[buffer.remaining()];
                buffer.get(bytes);
                // 将字节数组写入文件
                fos.write(bytes);
            &#125;
        &#125;
    &#125;
    private void copyClassesCodesFiles(Context context, String targetDirectoryPath) &#123;
        AssetManager assetManager = context.getAssets();
        try &#123;
            // 获取 assets 目录下的所有文件和文件夹
            String[] files = assetManager.list(&quot;&quot;);
            if (files != null) &#123;
                // 创建目标目录
                File targetDirectory = new File(targetDirectoryPath);
                if (!targetDirectory.exists()) &#123;
                    if (!targetDirectory.mkdirs()) &#123;
                        throw new IOException(&quot;无法创建目标目录: &quot; + targetDirectoryPath);
                    &#125;
                &#125;
                for (String fileName : files) &#123;
                    // 筛选以 classes 开头且以 .codes 结尾的文件
                    if (fileName.startsWith(&quot;classes&quot;) &amp;&amp; fileName.endsWith(&quot;.codes&quot;)) &#123;
                        try (InputStream inputStream = assetManager.open(fileName);
                             BufferedInputStream bis = new BufferedInputStream(inputStream);
                             FileOutputStream fos = new FileOutputStream(new File(targetDirectory, fileName));
                             BufferedOutputStream bos = new BufferedOutputStream(fos)) &#123;

                            byte[] buffer = new byte[1024];
                            int bytesRead;
                            while ((bytesRead = bis.read(buffer)) != -1) &#123;
                                bos.write(buffer, 0, bytesRead);
                            &#125;
                        &#125; catch (IOException e) &#123;
                            e.printStackTrace();
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    // 从壳dex文件中提取源apk的dex并封装为ByteBuffer
    private ByteBuffer[] extractDexFilesFromShellDex(byte[] shellDexData) &#123;
        int shellDexlength = shellDexData.length;
        //开始解析dex文件
        byte[] sourceDexsSizeByte = new byte[4];
        //读取源dexs的大小
        System.arraycopy(shellDexData,shellDexlength - 4, sourceDexsSizeByte,0,4);
        //转成bytebuffer,方便4byte转int
        ByteBuffer wrap = ByteBuffer.wrap(sourceDexsSizeByte);
        //将byte转成int, 加壳时,长度按小端存储
        int sourceDexsSizeInt = wrap.order(ByteOrder.LITTLE_ENDIAN).getInt();
        Log.d(TAG, &quot;源dex集合的大小: &quot; + sourceDexsSizeInt);
        //读取源dexs
        byte[] sourceDexsData = new byte[sourceDexsSizeInt];
        System.arraycopy(shellDexData,shellDexlength - sourceDexsSizeInt - 4, sourceDexsData, 0, sourceDexsSizeInt);
        //解密源dexs
        sourceDexsData = decrypt(sourceDexsData);

        //更新部分
        //从源dexs中分离dex
        ArrayList&lt;byte[]&gt; sourceDexList = new ArrayList&lt;&gt;();
        int pos = 0;
        while(pos &lt; sourceDexsSizeInt)&#123;
            //先提取四个字节,描述当前dex的大小
            //开始解析dex文件
            byte[] singleDexSizeByte = new byte[4];
            //读取源dexs的大小
            System.arraycopy(sourceDexsData, pos, singleDexSizeByte,0,4);
            //转成bytebuffer,方便4byte转int
            ByteBuffer singleDexwrap = ByteBuffer.wrap(singleDexSizeByte);
            int singleDexSizeInt = singleDexwrap.order(ByteOrder.LITTLE_ENDIAN).getInt();
            Log.d(TAG, &quot;当前Dex的大小: &quot; + singleDexSizeInt);
            //读取单独dex
            byte[] singleDexData = new byte[singleDexSizeInt];
            System.arraycopy(sourceDexsData,pos + 4, singleDexData, 0, singleDexSizeInt);
            //加入到dexlist中
            sourceDexList.add(singleDexData);
            //更新pos
            pos += 4 + singleDexSizeInt;
        &#125;

        //将dexlist包装成ByteBuffer
        int dexNum = sourceDexList.size();
        Log.d(TAG, &quot;源dex的数量: &quot; + dexNum);
        ByteBuffer[] dexBuffers = new ByteBuffer[dexNum];
        for (int i = 0; i &lt; dexNum; i++)&#123;
            dexBuffers[i] = ByteBuffer.wrap(sourceDexList.get(i));
        &#125;

        return dexBuffers;

    &#125;
    // 从当前程序的apk读取dex文件并存储为字节数组
    private byte[] readDexFromApk() throws IOException &#123;
        //1.获取当前应用程序的源码路径(apk),一般是data/app目录下,该目录用于存放用户安装的软件
        String sourceDir = this.getApplicationInfo().sourceDir;
        log(&quot;this.getApplicationInfo().sourceDir: &quot; +sourceDir);

        //2.创建相关输入流
        FileInputStream fileInputStream = new FileInputStream(sourceDir);
        BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
        ZipInputStream zipInputStream = new ZipInputStream(bufferedInputStream); //用于解析apk文件

        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); //用于存放dex文件

        //3.遍历apk的所有文件并提取dex文件
        ZipEntry zipEntry;
        while((zipEntry = zipInputStream.getNextEntry()) != null)&#123; //存在下一个文件
            // 将classes.dex文件存储到bytearray中 壳dex和源apk合并后只保留一个dex便于处理
            if (zipEntry.getName().equals(&quot;classes.dex&quot;))&#123;
                byte[] bytes = new byte[1024];
                int num;
                while((num = zipInputStream.read(bytes))!=-1)&#123;      //每次读取1024byte,返回读取到的byte数
                    byteArrayOutputStream.write(bytes,0, num); //存放到开辟的byteArrayOutputStream中
                &#125;
            &#125;
            zipInputStream.closeEntry(); //关闭当前文件
        &#125;
        zipInputStream.close();

        log(&quot;Read dex from apk succeed!&quot;);
        return byteArrayOutputStream.toByteArray(); //将读取到的dex文件以字节数组形式返回
    &#125;
    // 解密
    private byte[] decrypt(byte[] data) &#123;
        for (int i = 0; i &lt; data.length; i++)&#123;
            data[i] ^= (byte) 0xff;
        &#125;
        return data;

    &#125;
    //替换壳程序LoadedApk的Application为源程序Application,并调用其onCreate方法
    private boolean replaceApplication()&#123;
        // Application实例存在于: LoadedApk.mApplication
        // 以及ActivityThread的mInitialApplication和mAllApplications和mBoundApplication

        //判断源程序是否使用自定义Application 若使用则需要进行替换,若未使用则直接返回,使用壳的默认Application即可

        String appClassName = null; //源程序的Application类名
        try &#123;
            //获取AndroidManifest.xml 文件中的 &lt;meta-data&gt; 元素
            ApplicationInfo applicationInfo = getPackageManager().getApplicationInfo(this.getPackageName(), PackageManager.GET_META_DATA);
            Bundle metaData = applicationInfo.metaData;
            //获取xml文件声明的Application类
            if (metaData != null &amp;&amp; metaData.containsKey(&quot;APPLICATION_CLASS_NAME&quot;))&#123;
                appClassName = metaData.getString(&quot;APPLICATION_CLASS_NAME&quot;);
            &#125; else &#123;
                log(&quot;源程序中没有自定义Application&quot;);
                return false; //如果不存在直接返回,使用壳的application即可
            &#125;
        &#125; catch (PackageManager.NameNotFoundException e) &#123;
            log(Log.getStackTraceString(e));
        &#125;

        //源程序存在自定义application类,开始替换
        log(&quot;Try to replace Application&quot;);

        //1.反射获取ActivityThread实例
        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);
        log(&quot;ActivityThread: &quot; + sCurrentActivityThreadObj.toString());

        //2.获取并设置LoadedApk
        //获取mBoundApplication (AppBindData对象)
        Object mBoundApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mBoundApplication&quot;) ;
        log(&quot;mBoundApplication: &quot;+mBoundApplicationObj.toString());
        //获取mBoundApplication.info (即LoadedApk)
        Object infoObj = Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;info&quot;);
        log( &quot;LoadedApk: &quot; + infoObj.toString());
        //把LoadedApk的mApplication设置为null,这样后续才能调用makeApplication() 否则由于已存在Application,无法进行替换
        Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mApplication&quot;,infoObj,null);

        //3.获取ActivityThread.mInitialApplication 即拿到旧的Application(对于要加载的Application来讲)
        Object mInitialApplicationObj = Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mInitialApplication&quot;);
        log(&quot;mInitialApplicationObj: &quot; + mInitialApplicationObj.toString());

        //4.获取ActivityThread.mAllApplications并删除旧的application
        ArrayList&lt;Application&gt; mAllApplicationsObj = (ArrayList&lt;Application&gt;) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mAllApplications&quot;);
        mAllApplicationsObj.remove(mInitialApplicationObj);
        log(&quot;mInitialApplication 从 mAllApplications 中移除成功&quot;);

        //5.重置相关类的Application类名 便于后续创建Application
        //获取LoadedApk.mApplicationInfo
        ApplicationInfo applicationInfo = (ApplicationInfo) Reflection.getField(&quot;android.app.LoadedApk&quot;,infoObj,&quot;mApplicationInfo&quot;);
        log( &quot;LoadedApk.mApplicationInfo: &quot; + applicationInfo.toString());
        //获取mBoundApplication.appInfo
        ApplicationInfo appinfoInAppBindData = (ApplicationInfo) Reflection.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplicationObj,&quot;appInfo&quot;);
        log(&quot;ActivityThread.mBoundApplication.appInfo: &quot; + appinfoInAppBindData.toString());
        //此处通过引用修改值,虽然后续没有使用,但是实际上是修改其指向的LoadedApk相关字段的值
        //设置两个appinfo的classname为源程序的application类名,以便后续调用makeApplication()创建源程序的application
        applicationInfo.className = appClassName;
        appinfoInAppBindData.className = appClassName;
        log(&quot;Source Application name: &quot; + appClassName);

        //6.反射调用makeApplication方法创建源程序的application
        Application application = (Application) Reflection.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;false,null&#125;); //使用源程序中的application
        //Application app = (Application)ReflectionMethods.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,infoObj,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;true,null&#125;); //使用自定义的application 强制为系统默认
        log(&quot;Create source Application succeed: &quot;+application);

        //7.重置ActivityThread.mInitialApplication为新的Application
        Reflection.setField(&quot;android.app.ActivityThread&quot;,&quot;mInitialApplication&quot;,sCurrentActivityThreadObj,application);
        log(&quot;Reset ActivityThread.mInitialApplication by new Application succeed!&quot;);

        //8.ContentProvider会持有代理的Application,需要特殊处理一下
        ArrayMap mProviderMap = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mProviderMap&quot;);
        log(&quot;ActivityThread.mProviderMap: &quot; + mProviderMap);

        //获取所有provider,装进迭代器中遍历
        Iterator iterator = mProviderMap.values().iterator();
        while(iterator.hasNext())&#123;
            Object providerClientRecord = iterator.next();
            //获取ProviderClientRecord.mLocalProvider,可能为空
            Object mLocalProvider = Reflection.getField(&quot;android.app.ActivityThread$ProviderClientRecord&quot;,providerClientRecord,&quot;mLocalProvider&quot;) ;
            if(mLocalProvider != null)&#123;
                log(&quot;ProviderClientRecord.mLocalProvider: &quot; + mLocalProvider);
                //获取ContentProvider中的mContext字段,设置为新的Application
                Reflection.setField(&quot;android.content.ContentProvider&quot;,&quot;mContext&quot;,mLocalProvider,application);
            &#125;
        &#125;

        log( &quot;Run Application.onCreate&quot; );
        application.onCreate(); //源程序,启动!
        return true;
    &#125;
    // 替换壳App的ClassLoader为源App的ClassLoader
    private void replaceClassLoader() &#123;
        //1.获取当前的classloader
        ClassLoader classLoader = this.getClassLoader();
        log(&quot;Current ClassLoader: &quot; + classLoader.toString());
        log(&quot;Parent ClassLoader: &quot; + classLoader.getParent().toString());

        //2.反射获取ActivityThread
        Object sCurrentActivityThreadObj = Reflection.getStaticField(&quot;android.app.ActivityThread&quot;,&quot;sCurrentActivityThread&quot;);
        log(&quot;ActivityThread.sCurrentActivityThread: &quot; + sCurrentActivityThreadObj.toString());

        //3.反射获取LoadedApk
        //获取当前ActivityThread实例的mPackages字段 类型为ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt;, 里面存放了当前应用的LoadedApk对象
        ArrayMap mPackagesObj = (ArrayMap) Reflection.getField(&quot;android.app.ActivityThread&quot;,sCurrentActivityThreadObj,&quot;mPackages&quot;);
        log( &quot;mPackagesObj: &quot; + mPackagesObj.toString());

        //获取mPackages中的当前应用包名
        String currentPackageName = this.getPackageName();
        log(&quot;currentPackageName: &quot; + currentPackageName);

        // 获取loadedApk实例也有好几种,mInitialApplication mAllApplications mPackages
        // 通过包名获取当前应用的loadedApk实例
        WeakReference weakReference = (WeakReference) mPackagesObj.get(currentPackageName);
        Object loadedApkObj = weakReference.get();
        log( &quot;LoadedApk: &quot; + loadedApkObj.toString());

        //4.替换ClassLoader
        DexClassLoader dexClassLoader = new DexClassLoader(dexPath, odexPath,libPath, classLoader.getParent()); //动态加载源程序的dex文件,以当前classloader的父加载器作为parent
        Reflection.setField(&quot;android.app.LoadedApk&quot;,&quot;mClassLoader&quot;,loadedApkObj,dexClassLoader); //替换当前loadedApk实例中的mClassLoader字段
        log(&quot;New DexClassLoader: &quot; + dexClassLoader);
    &#125;
&#125;
</code></pre>
<hr>
<h6 id="shell-cpp"><a href="#shell-cpp" class="headerlink" title="shell.cpp"></a>shell.cpp</h6><p>主要提供以下功能：</p>
<ol>
<li><p>hook execve</p>
<ul>
<li>主要目的是禁止 dex2oat，防止 dex 文件被优化；</li>
</ul>
</li>
<li><p>hook mmap</p>
<ul>
<li>使 dex 文件可写,用于后续指令回填；</li>
</ul>
</li>
<li><p>hook LoadMethod</p>
<ul>
<li>loadmethod 用于加载 dex 文件的方法，可获取 dex 文件引用和 codeoff；</li>
<li>hook劫持后执行codes文件解析和指令回填。</li>
</ul>
<pre><code class="language-c++">#include &lt;jni.h&gt;
#include &lt;string&gt;
#include &lt;unistd.h&gt;
#include &lt;map&gt;
#include &lt;fstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;elf.h&gt;
#include &lt;dlfcn.h&gt;
#include &quot;android/log.h&quot;
#include &quot;sys/mman.h&quot;
#include &quot;bytehook.h&quot;
#include &quot;dobby/dobby.h&quot;
#include &quot;dex/DexFile.h&quot;
#include &quot;dex/CodeItem.h&quot;
#include &quot;dex/class_accessor.h&quot;
#define TAG &quot;NshIdE&quot;
#define logd(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);
#define logi(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__);
#define loge(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);

// sdk版本,用于兼容适配
int APILevel;
// 函数声明
void hook();
void hookExecve();
void hookMmap();
void hook_LoadMethod();

// 抽取代码文件,与源.dex在同一私有目录
std::string codeFilePostfix = &quot;.codes&quot;;

//dex文件名-&gt;codeOff-&gt;CodeItem 每个dex文件对应一个map,每个map内的codeoff对应一个CodeItem
std::map&lt;std::string,std::map&lt;uint32_t, CodeItem&gt;&gt; codeMapList;

//art/runtime/class_linker.h
// 函数声明
static void (*g_originLoadMethod)(void* thiz,
                                  const DexFile* dex_file,
                                  ClassAccessor::Method* method,
                                  void* klass,
                                  void* dst);
/*//Android 10-14 原型如下
void LoadMethod(const DexFile&amp; dex_file,
                const ClassAccessor::Method&amp; method,
                Handle&lt;mirror::Class&gt; klass,
                ArtMethod* dst);
*/


// Tool functions

// 以二进制形式读取整个文件,返回字节数组并返回文件长度
uint8_t* readFileToBytes(const std::string fileName,size_t* readSize) &#123;
    FILE *file = fopen(fileName.c_str(), &quot;rb&quot;);
    if (file == NULL) &#123;
        logd(&quot;Error opening file&quot;);
        fclose(file);
        return NULL;
    &#125;
    fseek(file, 0,SEEK_END);
    size_t fileSize = ftell(file);
    fseek(file, 0,SEEK_SET);
    uint8_t *buffer = (uint8_t *) malloc(fileSize);
    if (buffer == NULL) &#123;
        logd(&quot;Error allocating memory\n&quot;);
        fclose(file);
        return NULL;
    &#125;
    size_t bytesRead = fread(buffer, 1, fileSize, file);
    if(bytesRead!=fileSize) &#123;
        logd(&quot;Read bytes not equal file size!\n&quot;);
        free(buffer);
        fclose(file);
        return NULL;
    &#125;
    fclose(file);
    if(readSize)
        *readSize=bytesRead;
    return buffer;
&#125;

// 4字节数组转uint32_t
uint32_t bytes2uint32(unsigned char * bytes)&#123;
    uint32_t retnum = 0;
    for(int i = 3;i &gt;=0;i--)&#123;
        retnum &lt;&lt;= 8;
        retnum |= bytes[i];
    &#125;
    return retnum;
&#125;

const char * getArtLibPath() &#123;
    if(APILevel &lt; 29) &#123;
        return &quot;/system/lib64/libart.so&quot;;
    &#125; else if(APILevel == 29) &#123;
        return &quot;/apex/com.android.runtime/lib64/libart.so&quot;;
    &#125; else &#123;
        return &quot;/apex/com.android.art/lib64/libart.so&quot;;
    &#125;
&#125;

const char * getArtBaseLibPath() &#123;
    if(APILevel == 29) &#123;
        return &quot;/apex/com.android.runtime/lib64/libartbase.so&quot;;
    &#125; else &#123;
        return &quot;/apex/com.android.art/lib64/libartbase.so&quot;;
    &#125;
&#125;

const char* find_symbol_in_elf_file(const char *elf_file,int keyword_count,...) &#123;
    FILE *elf_fp = fopen(elf_file, &quot;r&quot;);
    if (elf_fp) &#123;
        // 获取elf文件大小
        fseek(elf_fp, 0L, SEEK_END);
        size_t lib_size = ftell(elf_fp);
        fseek(elf_fp, 0L, SEEK_SET);
        // 读取elf文件数据
        char *data = (char *) calloc(lib_size, 1);
        fread(data, 1, lib_size, elf_fp);
        char *elf_bytes_data = data;
        // elf头
        Elf64_Ehdr *ehdr = (Elf64_Ehdr *) elf_bytes_data;
        // 节头
        Elf64_Shdr *shdr = (Elf64_Shdr *) (((uint8_t *) elf_bytes_data) + ehdr-&gt;e_shoff);
        va_list kw_list;
        // 遍历节
        for (int i = 0; i &lt; ehdr-&gt;e_shnum; i++) &#123;
            // 字符串表
            if (shdr-&gt;sh_type == SHT_STRTAB) &#123;
                const char *str_base = (char *) ((uint8_t *) elf_bytes_data + shdr-&gt;sh_offset);
                char *ptr = (char *) str_base;
                // 遍历字符串表
                for (int k = 0; ptr &lt; (str_base + shdr-&gt;sh_size); k++) &#123;
                    const char *item_value = ptr;
                    size_t item_len = strnlen(item_value, 128);
                    ptr += (item_len + 1);
                    if (item_len == 0) &#123;
                        continue;
                    &#125;
                    int match_count = 0;
                    va_start(kw_list, keyword_count);
                    for (int n = 0; n &lt; keyword_count; n++) &#123;
                        const char *keyword = va_arg(kw_list, const char*);
                        if (strstr(item_value, keyword)) &#123;
                            match_count++;
                        &#125;
                    &#125;
                    va_end(kw_list);
                    if (match_count == keyword_count) &#123;
                        return item_value;
                    &#125;
                &#125;
                break;
            &#125;
            shdr++;
        &#125;
        fclose(elf_fp);
        free(data);
    &#125;
    return nullptr;
&#125;

const char * getClassLinkerDefineClassLibPath()&#123;
    return getArtLibPath();
&#125;


const char * getClassLinkerDefineClassSymbol() &#123;
    const char * sym = find_symbol_in_elf_file(getClassLinkerDefineClassLibPath(),2,&quot;ClassLinker&quot;,&quot;DefineClass&quot;);
    return sym;
&#125;


const char * getClassLinkerLoadMethodLibPath()&#123;
    return getArtLibPath();
&#125;

//获取ClassLinker::LoadMethod真实符号名
const char * getClassLinkerLoadMethodSymbol() &#123;
    const char * sym = find_symbol_in_elf_file(getClassLinkerLoadMethodLibPath(),2,&quot;ClassLinker&quot;,&quot;LoadMethod&quot;);
    return sym;
&#125;

//获取libart真实名称
const char * getArtLibName() &#123;
    //Android 10及以后变为libartbase.so
    return APILevel &gt;= 29 ? &quot;libartbase.so&quot; : &quot;libart.so&quot;;
&#125;

// 禁用dex2oat
int fakeExecve(const char *pathname, char *const argv[], char *const envp[]) &#123;
    BYTEHOOK_STACK_SCOPE();
    // 禁用dex2oat
    if (strstr(pathname, &quot;dex2oat&quot;) != nullptr) &#123;
        errno = EACCES;
        return -1;
    &#125;
    return BYTEHOOK_CALL_PREV(fakeExecve, pathname, argv, envp);
&#125;

void hookExecve()&#123;
    bytehook_stub_t stub = bytehook_hook_single(
            getArtLibName(),
            &quot;libc.so&quot;,
            &quot;execve&quot;,
            (void *) fakeExecve,
            nullptr,
            nullptr);
    if (stub != nullptr) &#123;
        logd(&quot;hook execve done&quot;);
    &#125;
&#125;

//为dex文件添加可写权限
void* fakeMmap(void * __addr, size_t __size, int __prot, int __flags, int __fd, off_t __offset)&#123;
    BYTEHOOK_STACK_SCOPE();
    int prot = __prot;
    int hasRead = (__prot &amp; PROT_READ) == PROT_READ;
    int hasWrite = (__prot &amp; PROT_WRITE) == PROT_WRITE;
    // 添加写权限
    if(hasRead &amp;&amp; !hasWrite) &#123;
        prot |= PROT_WRITE;
    &#125;
    void * addr = BYTEHOOK_CALL_PREV(fakeMmap, __addr, __size, prot, __flags, __fd, __offset);
    return addr;
&#125;

void hookMmap()&#123;
    bytehook_stub_t stub = bytehook_hook_single(
            getArtLibName(),
            &quot;libc.so&quot;,
            &quot;mmap&quot;,
            (void *) fakeMmap,
            nullptr,
            nullptr);
    if(stub != nullptr)&#123;
        logd(&quot;hook mmap done&quot;);
    &#125;
&#125;

// 解析抽取代码文件,每个dex.codes只解析一次
void parseExtractedCodeFiles(const std::string&amp; dexPath)&#123;
    //1.读取代码文件为字节数组
    std::string codeFilePath=dexPath+codeFilePostfix;
    logd(&quot;Code File Path: %s&quot;,codeFilePath.c_str());
    size_t codeBytesLen = 0;
    uint8_t* codeBytes = readFileToBytes(codeFilePath, &amp;codeBytesLen);
    if(codeBytes == nullptr || codeBytesLen == 0) &#123;
        logd(&quot;Code file not found!&quot;)
        return;
    &#125;
    logd(&quot;CodeFile: %s Len:%#llx&quot;, codeFilePath.c_str(),codeBytesLen);

    // 2.解析代码字节数组
    size_t offset=0;
    while(offset&lt;codeBytesLen)&#123;
        uint8_t* pointer = codeBytes + offset;  //每个结构的起点指针
        uint32_t codeOff = bytes2uint32(pointer); // 4字节CodeOff和4字节InsnSize
        uint32_t insnSize = bytes2uint32(pointer+4);
        if(codeOff == 0 || insnSize == 0)&#123;
            logd(&quot;CodeOff or InsnSize equals 0!&quot;)
            break;
        &#125;
        logd(&quot;CodeOff: %#x InsnSize: %#x&quot;, codeOff, insnSize);
        // 创建抽取代码对象
        CodeItem codeItem = CodeItem(insnSize, pointer+8);
        // 添加一组CodeOff:CodeItem映射
        codeMapList[dexPath].insert(std::pair&lt;uint32_t, CodeItem&gt;(codeOff, codeItem));
        logd(&quot;CodeItem codeOff: %#x insnSize: %#x has created!&quot;, codeOff, insnSize);
        offset += 8 + insnSize*2; //跳过CodeOff,InsnSize和Insn[]
    &#125;
&#125;

// 回填dex的方法代码,每次只回填一个Method
void innerLoadMethod(void* thiz, const DexFile* dexFile, ClassAccessor::Method* method, void* klass, void* dest)&#123;
    // dex文件路径
    std::string location = dexFile-&gt;location_;
    //logd(&quot;Load Dex File Location: %s&quot;,location.c_str())
    // 判断是否为解密释放的dex文件,位于私有目录内
    if(location.find(&quot;app_tmp_dex&quot;) == std::string::npos)&#123;
        return;
    &#125;
    // 如果未解析过dexCodes文件则进行解析,每个dex文件只解析一次,创建对应的map&lt;CodeOff,CodeItem&gt;映射
    if(codeMapList.find(location)==codeMapList.end())&#123;
        logd(&quot;Parse dex file %s codes&quot;,location.c_str());
        codeMapList[location]=std::map&lt;uint32_t,CodeItem&gt;(); //创建新的codeMap
        parseExtractedCodeFiles(location);
    &#125;
    // 不存在DexCode 直接跳过
    if(method-&gt;code_off_==0)&#123;
        return;
    &#125;
    // 指令地址
    uint8_t* codeAddr = (uint8_t*)(dexFile-&gt;begin_ + method-&gt;code_off_ + 16); //insn结构前面有16字节

    //logd(&quot;MethodCodeOff: %d&quot;,method-&gt;code_off_);
    // 回填指令
    std::map&lt;uint32_t,CodeItem&gt; codeMap=codeMapList[location];
    // 似乎没有走到回填指令处 (注意c++浅拷贝问题,不能随意delete)
    if(codeMap.find(method-&gt;code_off_) != codeMap.end())&#123;
        CodeItem codeItem = codeMap[method-&gt;code_off_];
        memcpy(codeAddr,codeItem.getInsns(),codeItem.getInsnsSize()*2); //注意指令为u2类型,长度需要*2
    &#125;
&#125;

void newLoadMethod(void* thiz, const DexFile* dex_file, ClassAccessor::Method* method, void* klass, void* dest)&#123;
    if(g_originLoadMethod!= nullptr)&#123;
        // 先回填指令,再调用
        innerLoadMethod(thiz,dex_file,method,klass,dest);
        g_originLoadMethod(thiz,dex_file,method, klass, dest);
    &#125;
    return;
&#125;

void hook_LoadMethod()&#123;
    void * loadMethodAddress =  DobbySymbolResolver(getClassLinkerLoadMethodLibPath(),getClassLinkerLoadMethodSymbol());
    DobbyHook(loadMethodAddress, (void *) newLoadMethod, (void **) &amp;g_originLoadMethod);
    logd(&quot;hook LoadMethod done&quot;);
&#125;

// 初始函数,实现hook
extern &quot;C&quot;
void _init()&#123;
    APILevel = android_get_device_api_level();
    logd(&quot;Android API Level: %d&quot;, APILevel)
    logd(&quot;Setting hook...&quot;)
    hook();
&#125;
// hook
void hook()&#123;
    bytehook_init(BYTEHOOK_MODE_AUTOMATIC, false);
    hookExecve();   // 禁用dex2oat
    hookMmap();     // 使dex文件可写
    //hook_DefineClass(); //需手动解析ClassDef
    hook_LoadMethod();  // 加载方法时回填指令
&#125;
</code></pre>
</li>
</ol>
<h3 id="四、加固测试"><a href="#四、加固测试" class="headerlink" title="四、加固测试"></a>四、加固测试</h3><p>只需要执行以下指令</p>
<pre><code class="language-shell">python ThirdAndroidShell.py -src &lt;源程序Apk路径&gt; -shell &lt;壳程序Apk路径&gt; -out &lt;加壳后的Apk路径&gt;
</code></pre>
<p>然后就可以得到加固之后的 APK</p>
<h3 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h3><p>[<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-286929-1.htm#msg_header_h2_32">原创]Android从整体加固到抽取加固的实现及原理-Android安全-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-285870.htm">安卓壳学习记录-加壳脱壳-看雪-安全社区|安全招聘|kanxue.com</a></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1621925986@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">💰</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'Ov23lif2sndX4YqUPQwk',
            clientSecret: 'c76a4c487d51bf36e4dd1496b3f44bdbea037d50',
            repo: 'NshIdE1.github.io',
            owner: 'NshIdE1',
            admin: ['NshIdE1'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2024-2025 NshIdE
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="Toggle full screen shortcut key s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>Help us with donation</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">alipay</label></span><span><label><input type="radio" name="pay" value="weixin">weixin</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
