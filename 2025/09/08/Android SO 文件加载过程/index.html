<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Android SO 文件加载过程 | NshIdE&#39;s Home</title>
  <meta name="keywords" content=" Android ">
  <meta name="description" content="Android SO 文件加载过程 | NshIdE&#39;s Home">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta property="og:type" content="website">
<meta property="og:title" content="tags">
<meta property="og:url" content="https://nshide1.github.io/tags/">
<meta property="og:site_name" content="NshIdE&#39;s Home">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-03-04T12:20:04.979Z">
<meta property="article:modified_time" content="2025-03-04T12:20:04.979Z">
<meta property="article:author" content="NshIdE">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/logo.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/logo.jpg"/>
</a>
<div class="author">
    <span>NshIdE</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/NshIdE1/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="csdn"
               href="https://www.csdn.net/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-csdn"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1621925986&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(40)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="其他">
            
            其他
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Android-RE">
            
            Android-RE
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Android学习">
            
            Android学习
            <small>(9)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Angr入门">
            
            Angr入门
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="CTF">
            
            CTF
            <small>(15)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Frida入门">
            
            Frida入门
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Java学习">
            
            Java学习
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="Unidbg学习">
            
            Unidbg学习
            <small>(10)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="40">
<input type="hidden" id="yelog_site_word_count" value="221.9k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://bananashipsbbq.github.io/">bananaships</a></li>
            
            <li><a target="_blank" href="https://astralprisma.github.io/">AstralPrisma</a></li>
            
            <li><a target="_blank" href="https://monoceros406.github.io/">Monoceros406</a></li>
            
            <li><a target="_blank" href="https://github.com/Thir0th">Thir0th</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="search shortcut key i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="switch to outline view shortcut key w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="return"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="case sensitive"></i>
            <i class="iconfont icon-tag" data-title="label"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">outline</div>
            <i class="iconfont icon-list" data-title="switch to article list"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>抽象</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>符号执行</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>取证</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>应急响应</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Android</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CTF</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Frida</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>go</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Harmony</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>il2Cpps</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>iOS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ISW</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>RE</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SIMD</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unidbg</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Unity</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>vm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>WritesUp</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="All CTF "
           href="/2025/10/25/%E7%AC%AC%E5%85%AB%E5%B1%8A%E5%BC%BA%E7%BD%91%C2%B7%E6%8B%9F%E6%80%81%E9%98%B2%E5%BE%A1%E5%9B%BD%E9%99%85%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B/"
           data-tag="CTF,RE,WritesUp,Android,il2Cpps"
           data-author="" >
            <span class="post-title" title="第八届强网·拟态防御国际精英挑战赛">第八届强网·拟态防御国际精英挑战赛</span>
            <span class="post-date" title="2025-10-25 17:31:37">2025/10/25</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/10/22/Android%20APP%20%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android APP 常见漏洞">Android APP 常见漏洞</span>
            <span class="post-date" title="2025-10-22 17:06:07">2025/10/22</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/10/10/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20PackageInfo%20%E5%92%8C%20LoadedApk/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="从源码分析 PackageInfo 和 LoadedApk">从源码分析 PackageInfo 和 LoadedApk</span>
            <span class="post-date" title="2025-10-10 18:15:17">2025/10/10</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/09/09/2025%E5%B9%B4%E6%B9%BE%E5%8C%BA%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E5%88%9D%E8%B5%9B/"
           data-tag="CTF,RE,WritesUp,Android"
           data-author="" >
            <span class="post-title" title="2025年湾区杯网络安全大赛初赛">2025年湾区杯网络安全大赛初赛</span>
            <span class="post-date" title="2025-09-09 09:34:17">2025/09/09</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/09/08/Android%20SO%20%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android SO 文件加载过程">Android SO 文件加载过程</span>
            <span class="post-date" title="2025-09-08 17:18:50">2025/09/08</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/25/Dex%20%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Dex 文件结构学习">Dex 文件结构学习</span>
            <span class="post-date" title="2025-08-25 17:33:29">2025/08/25</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/19/ClassLoader%20%E6%9C%BA%E5%88%B6/"
           data-tag="Android,Java"
           data-author="" >
            <span class="post-title" title="ClassLoader 机制">ClassLoader 机制</span>
            <span class="post-date" title="2025-08-19 17:42:51">2025/08/19</span>
        </a>
        
        
        <a  class="All Java学习 "
           href="/2025/08/19/Java%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"
           data-tag="Android,Java"
           data-author="" >
            <span class="post-title" title="Java学习----反射机制">Java学习----反射机制</span>
            <span class="post-date" title="2025-08-19 17:00:02">2025/08/19</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/19/Android%20%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android 应用启动流程">Android 应用启动流程</span>
            <span class="post-date" title="2025-08-19 11:14:13">2025/08/19</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/19/%E5%AE%89%E5%8D%93%E5%8A%A0%E5%9B%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="安卓加固学习记录">安卓加固学习记录</span>
            <span class="post-date" title="2025-08-19 10:50:46">2025/08/19</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/14/Android%20%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94NDK%20%E5%BC%80%E5%8F%91/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="Android 开发--NDK 开发">Android 开发--NDK 开发</span>
            <span class="post-date" title="2025-08-14 17:56:58">2025/08/14</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/08/10/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E5%85%AD)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(六)">从实践中学习unidbg使用(六)</span>
            <span class="post-date" title="2025-08-10 10:25:02">2025/08/10</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/08/08/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%BA%94)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(五)">从实践中学习unidbg使用(五)</span>
            <span class="post-date" title="2025-08-08 17:45:59">2025/08/08</span>
        </a>
        
        
        <a  class="All Android学习 "
           href="/2025/08/05/%E6%BC%AB%E8%B0%88%E5%94%AF%E4%B8%80%E8%AE%BE%E5%A4%87ID/"
           data-tag="Android"
           data-author="" >
            <span class="post-title" title="漫谈唯一设备 ID">漫谈唯一设备 ID</span>
            <span class="post-date" title="2025-08-05 18:00:44">2025/08/05</span>
        </a>
        
        
        <a  class="All 其他 "
           href="/2025/07/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Linux%20%E7%B3%BB%E7%BB%9F%E4%B8%8B%20proc%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AE%B9/"
           data-tag="Android,Linux"
           data-author="" >
            <span class="post-title" title="浅谈 Linux 系统下 proc 文件系统内容">浅谈 Linux 系统下 proc 文件系统内容</span>
            <span class="post-date" title="2025-07-24 17:56:57">2025/07/24</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/07/24/Unidbg%20%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%88%E4%BA%8C%EF%BC%89/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="Unidbg 中处理文件访问(二)">Unidbg 中处理文件访问(二)</span>
            <span class="post-date" title="2025-07-24 17:00:12">2025/07/24</span>
        </a>
        
        
        <a  class="All Android-RE "
           href="/2025/07/23/2025%E7%AC%AC%E5%8D%81%E5%B1%8A%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B-%E5%88%9D%E8%B5%9B-%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/"
           data-tag="RE,WritesUp,Android"
           data-author="" >
            <span class="post-title" title="2025第十届游戏安全竞赛-初赛-安卓客户端安全">2025第十届游戏安全竞赛-初赛-安卓客户端安全</span>
            <span class="post-date" title="2025-07-23 15:32:11">2025/07/23</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/07/19/%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="创建模拟器和加载模块">创建模拟器和加载模块</span>
            <span class="post-date" title="2025-07-19 15:14:29">2025/07/19</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/07/15/Unidbg%20%E4%B8%AD%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%88%E4%B8%80%EF%BC%89/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="Unidbg 中处理文件访问(一)">Unidbg 中处理文件访问(一)</span>
            <span class="post-date" title="2025-07-15 16:52:06">2025/07/15</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/07/08/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E5%9B%9B)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(四)">从实践中学习unidbg使用(四)</span>
            <span class="post-date" title="2025-07-08 11:44:49">2025/07/08</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/07/01/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%B8%89)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(三)">从实践中学习unidbg使用(三)</span>
            <span class="post-date" title="2025-07-01 15:29:42">2025/07/01</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/06/07/%E7%AC%AC%E4%B8%80%E5%B1%8AOpenHarmonyCTF/"
           data-tag="CTF,RE,WritesUp,Harmony"
           data-author="" >
            <span class="post-title" title="第一届OpenHarmonyCTF">第一届OpenHarmonyCTF</span>
            <span class="post-date" title="2025-06-07 13:32:45">2025/06/07</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/06/04/%E8%A1%A5%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%94%EF%BC%89/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="补库函数(五)">补库函数(五)</span>
            <span class="post-date" title="2025-06-04 19:07:56">2025/06/04</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/06/02/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%BA%8C)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(二)">从实践中学习unidbg使用(二)</span>
            <span class="post-date" title="2025-06-02 15:33:15">2025/06/02</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/05/31/D%5E3CTF2025/"
           data-tag="CTF,RE,WritesUp,Android"
           data-author="" >
            <span class="post-title" title="D^3CTF2025">D^3CTF2025</span>
            <span class="post-date" title="2025-05-31 16:21:11">2025/05/31</span>
        </a>
        
        
        <a  class="All Unidbg学习 "
           href="/2025/05/28/%E4%BB%8E%E5%AE%9E%E8%B7%B5%E4%B8%AD%E5%AD%A6%E4%B9%A0unidbg%E4%BD%BF%E7%94%A8(%E4%B8%80)/"
           data-tag="Unidbg"
           data-author="" >
            <span class="post-title" title="从实践中学习unidbg使用(一)">从实践中学习unidbg使用(一)</span>
            <span class="post-date" title="2025-05-28 16:39:23">2025/05/28</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/05/17/Parloo2025/"
           data-tag="CTF,RE,WritesUp"
           data-author="" >
            <span class="post-title" title="Parloo RE">Parloo RE</span>
            <span class="post-date" title="2025-05-17 09:34:20">2025/05/17</span>
        </a>
        
        
        <a  class="All Android-RE "
           href="/2025/05/07/%E8%AE%B0%E4%B8%80%E6%AC%A1APK%E5%88%86%E6%9E%90/"
           data-tag="RE,WritesUp,Android"
           data-author="" >
            <span class="post-title" title="记一次APK分析">记一次APK分析</span>
            <span class="post-date" title="2025-05-07 21:12:00">2025/05/07</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/04/26/%E4%B8%80%E9%81%93%E5%BE%88%E9%80%86%E5%A4%A9%E7%9A%84RC4/"
           data-tag="CTF,RE,WritesUp,抽象"
           data-author="" >
            <span class="post-title" title="抽象RC4">抽象RC4</span>
            <span class="post-date" title="2025-04-26 22:21:19">2025/04/26</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/04/24/%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98/"
           data-tag="CTF,RE,WritesUp"
           data-author="" >
            <span class="post-title" title="很有意思的一道题">很有意思的一道题</span>
            <span class="post-date" title="2025-04-24 21:56:18">2025/04/24</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/04/23/%E4%BA%AC%E9%BA%92CTF2025%20%E7%83%AD%E8%BA%AB%E8%B5%9B/"
           data-tag="CTF,RE,WritesUp,iOS,SIMD"
           data-author="" >
            <span class="post-title" title="京麒CTF2025热身赛">京麒CTF2025热身赛</span>
            <span class="post-date" title="2025-04-23 13:33:59">2025/04/23</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/04/14/TGCTF2025/"
           data-tag="CTF,RE,WritesUp"
           data-author="" >
            <span class="post-title" title="TGCTF2025 RE">TGCTF2025 RE</span>
            <span class="post-date" title="2025-04-14 18:51:29">2025/04/14</span>
        </a>
        
        
        <a  class="All Angr入门 "
           href="/2025/04/14/Angr%E5%85%A5%E9%97%A8/"
           data-tag="符号执行"
           data-author="" >
            <span class="post-title" title="Angr入门">Angr入门</span>
            <span class="post-date" title="2025-04-14 18:50:44">2025/04/14</span>
        </a>
        
        
        <a  class="All Frida入门 "
           href="/2025/04/14/Frida%E5%85%A5%E9%97%A8/"
           data-tag="Android,Frida"
           data-author="" >
            <span class="post-title" title="Frida入门">Frida入门</span>
            <span class="post-date" title="2025-04-14 18:47:37">2025/04/14</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/04/12/TEXSAWCTF%202025/"
           data-tag="CTF,RE,WritesUp"
           data-author="" >
            <span class="post-title" title="TEXSAWCTF 2025">TEXSAWCTF 2025</span>
            <span class="post-date" title="2025-04-12 15:32:31">2025/04/12</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/03/23/NCTF2024/"
           data-tag="CTF,RE,WritesUp,vm,go"
           data-author="" >
            <span class="post-title" title="NCTF2024">NCTF2024</span>
            <span class="post-date" title="2025-03-23 11:58:53">2025/03/23</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/03/18/CISCN%20x%20CCB%20%E5%8D%8A%E5%86%B3%E8%B5%9B%202025%20ISW(%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94)/"
           data-tag="ISW,应急响应,取证"
           data-author="" >
            <span class="post-title" title="CISCN x CCB 半决赛 2025 ISW(应急响应)">CISCN x CCB 半决赛 2025 ISW(应急响应)</span>
            <span class="post-date" title="2025-03-18 10:24:23">2025/03/18</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/03/11/TPCTF%202025/"
           data-tag="CTF,RE,WritesUp"
           data-author="" >
            <span class="post-title" title="TPCTF 2025">TPCTF 2025</span>
            <span class="post-date" title="2025-03-11 21:41:19">2025/03/11</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/03/06/VishwaCTF2025/"
           data-tag="CTF,RE,WritesUp,Android,Unity"
           data-author="" >
            <span class="post-title" title="VishwaCTF2025">VishwaCTF2025</span>
            <span class="post-date" title="2025-03-06 21:52:51">2025/03/06</span>
        </a>
        
        
        <a  class="All CTF "
           href="/2025/03/03/HGAME%20RE/"
           data-tag="CTF,RE,WritesUp,Android"
           data-author="" >
            <span class="post-title" title="HGAME-RE-WEEK1">HGAME-RE-WEEK1</span>
            <span class="post-date" title="2025-03-03 22:20:33">2025/03/03</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="Toggle full screen shortcut key s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Android SO 文件加载过程" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Android SO 文件加载过程</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Android学习">Android学习</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color3">Android</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-09-09 18:01:47'>2025-09-08 17:18</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:7.9k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="Jump to comment area">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android-SO-%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">Android SO 文件加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BC%80%E5%A7%8B"><span class="toc-text">二、开始</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">三、总结</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-SO-文件加载过程"><a href="#Android-SO-文件加载过程" class="headerlink" title="Android SO 文件加载过程"></a>Android SO 文件加载过程</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​		针对 Android so 文件加载过程只有一个很浅显的认识，后来想稍微系统学习的时候，AOSP 的源码不公开了…直到最近在看雪上看到一篇<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-285788.htm">文章</a>，里面贴出了一个网址，可以正常访问到 AOSP 的源码，于是乎打算学习并记录一下。</p>
<h3 id="二、开始"><a href="#二、开始" class="headerlink" title="二、开始"></a>二、开始</h3><p>​		在 Android 中，.so 文件是 <strong>共享库</strong> 文件，共享库文件又可以细分为 <strong>动态链接库</strong>（动态 .so 文件）和 <strong>静态链接库</strong>（静态 .a 文件）。但在 Android 中一般更常见的是动态 .so 文件，静态链接库通常在编译时就被集成到最终应用中，而不是直接加载。所以经常看到的 so 文件的链接大多都是以动态链接的。</p>
<p>​		动态链接会利用对应的打包生成的 APK，按照对应的 ABI（lib&#x2F;armeabi-v7a&#x2F;，lib&#x2F;arm64-v8a&#x2F;，lib&#x2F;x86&#x2F;，lib&#x2F;x86_64&#x2F;）去选择对应的 so 文件，然后去实现在 Java 层的调用，或者在 native 层调用 Java层的代码逻辑。</p>
<p>​		Java 代码使用 静态 <code>System.loadLibrary(&quot;libsofile&quot;)</code> 来加载共享库文件；或者通过动态加载路径的 so 文件来实现。</p>
<p>​		在 Android 中，<strong>静态链接库</strong> （.a 文件）是被链接到最终的可执行文件中，而不是在运行时加载。Android NDK 编译时，静态库会被打包到 APK 中的应用代码部分。</p>
<p>​		要探究 so 文件最真实的加载过程就从 System.load(soPath); 开始，去剖析<a target="_blank" rel="noopener" href="https://cs.android.com/">安卓源码</a>。</p>
<p>​		这里我就用自己写的一个题目为例，来进行分析。首先看到在 MainActivity.java 中的 <strong>System.loadLibrary(“ctf1”);</strong>。<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909112636118.png" alt="image-20250909112636118"></p>
<p>跟进 <strong>loadLibrary</strong> 函数</p>
<pre><code class="language-Java">    @CallerSensitive
    public static void loadLibrary(String libname) &#123;
        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);
    &#125;
</code></pre>
<p>​		首先第一行的注解，作用是告诉 JVM&#x2F;安全检查逻辑：</p>
<ul>
<li>这个方法的行为 <strong>依赖于调用者是谁</strong>；</li>
<li>不能随便内联或优化，因为它需要直到调用栈上是谁在调用。</li>
</ul>
<p>​		比如 <strong>System.loadLibrary</strong> 最终要决定：是允许调用方加载本地库，还是拒绝（比如安全管理器里限制）；所以 JVM 会特别处理 <code>@CallerSensitive</code>，正确识别“真实的调用者类”。</p>
<p>​		接下来通过 Java 的反射机制拿到调用类，并和 so 文件名一起传入到由 JVM 的运行时对象调用的 <strong>loadLibrary0</strong> 方法中。到这里要想再进一步跟进就得上网站看 Android 源码了。直接进行搜索，就可以找到。</p>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909113351174.png" alt="image-20250909113351174"></p>
<p>​		该方法先拿到调用者类对应的类加载器，然后又将其作为参数之一，调用了另一个重载版本，继续跟进。</p>
<pre><code class="language-Java">private synchronized void loadLibrary0(ClassLoader loader, Class&lt;?&gt; callerClass, String libname) &#123;
        if (libname.indexOf((int)File.separatorChar) != -1) &#123;
            throw new UnsatisfiedLinkError(
    &quot;Directory separator should not appear in library name: &quot; + libname);
        &#125;
        String libraryName = libname;
        // Android-note: BootClassLoader doesn&#39;t implement findLibrary(). http://b/111850480
        // Android&#39;s class.getClassLoader() can return BootClassLoader where the RI would
        // have returned null; therefore we treat BootClassLoader the same as null here.
        if (loader != null &amp;&amp; !(loader instanceof BootClassLoader)) &#123;
            String filename = loader.findLibrary(libraryName);
            if (filename == null &amp;&amp;
                    (loader.getClass() == PathClassLoader.class ||
                     loader.getClass() == DelegateLastClassLoader.class)) &#123;
                // Don&#39;t give up even if we failed to find the library in the native lib paths.
                // The underlying dynamic linker might be able to find the lib in one of the linker
                // namespaces associated with the current linker namespace. In order to give the
                // dynamic linker a chance, proceed to load the library with its soname, which
                // is the fileName.
                // Note that we do this only for PathClassLoader  and DelegateLastClassLoader to
                // minimize the scope of this behavioral change as much as possible, which might
                // cause problem like b/143649498. These two class loaders are the only
                // platform-provided class loaders that can load apps. See the classLoader attribute
                // of the application tag in app manifest.
                filename = System.mapLibraryName(libraryName);
            &#125;
            if (filename == null) &#123;
                // It&#39;s not necessarily true that the ClassLoader used
                // System.mapLibraryName, but the default setup does, and it&#39;s
                // misleading to say we didn&#39;t find &quot;libMyLibrary.so&quot; when we
                // actually searched for &quot;liblibMyLibrary.so.so&quot;.
                throw new UnsatisfiedLinkError(loader + &quot; couldn&#39;t find \&quot;&quot; +
                                               System.mapLibraryName(libraryName) + &quot;\&quot;&quot;);
            &#125;
            String error = nativeLoad(filename, loader, callerClass);
            if (error != null) &#123;
                throw new UnsatisfiedLinkError(error);
            &#125;
            return;
        &#125;

        // We know some apps use mLibPaths directly, potentially assuming it&#39;s not null.
        // Initialize it here to make sure apps see a non-null value.
        getLibPaths();
        String filename = System.mapLibraryName(libraryName);
        String error = nativeLoad(filename, loader, callerClass);
        if (error != null) &#123;
            throw new UnsatisfiedLinkError(error);
        &#125;
    &#125;
</code></pre>
<p>​		该重载方法首先先检查库名是否合法，然后判断 loader 非空且不是 BootClassLoader，就调用 <strong>findLibrary</strong>，让类加载器自己找库文件；而如果找不到，就会分别调用 <strong>PathClassLoader</strong> 和 <strong>DelegateLastClassLoader</strong> 再进一步尝试去加载库。如果依旧找不到，那么系统就会抛出 UnsatisfiedLinkError，告诉开发人员哪个 ClassLoader 找不到哪个库。接下来便是调用 JNI 层方法 <strong>nativeLoad</strong>，内部最终会调用 dlopen 函数。而如果 loader 为 null 或 BootClassLoader，则使用 JVM 默认的库路径（java.library.path &#x2F; Android 的 mLibPaths），拼接文件名，再调用 <strong>nativeLoad</strong>，同样，失败抛出异常。继续跟进。</p>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909115530624.png" alt="image-20250909115530624"></p>
<p>​		到这里就是 native 函数了，就需要去看对应的 c 文件了，所以要重新去搜索了，这里的搜索方法就是 <strong>类名_函数名</strong> 的形式，转换过去就是 <strong>Runtime_nativeLoad</strong> 函数。</p>
<pre><code class="language-c">JNIEXPORT jstring JNICALL
Runtime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,
                   jobject javaLoader, jclass caller)
&#123;
    return JVM_NativeLoad(env, javaFilename, javaLoader, caller);
&#125;
</code></pre>
<p>​		这里就是正常的返回，直接走 JVM_NativeLoad(env, javaFilename, javaLoader, caller); 。继续跟进。</p>
<pre><code class="language-c++">JNIEXPORT jstring JVM_NativeLoad(JNIEnv* env,
                                 jstring javaFilename,
                                 jobject javaLoader,
                                 jclass caller) &#123;
  ScopedUtfChars filename(env, javaFilename);
  if (filename.c_str() == nullptr) &#123;
    return nullptr;
  &#125;

  std::string error_msg;
  &#123;
    art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM();
    bool success = vm-&gt;LoadNativeLibrary(env,
                                         filename.c_str(),
                                         javaLoader,
                                         caller,
                                         &amp;error_msg);
    if (success) &#123;
      return nullptr;
    &#125;
  &#125;

  // Don&#39;t let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.
  env-&gt;ExceptionClear();
  return env-&gt;NewStringUTF(error_msg.c_str());
&#125;
</code></pre>
<p>​		该方法 首先将传进来的 so 库库名转为 C++ 字符串，然后获取当前 ART 运行时实例，并获取对应的 <strong>JavaVMExt</strong> 对象，再将多个函数传入到 <strong>LoadNativeLibrary</strong> 函数中，如果成功，返回 true，失败则返回 false 并 填充 error_msg。后面是异常处理部分，就没什么好说的了，继续跟进。</p>
<pre><code class="language-C++">bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,
                                  const std::string&amp; path,
                                  jobject class_loader,
                                  jclass caller_class,
                                  std::string* error_msg) &#123;
  error_msg-&gt;clear();

  // See if we&#39;ve already loaded this library.  If we have, and the class loader
  // matches, return successfully without doing anything.
  // TODO: for better results we should canonicalize the pathname (or even compare
  // inodes). This implementation is fine if everybody is using System.loadLibrary.
  SharedLibrary* library;
  Thread* self = Thread::Current();
  &#123;
    // TODO: move the locking (and more of this logic) into Libraries.
    MutexLock mu(self, *Locks::jni_libraries_lock_);
    library = libraries_-&gt;Get(path);
  &#125;
  void* class_loader_allocator = nullptr;
  std::string caller_location;
  &#123;
    ScopedObjectAccess soa(env);
    // As the incoming class loader is reachable/alive during the call of this function,
    // it&#39;s okay to decode it without worrying about unexpectedly marking it alive.
    ObjPtr&lt;mirror::ClassLoader&gt; loader = soa.Decode&lt;mirror::ClassLoader&gt;(class_loader);

    ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();
    if (class_linker-&gt;IsBootClassLoader(loader)) &#123;
      loader = nullptr;
      class_loader = nullptr;
    &#125;
    if (caller_class != nullptr) &#123;
      ObjPtr&lt;mirror::Class&gt; caller = soa.Decode&lt;mirror::Class&gt;(caller_class);
      ObjPtr&lt;mirror::DexCache&gt; dex_cache = caller-&gt;GetDexCache();
      if (dex_cache != nullptr) &#123;
        caller_location = dex_cache-&gt;GetLocation()-&gt;ToModifiedUtf8();
      &#125;
    &#125;

    class_loader_allocator = class_linker-&gt;GetAllocatorForClassLoader(loader);
    CHECK(class_loader_allocator != nullptr);
  &#125;
  if (library != nullptr) &#123;
    // Use the allocator pointers for class loader equality to avoid unnecessary weak root decode.
    if (library-&gt;GetClassLoaderAllocator() != class_loader_allocator) &#123;
      // The library will be associated with class_loader. The JNI
      // spec says we can&#39;t load the same library into more than one
      // class loader.
      //
      // This isn&#39;t very common. So spend some time to get a readable message.
      auto call_to_string = [&amp;](jobject obj) -&gt; std::string &#123;
        if (obj == nullptr) &#123;
          return &quot;null&quot;;
        &#125;
        // Handle jweaks. Ignore double local-ref.
        ScopedLocalRef&lt;jobject&gt; local_ref(env, env-&gt;NewLocalRef(obj));
        if (local_ref != nullptr) &#123;
          ScopedLocalRef&lt;jclass&gt; local_class(env, env-&gt;GetObjectClass(local_ref.get()));
          jmethodID to_string = env-&gt;GetMethodID(local_class.get(),
                                                 &quot;toString&quot;,
                                                 &quot;()Ljava/lang/String;&quot;);
          DCHECK(to_string != nullptr);
          ScopedLocalRef&lt;jobject&gt; local_string(env,
                                               env-&gt;CallObjectMethod(local_ref.get(), to_string));
          if (local_string != nullptr) &#123;
            ScopedUtfChars utf(env, reinterpret_cast&lt;jstring&gt;(local_string.get()));
            if (utf.c_str() != nullptr) &#123;
              return utf.c_str();
            &#125;
          &#125;
          if (env-&gt;ExceptionCheck()) &#123;
            // We can&#39;t do much better logging, really. So leave it with a Describe.
            env-&gt;ExceptionDescribe();
            env-&gt;ExceptionClear();
          &#125;
          return &quot;(Error calling toString)&quot;;
        &#125;
        return &quot;null&quot;;
      &#125;;
      std::string old_class_loader = call_to_string(library-&gt;GetClassLoader());
      std::string new_class_loader = call_to_string(class_loader);
      StringAppendF(error_msg, &quot;Shared library \&quot;%s\&quot; already opened by &quot;
          &quot;ClassLoader %p(%s); can&#39;t open in ClassLoader %p(%s)&quot;,
          path.c_str(),
          library-&gt;GetClassLoader(),
          old_class_loader.c_str(),
          class_loader,
          new_class_loader.c_str());
      LOG(WARNING) &lt;&lt; *error_msg;
      return false;
    &#125;
    VLOG(jni) &lt;&lt; &quot;[Shared library \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; already loaded in &quot;
              &lt;&lt; &quot; ClassLoader &quot; &lt;&lt; class_loader &lt;&lt; &quot;]&quot;;
    if (!library-&gt;CheckOnLoadResult()) &#123;
      StringAppendF(error_msg, &quot;JNI_OnLoad failed on a previous attempt &quot;
          &quot;to load \&quot;%s\&quot;&quot;, path.c_str());
      return false;
    &#125;
    return true;
  &#125;
// Open the shared library.  Because we&#39;re using a full path, the system
  // doesn&#39;t have to search through LD_LIBRARY_PATH.  (It may do so to
  // resolve this library&#39;s dependencies though.)

  // Failures here are expected when java.library.path has several entries
  // and we have to hunt for the lib.

  // Below we dlopen but there is no paired dlclose, this would be necessary if we supported
  // class unloading. Libraries will only be unloaded when the reference count (incremented by
  // dlopen) becomes zero from dlclose.

  // Retrieve the library path from the classloader, if necessary.
  ScopedLocalRef&lt;jstring&gt; library_path(env, GetLibrarySearchPath(env, class_loader));

  Locks::mutator_lock_-&gt;AssertNotHeld(self);
  const char* path_str = path.empty() ? nullptr : path.c_str();
  bool needs_native_bridge = false;
  char* nativeloader_error_msg = nullptr;
  void* handle = android::OpenNativeLibrary(
      env,
      runtime_-&gt;GetTargetSdkVersion(),
      path_str,
      class_loader,
      (caller_location.empty() ? nullptr : caller_location.c_str()),
      library_path.get(),
      &amp;needs_native_bridge,
      &amp;nativeloader_error_msg);
  VLOG(jni) &lt;&lt; &quot;[Call to dlopen(\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;, RTLD_NOW) returned &quot; &lt;&lt; handle &lt;&lt; &quot;]&quot;;

  if (handle == nullptr) &#123;
    *error_msg = nativeloader_error_msg;
    android::NativeLoaderFreeErrorMessage(nativeloader_error_msg);
    VLOG(jni) &lt;&lt; &quot;dlopen(\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;, RTLD_NOW) failed: &quot; &lt;&lt; *error_msg;
    return false;
  &#125;

  if (env-&gt;ExceptionCheck() == JNI_TRUE) &#123;
    LOG(ERROR) &lt;&lt; &quot;Unexpected exception:&quot;;
    env-&gt;ExceptionDescribe();
    env-&gt;ExceptionClear();
  &#125;
  // Create a new entry.
  // TODO: move the locking (and more of this logic) into Libraries.
  bool created_library = false;
  &#123;
    // Create SharedLibrary ahead of taking the libraries lock to maintain lock ordering.
    std::unique_ptr&lt;SharedLibrary&gt; new_library(
        new SharedLibrary(env,
                          self,
                          path,
                          handle,
                          needs_native_bridge,
                          class_loader,
                          class_loader_allocator));

    MutexLock mu(self, *Locks::jni_libraries_lock_);
    library = libraries_-&gt;Get(path);
    if (library == nullptr) &#123;  // We won race to get libraries_lock.
      library = new_library.release();
      libraries_-&gt;Put(path, library);
      created_library = true;
    &#125;
  &#125;
  if (!created_library) &#123;
    LOG(INFO) &lt;&lt; &quot;WOW: we lost a race to add shared library: &quot;
        &lt;&lt; &quot;\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; ClassLoader=&quot; &lt;&lt; class_loader;
    return library-&gt;CheckOnLoadResult();
  &#125;
  VLOG(jni) &lt;&lt; &quot;[Added shared library \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot; for ClassLoader &quot; &lt;&lt; class_loader &lt;&lt; &quot;]&quot;;

  bool was_successful = false;
  void* sym = library-&gt;FindSymbol(&quot;JNI_OnLoad&quot;, nullptr, android::kJNICallTypeRegular);
  if (sym == nullptr) &#123;
    VLOG(jni) &lt;&lt; &quot;[No JNI_OnLoad found in \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;]&quot;;
    was_successful = true;
  &#125; else &#123;
    // Call JNI_OnLoad.  We have to override the current class
    // loader, which will always be &quot;null&quot; since the stuff at the
    // top of the stack is around Runtime.loadLibrary().  (See
    // the comments in the JNI FindClass function.)
    ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));
    self-&gt;SetClassLoaderOverride(class_loader);

    VLOG(jni) &lt;&lt; &quot;[Calling JNI_OnLoad in \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;]&quot;;
    using JNI_OnLoadFn = int(*)(JavaVM*, void*);
    JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym);
    int version = (*jni_on_load)(this, nullptr);

    if (IsSdkVersionSetAndAtMost(runtime_-&gt;GetTargetSdkVersion(), SdkVersion::kL)) &#123;
      // Make sure that sigchain owns SIGSEGV.
      EnsureFrontOfChain(SIGSEGV);
    &#125;

    self-&gt;SetClassLoaderOverride(old_class_loader.get());

    if (version == JNI_ERR) &#123;
      StringAppendF(error_msg, &quot;JNI_ERR returned from JNI_OnLoad in \&quot;%s\&quot;&quot;, path.c_str());
    &#125; else if (JavaVMExt::IsBadJniVersion(version)) &#123;
      StringAppendF(error_msg, &quot;Bad JNI version returned from JNI_OnLoad in \&quot;%s\&quot;: %d&quot;,
                    path.c_str(), version);
      // It&#39;s unwise to call dlclose() here, but we can mark it
      // as bad and ensure that future load attempts will fail.
      // We don&#39;t know how far JNI_OnLoad got, so there could
      // be some partially-initialized stuff accessible through
      // newly-registered native method calls.  We could try to
      // unregister them, but that doesn&#39;t seem worthwhile.
    &#125; else &#123;
      was_successful = true;
    &#125;
    VLOG(jni) &lt;&lt; &quot;[Returned &quot; &lt;&lt; (was_successful ? &quot;successfully&quot; : &quot;failure&quot;)
              &lt;&lt; &quot; from JNI_OnLoad in \&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\&quot;]&quot;;
  &#125;

  library-&gt;SetResult(was_successful);
  return was_successful;
&#125;
</code></pre>
<p>​		首先，该方法先进行初始化和查找已加载库，<strong>ART</strong> 会维护一个 libraries_ <strong>哈希表</strong>，记录已经成功加载的 native 库，通过该表来检查是否已经加载过（并加锁保护，防止多个线程同时加载同一库）；<strong>ScopedObjectAccess</strong> 用于安全访问 Java 对象，Decode 把 jobject 转成 ART 内部对象指针，然后获取 ClassLinker，再检查传进来的调用者 ClassLoader 是不是引导类加载器，为什么要做特殊处理？因为系统类加载器不记录 native 库，直接置为 nullptr；接着获取调用类所在的 Dex 文件位置，用于日志或调试；然后获取 ClassLoader 分配器，因为 ART 每个 ClassLoader 都有一个 <strong>allocator</strong>（内存分配标识），用于区分库属于哪个 ClassLoader（注：JNI 规范要求：<strong>同一个 native 库不能加载到不同的 ClassLoader</strong>），获取到了之后就会进行检查是否 重复加载，如果不一致，说明已经被加载过了，报错，如果一致，再检查 JNI_OnLoad 是否成功。</p>
<p>​		解下来是核心逻辑，调用 <strong>OpenNativeLibrary</strong> ，内部会根据入参中的 <strong>class_loader</strong> 的 <strong>nativeLibraryPath(s)</strong>（通常是 <code>/data/app/.../lib/arm/</code> 或 <code>/system/lib/</code>）去找 .so 文件，最终会调用到 dlopen 来加载动态库，返回 <strong>so 文件的 dlopen 句柄</strong>，如果加载失败，错误信息会写到 error_msg 中，这里没有 dlclose，注释里也解释清楚了，因为 ART&#x2F;Java 默认不支持类卸载，所以即使 classloader 被 GC 回收，库也不会 dlclose，因此 so 文件一旦加载成功，就常驻进程，直到进程退出；后续的逻辑会为每个 so 文件生成一个 SharedLibrary 对象，保存 path、dlopen 句柄、class_loader、是否需要 native bridge（比如 32bit &lt;-&gt; 64bit 兼容），并放到 libraries_ 这个全局表里，保证重复加载时能复用；然后调用 JNI_OnLoad，从已加载的 so 库中寻找有没有 JNI_OnLoad 函数，有的话就直接调用，最后便是设置结果并返回。继续跟进 OpenNativeLibrary 函数。</p>
<pre><code class="language-C++">void* OpenNativeLibrary(JNIEnv* env,
                        int32_t target_sdk_version,
                        const char* path,
                        jobject class_loader,
                        const char* caller_location,
                        jstring library_path_j,
                        bool* needs_native_bridge,
                        char** error_msg) &#123;
#if defined(ART_TARGET_ANDROID)
  if (class_loader == nullptr) &#123;
    // class_loader is null only for the boot class loader (see
    // IsBootClassLoader call in JavaVMExt::LoadNativeLibrary), i.e. the caller
    // is in the boot classpath.
    *needs_native_bridge = false;
    if (caller_location != nullptr) &#123;
      std::optional&lt;NativeLoaderNamespace&gt; ns = FindApexNamespace(caller_location);
      if (ns.has_value()) &#123;
        const android_dlextinfo dlextinfo = &#123;
            .flags = ANDROID_DLEXT_USE_NAMESPACE,
            .library_namespace = ns.value().ToRawAndroidNamespace(),
        &#125;;
        void* handle = android_dlopen_ext(path, RTLD_NOW, &amp;dlextinfo);
        char* dlerror_msg = handle == nullptr ? strdup(dlerror()) : nullptr;
        ALOGD(&quot;Load %s using APEX ns %s for caller %s: %s&quot;,
              path,
              ns.value().name().c_str(),
              caller_location,
              dlerror_msg == nullptr ? &quot;ok&quot; : dlerror_msg);
        if (dlerror_msg != nullptr) &#123;
          *error_msg = dlerror_msg;
        &#125;
        return handle;
      &#125;
    &#125;

    // Check if the library is in NATIVELOADER_DEFAULT_NAMESPACE_LIBS and should
    // be loaded from the kNativeloaderExtraLibs namespace.
    &#123;
      Result&lt;void*&gt; handle = TryLoadNativeloaderExtraLib(path);
      if (!handle.ok()) &#123;
        *error_msg = strdup(handle.error().message().c_str());
        return nullptr;
      &#125;
      if (handle.value() != nullptr) &#123;
        return handle.value();
      &#125;
    &#125;

    // Handle issue b/349878424.
    static bool bypass_loading_for_b349878424 = ShouldBypassLoadingForB349878424();

    if (bypass_loading_for_b349878424 &amp;&amp;
        (strcmp(&quot;libsobridge.so&quot;, path) == 0 || strcmp(&quot;libwalkstack.so&quot;, path) == 0)) &#123;
      // Load a different library to pretend the loading was successful. This
      // allows the device to boot.
      ALOGD(&quot;Loading libbase.so instead of %s due to b/349878424&quot;, path);
      path = &quot;libbase.so&quot;;
    &#125;

    // Fall back to the system namespace. This happens for preloaded JNI
    // libraries in the zygote.
    void* handle = OpenSystemLibrary(path, RTLD_NOW);
    char* dlerror_msg = handle == nullptr ? strdup(dlerror()) : nullptr;
    ALOGD(&quot;Load %s using system ns (caller=%s): %s&quot;,
          path,
          caller_location == nullptr ? &quot;&lt;unknown&gt;&quot; : caller_location,
          dlerror_msg == nullptr ? &quot;ok&quot; : dlerror_msg);
    if (dlerror_msg != nullptr) &#123;
      *error_msg = dlerror_msg;
    &#125;
    return handle;
  &#125;

  // If the caller is in any of the system image partitions and the library is
  // in the same partition then load it without regards to public library
  // restrictions. This is only done if the library is specified by an absolute
  // path, so we don&#39;t affect the lookup process for libraries specified by name
  // only.
  if (caller_location != nullptr &amp;&amp;
      // Apps in the partition may have their own native libraries which should
      // be loaded with the app&#39;s classloader namespace, so only do this for
      // libraries in the partition-wide lib(64) directories.
      nativeloader::IsPartitionNativeLibPath(path) &amp;&amp;
      // Don&#39;t do this if the system image is older than V, to avoid any compat
      // issues with apps and shared libs in them.
      android::modules::sdklevel::IsAtLeastV()) &#123;
    nativeloader::ApiDomain caller_api_domain = nativeloader::GetApiDomainFromPath(caller_location);
    if (caller_api_domain != nativeloader::API_DOMAIN_DEFAULT) &#123;
      nativeloader::ApiDomain library_api_domain = nativeloader::GetApiDomainFromPath(path);

      if (library_api_domain == caller_api_domain) &#123;
        bool is_bridged = false;
        if (library_path_j != nullptr) &#123;
          ScopedUtfChars library_path_utf_chars(env, library_path_j);
          if (library_path_utf_chars[0] != &#39;\0&#39;) &#123;
            is_bridged = NativeBridgeIsPathSupported(library_path_utf_chars.c_str());
          &#125;
        &#125;

        Result&lt;NativeLoaderNamespace&gt; ns = GetNamespaceForApiDomain(caller_api_domain, is_bridged);
        if (!ns.ok()) &#123;
          ALOGD(&quot;Failed to find ns for caller %s in API domain %d to load %s (is_bridged=%b): %s&quot;,
                caller_location,
                caller_api_domain,
                path,
                is_bridged,
                ns.error().message().c_str());
          *error_msg = strdup(ns.error().message().c_str());
          return nullptr;
        &#125;

        *needs_native_bridge = ns.value().IsBridged();
        Result&lt;void*&gt; handle = ns.value().Load(path);
        ALOGD(&quot;Load %s using ns %s for caller %s in same partition (is_bridged=%b): %s&quot;,
              path,
              ns.value().name().c_str(),
              caller_location,
              is_bridged,
              handle.ok() ? &quot;ok&quot; : handle.error().message().c_str());
        if (!handle.ok()) &#123;
          *error_msg = strdup(handle.error().message().c_str());
          return nullptr;
        &#125;
        return handle.value();
      &#125;
    &#125;
  &#125;

  NativeLoaderNamespace* ns;
  const char* ns_descr;
  &#123;
    std::lock_guard&lt;std::mutex&gt; guard(g_namespaces_mutex);

    ns = g_namespaces-&gt;FindNamespaceByClassLoader(env, class_loader);
    ns_descr = &quot;class loader&quot;;

    if (ns == nullptr) &#123;
      // This is the case where the classloader was not created by ApplicationLoaders
      // In this case we create an isolated not-shared namespace for it.
      const std::string empty_dex_path;
      Result&lt;NativeLoaderNamespace*&gt; res =
          CreateClassLoaderNamespaceLocked(env,
                                           target_sdk_version,
                                           class_loader,
                                           nativeloader::API_DOMAIN_DEFAULT,
                                           /*is_shared=*/false,
                                           empty_dex_path,
                                           library_path_j,
                                           /*permitted_path_j=*/nullptr,
                                           /*uses_library_list_j=*/nullptr);
      if (!res.ok()) &#123;
        ALOGD(&quot;Failed to create isolated ns for %s (caller=%s)&quot;,
              path,
              caller_location == nullptr ? &quot;&lt;unknown&gt;&quot; : caller_location);
        *error_msg = strdup(res.error().message().c_str());
        return nullptr;
      &#125;
      ns = res.value();
      ns_descr = &quot;isolated&quot;;
    &#125;
  &#125;

  *needs_native_bridge = ns-&gt;IsBridged();
  Result&lt;void*&gt; handle = ns-&gt;Load(path);
  ALOGD(&quot;Load %s using %s ns %s (caller=%s): %s&quot;,
        path,
        ns_descr,
        ns-&gt;name().c_str(),
        caller_location == nullptr ? &quot;&lt;unknown&gt;&quot; : caller_location,
        handle.ok() ? &quot;ok&quot; : handle.error().message().c_str());
  if (!handle.ok()) &#123;
    *error_msg = strdup(handle.error().message().c_str());
    return nullptr;
  &#125;
  return handle.value();

#else   // !ART_TARGET_ANDROID
  UNUSED(env, target_sdk_version, class_loader, caller_location);

  // Do some best effort to emulate library-path support. It will not
  // work for dependencies.
  //
  // Note: null has a special meaning and must be preserved.
  std::string library_path;  // Empty string by default.
  if (library_path_j != nullptr &amp;&amp; path != nullptr &amp;&amp; path[0] != &#39;/&#39;) &#123;
    ScopedUtfChars library_path_utf_chars(env, library_path_j);
    library_path = library_path_utf_chars.c_str();
  &#125;

  std::vector&lt;std::string&gt; library_paths = base::Split(library_path, &quot;:&quot;);

  for (const std::string&amp; lib_path : library_paths) &#123;
    *needs_native_bridge = false;
    const char* path_arg;
    std::string complete_path;
    if (path == nullptr) &#123;
      // Preserve null.
      path_arg = nullptr;
    &#125; else &#123;
      complete_path = lib_path;
      if (!complete_path.empty()) &#123;
        complete_path.append(&quot;/&quot;);
      &#125;
      complete_path.append(path);
      path_arg = complete_path.c_str();
    &#125;
    void* handle = dlopen(path_arg, RTLD_NOW);
    if (handle != nullptr) &#123;
      return handle;
    &#125;
    if (NativeBridgeIsSupported(path_arg)) &#123;
      *needs_native_bridge = true;
      handle = NativeBridgeLoadLibrary(path_arg, RTLD_NOW);
      if (handle != nullptr) &#123;
        return handle;
      &#125;
      *error_msg = strdup(NativeBridgeGetError());
    &#125; else &#123;
      *error_msg = strdup(dlerror());
    &#125;
  &#125;
  return nullptr;
#endif  // !ART_TARGET_ANDROID
&#125;
</code></pre>
<p>​		总的来说该函数的作用就是根据传入的 class_loader &#x2F; caller_location &#x2F; library_path_j 等上下文，选择合适的 native loader namespace，然后最终调用 dlopen（或 android_dlopen_ext &#x2F; native-bridge）加载目标 .so，返回 dlopen 的句柄。而这里的 <strong>android_dlopen_ext</strong> 函数也就是经常进行 Hook 的位置了。跟进。</p>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909165103651.png" alt="image-20250909165103651"></p>
<p>​		根据看雪的那篇文章中所提及的，在 Android 12 中会直接调用到 <strong>__loader_android_dlopen_ext</strong> 函数，而在其他版本会调转到 <strong>mock-&gt;mock_dlopen_ext</strong> （如上图，会模拟 dlopen 的行为，同时通过 flag 和宏定义走到不同的函数位置）。</p>
<p>​		这里我们固定在 Android 12 的位置去实现。代码如下</p>
<pre><code class="language-c++">void* __loader_android_dlopen_ext(const char* filename,
                           int flags,
                           const android_dlextinfo* extinfo,
                           const void* caller_addr) &#123;
  return dlopen_ext(filename, flags, extinfo, caller_addr);
&#125;
</code></pre>
<p>​		跟进 <strong>dlopen_ext</strong> 函数。</p>
<pre><code class="language-c++">static void* dlopen_ext(const char* filename,
                        int flags,
                        const android_dlextinfo* extinfo,
                        const void* caller_addr) &#123;
  ScopedPthreadMutexLocker locker(&amp;g_dl_mutex);
  g_linker_logger.ResetState();
  void* result = do_dlopen(filename, flags, extinfo, caller_addr);
  if (result == nullptr) &#123;
    __bionic_format_dlerror(&quot;dlopen failed&quot;, linker_get_error_buffer());
    return nullptr;
  &#125;
  return result;
&#125;
</code></pre>
<p>​		同样进入 do_dlopen(filename, flags, extinfo, caller_addr)，在这个函数中附加了很多对于 do_dlopen 函数参数的检测和判断。</p>
<pre><code class="language-c++">void* do_dlopen(const char* name, int flags,
                const android_dlextinfo* extinfo,
                const void* caller_addr) &#123;
  std::string trace_prefix = std::string(&quot;dlopen: &quot;) + (name == nullptr ? &quot;(nullptr)&quot; : name);
  ScopedTrace trace(trace_prefix.c_str());
  ScopedTrace loading_trace((trace_prefix + &quot; - loading and linking&quot;).c_str());
  soinfo* const caller = find_containing_library(caller_addr);
  android_namespace_t* ns = get_caller_namespace(caller);

  LD_LOG(kLogDlopen,
         &quot;dlopen(name=\&quot;%s\&quot;, flags=0x%x, extinfo=%s, caller=\&quot;%s\&quot;, caller_ns=%s@%p, targetSdkVersion=%i) ...&quot;,
         name,
         flags,
         android_dlextinfo_to_string(extinfo).c_str(),
         caller == nullptr ? &quot;(null)&quot; : caller-&gt;get_realpath(),
         ns == nullptr ? &quot;(null)&quot; : ns-&gt;get_name(),
         ns,
         get_application_target_sdk_version());

  auto purge_guard = android::base::make_scope_guard([&amp;]() &#123; purge_unused_memory(); &#125;);

  auto failure_guard = android::base::make_scope_guard(
      [&amp;]() &#123; LD_LOG(kLogDlopen, &quot;... dlopen failed: %s&quot;, linker_get_error_buffer()); &#125;);

  if ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL|RTLD_NODELETE|RTLD_NOLOAD)) != 0) &#123;
    DL_OPEN_ERR(&quot;invalid flags to dlopen: %x&quot;, flags);
    return nullptr;
  &#125;

  if (extinfo != nullptr) &#123;
    if ((extinfo-&gt;flags &amp; ~(ANDROID_DLEXT_VALID_FLAG_BITS)) != 0) &#123;
      DL_OPEN_ERR(&quot;invalid extended flags to android_dlopen_ext: 0x%&quot; PRIx64, extinfo-&gt;flags);
      return nullptr;
    &#125;

    if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) == 0 &amp;&amp;
        (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != 0) &#123;
      DL_OPEN_ERR(&quot;invalid extended flag combination (ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET without &quot;
          &quot;ANDROID_DLEXT_USE_LIBRARY_FD): 0x%&quot; PRIx64, extinfo-&gt;flags);
      return nullptr;
    &#125;

    if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_NAMESPACE) != 0) &#123;
      if (extinfo-&gt;library_namespace == nullptr) &#123;
        DL_OPEN_ERR(&quot;ANDROID_DLEXT_USE_NAMESPACE is set but extinfo-&gt;library_namespace is null&quot;);
        return nullptr;
      &#125;
      ns = extinfo-&gt;library_namespace;
    &#125;
  &#125;

  // Workaround for dlopen(/system/lib/&lt;soname&gt;) when .so is in /apex. http://b/121248172
  // The workaround works only when targetSdkVersion &lt; Q.
  std::string name_to_apex;
  if (translateSystemPathToApexPath(name, &amp;name_to_apex)) &#123;
    const char* new_name = name_to_apex.c_str();
    LD_LOG(kLogDlopen, &quot;dlopen considering translation from %s to APEX path %s&quot;,
           name,
           new_name);
    // Some APEXs could be optionally disabled. Only translate the path
    // when the old file is absent and the new file exists.
    // TODO(b/124218500): Re-enable it once app compat issue is resolved
    /*
    if (file_exists(name)) &#123;
      LD_LOG(kLogDlopen, &quot;dlopen %s exists, not translating&quot;, name);
    &#125; else
    */
    if (!file_exists(new_name)) &#123;
      LD_LOG(kLogDlopen, &quot;dlopen %s does not exist, not translating&quot;,
             new_name);
    &#125; else &#123;
      LD_LOG(kLogDlopen, &quot;dlopen translation accepted: using %s&quot;, new_name);
      name = new_name;
    &#125;
  &#125;
  // End Workaround for dlopen(/system/lib/&lt;soname&gt;) when .so is in /apex.

  std::string translated_name_holder;

  assert(!g_is_hwasan || !g_is_asan);
  const char* translated_name = name;
  if (g_is_asan &amp;&amp; translated_name != nullptr &amp;&amp; translated_name[0] == &#39;/&#39;) &#123;
    char original_path[PATH_MAX];
    if (realpath(name, original_path) != nullptr) &#123;
      translated_name_holder = std::string(kAsanLibDirPrefix) + original_path;
      if (file_exists(translated_name_holder.c_str())) &#123;
        soinfo* si = nullptr;
        if (find_loaded_library_by_realpath(ns, original_path, true, &amp;si)) &#123;
          DL_WARN(&quot;linker_asan dlopen NOT translating \&quot;%s\&quot; -&gt; \&quot;%s\&quot;: library already loaded&quot;, name,
                  translated_name_holder.c_str());
        &#125; else &#123;
          DL_WARN(&quot;linker_asan dlopen translating \&quot;%s\&quot; -&gt; \&quot;%s\&quot;&quot;, name, translated_name);
          translated_name = translated_name_holder.c_str();
        &#125;
      &#125;
    &#125;
  &#125; else if (g_is_hwasan &amp;&amp; translated_name != nullptr &amp;&amp; translated_name[0] == &#39;/&#39;) &#123;
    char original_path[PATH_MAX];
    if (realpath(name, original_path) != nullptr) &#123;
      // Keep this the same as CreateHwasanPath in system/linkerconfig/modules/namespace.cc.
      std::string path(original_path);
      auto slash = path.rfind(&#39;/&#39;);
      if (slash != std::string::npos || slash != path.size() - 1) &#123;
        translated_name_holder = path.substr(0, slash) + &quot;/hwasan&quot; + path.substr(slash);
      &#125;
      if (!translated_name_holder.empty() &amp;&amp; file_exists(translated_name_holder.c_str())) &#123;
        soinfo* si = nullptr;
        if (find_loaded_library_by_realpath(ns, original_path, true, &amp;si)) &#123;
          DL_WARN(&quot;linker_hwasan dlopen NOT translating \&quot;%s\&quot; -&gt; \&quot;%s\&quot;: library already loaded&quot;,
                  name, translated_name_holder.c_str());
        &#125; else &#123;
          DL_WARN(&quot;linker_hwasan dlopen translating \&quot;%s\&quot; -&gt; \&quot;%s\&quot;&quot;, name, translated_name);
          translated_name = translated_name_holder.c_str();
        &#125;
      &#125;
    &#125;
  &#125;
  ProtectedDataGuard guard;
  soinfo* si = find_library(ns, translated_name, flags, extinfo, caller);
  loading_trace.End();

  if (si != nullptr) &#123;
    void* handle = si-&gt;to_handle();
    LD_LOG(kLogDlopen,
           &quot;... dlopen calling constructors: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;, handle=%p&quot;,
           si-&gt;get_realpath(), si-&gt;get_soname(), handle);
    si-&gt;call_constructors();
    failure_guard.Disable();
    LD_LOG(kLogDlopen,
           &quot;... dlopen successful: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;, handle=%p&quot;,
           si-&gt;get_realpath(), si-&gt;get_soname(), handle);
    return handle;
  &#125;

  return nullptr;
&#125;

int do_dladdr(const void* addr, Dl_info* info) &#123;
  // Determine if this address can be found in any library currently mapped.
  soinfo* si = find_containing_library(addr);
  if (si == nullptr) &#123;
    return 0;
  &#125;

  memset(info, 0, sizeof(Dl_info));

  info-&gt;dli_fname = si-&gt;get_realpath();
  // Address at which the shared object is loaded.
  info-&gt;dli_fbase = reinterpret_cast&lt;void*&gt;(si-&gt;base);

  // Determine if any symbol in the library contains the specified address.
  ElfW(Sym)* sym = si-&gt;find_symbol_by_address(addr);
  if (sym != nullptr) &#123;
    info-&gt;dli_sname = si-&gt;get_string(sym-&gt;st_name);
    info-&gt;dli_saddr = reinterpret_cast&lt;void*&gt;(si-&gt;resolve_symbol_address(sym));
  &#125;

  return 1;
&#125;

static soinfo* soinfo_from_handle(void* handle) &#123;
  if ((reinterpret_cast&lt;uintptr_t&gt;(handle) &amp; 1) != 0) &#123;
    auto it = g_soinfo_handles_map.find(reinterpret_cast&lt;uintptr_t&gt;(handle));
    if (it == g_soinfo_handles_map.end()) &#123;
      return nullptr;
    &#125; else &#123;
      return it-&gt;second;
    &#125;
  &#125;

  return static_cast&lt;soinfo*&gt;(handle);
&#125;
</code></pre>
<p><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909165939099.png" alt="image-20250909165939099"></p>
<p>​		首先对 flags 进行校验，然后大面积的对传入的 extinfo 进行检查，接着对 APEX 路径进行翻译；调用 find_library 查找并加载库，即在 namespace 下查找库是否已加载，如果未加载，则解析 ELF、执行 mmap、解析依赖，返回 <code>soinfo*</code>（库的内部结构，包括基址、soname、symbols）；然后调用构造函数，也就是对库的 <strong>.init_array</strong> 执行初始化函数（包括 JNI_OnLoad 会在上层封装调用），很多检测逻辑就会在写在这个段，在 JNI_OnLoad 函数之前运行。继续跟进 find_library(ns, translated_name, flags, extinfo, caller)。</p>
<pre><code class="language-c++">static soinfo* find_library(android_namespace_t* ns,
                            const char* name, int rtld_flags,
                            const android_dlextinfo* extinfo,
                            soinfo* needed_by) &#123;
  soinfo* si = nullptr;

  if (name == nullptr) &#123;
    si = solist_get_somain();
  &#125; else if (!find_libraries(ns,
                             needed_by,
                             &amp;name,
                             1,
                             &amp;si,
                             nullptr,
                             0,
                             rtld_flags,
                             extinfo,
                             false /* add_as_children */)) &#123;
    if (si != nullptr) &#123;
      soinfo_unload(si);
    &#125;
    return nullptr;
  &#125;

  si-&gt;increment_ref_count();

  return si;
&#125;
</code></pre>
<p>直接继续跟进 find_libraries 函数</p>
<pre><code class="language-c++">bool find_libraries(android_namespace_t* ns,
                    soinfo* start_with,
                    const char* const library_names[],
                    size_t library_names_count,
                    soinfo* soinfos[],
                    std::vector&lt;soinfo*&gt;* ld_preloads,
                    size_t ld_preloads_count,
                    int rtld_flags,
                    const android_dlextinfo* extinfo,
                    bool add_as_children,
                    std::vector&lt;android_namespace_t*&gt;* namespaces) &#123;
  // Step 0: prepare.
  std::unordered_map&lt;const soinfo*, ElfReader&gt; readers_map;
  LoadTaskList load_tasks;

  for (size_t i = 0; i &lt; library_names_count; ++i) &#123;
    const char* name = library_names[i];
    load_tasks.push_back(LoadTask::create(name, start_with, ns, &amp;readers_map));
  &#125;

  // If soinfos array is null allocate one on stack.
  // The array is needed in case of failure; for example
  // when library_names[] = &#123;libone.so, libtwo.so&#125; and libone.so
  // is loaded correctly but libtwo.so failed for some reason.
  // In this case libone.so should be unloaded on return.
  // See also implementation of failure_guard below.

  if (soinfos == nullptr) &#123;
    size_t soinfos_size = sizeof(soinfo*)*library_names_count;
    soinfos = reinterpret_cast&lt;soinfo**&gt;(alloca(soinfos_size));
    memset(soinfos, 0, soinfos_size);
  &#125;

  // list of libraries to link - see step 2.
  size_t soinfos_count = 0;

  auto scope_guard = android::base::make_scope_guard([&amp;]() &#123;
    for (LoadTask* t : load_tasks) &#123;
      LoadTask::deleter(t);
    &#125;
  &#125;);

  ZipArchiveCache zip_archive_cache;
  soinfo_list_t new_global_group_members;

  // Step 1: expand the list of load_tasks to include
  // all DT_NEEDED libraries (do not load them just yet)
  for (size_t i = 0; i&lt;load_tasks.size(); ++i) &#123;
    LoadTask* task = load_tasks[i];
    soinfo* needed_by = task-&gt;get_needed_by();

    bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children);
    task-&gt;set_extinfo(is_dt_needed ? nullptr : extinfo);
    task-&gt;set_dt_needed(is_dt_needed);

    // Note: start from the namespace that is stored in the LoadTask. This namespace
    // is different from the current namespace when the LoadTask is for a transitive
    // dependency and the lib that created the LoadTask is not found in the
    // current namespace but in one of the linked namespaces.
    android_namespace_t* start_ns = const_cast&lt;android_namespace_t*&gt;(task-&gt;get_start_from());

    LD_LOG(kLogDlopen, &quot;find_library_internal(ns=%s@%p): task=%s, is_dt_needed=%d&quot;,
           start_ns-&gt;get_name(), start_ns, task-&gt;get_name(), is_dt_needed);

    if (!find_library_internal(start_ns, task, &amp;zip_archive_cache, &amp;load_tasks, rtld_flags)) &#123;
      return false;
    &#125;

    soinfo* si = task-&gt;get_soinfo();

    if (is_dt_needed) &#123;
      needed_by-&gt;add_child(si);
    &#125;

    // When ld_preloads is not null, the first
    // ld_preloads_count libs are in fact ld_preloads.
    bool is_ld_preload = false;
    if (ld_preloads != nullptr &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123;
      ld_preloads-&gt;push_back(si);
      is_ld_preload = true;
    &#125;

    if (soinfos_count &lt; library_names_count) &#123;
      soinfos[soinfos_count++] = si;
    &#125;

    // Add the new global group members to all initial namespaces. Do this secondary namespace setup
    // at the same time that libraries are added to their primary namespace so that the order of
    // global group members is the same in the every namespace. Only add a library to a namespace
    // once, even if it appears multiple times in the dependency graph.
    if (is_ld_preload || (si-&gt;get_dt_flags_1() &amp; DF_1_GLOBAL) != 0) &#123;
      if (!si-&gt;is_linked() &amp;&amp; namespaces != nullptr &amp;&amp; !new_global_group_members.contains(si)) &#123;
        new_global_group_members.push_back(si);
        for (auto linked_ns : *namespaces) &#123;
          if (si-&gt;get_primary_namespace() != linked_ns) &#123;
            linked_ns-&gt;add_soinfo(si);
            si-&gt;add_secondary_namespace(linked_ns);
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;

  // Step 2: Load libraries in random order (see b/24047022)
  LoadTaskList load_list;
  for (auto&amp;&amp; task : load_tasks) &#123;
    soinfo* si = task-&gt;get_soinfo();
    auto pred = [&amp;](const LoadTask* t) &#123;
      return t-&gt;get_soinfo() == si;
    &#125;;

    if (!si-&gt;is_linked() &amp;&amp;
        std::find_if(load_list.begin(), load_list.end(), pred) == load_list.end() ) &#123;
      load_list.push_back(task);
    &#125;
  &#125;
  bool reserved_address_recursive = false;
  if (extinfo) &#123;
    reserved_address_recursive = extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE;
  &#125;
  if (!reserved_address_recursive) &#123;
    // Shuffle the load order in the normal case, but not if we are loading all
    // the libraries to a reserved address range.
    shuffle(&amp;load_list);
  &#125;

  // Set up address space parameters.
  address_space_params extinfo_params, default_params;
  size_t relro_fd_offset = 0;
  if (extinfo) &#123;
    if (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS) &#123;
      extinfo_params.start_addr = extinfo-&gt;reserved_addr;
      extinfo_params.reserved_size = extinfo-&gt;reserved_size;
      extinfo_params.must_use_address = true;
    &#125; else if (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_HINT) &#123;
      extinfo_params.start_addr = extinfo-&gt;reserved_addr;
      extinfo_params.reserved_size = extinfo-&gt;reserved_size;
    &#125;
  &#125;

  for (auto&amp;&amp; task : load_list) &#123;
    address_space_params* address_space =
        (reserved_address_recursive || !task-&gt;is_dt_needed()) ? &amp;extinfo_params : &amp;default_params;
    if (!task-&gt;load(address_space)) &#123;
      return false;
    &#125;
  &#125;

  // The WebView loader uses RELRO sharing in order to promote page sharing of the large RELRO
  // segment, as it&#39;s full of C++ vtables. Because MTE globals, by default, applies random tags to
  // each global variable, the RELRO segment is polluted and unique for each process. In order to
  // allow sharing, but still provide some protection, we use deterministic global tagging schemes
  // for DSOs that are loaded through android_dlopen_ext, such as those loaded by WebView.
  bool dlext_use_relro =
      extinfo &amp;&amp; extinfo-&gt;flags &amp; (ANDROID_DLEXT_WRITE_RELRO | ANDROID_DLEXT_USE_RELRO);

  // Step 3: pre-link all DT_NEEDED libraries in breadth first order.
  bool any_memtag_stack = false;
  for (auto&amp;&amp; task : load_tasks) &#123;
    soinfo* si = task-&gt;get_soinfo();
    if (!si-&gt;is_linked() &amp;&amp; !si-&gt;prelink_image(dlext_use_relro)) &#123;
      return false;
    &#125;
    // si-&gt;memtag_stack() needs to be called after si-&gt;prelink_image() which populates
    // the dynamic section.
    if (si-&gt;memtag_stack()) &#123;
      any_memtag_stack = true;
      LD_LOG(kLogDlopen,
             &quot;... load_library requesting stack MTE for: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;&quot;,
             si-&gt;get_realpath(), si-&gt;get_soname());
    &#125;
    register_soinfo_tls(si);
  &#125;
  if (any_memtag_stack) &#123;
    if (auto* cb = __libc_shared_globals()-&gt;memtag_stack_dlopen_callback) &#123;
      cb();
    &#125; else &#123;
      // find_library is used by the initial linking step, so we communicate that we
      // want memtag_stack enabled to __libc_init_mte.
      __libc_shared_globals()-&gt;initial_memtag_stack_abi = true;
    &#125;
  &#125;

  // Step 4: Construct the global group. DF_1_GLOBAL bit is force set for LD_PRELOADed libs because
  // they must be added to the global group. Note: The DF_1_GLOBAL bit for a library is normally set
  // in step 3.
  if (ld_preloads != nullptr) &#123;
    for (auto&amp;&amp; si : *ld_preloads) &#123;
      si-&gt;set_dt_flags_1(si-&gt;get_dt_flags_1() | DF_1_GLOBAL);
    &#125;
  &#125;

  // Step 5: Collect roots of local_groups.
  // Whenever needed_by-&gt;si link crosses a namespace boundary it forms its own local_group.
  // Here we collect new roots to link them separately later on. Note that we need to avoid
  // collecting duplicates. Also the order is important. They need to be linked in the same
  // BFS order we link individual libraries.
  std::vector&lt;soinfo*&gt; local_group_roots;
  if (start_with != nullptr &amp;&amp; add_as_children) &#123;
    local_group_roots.push_back(start_with);
  &#125; else &#123;
    CHECK(soinfos_count == 1);
    local_group_roots.push_back(soinfos[0]);
  &#125;

  for (auto&amp;&amp; task : load_tasks) &#123;
    soinfo* si = task-&gt;get_soinfo();
    soinfo* needed_by = task-&gt;get_needed_by();
    bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children);
    android_namespace_t* needed_by_ns =
        is_dt_needed ? needed_by-&gt;get_primary_namespace() : ns;

    if (!si-&gt;is_linked() &amp;&amp; si-&gt;get_primary_namespace() != needed_by_ns) &#123;
      auto it = std::find(local_group_roots.begin(), local_group_roots.end(), si);
      LD_LOG(kLogDlopen,
             &quot;Crossing namespace boundary (si=%s@%p, si_ns=%s@%p, needed_by=%s@%p, ns=%s@%p, needed_by_ns=%s@%p) adding to local_group_roots: %s&quot;,
             si-&gt;get_realpath(),
             si,
             si-&gt;get_primary_namespace()-&gt;get_name(),
             si-&gt;get_primary_namespace(),
             needed_by == nullptr ? &quot;(nullptr)&quot; : needed_by-&gt;get_realpath(),
             needed_by,
             ns-&gt;get_name(),
             ns,
             needed_by_ns-&gt;get_name(),
             needed_by_ns,
             it == local_group_roots.end() ? &quot;yes&quot; : &quot;no&quot;);

      if (it == local_group_roots.end()) &#123;
        local_group_roots.push_back(si);
      &#125;
    &#125;
  &#125;

  // Step 6: Link all local groups
  for (auto root : local_group_roots) &#123;
    soinfo_list_t local_group;
    android_namespace_t* local_group_ns = root-&gt;get_primary_namespace();

    walk_dependencies_tree(root,
      [&amp;] (soinfo* si) &#123;
        if (local_group_ns-&gt;is_accessible(si)) &#123;
          local_group.push_back(si);
          return kWalkContinue;
        &#125; else &#123;
          return kWalkSkip;
        &#125;
      &#125;);

    soinfo_list_t global_group = local_group_ns-&gt;get_global_group();
    SymbolLookupList lookup_list(global_group, local_group);
    soinfo* local_group_root = local_group.front();

    bool linked = local_group.visit([&amp;](soinfo* si) &#123;
      // Even though local group may contain accessible soinfos from other namespaces
      // we should avoid linking them (because if they are not linked -&gt; they
      // are in the local_group_roots and will be linked later).
      if (!si-&gt;is_linked() &amp;&amp; si-&gt;get_primary_namespace() == local_group_ns) &#123;
        const android_dlextinfo* link_extinfo = nullptr;
        if (si == soinfos[0] || reserved_address_recursive) &#123;
          // Only forward extinfo for the first library unless the recursive
          // flag is set.
          link_extinfo = extinfo;
        &#125;
        if (__libc_shared_globals()-&gt;load_hook) &#123;
          __libc_shared_globals()-&gt;load_hook(si-&gt;load_bias, si-&gt;phdr, si-&gt;phnum);
        &#125;
        lookup_list.set_dt_symbolic_lib(si-&gt;has_DT_SYMBOLIC ? si : nullptr);
        if (!si-&gt;link_image(lookup_list, local_group_root, link_extinfo, &amp;relro_fd_offset) ||
            !get_cfi_shadow()-&gt;AfterLoad(si, solist_get_head())) &#123;
          return false;
        &#125;
      &#125;

      return true;
    &#125;);

    if (!linked) &#123;
      return false;
    &#125;
  &#125;

  // Step 7: Mark all load_tasks as linked and increment refcounts
  // for references between load_groups (at this point it does not matter if
  // referenced load_groups were loaded by previous dlopen or as part of this
  // one on step 6)
  if (start_with != nullptr &amp;&amp; add_as_children) &#123;
    start_with-&gt;set_linked();
  &#125;

  for (auto&amp;&amp; task : load_tasks) &#123;
    soinfo* si = task-&gt;get_soinfo();
    si-&gt;set_linked();
  &#125;

  for (auto&amp;&amp; task : load_tasks) &#123;
    soinfo* si = task-&gt;get_soinfo();
    soinfo* needed_by = task-&gt;get_needed_by();
    if (needed_by != nullptr &amp;&amp;
        needed_by != start_with &amp;&amp;
        needed_by-&gt;get_local_group_root() != si-&gt;get_local_group_root()) &#123;
      si-&gt;increment_ref_count();
    &#125;
  &#125;


  return true;
&#125;

static soinfo* find_library(android_namespace_t* ns,
                            const char* name, int rtld_flags,
                            const android_dlextinfo* extinfo,
                            soinfo* needed_by) &#123;
  soinfo* si = nullptr;

  if (name == nullptr) &#123;
    si = solist_get_somain();
  &#125; else if (!find_libraries(ns,
                             needed_by,
                             &amp;name,
                             1,
                             &amp;si,
                             nullptr,
                             0,
                             rtld_flags,
                             extinfo,
                             false /* add_as_children */)) &#123;
    if (si != nullptr) &#123;
      soinfo_unload(si);
    &#125;
    return nullptr;
  &#125;

  si-&gt;increment_ref_count();

  return si;
&#125;
</code></pre>
<p>​		这部分代码很长，在安卓源码中也有对齐进行了批注，一步一步地去加载和解析 so 文件，去实现 so 文件的加载。<br>​		</p>
<p><strong>Step 0</strong>：准备 load_tasks 和 soinfos</p>
<ul>
<li>每个库对应一个 LoadTask，保存库名、namespace、依赖信息；</li>
<li>如果 soinfos 为 null，临时在栈上分配并构造，用于回滚失败（即如果某个库加载失败，要卸载前面已经加载的库）。</li>
</ul>
<pre><code class="language-c++">for (size_t i = 0; i &lt; library_names_count; ++i) &#123;
    load_tasks.push_back(LoadTask::create(name, start_with, ns, &amp;readers_map));
&#125;
</code></pre>
<p><strong>Step 1</strong>：扩展 DT_NEEDED 依赖</p>
<ul>
<li>对每个 <strong>LoadTask</strong>，查找它的依赖库（DT_NEEDED）；</li>
<li><strong>注意</strong>：先不真正加载 DT_NEEDED 的库，只是把它们加入 load_tasks 队列；</li>
<li>is_dt_need 表示当前库是依赖库还是主库，主库可以使用 <strong>extinfo</strong>（比如保留地址）；</li>
<li>如果 find_library_internal 失败，直接返回 false；</li>
<li>LD_PRELOAD 的库必须加入全局组（DF_1_GLOBAL)；</li>
<li>可选地把库添加到其他 namespace，实现跨 namespace 可见。</li>
</ul>
<pre><code class="language-c++">for (size_t i = 0; i&lt;load_tasks.size(); ++i) &#123;
    LoadTask* task = load_tasks[i];
    bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children);
    task-&gt;set_extinfo(is_dt_needed ? nullptr : extinfo);
    task-&gt;set_dt_needed(is_dt_needed);
    if (!find_library_internal(start_ns, task, &amp;zip_archive_cache, &amp;load_tasks, rtld_flags)) &#123;
      return false;
    &#125;
&#125;
</code></pre>
<pre><code class="language-c++">if (ld_preloads != nullptr &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123;
    ld_preloads-&gt;push_back(si);
&#125;
if (is_ld_preload || (si-&gt;get_dt_flags_1() &amp; DF_1_GLOBAL) != 0) &#123;
    for (auto linked_ns : *namespaces) &#123;
        linked_ns-&gt;add_soinfo(si);
        si-&gt;add_secondary_namespace(linked_ns);
    &#125;
&#125;
</code></pre>
<p><strong>Step 2</strong>：加载库的顺序处理</p>
<ul>
<li>将待加载库整理到 load_list；</li>
<li><strong>随机顺序加载</strong>：为了避免库依赖顺序错误；</li>
<li>如果使用保留地址（ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE），则不打乱顺序。</li>
</ul>
<pre><code class="language-c++">LoadTaskList load_list;
for (auto&amp;&amp; task : load_tasks) &#123; ... &#125;
shuffle(&amp;load_list);
</code></pre>
<p><strong>Step 3</strong>：预链接 DT_NEEDED 库</p>
<ul>
<li>预解析动态节（.dynamic），计算符号表、依赖关系；</li>
<li>支持 RELRO（只读重定位段）共享，提升 WebView 等库安全性；</li>
<li>对 ELF 文件结构进行检查，只有对应的 so 文件时完整的才能进行加载链接；</li>
<li>将 soinfo 注册到 TLS 段。</li>
</ul>
<pre><code class="language-c++">bool any_memtag_stack = false;
for (auto&amp;&amp; task : load_tasks) &#123;
  soinfo* si = task-&gt;get_soinfo();
  if (!si-&gt;is_linked() &amp;&amp; !si-&gt;prelink_image(dlext_use_relro)) &#123;
    return false;
  &#125;
  // si-&gt;memtag_stack() needs to be called after si-&gt;prelink_image() which populates
  // the dynamic section.
  if (si-&gt;memtag_stack()) &#123;
    any_memtag_stack = true;
    LD_LOG(kLogDlopen,
           &quot;... load_library requesting stack MTE for: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;&quot;,
           si-&gt;get_realpath(), si-&gt;get_soname());
  &#125;
  register_soinfo_tls(si);
&#125;
</code></pre>
<p><strong>Step 4</strong>：处理全局符号解析</p>
<ul>
<li>设置 LD_PRELOAD 库为全局，该库必须全局可见，以便后续库解析符号。</li>
</ul>
<pre><code class="language-c++">if (ld_preloads != nullptr) &#123;
    for (auto&amp;&amp; si : *ld_preloads) &#123;
        si-&gt;set_dt_flags_1(si-&gt;get_dt_flags_1() | DF_1_GLOBAL);
    &#125;
&#125;
</code></pre>
<p><strong>Step 5 — 7</strong>：这几步就很细节了，确定哪些库是 local_group 的根节点，用于处理跨 namespace 的依赖，保证跨 namespace 的库在独立的 local_group 内被链接，不干扰其他 namespace；遍历每个 local_group root 的依赖树，对每个库 调用 link_image，执行 ELF load &#x2F; mmap、Relocation、符号解析、RELRO &#x2F; memtag 支持，即保证依赖库按正确顺序链接，支持 namespace 隔离和安全特性；管理生命周期，保证库在依赖的期间不会被卸载。</p>
<p>​		至此，整个 so 文件被全部解析处理。</p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>​		重新梳理一下整个 so 文件加载过程，我们首先通过 <strong>System.load()</strong> 进入，此方法最终调用 Runtime.loadLibrary0()，然后进入 nativeLoad() 函数，nativeLoad –&gt; JVM_NativeLoad，接着进入 JavaVMExt::LoadNativeLibrary 方法后，最终会调用 dlopen 进行真正的 so 文件加载（在 Android 12 及以上版本，会调用 <code>android_dlopen_ext</code> 返回 <code>__loader_android_dlopen_ext</code>），该方法最终调用 dlopen_ext()；再就是 do_dlopen()，在该函数中，会调用 <code>find_library()</code> 进行 SO 文件的真正加载。</p>
<p>​		这里是对于soinfo的赋值，同时在这里开始调用so的.init_proc函数，接着调用.init_array中的函数，最后才是JNI_OnLoad函数。最后到达<strong>find_libraries</strong> 执行最后的处理。</p>
<p>附上文章中的流程图<br><img src="https://nshide.oss-cn-hangzhou.aliyuncs.com/img_temp/image-20250909175709885.png" alt="image-20250909175709885"></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1621925986@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">💰</a>
</p>




    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: 'Ov23lif2sndX4YqUPQwk',
            clientSecret: 'c76a4c487d51bf36e4dd1496b3f44bdbea037d50',
            repo: 'NshIdE1.github.io',
            owner: 'NshIdE1',
            admin: ['NshIdE1'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2024-2025 NshIdE
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="Toggle full screen shortcut key s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>Help us with donation</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">alipay</label></span><span><label><input type="radio" name="pay" value="weixin">weixin</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
